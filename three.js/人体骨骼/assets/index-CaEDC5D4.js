var NA = Object.defineProperty;
var FA = (i, e, t) => (e in i ? NA(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t));
var Ut = (i, e, t) => FA(i, typeof e != 'symbol' ? e + '' : e, t);
function u6() {
	import.meta.url, import('_').catch(() => 1), (async function* () {})().next();
}
(function () {
	const e = document.createElement('link').relList;
	if (e && e.supports && e.supports('modulepreload')) return;
	for (const s of document.querySelectorAll('link[rel="modulepreload"]')) n(s);
	new MutationObserver((s) => {
		for (const r of s)
			if (r.type === 'childList') for (const o of r.addedNodes) o.tagName === 'LINK' && o.rel === 'modulepreload' && n(o);
	}).observe(document, { childList: !0, subtree: !0 });
	function t(s) {
		const r = {};
		return (
			s.integrity && (r.integrity = s.integrity),
			s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy),
			s.crossOrigin === 'use-credentials'
				? (r.credentials = 'include')
				: s.crossOrigin === 'anonymous'
				? (r.credentials = 'omit')
				: (r.credentials = 'same-origin'),
			r
		);
	}
	function n(s) {
		if (s.ep) return;
		s.ep = !0;
		const r = t(s);
		fetch(s.href, r);
	}
})();
/**
 * @vue/shared v3.4.38
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ /*! #__NO_SIDE_EFFECTS__ */ function zv(i, e) {
	const t = new Set(i.split(','));
	return (n) => t.has(n);
}
const en = {},
	Dl = [],
	Qi = () => {},
	BA = () => !1,
	_p = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && (i.charCodeAt(2) > 122 || i.charCodeAt(2) < 97),
	Vv = (i) => i.startsWith('onUpdate:'),
	Zn = Object.assign,
	Hv = (i, e) => {
		const t = i.indexOf(e);
		t > -1 && i.splice(t, 1);
	},
	kA = Object.prototype.hasOwnProperty,
	xt = (i, e) => kA.call(i, e),
	nt = Array.isArray,
	Kc = (i) => yp(i) === '[object Map]',
	zA = (i) => yp(i) === '[object Set]',
	ct = (i) => typeof i == 'function',
	zn = (i) => typeof i == 'string',
	oc = (i) => typeof i == 'symbol',
	_n = (i) => i !== null && typeof i == 'object',
	$w = (i) => (_n(i) || ct(i)) && ct(i.then) && ct(i.catch),
	VA = Object.prototype.toString,
	yp = (i) => VA.call(i),
	HA = (i) => yp(i).slice(8, -1),
	GA = (i) => yp(i) === '[object Object]',
	Gv = (i) => zn(i) && i !== 'NaN' && i[0] !== '-' && '' + parseInt(i, 10) === i,
	$c = zv(
		',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'
	),
	xp = (i) => {
		const e = Object.create(null);
		return (t) => e[t] || (e[t] = i(t));
	},
	WA = /-(\w)/g,
	Ma = xp((i) => i.replace(WA, (e, t) => (t ? t.toUpperCase() : ''))),
	XA = /\B([A-Z])/g,
	Fa = xp((i) => i.replace(XA, '-$1').toLowerCase()),
	Zw = xp((i) => i.charAt(0).toUpperCase() + i.slice(1)),
	Cf = xp((i) => (i ? 'on'.concat(Zw(i)) : '')),
	vo = (i, e) => !Object.is(i, e),
	Rf = (i, ...e) => {
		for (let t = 0; t < i.length; t++) i[t](...e);
	},
	Jw = (i, e, t, n = !1) => {
		Object.defineProperty(i, e, { configurable: !0, enumerable: !1, writable: n, value: t });
	},
	qA = (i) => {
		const e = parseFloat(i);
		return isNaN(e) ? i : e;
	};
let Q0;
const Qw = () =>
	Q0 ||
	(Q0 =
		typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : typeof global < 'u' ? global : {});
function Wv(i) {
	if (nt(i)) {
		const e = {};
		for (let t = 0; t < i.length; t++) {
			const n = i[t],
				s = zn(n) ? $A(n) : Wv(n);
			if (s) for (const r in s) e[r] = s[r];
		}
		return e;
	} else if (zn(i) || _n(i)) return i;
}
const YA = /;(?![^(]*\))/g,
	jA = /:([^]+)/,
	KA = /\/\*[^]*?\*\//g;
function $A(i) {
	const e = {};
	return (
		i
			.replace(KA, '')
			.split(YA)
			.forEach((t) => {
				if (t) {
					const n = t.split(jA);
					n.length > 1 && (e[n[0].trim()] = n[1].trim());
				}
			}),
		e
	);
}
function bp(i) {
	let e = '';
	if (zn(i)) e = i;
	else if (nt(i))
		for (let t = 0; t < i.length; t++) {
			const n = bp(i[t]);
			n && (e += n + ' ');
		}
	else if (_n(i)) for (const t in i) i[t] && (e += t + ' ');
	return e.trim();
}
const ZA = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
	JA = zv(ZA);
function eS(i) {
	return !!i || i === '';
}
/**
 * @vue/reactivity v3.4.38
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let gs;
class QA {
	constructor(e = !1) {
		(this.detached = e),
			(this._active = !0),
			(this.effects = []),
			(this.cleanups = []),
			(this.parent = gs),
			!e && gs && (this.index = (gs.scopes || (gs.scopes = [])).push(this) - 1);
	}
	get active() {
		return this._active;
	}
	run(e) {
		if (this._active) {
			const t = gs;
			try {
				return (gs = this), e();
			} finally {
				gs = t;
			}
		}
	}
	on() {
		gs = this;
	}
	off() {
		gs = this.parent;
	}
	stop(e) {
		if (this._active) {
			let t, n;
			for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].stop();
			for (t = 0, n = this.cleanups.length; t < n; t++) this.cleanups[t]();
			if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0);
			if (!this.detached && this.parent && !e) {
				const s = this.parent.scopes.pop();
				s && s !== this && ((this.parent.scopes[this.index] = s), (s.index = this.index));
			}
			(this.parent = void 0), (this._active = !1);
		}
	}
}
function eC(i, e = gs) {
	e && e.active && e.effects.push(i);
}
function tC() {
	return gs;
}
let fa;
class Xv {
	constructor(e, t, n, s) {
		(this.fn = e),
			(this.trigger = t),
			(this.scheduler = n),
			(this.active = !0),
			(this.deps = []),
			(this._dirtyLevel = 4),
			(this._trackId = 0),
			(this._runnings = 0),
			(this._shouldSchedule = !1),
			(this._depsLength = 0),
			eC(this, s);
	}
	get dirty() {
		if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
			(this._dirtyLevel = 1), To();
			for (let e = 0; e < this._depsLength; e++) {
				const t = this.deps[e];
				if (t.computed && (nC(t.computed), this._dirtyLevel >= 4)) break;
			}
			this._dirtyLevel === 1 && (this._dirtyLevel = 0), Ao();
		}
		return this._dirtyLevel >= 4;
	}
	set dirty(e) {
		this._dirtyLevel = e ? 4 : 0;
	}
	run() {
		if (((this._dirtyLevel = 0), !this.active)) return this.fn();
		let e = oo,
			t = fa;
		try {
			return (oo = !0), (fa = this), this._runnings++, ey(this), this.fn();
		} finally {
			ty(this), this._runnings--, (fa = t), (oo = e);
		}
	}
	stop() {
		this.active && (ey(this), ty(this), this.onStop && this.onStop(), (this.active = !1));
	}
}
function nC(i) {
	return i.value;
}
function ey(i) {
	i._trackId++, (i._depsLength = 0);
}
function ty(i) {
	if (i.deps.length > i._depsLength) {
		for (let e = i._depsLength; e < i.deps.length; e++) tS(i.deps[e], i);
		i.deps.length = i._depsLength;
	}
}
function tS(i, e) {
	const t = i.get(e);
	t !== void 0 && e._trackId !== t && (i.delete(e), i.size === 0 && i.cleanup());
}
let oo = !0,
	hg = 0;
const nS = [];
function To() {
	nS.push(oo), (oo = !1);
}
function Ao() {
	const i = nS.pop();
	oo = i === void 0 ? !0 : i;
}
function qv() {
	hg++;
}
function Yv() {
	for (hg--; !hg && ug.length; ) ug.shift()();
}
function iS(i, e, t) {
	if (e.get(i) !== i._trackId) {
		e.set(i, i._trackId);
		const n = i.deps[i._depsLength];
		n !== e ? (n && tS(n, i), (i.deps[i._depsLength++] = e)) : i._depsLength++;
	}
}
const ug = [];
function sS(i, e, t) {
	qv();
	for (const n of i.keys()) {
		let s;
		n._dirtyLevel < e &&
			(s != null ? s : (s = i.get(n) === n._trackId)) &&
			(n._shouldSchedule || (n._shouldSchedule = n._dirtyLevel === 0), (n._dirtyLevel = e)),
			n._shouldSchedule &&
				(s != null ? s : (s = i.get(n) === n._trackId)) &&
				(n.trigger(),
				(!n._runnings || n.allowRecurse) && n._dirtyLevel !== 2 && ((n._shouldSchedule = !1), n.scheduler && ug.push(n.scheduler)));
	}
	Yv();
}
const rS = (i, e) => {
		const t = new Map();
		return (t.cleanup = i), (t.computed = e), t;
	},
	dg = new WeakMap(),
	ma = Symbol(''),
	pg = Symbol('');
function bi(i, e, t) {
	if (oo && fa) {
		let n = dg.get(i);
		n || dg.set(i, (n = new Map()));
		let s = n.get(t);
		s || n.set(t, (s = rS(() => n.delete(t)))), iS(fa, s);
	}
}
function fr(i, e, t, n, s, r) {
	const o = dg.get(i);
	if (!o) return;
	let a = [];
	if (e === 'clear') a = [...o.values()];
	else if (t === 'length' && nt(i)) {
		const l = Number(n);
		o.forEach((c, h) => {
			(h === 'length' || (!oc(h) && h >= l)) && a.push(c);
		});
	} else
		switch ((t !== void 0 && a.push(o.get(t)), e)) {
			case 'add':
				nt(i) ? Gv(t) && a.push(o.get('length')) : (a.push(o.get(ma)), Kc(i) && a.push(o.get(pg)));
				break;
			case 'delete':
				nt(i) || (a.push(o.get(ma)), Kc(i) && a.push(o.get(pg)));
				break;
			case 'set':
				Kc(i) && a.push(o.get(ma));
				break;
		}
	qv();
	for (const l of a) l && sS(l, 4);
	Yv();
}
const iC = zv('__proto__,__v_isRef,__isVue'),
	oS = new Set(
		Object.getOwnPropertyNames(Symbol)
			.filter((i) => i !== 'arguments' && i !== 'caller')
			.map((i) => Symbol[i])
			.filter(oc)
	),
	ny = sC();
function sC() {
	const i = {};
	return (
		['includes', 'indexOf', 'lastIndexOf'].forEach((e) => {
			i[e] = function (...t) {
				const n = Ot(this);
				for (let r = 0, o = this.length; r < o; r++) bi(n, 'get', r + '');
				const s = n[e](...t);
				return s === -1 || s === !1 ? n[e](...t.map(Ot)) : s;
			};
		}),
		['push', 'pop', 'shift', 'unshift', 'splice'].forEach((e) => {
			i[e] = function (...t) {
				To(), qv();
				const n = Ot(this)[e].apply(this, t);
				return Yv(), Ao(), n;
			};
		}),
		i
	);
}
function rC(i) {
	oc(i) || (i = String(i));
	const e = Ot(this);
	return bi(e, 'has', i), e.hasOwnProperty(i);
}
class aS {
	constructor(e = !1, t = !1) {
		(this._isReadonly = e), (this._isShallow = t);
	}
	get(e, t, n) {
		const s = this._isReadonly,
			r = this._isShallow;
		if (t === '__v_isReactive') return !s;
		if (t === '__v_isReadonly') return s;
		if (t === '__v_isShallow') return r;
		if (t === '__v_raw')
			return n === (s ? (r ? _C : uS) : r ? hS : cS).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
		const o = nt(e);
		if (!s) {
			if (o && xt(ny, t)) return Reflect.get(ny, t, n);
			if (t === 'hasOwnProperty') return rC;
		}
		const a = Reflect.get(e, t, n);
		return (oc(t) ? oS.has(t) : iC(t)) || (s || bi(e, 'get', t), r)
			? a
			: wi(a)
			? o && Gv(t)
				? a
				: a.value
			: _n(a)
			? s
				? pS(a)
				: Sp(a)
			: a;
	}
}
class lS extends aS {
	constructor(e = !1) {
		super(!1, e);
	}
	set(e, t, n, s) {
		let r = e[t];
		if (!this._isShallow) {
			const l = Ea(r);
			if ((!Wl(n) && !Ea(n) && ((r = Ot(r)), (n = Ot(n))), !nt(e) && wi(r) && !wi(n))) return l ? !1 : ((r.value = n), !0);
		}
		const o = nt(e) && Gv(t) ? Number(t) < e.length : xt(e, t),
			a = Reflect.set(e, t, n, s);
		return e === Ot(s) && (o ? vo(n, r) && fr(e, 'set', t, n) : fr(e, 'add', t, n)), a;
	}
	deleteProperty(e, t) {
		const n = xt(e, t);
		e[t];
		const s = Reflect.deleteProperty(e, t);
		return s && n && fr(e, 'delete', t, void 0), s;
	}
	has(e, t) {
		const n = Reflect.has(e, t);
		return (!oc(t) || !oS.has(t)) && bi(e, 'has', t), n;
	}
	ownKeys(e) {
		return bi(e, 'iterate', nt(e) ? 'length' : ma), Reflect.ownKeys(e);
	}
}
class oC extends aS {
	constructor(e = !1) {
		super(!0, e);
	}
	set(e, t) {
		return !0;
	}
	deleteProperty(e, t) {
		return !0;
	}
}
const aC = new lS(),
	lC = new oC(),
	cC = new lS(!0);
const jv = (i) => i,
	wp = (i) => Reflect.getPrototypeOf(i);
function Su(i, e, t = !1, n = !1) {
	i = i.__v_raw;
	const s = Ot(i),
		r = Ot(e);
	t || (vo(e, r) && bi(s, 'get', e), bi(s, 'get', r));
	const { has: o } = wp(s),
		a = n ? jv : t ? Zv : hh;
	if (o.call(s, e)) return a(i.get(e));
	if (o.call(s, r)) return a(i.get(r));
	i !== s && i.get(e);
}
function Mu(i, e = !1) {
	const t = this.__v_raw,
		n = Ot(t),
		s = Ot(i);
	return e || (vo(i, s) && bi(n, 'has', i), bi(n, 'has', s)), i === s ? t.has(i) : t.has(i) || t.has(s);
}
function Eu(i, e = !1) {
	return (i = i.__v_raw), !e && bi(Ot(i), 'iterate', ma), Reflect.get(i, 'size', i);
}
function iy(i, e = !1) {
	!e && !Wl(i) && !Ea(i) && (i = Ot(i));
	const t = Ot(this);
	return wp(t).has.call(t, i) || (t.add(i), fr(t, 'add', i, i)), this;
}
function sy(i, e, t = !1) {
	!t && !Wl(e) && !Ea(e) && (e = Ot(e));
	const n = Ot(this),
		{ has: s, get: r } = wp(n);
	let o = s.call(n, i);
	o || ((i = Ot(i)), (o = s.call(n, i)));
	const a = r.call(n, i);
	return n.set(i, e), o ? vo(e, a) && fr(n, 'set', i, e) : fr(n, 'add', i, e), this;
}
function ry(i) {
	const e = Ot(this),
		{ has: t, get: n } = wp(e);
	let s = t.call(e, i);
	s || ((i = Ot(i)), (s = t.call(e, i))), n && n.call(e, i);
	const r = e.delete(i);
	return s && fr(e, 'delete', i, void 0), r;
}
function oy() {
	const i = Ot(this),
		e = i.size !== 0,
		t = i.clear();
	return e && fr(i, 'clear', void 0, void 0), t;
}
function Tu(i, e) {
	return function (n, s) {
		const r = this,
			o = r.__v_raw,
			a = Ot(o),
			l = e ? jv : i ? Zv : hh;
		return !i && bi(a, 'iterate', ma), o.forEach((c, h) => n.call(s, l(c), l(h), r));
	};
}
function Au(i, e, t) {
	return function (...n) {
		const s = this.__v_raw,
			r = Ot(s),
			o = Kc(r),
			a = i === 'entries' || (i === Symbol.iterator && o),
			l = i === 'keys' && o,
			c = s[i](...n),
			h = t ? jv : e ? Zv : hh;
		return (
			!e && bi(r, 'iterate', l ? pg : ma),
			{
				next() {
					const { value: u, done: d } = c.next();
					return d ? { value: u, done: d } : { value: a ? [h(u[0]), h(u[1])] : h(u), done: d };
				},
				[Symbol.iterator]() {
					return this;
				},
			}
		);
	};
}
function Rr(i) {
	return function (...e) {
		return i === 'delete' ? !1 : i === 'clear' ? void 0 : this;
	};
}
function hC() {
	const i = {
			get(r) {
				return Su(this, r);
			},
			get size() {
				return Eu(this);
			},
			has: Mu,
			add: iy,
			set: sy,
			delete: ry,
			clear: oy,
			forEach: Tu(!1, !1),
		},
		e = {
			get(r) {
				return Su(this, r, !1, !0);
			},
			get size() {
				return Eu(this);
			},
			has: Mu,
			add(r) {
				return iy.call(this, r, !0);
			},
			set(r, o) {
				return sy.call(this, r, o, !0);
			},
			delete: ry,
			clear: oy,
			forEach: Tu(!1, !0),
		},
		t = {
			get(r) {
				return Su(this, r, !0);
			},
			get size() {
				return Eu(this, !0);
			},
			has(r) {
				return Mu.call(this, r, !0);
			},
			add: Rr('add'),
			set: Rr('set'),
			delete: Rr('delete'),
			clear: Rr('clear'),
			forEach: Tu(!0, !1),
		},
		n = {
			get(r) {
				return Su(this, r, !0, !0);
			},
			get size() {
				return Eu(this, !0);
			},
			has(r) {
				return Mu.call(this, r, !0);
			},
			add: Rr('add'),
			set: Rr('set'),
			delete: Rr('delete'),
			clear: Rr('clear'),
			forEach: Tu(!0, !0),
		};
	return (
		['keys', 'values', 'entries', Symbol.iterator].forEach((r) => {
			(i[r] = Au(r, !1, !1)), (t[r] = Au(r, !0, !1)), (e[r] = Au(r, !1, !0)), (n[r] = Au(r, !0, !0));
		}),
		[i, t, e, n]
	);
}
const [uC, dC, pC, fC] = hC();
function Kv(i, e) {
	const t = e ? (i ? fC : pC) : i ? dC : uC;
	return (n, s, r) =>
		s === '__v_isReactive' ? !i : s === '__v_isReadonly' ? i : s === '__v_raw' ? n : Reflect.get(xt(t, s) && s in n ? t : n, s, r);
}
const mC = { get: Kv(!1, !1) },
	gC = { get: Kv(!1, !0) },
	vC = { get: Kv(!0, !1) };
const cS = new WeakMap(),
	hS = new WeakMap(),
	uS = new WeakMap(),
	_C = new WeakMap();
function yC(i) {
	switch (i) {
		case 'Object':
		case 'Array':
			return 1;
		case 'Map':
		case 'Set':
		case 'WeakMap':
		case 'WeakSet':
			return 2;
		default:
			return 0;
	}
}
function xC(i) {
	return i.__v_skip || !Object.isExtensible(i) ? 0 : yC(HA(i));
}
function Sp(i) {
	return Ea(i) ? i : $v(i, !1, aC, mC, cS);
}
function dS(i) {
	return $v(i, !1, cC, gC, hS);
}
function pS(i) {
	return $v(i, !0, lC, vC, uS);
}
function $v(i, e, t, n, s) {
	if (!_n(i) || (i.__v_raw && !(e && i.__v_isReactive))) return i;
	const r = s.get(i);
	if (r) return r;
	const o = xC(i);
	if (o === 0) return i;
	const a = new Proxy(i, o === 2 ? n : t);
	return s.set(i, a), a;
}
function Zc(i) {
	return Ea(i) ? Zc(i.__v_raw) : !!(i && i.__v_isReactive);
}
function Ea(i) {
	return !!(i && i.__v_isReadonly);
}
function Wl(i) {
	return !!(i && i.__v_isShallow);
}
function fS(i) {
	return i ? !!i.__v_raw : !1;
}
function Ot(i) {
	const e = i && i.__v_raw;
	return e ? Ot(e) : i;
}
function bC(i) {
	return Object.isExtensible(i) && Jw(i, '__v_skip', !0), i;
}
const hh = (i) => (_n(i) ? Sp(i) : i),
	Zv = (i) => (_n(i) ? pS(i) : i);
class mS {
	constructor(e, t, n, s) {
		(this.getter = e),
			(this._setter = t),
			(this.dep = void 0),
			(this.__v_isRef = !0),
			(this.__v_isReadonly = !1),
			(this.effect = new Xv(
				() => e(this._value),
				() => Rd(this, this.effect._dirtyLevel === 2 ? 2 : 3)
			)),
			(this.effect.computed = this),
			(this.effect.active = this._cacheable = !s),
			(this.__v_isReadonly = n);
	}
	get value() {
		const e = Ot(this);
		return (
			(!e._cacheable || e.effect.dirty) && vo(e._value, (e._value = e.effect.run())) && Rd(e, 4),
			gS(e),
			e.effect._dirtyLevel >= 2 && Rd(e, 2),
			e._value
		);
	}
	set value(e) {
		this._setter(e);
	}
	get _dirty() {
		return this.effect.dirty;
	}
	set _dirty(e) {
		this.effect.dirty = e;
	}
}
function wC(i, e, t = !1) {
	let n, s;
	const r = ct(i);
	return r ? ((n = i), (s = Qi)) : ((n = i.get), (s = i.set)), new mS(n, s, r || !s, t);
}
function gS(i) {
	var e;
	oo && fa && ((i = Ot(i)), iS(fa, (e = i.dep) != null ? e : (i.dep = rS(() => (i.dep = void 0), i instanceof mS ? i : void 0))));
}
function Rd(i, e = 4, t, n) {
	i = Ot(i);
	const s = i.dep;
	s && sS(s, e);
}
function wi(i) {
	return !!(i && i.__v_isRef === !0);
}
function Mp(i) {
	return vS(i, !1);
}
function SC(i) {
	return vS(i, !0);
}
function vS(i, e) {
	return wi(i) ? i : new MC(i, e);
}
class MC {
	constructor(e, t) {
		(this.__v_isShallow = t),
			(this.dep = void 0),
			(this.__v_isRef = !0),
			(this._rawValue = t ? e : Ot(e)),
			(this._value = t ? e : hh(e));
	}
	get value() {
		return gS(this), this._value;
	}
	set value(e) {
		const t = this.__v_isShallow || Wl(e) || Ea(e);
		(e = t ? e : Ot(e)), vo(e, this._rawValue) && (this._rawValue, (this._rawValue = e), (this._value = t ? e : hh(e)), Rd(this, 4));
	}
}
function ao(i) {
	return wi(i) ? i.value : i;
}
const EC = {
	get: (i, e, t) => ao(Reflect.get(i, e, t)),
	set: (i, e, t, n) => {
		const s = i[e];
		return wi(s) && !wi(t) ? ((s.value = t), !0) : Reflect.set(i, e, t, n);
	},
};
function _S(i) {
	return Zc(i) ? i : new Proxy(i, EC);
}
/**
 * @vue/runtime-core v3.4.38
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function lo(i, e, t, n) {
	try {
		return n ? i(...n) : i();
	} catch (s) {
		Ep(s, e, t);
	}
}
function ws(i, e, t, n) {
	if (ct(i)) {
		const s = lo(i, e, t, n);
		return (
			s &&
				$w(s) &&
				s.catch((r) => {
					Ep(r, e, t);
				}),
			s
		);
	}
	if (nt(i)) {
		const s = [];
		for (let r = 0; r < i.length; r++) s.push(ws(i[r], e, t, n));
		return s;
	}
}
function Ep(i, e, t, n = !0) {
	const s = e ? e.vnode : null;
	if (e) {
		let r = e.parent;
		const o = e.proxy,
			a = 'https://vuejs.org/error-reference/#runtime-'.concat(t);
		for (; r; ) {
			const c = r.ec;
			if (c) {
				for (let h = 0; h < c.length; h++) if (c[h](i, o, a) === !1) return;
			}
			r = r.parent;
		}
		const l = e.appContext.config.errorHandler;
		if (l) {
			To(), lo(l, null, 10, [i, o, a]), Ao();
			return;
		}
	}
	TC(i, t, s, n);
}
function TC(i, e, t, n = !0) {
	console.error(i);
}
let uh = !1,
	fg = !1;
const qn = [];
let Bs = 0;
const Ol = [];
let jr = null,
	ia = 0;
const yS = Promise.resolve();
let Jv = null;
function xS(i) {
	const e = Jv || yS;
	return i ? e.then(this ? i.bind(this) : i) : e;
}
function AC(i) {
	let e = Bs + 1,
		t = qn.length;
	for (; e < t; ) {
		const n = (e + t) >>> 1,
			s = qn[n],
			r = dh(s);
		r < i || (r === i && s.pre) ? (e = n + 1) : (t = n);
	}
	return e;
}
function Qv(i) {
	(!qn.length || !qn.includes(i, uh && i.allowRecurse ? Bs + 1 : Bs)) && (i.id == null ? qn.push(i) : qn.splice(AC(i.id), 0, i), bS());
}
function bS() {
	!uh && !fg && ((fg = !0), (Jv = yS.then(SS)));
}
function CC(i) {
	const e = qn.indexOf(i);
	e > Bs && qn.splice(e, 1);
}
function RC(i) {
	nt(i) ? Ol.push(...i) : (!jr || !jr.includes(i, i.allowRecurse ? ia + 1 : ia)) && Ol.push(i), bS();
}
function ay(i, e, t = uh ? Bs + 1 : 0) {
	for (; t < qn.length; t++) {
		const n = qn[t];
		if (n && n.pre) {
			if (i && n.id !== i.uid) continue;
			qn.splice(t, 1), t--, n();
		}
	}
}
function wS(i) {
	if (Ol.length) {
		const e = [...new Set(Ol)].sort((t, n) => dh(t) - dh(n));
		if (((Ol.length = 0), jr)) {
			jr.push(...e);
			return;
		}
		for (jr = e, ia = 0; ia < jr.length; ia++) {
			const t = jr[ia];
			t.active !== !1 && t();
		}
		(jr = null), (ia = 0);
	}
}
const dh = (i) => (i.id == null ? 1 / 0 : i.id),
	PC = (i, e) => {
		const t = dh(i) - dh(e);
		if (t === 0) {
			if (i.pre && !e.pre) return -1;
			if (e.pre && !i.pre) return 1;
		}
		return t;
	};
function SS(i) {
	(fg = !1), (uh = !0), qn.sort(PC);
	try {
		for (Bs = 0; Bs < qn.length; Bs++) {
			const e = qn[Bs];
			e && e.active !== !1 && lo(e, e.i, e.i ? 15 : 14);
		}
	} finally {
		(Bs = 0), (qn.length = 0), wS(), (uh = !1), (Jv = null), (qn.length || Ol.length) && SS();
	}
}
let zs = null,
	MS = null;
function jd(i) {
	const e = zs;
	return (zs = i), (MS = (i && i.type.__scopeId) || null), e;
}
function LC(i, e = zs, t) {
	if (!e || i._n) return i;
	const n = (...s) => {
		n._d && my(-1);
		const r = jd(e);
		let o;
		try {
			o = i(...s);
		} finally {
			jd(r), n._d && my(1);
		}
		return o;
	};
	return (n._n = !0), (n._c = !0), (n._d = !0), n;
}
function Oo(i, e, t, n) {
	const s = i.dirs,
		r = e && e.dirs;
	for (let o = 0; o < s.length; o++) {
		const a = s[o];
		r && (a.oldValue = r[o].value);
		let l = a.dir[n];
		l && (To(), ws(l, t, 8, [i.el, a, i, e]), Ao());
	}
}
function ES(i, e) {
	i.shapeFlag & 6 && i.component
		? ES(i.component.subTree, e)
		: i.shapeFlag & 128
		? ((i.ssContent.transition = e.clone(i.ssContent)), (i.ssFallback.transition = e.clone(i.ssFallback)))
		: (i.transition = e);
}
/*! #__NO_SIDE_EFFECTS__ */ function ac(i, e) {
	return ct(i) ? Zn({ name: i.name }, e, { setup: i }) : i;
}
const Pd = (i) => !!i.type.__asyncLoader,
	TS = (i) => i.type.__isKeepAlive;
function IC(i, e) {
	AS(i, 'a', e);
}
function DC(i, e) {
	AS(i, 'da', e);
}
function AS(i, e, t = si) {
	const n =
		i.__wdc ||
		(i.__wdc = () => {
			let s = t;
			for (; s; ) {
				if (s.isDeactivated) return;
				s = s.parent;
			}
			return i();
		});
	if ((Tp(e, n, t), t)) {
		let s = t.parent;
		for (; s && s.parent; ) TS(s.parent.vnode) && OC(n, e, t, s), (s = s.parent);
	}
}
function OC(i, e, t, n) {
	const s = Tp(e, i, n, !0);
	CS(() => {
		Hv(n[e], s);
	}, t);
}
function Tp(i, e, t = si, n = !1) {
	if (t) {
		const s = t[i] || (t[i] = []),
			r =
				e.__weh ||
				(e.__weh = (...o) => {
					To();
					const a = jh(t),
						l = ws(e, t, i, o);
					return a(), Ao(), l;
				});
		return n ? s.unshift(r) : s.push(r), r;
	}
}
const Er =
		(i) =>
		(e, t = si) => {
			(!Ip || i === 'sp') && Tp(i, (...n) => e(...n), t);
		},
	UC = Er('bm'),
	Ap = Er('m'),
	NC = Er('bu'),
	FC = Er('u'),
	Cp = Er('bum'),
	CS = Er('um'),
	BC = Er('sp'),
	kC = Er('rtg'),
	zC = Er('rtc');
function VC(i, e = si) {
	Tp('ec', i, e);
}
const HC = Symbol.for('v-ndc'),
	mg = (i) => (i ? (YS(i) ? s_(i) : mg(i.parent)) : null),
	Jc = Zn(Object.create(null), {
		$: (i) => i,
		$el: (i) => i.vnode.el,
		$data: (i) => i.data,
		$props: (i) => i.props,
		$attrs: (i) => i.attrs,
		$slots: (i) => i.slots,
		$refs: (i) => i.refs,
		$parent: (i) => mg(i.parent),
		$root: (i) => mg(i.root),
		$emit: (i) => i.emit,
		$options: (i) => e_(i),
		$forceUpdate: (i) =>
			i.f ||
			(i.f = () => {
				(i.effect.dirty = !0), Qv(i.update);
			}),
		$nextTick: (i) => i.n || (i.n = xS.bind(i.proxy)),
		$watch: (i) => uR.bind(i),
	}),
	Pf = (i, e) => i !== en && !i.__isScriptSetup && xt(i, e),
	GC = {
		get({ _: i }, e) {
			if (e === '__v_skip') return !0;
			const { ctx: t, setupState: n, data: s, props: r, accessCache: o, type: a, appContext: l } = i;
			let c;
			if (e[0] !== '$') {
				const p = o[e];
				if (p !== void 0)
					switch (p) {
						case 1:
							return n[e];
						case 2:
							return s[e];
						case 4:
							return t[e];
						case 3:
							return r[e];
					}
				else {
					if (Pf(n, e)) return (o[e] = 1), n[e];
					if (s !== en && xt(s, e)) return (o[e] = 2), s[e];
					if ((c = i.propsOptions[0]) && xt(c, e)) return (o[e] = 3), r[e];
					if (t !== en && xt(t, e)) return (o[e] = 4), t[e];
					gg && (o[e] = 0);
				}
			}
			const h = Jc[e];
			let u, d;
			if (h) return e === '$attrs' && bi(i.attrs, 'get', ''), h(i);
			if ((u = a.__cssModules) && (u = u[e])) return u;
			if (t !== en && xt(t, e)) return (o[e] = 4), t[e];
			if (((d = l.config.globalProperties), xt(d, e))) return d[e];
		},
		set({ _: i }, e, t) {
			const { data: n, setupState: s, ctx: r } = i;
			return Pf(s, e)
				? ((s[e] = t), !0)
				: n !== en && xt(n, e)
				? ((n[e] = t), !0)
				: xt(i.props, e) || (e[0] === '$' && e.slice(1) in i)
				? !1
				: ((r[e] = t), !0);
		},
		has({ _: { data: i, setupState: e, accessCache: t, ctx: n, appContext: s, propsOptions: r } }, o) {
			let a;
			return (
				!!t[o] ||
				(i !== en && xt(i, o)) ||
				Pf(e, o) ||
				((a = r[0]) && xt(a, o)) ||
				xt(n, o) ||
				xt(Jc, o) ||
				xt(s.config.globalProperties, o)
			);
		},
		defineProperty(i, e, t) {
			return (
				t.get != null ? (i._.accessCache[e] = 0) : xt(t, 'value') && this.set(i, e, t.value, null), Reflect.defineProperty(i, e, t)
			);
		},
	};
function ly(i) {
	return nt(i) ? i.reduce((e, t) => ((e[t] = null), e), {}) : i;
}
let gg = !0;
function WC(i) {
	const e = e_(i),
		t = i.proxy,
		n = i.ctx;
	(gg = !1), e.beforeCreate && cy(e.beforeCreate, i, 'bc');
	const {
		data: s,
		computed: r,
		methods: o,
		watch: a,
		provide: l,
		inject: c,
		created: h,
		beforeMount: u,
		mounted: d,
		beforeUpdate: p,
		updated: g,
		activated: v,
		deactivated: m,
		beforeDestroy: f,
		beforeUnmount: y,
		destroyed: _,
		unmounted: x,
		render: E,
		renderTracked: w,
		renderTriggered: C,
		errorCaptured: P,
		serverPrefetch: S,
		expose: M,
		inheritAttrs: k,
		components: q,
		directives: B,
		filters: W,
	} = e;
	if ((c && XC(c, n, null), o))
		for (const le in o) {
			const Z = o[le];
			ct(Z) && (n[le] = Z.bind(t));
		}
	if (s) {
		const le = s.call(t, t);
		_n(le) && (i.data = Sp(le));
	}
	if (((gg = !0), r))
		for (const le in r) {
			const Z = r[le],
				xe = ct(Z) ? Z.bind(t, t) : ct(Z.get) ? Z.get.bind(t, t) : Qi,
				ue = !ct(Z) && ct(Z.set) ? Z.set.bind(t) : Qi,
				Te = ys({ get: xe, set: ue });
			Object.defineProperty(n, le, { enumerable: !0, configurable: !0, get: () => Te.value, set: (Ae) => (Te.value = Ae) });
		}
	if (a) for (const le in a) RS(a[le], n, t, le);
	if (l) {
		const le = ct(l) ? l.call(t) : l;
		Reflect.ownKeys(le).forEach((Z) => {
			Ld(Z, le[Z]);
		});
	}
	h && cy(h, i, 'c');
	function $(le, Z) {
		nt(Z) ? Z.forEach((xe) => le(xe.bind(t))) : Z && le(Z.bind(t));
	}
	if (($(UC, u), $(Ap, d), $(NC, p), $(FC, g), $(IC, v), $(DC, m), $(VC, P), $(zC, w), $(kC, C), $(Cp, y), $(CS, x), $(BC, S), nt(M)))
		if (M.length) {
			const le = i.exposed || (i.exposed = {});
			M.forEach((Z) => {
				Object.defineProperty(le, Z, { get: () => t[Z], set: (xe) => (t[Z] = xe) });
			});
		} else i.exposed || (i.exposed = {});
	E && i.render === Qi && (i.render = E), k != null && (i.inheritAttrs = k), q && (i.components = q), B && (i.directives = B);
}
function XC(i, e, t = Qi) {
	nt(i) && (i = vg(i));
	for (const n in i) {
		const s = i[n];
		let r;
		_n(s) ? ('default' in s ? (r = mr(s.from || n, s.default, !0)) : (r = mr(s.from || n))) : (r = mr(s)),
			wi(r)
				? Object.defineProperty(e, n, { enumerable: !0, configurable: !0, get: () => r.value, set: (o) => (r.value = o) })
				: (e[n] = r);
	}
}
function cy(i, e, t) {
	ws(nt(i) ? i.map((n) => n.bind(e.proxy)) : i.bind(e.proxy), e, t);
}
function RS(i, e, t, n) {
	const s = n.includes('.') ? GS(t, n) : () => t[n];
	if (zn(i)) {
		const r = e[i];
		ct(r) && Id(s, r);
	} else if (ct(i)) Id(s, i.bind(t));
	else if (_n(i))
		if (nt(i)) i.forEach((r) => RS(r, e, t, n));
		else {
			const r = ct(i.handler) ? i.handler.bind(t) : e[i.handler];
			ct(r) && Id(s, r, i);
		}
}
function e_(i) {
	const e = i.type,
		{ mixins: t, extends: n } = e,
		{
			mixins: s,
			optionsCache: r,
			config: { optionMergeStrategies: o },
		} = i.appContext,
		a = r.get(e);
	let l;
	return (
		a ? (l = a) : !s.length && !t && !n ? (l = e) : ((l = {}), s.length && s.forEach((c) => Kd(l, c, o, !0)), Kd(l, e, o)),
		_n(e) && r.set(e, l),
		l
	);
}
function Kd(i, e, t, n = !1) {
	const { mixins: s, extends: r } = e;
	r && Kd(i, r, t, !0), s && s.forEach((o) => Kd(i, o, t, !0));
	for (const o in e)
		if (!(n && o === 'expose')) {
			const a = qC[o] || (t && t[o]);
			i[o] = a ? a(i[o], e[o]) : e[o];
		}
	return i;
}
const qC = {
	data: hy,
	props: uy,
	emits: uy,
	methods: Wc,
	computed: Wc,
	beforeCreate: ni,
	created: ni,
	beforeMount: ni,
	mounted: ni,
	beforeUpdate: ni,
	updated: ni,
	beforeDestroy: ni,
	beforeUnmount: ni,
	destroyed: ni,
	unmounted: ni,
	activated: ni,
	deactivated: ni,
	errorCaptured: ni,
	serverPrefetch: ni,
	components: Wc,
	directives: Wc,
	watch: jC,
	provide: hy,
	inject: YC,
};
function hy(i, e) {
	return e
		? i
			? function () {
					return Zn(ct(i) ? i.call(this, this) : i, ct(e) ? e.call(this, this) : e);
			  }
			: e
		: i;
}
function YC(i, e) {
	return Wc(vg(i), vg(e));
}
function vg(i) {
	if (nt(i)) {
		const e = {};
		for (let t = 0; t < i.length; t++) e[i[t]] = i[t];
		return e;
	}
	return i;
}
function ni(i, e) {
	return i ? [...new Set([].concat(i, e))] : e;
}
function Wc(i, e) {
	return i ? Zn(Object.create(null), i, e) : e;
}
function uy(i, e) {
	return i ? (nt(i) && nt(e) ? [...new Set([...i, ...e])] : Zn(Object.create(null), ly(i), ly(e != null ? e : {}))) : e;
}
function jC(i, e) {
	if (!i) return e;
	if (!e) return i;
	const t = Zn(Object.create(null), i);
	for (const n in e) t[n] = ni(i[n], e[n]);
	return t;
}
function PS() {
	return {
		app: null,
		config: {
			isNativeTag: BA,
			performance: !1,
			globalProperties: {},
			optionMergeStrategies: {},
			errorHandler: void 0,
			warnHandler: void 0,
			compilerOptions: {},
		},
		mixins: [],
		components: {},
		directives: {},
		provides: Object.create(null),
		optionsCache: new WeakMap(),
		propsCache: new WeakMap(),
		emitsCache: new WeakMap(),
	};
}
let KC = 0;
function $C(i, e) {
	return function (n, s = null) {
		ct(n) || (n = Zn({}, n)), s != null && !_n(s) && (s = null);
		const r = PS(),
			o = new WeakSet();
		let a = !1;
		const l = (r.app = {
			_uid: KC++,
			_component: n,
			_props: s,
			_container: null,
			_context: r,
			_instance: null,
			version: OR,
			get config() {
				return r.config;
			},
			set config(c) {},
			use(c, ...h) {
				return o.has(c) || (c && ct(c.install) ? (o.add(c), c.install(l, ...h)) : ct(c) && (o.add(c), c(l, ...h))), l;
			},
			mixin(c) {
				return r.mixins.includes(c) || r.mixins.push(c), l;
			},
			component(c, h) {
				return h ? ((r.components[c] = h), l) : r.components[c];
			},
			directive(c, h) {
				return h ? ((r.directives[c] = h), l) : r.directives[c];
			},
			mount(c, h, u) {
				if (!a) {
					const d = es(n, s);
					return (
						(d.appContext = r),
						u === !0 ? (u = 'svg') : u === !1 && (u = void 0),
						h && e ? e(d, c) : i(d, c, u),
						(a = !0),
						(l._container = c),
						(c.__vue_app__ = l),
						s_(d.component)
					);
				}
			},
			unmount() {
				a && (i(null, l._container), delete l._container.__vue_app__);
			},
			provide(c, h) {
				return (r.provides[c] = h), l;
			},
			runWithContext(c) {
				const h = Ul;
				Ul = l;
				try {
					return c();
				} finally {
					Ul = h;
				}
			},
		});
		return l;
	};
}
let Ul = null;
function Ld(i, e) {
	if (si) {
		let t = si.provides;
		const n = si.parent && si.parent.provides;
		n === t && (t = si.provides = Object.create(n)), (t[i] = e);
	}
}
function mr(i, e, t = !1) {
	const n = si || zs;
	if (n || Ul) {
		const s = Ul
			? Ul._context.provides
			: n
			? n.parent == null
				? n.vnode.appContext && n.vnode.appContext.provides
				: n.parent.provides
			: void 0;
		if (s && i in s) return s[i];
		if (arguments.length > 1) return t && ct(e) ? e.call(n && n.proxy) : e;
	}
}
const LS = {},
	IS = () => Object.create(LS),
	DS = (i) => Object.getPrototypeOf(i) === LS;
function ZC(i, e, t, n = !1) {
	const s = {},
		r = IS();
	(i.propsDefaults = Object.create(null)), OS(i, e, s, r);
	for (const o in i.propsOptions[0]) o in s || (s[o] = void 0);
	t ? (i.props = n ? s : dS(s)) : i.type.props ? (i.props = s) : (i.props = r), (i.attrs = r);
}
function JC(i, e, t, n) {
	const {
			props: s,
			attrs: r,
			vnode: { patchFlag: o },
		} = i,
		a = Ot(s),
		[l] = i.propsOptions;
	let c = !1;
	if ((n || o > 0) && !(o & 16)) {
		if (o & 8) {
			const h = i.vnode.dynamicProps;
			for (let u = 0; u < h.length; u++) {
				let d = h[u];
				if (Rp(i.emitsOptions, d)) continue;
				const p = e[d];
				if (l)
					if (xt(r, d)) p !== r[d] && ((r[d] = p), (c = !0));
					else {
						const g = Ma(d);
						s[g] = _g(l, a, g, p, i, !1);
					}
				else p !== r[d] && ((r[d] = p), (c = !0));
			}
		}
	} else {
		OS(i, e, s, r) && (c = !0);
		let h;
		for (const u in a)
			(!e || (!xt(e, u) && ((h = Fa(u)) === u || !xt(e, h)))) &&
				(l ? t && (t[u] !== void 0 || t[h] !== void 0) && (s[u] = _g(l, a, u, void 0, i, !0)) : delete s[u]);
		if (r !== a) for (const u in r) (!e || !xt(e, u)) && (delete r[u], (c = !0));
	}
	c && fr(i.attrs, 'set', '');
}
function OS(i, e, t, n) {
	const [s, r] = i.propsOptions;
	let o = !1,
		a;
	if (e)
		for (let l in e) {
			if ($c(l)) continue;
			const c = e[l];
			let h;
			s && xt(s, (h = Ma(l)))
				? !r || !r.includes(h)
					? (t[h] = c)
					: ((a || (a = {}))[h] = c)
				: Rp(i.emitsOptions, l) || ((!(l in n) || c !== n[l]) && ((n[l] = c), (o = !0)));
		}
	if (r) {
		const l = Ot(t),
			c = a || en;
		for (let h = 0; h < r.length; h++) {
			const u = r[h];
			t[u] = _g(s, l, u, c[u], i, !xt(c, u));
		}
	}
	return o;
}
function _g(i, e, t, n, s, r) {
	const o = i[t];
	if (o != null) {
		const a = xt(o, 'default');
		if (a && n === void 0) {
			const l = o.default;
			if (o.type !== Function && !o.skipFactory && ct(l)) {
				const { propsDefaults: c } = s;
				if (t in c) n = c[t];
				else {
					const h = jh(s);
					(n = c[t] = l.call(null, e)), h();
				}
			} else n = l;
		}
		o[0] && (r && !a ? (n = !1) : o[1] && (n === '' || n === Fa(t)) && (n = !0));
	}
	return n;
}
const QC = new WeakMap();
function US(i, e, t = !1) {
	const n = t ? QC : e.propsCache,
		s = n.get(i);
	if (s) return s;
	const r = i.props,
		o = {},
		a = [];
	let l = !1;
	if (!ct(i)) {
		const h = (u) => {
			l = !0;
			const [d, p] = US(u, e, !0);
			Zn(o, d), p && a.push(...p);
		};
		!t && e.mixins.length && e.mixins.forEach(h), i.extends && h(i.extends), i.mixins && i.mixins.forEach(h);
	}
	if (!r && !l) return _n(i) && n.set(i, Dl), Dl;
	if (nt(r))
		for (let h = 0; h < r.length; h++) {
			const u = Ma(r[h]);
			dy(u) && (o[u] = en);
		}
	else if (r)
		for (const h in r) {
			const u = Ma(h);
			if (dy(u)) {
				const d = r[h],
					p = (o[u] = nt(d) || ct(d) ? { type: d } : Zn({}, d)),
					g = p.type;
				let v = !1,
					m = !0;
				if (nt(g))
					for (let f = 0; f < g.length; ++f) {
						const y = g[f],
							_ = ct(y) && y.name;
						if (_ === 'Boolean') {
							v = !0;
							break;
						} else _ === 'String' && (m = !1);
					}
				else v = ct(g) && g.name === 'Boolean';
				(p[0] = v), (p[1] = m), (v || xt(p, 'default')) && a.push(u);
			}
		}
	const c = [o, a];
	return _n(i) && n.set(i, c), c;
}
function dy(i) {
	return i[0] !== '$' && !$c(i);
}
const NS = (i) => i[0] === '_' || i === '$stable',
	t_ = (i) => (nt(i) ? i.map(Fs) : [Fs(i)]),
	eR = (i, e, t) => {
		if (e._n) return e;
		const n = LC((...s) => t_(e(...s)), t);
		return (n._c = !1), n;
	},
	FS = (i, e, t) => {
		const n = i._ctx;
		for (const s in i) {
			if (NS(s)) continue;
			const r = i[s];
			if (ct(r)) e[s] = eR(s, r, n);
			else if (r != null) {
				const o = t_(r);
				e[s] = () => o;
			}
		}
	},
	BS = (i, e) => {
		const t = t_(e);
		i.slots.default = () => t;
	},
	kS = (i, e, t) => {
		for (const n in e) (t || n !== '_') && (i[n] = e[n]);
	},
	tR = (i, e, t) => {
		const n = (i.slots = IS());
		if (i.vnode.shapeFlag & 32) {
			const s = e._;
			s ? (kS(n, e, t), t && Jw(n, '_', s, !0)) : FS(e, n);
		} else e && BS(i, e);
	},
	nR = (i, e, t) => {
		const { vnode: n, slots: s } = i;
		let r = !0,
			o = en;
		if (n.shapeFlag & 32) {
			const a = e._;
			a ? (t && a === 1 ? (r = !1) : kS(s, e, t)) : ((r = !e.$stable), FS(e, s)), (o = e);
		} else e && (BS(i, e), (o = { default: 1 }));
		if (r) for (const a in s) !NS(a) && o[a] == null && delete s[a];
	};
function yg(i, e, t, n, s = !1) {
	if (nt(i)) {
		i.forEach((d, p) => yg(d, e && (nt(e) ? e[p] : e), t, n, s));
		return;
	}
	if (Pd(n) && !s) return;
	const r = n.shapeFlag & 4 ? s_(n.component) : n.el,
		o = s ? null : r,
		{ i: a, r: l } = i,
		c = e && e.r,
		h = a.refs === en ? (a.refs = {}) : a.refs,
		u = a.setupState;
	if ((c != null && c !== l && (zn(c) ? ((h[c] = null), xt(u, c) && (u[c] = null)) : wi(c) && (c.value = null)), ct(l)))
		lo(l, a, 12, [o, h]);
	else {
		const d = zn(l),
			p = wi(l);
		if (d || p) {
			const g = () => {
				if (i.f) {
					const v = d ? (xt(u, l) ? u[l] : h[l]) : l.value;
					s
						? nt(v) && Hv(v, r)
						: nt(v)
						? v.includes(r) || v.push(r)
						: d
						? ((h[l] = [r]), xt(u, l) && (u[l] = h[l]))
						: ((l.value = [r]), i.k && (h[i.k] = l.value));
				} else d ? ((h[l] = o), xt(u, l) && (u[l] = o)) : p && ((l.value = o), i.k && (h[i.k] = o));
			};
			o ? ((g.id = -1), pi(g, t)) : g();
		}
	}
}
const iR = Symbol('_vte'),
	sR = (i) => i.__isTeleport,
	pi = yR;
function rR(i) {
	return oR(i);
}
function oR(i, e) {
	const t = Qw();
	t.__VUE__ = !0;
	const {
			insert: n,
			remove: s,
			patchProp: r,
			createElement: o,
			createText: a,
			createComment: l,
			setText: c,
			setElementText: h,
			parentNode: u,
			nextSibling: d,
			setScopeId: p = Qi,
			insertStaticContent: g,
		} = i,
		v = (L, D, z, Y = null, K = null, re = null, O = void 0, T = null, V = !!D.dynamicChildren) => {
			if (L === D) return;
			L && !vc(L, D) && ((Y = X(L)), Ae(L, K, re, !0), (L = null)), D.patchFlag === -2 && ((V = !1), (D.dynamicChildren = null));
			const { type: G, ref: ee, shapeFlag: ne } = D;
			switch (G) {
				case Pp:
					m(L, D, z, Y);
					break;
				case ph:
					f(L, D, z, Y);
					break;
				case Df:
					L == null && y(D, z, Y, O);
					break;
				case hr:
					q(L, D, z, Y, K, re, O, T, V);
					break;
				default:
					ne & 1
						? E(L, D, z, Y, K, re, O, T, V)
						: ne & 6
						? B(L, D, z, Y, K, re, O, T, V)
						: (ne & 64 || ne & 128) && G.process(L, D, z, Y, K, re, O, T, V, H);
			}
			ee != null && K && yg(ee, L && L.ref, re, D || L, !D);
		},
		m = (L, D, z, Y) => {
			if (L == null) n((D.el = a(D.children)), z, Y);
			else {
				const K = (D.el = L.el);
				D.children !== L.children && c(K, D.children);
			}
		},
		f = (L, D, z, Y) => {
			L == null ? n((D.el = l(D.children || '')), z, Y) : (D.el = L.el);
		},
		y = (L, D, z, Y) => {
			[L.el, L.anchor] = g(L.children, D, z, Y, L.el, L.anchor);
		},
		_ = ({ el: L, anchor: D }, z, Y) => {
			let K;
			for (; L && L !== D; ) (K = d(L)), n(L, z, Y), (L = K);
			n(D, z, Y);
		},
		x = ({ el: L, anchor: D }) => {
			let z;
			for (; L && L !== D; ) (z = d(L)), s(L), (L = z);
			s(D);
		},
		E = (L, D, z, Y, K, re, O, T, V) => {
			D.type === 'svg' ? (O = 'svg') : D.type === 'math' && (O = 'mathml'),
				L == null ? w(D, z, Y, K, re, O, T, V) : S(L, D, K, re, O, T, V);
		},
		w = (L, D, z, Y, K, re, O, T) => {
			let V, G;
			const { props: ee, shapeFlag: ne, transition: _e, dirs: me } = L;
			if (
				((V = L.el = o(L.type, re, ee && ee.is, ee)),
				ne & 8 ? h(V, L.children) : ne & 16 && P(L.children, V, null, Y, K, Lf(L, re), O, T),
				me && Oo(L, null, Y, 'created'),
				C(V, L, L.scopeId, O, Y),
				ee)
			) {
				for (const De in ee) De !== 'value' && !$c(De) && r(V, De, null, ee[De], re, Y);
				'value' in ee && r(V, 'value', null, ee.value, re), (G = ee.onVnodeBeforeMount) && Ps(G, Y, L);
			}
			me && Oo(L, null, Y, 'beforeMount');
			const ye = aR(K, _e);
			ye && _e.beforeEnter(V),
				n(V, D, z),
				((G = ee && ee.onVnodeMounted) || ye || me) &&
					pi(() => {
						G && Ps(G, Y, L), ye && _e.enter(V), me && Oo(L, null, Y, 'mounted');
					}, K);
		},
		C = (L, D, z, Y, K) => {
			if ((z && p(L, z), Y)) for (let re = 0; re < Y.length; re++) p(L, Y[re]);
			if (K) {
				let re = K.subTree;
				if (D === re) {
					const O = K.vnode;
					C(L, O, O.scopeId, O.slotScopeIds, K.parent);
				}
			}
		},
		P = (L, D, z, Y, K, re, O, T, V = 0) => {
			for (let G = V; G < L.length; G++) {
				const ee = (L[G] = T ? Kr(L[G]) : Fs(L[G]));
				v(null, ee, D, z, Y, K, re, O, T);
			}
		},
		S = (L, D, z, Y, K, re, O) => {
			const T = (D.el = L.el);
			let { patchFlag: V, dynamicChildren: G, dirs: ee } = D;
			V |= L.patchFlag & 16;
			const ne = L.props || en,
				_e = D.props || en;
			let me;
			if (
				(z && Uo(z, !1),
				(me = _e.onVnodeBeforeUpdate) && Ps(me, z, D, L),
				ee && Oo(D, L, z, 'beforeUpdate'),
				z && Uo(z, !0),
				((ne.innerHTML && _e.innerHTML == null) || (ne.textContent && _e.textContent == null)) && h(T, ''),
				G ? M(L.dynamicChildren, G, T, z, Y, Lf(D, K), re) : O || Z(L, D, T, null, z, Y, Lf(D, K), re, !1),
				V > 0)
			) {
				if (V & 16) k(T, ne, _e, z, K);
				else if (
					(V & 2 && ne.class !== _e.class && r(T, 'class', null, _e.class, K),
					V & 4 && r(T, 'style', ne.style, _e.style, K),
					V & 8)
				) {
					const ye = D.dynamicProps;
					for (let De = 0; De < ye.length; De++) {
						const ve = ye[De],
							Le = ne[ve],
							Ye = _e[ve];
						(Ye !== Le || ve === 'value') && r(T, ve, Le, Ye, K, z);
					}
				}
				V & 1 && L.children !== D.children && h(T, D.children);
			} else !O && G == null && k(T, ne, _e, z, K);
			((me = _e.onVnodeUpdated) || ee) &&
				pi(() => {
					me && Ps(me, z, D, L), ee && Oo(D, L, z, 'updated');
				}, Y);
		},
		M = (L, D, z, Y, K, re, O) => {
			for (let T = 0; T < D.length; T++) {
				const V = L[T],
					G = D[T],
					ee = V.el && (V.type === hr || !vc(V, G) || V.shapeFlag & 70) ? u(V.el) : z;
				v(V, G, ee, null, Y, K, re, O, !0);
			}
		},
		k = (L, D, z, Y, K) => {
			if (D !== z) {
				if (D !== en) for (const re in D) !$c(re) && !(re in z) && r(L, re, D[re], null, K, Y);
				for (const re in z) {
					if ($c(re)) continue;
					const O = z[re],
						T = D[re];
					O !== T && re !== 'value' && r(L, re, T, O, K, Y);
				}
				'value' in z && r(L, 'value', D.value, z.value, K);
			}
		},
		q = (L, D, z, Y, K, re, O, T, V) => {
			const G = (D.el = L ? L.el : a('')),
				ee = (D.anchor = L ? L.anchor : a(''));
			let { patchFlag: ne, dynamicChildren: _e, slotScopeIds: me } = D;
			me && (T = T ? T.concat(me) : me),
				L == null
					? (n(G, z, Y), n(ee, z, Y), P(D.children || [], z, ee, K, re, O, T, V))
					: ne > 0 && ne & 64 && _e && L.dynamicChildren
					? (M(L.dynamicChildren, _e, z, K, re, O, T), (D.key != null || (K && D === K.subTree)) && zS(L, D, !0))
					: Z(L, D, z, ee, K, re, O, T, V);
		},
		B = (L, D, z, Y, K, re, O, T, V) => {
			(D.slotScopeIds = T), L == null ? (D.shapeFlag & 512 ? K.ctx.activate(D, z, Y, O, V) : W(D, z, Y, K, re, O, V)) : Q(L, D, V);
		},
		W = (L, D, z, Y, K, re, O) => {
			const T = (L.component = CR(L, Y, K));
			if ((TS(L) && (T.ctx.renderer = H), RR(T, !1, O), T.asyncDep)) {
				if ((K && K.registerDep(T, $, O), !L.el)) {
					const V = (T.subTree = es(ph));
					f(null, V, D, z);
				}
			} else $(T, L, D, z, K, re, O);
		},
		Q = (L, D, z) => {
			const Y = (D.component = L.component);
			if (gR(L, D, z))
				if (Y.asyncDep && !Y.asyncResolved) {
					le(Y, D, z);
					return;
				} else (Y.next = D), CC(Y.update), (Y.effect.dirty = !0), Y.update();
			else (D.el = L.el), (Y.vnode = D);
		},
		$ = (L, D, z, Y, K, re, O) => {
			const T = () => {
					if (L.isMounted) {
						let { next: ee, bu: ne, u: _e, parent: me, vnode: ye } = L;
						{
							const Xe = VS(L);
							if (Xe) {
								ee && ((ee.el = ye.el), le(L, ee, O)),
									Xe.asyncDep.then(() => {
										L.isUnmounted || T();
									});
								return;
							}
						}
						let De = ee,
							ve;
						Uo(L, !1),
							ee ? ((ee.el = ye.el), le(L, ee, O)) : (ee = ye),
							ne && Rf(ne),
							(ve = ee.props && ee.props.onVnodeBeforeUpdate) && Ps(ve, me, ee, ye),
							Uo(L, !0);
						const Le = If(L),
							Ye = L.subTree;
						(L.subTree = Le),
							v(Ye, Le, u(Ye.el), X(Ye), L, K, re),
							(ee.el = Le.el),
							De === null && vR(L, Le.el),
							_e && pi(_e, K),
							(ve = ee.props && ee.props.onVnodeUpdated) && pi(() => Ps(ve, me, ee, ye), K);
					} else {
						let ee;
						const { el: ne, props: _e } = D,
							{ bm: me, m: ye, parent: De } = L,
							ve = Pd(D);
						if ((Uo(L, !1), me && Rf(me), !ve && (ee = _e && _e.onVnodeBeforeMount) && Ps(ee, De, D), Uo(L, !0), ne && oe)) {
							const Le = () => {
								(L.subTree = If(L)), oe(ne, L.subTree, L, K, null);
							};
							ve ? D.type.__asyncLoader().then(() => !L.isUnmounted && Le()) : Le();
						} else {
							const Le = (L.subTree = If(L));
							v(null, Le, z, Y, L, K, re), (D.el = Le.el);
						}
						if ((ye && pi(ye, K), !ve && (ee = _e && _e.onVnodeMounted))) {
							const Le = D;
							pi(() => Ps(ee, De, Le), K);
						}
						(D.shapeFlag & 256 || (De && Pd(De.vnode) && De.vnode.shapeFlag & 256)) && L.a && pi(L.a, K),
							(L.isMounted = !0),
							(D = z = Y = null);
					}
				},
				V = (L.effect = new Xv(T, Qi, () => Qv(G), L.scope)),
				G = (L.update = () => {
					V.dirty && V.run();
				});
			(G.i = L), (G.id = L.uid), Uo(L, !0), G();
		},
		le = (L, D, z) => {
			D.component = L;
			const Y = L.vnode.props;
			(L.vnode = D), (L.next = null), JC(L, D.props, Y, z), nR(L, D.children, z), To(), ay(L), Ao();
		},
		Z = (L, D, z, Y, K, re, O, T, V = !1) => {
			const G = L && L.children,
				ee = L ? L.shapeFlag : 0,
				ne = D.children,
				{ patchFlag: _e, shapeFlag: me } = D;
			if (_e > 0) {
				if (_e & 128) {
					ue(G, ne, z, Y, K, re, O, T, V);
					return;
				} else if (_e & 256) {
					xe(G, ne, z, Y, K, re, O, T, V);
					return;
				}
			}
			me & 8
				? (ee & 16 && we(G, K, re), ne !== G && h(z, ne))
				: ee & 16
				? me & 16
					? ue(G, ne, z, Y, K, re, O, T, V)
					: we(G, K, re, !0)
				: (ee & 8 && h(z, ''), me & 16 && P(ne, z, Y, K, re, O, T, V));
		},
		xe = (L, D, z, Y, K, re, O, T, V) => {
			(L = L || Dl), (D = D || Dl);
			const G = L.length,
				ee = D.length,
				ne = Math.min(G, ee);
			let _e;
			for (_e = 0; _e < ne; _e++) {
				const me = (D[_e] = V ? Kr(D[_e]) : Fs(D[_e]));
				v(L[_e], me, z, null, K, re, O, T, V);
			}
			G > ee ? we(L, K, re, !0, !1, ne) : P(D, z, Y, K, re, O, T, V, ne);
		},
		ue = (L, D, z, Y, K, re, O, T, V) => {
			let G = 0;
			const ee = D.length;
			let ne = L.length - 1,
				_e = ee - 1;
			for (; G <= ne && G <= _e; ) {
				const me = L[G],
					ye = (D[G] = V ? Kr(D[G]) : Fs(D[G]));
				if (vc(me, ye)) v(me, ye, z, null, K, re, O, T, V);
				else break;
				G++;
			}
			for (; G <= ne && G <= _e; ) {
				const me = L[ne],
					ye = (D[_e] = V ? Kr(D[_e]) : Fs(D[_e]));
				if (vc(me, ye)) v(me, ye, z, null, K, re, O, T, V);
				else break;
				ne--, _e--;
			}
			if (G > ne) {
				if (G <= _e) {
					const me = _e + 1,
						ye = me < ee ? D[me].el : Y;
					for (; G <= _e; ) v(null, (D[G] = V ? Kr(D[G]) : Fs(D[G])), z, ye, K, re, O, T, V), G++;
				}
			} else if (G > _e) for (; G <= ne; ) Ae(L[G], K, re, !0), G++;
			else {
				const me = G,
					ye = G,
					De = new Map();
				for (G = ye; G <= _e; G++) {
					const Qe = (D[G] = V ? Kr(D[G]) : Fs(D[G]));
					Qe.key != null && De.set(Qe.key, G);
				}
				let ve,
					Le = 0;
				const Ye = _e - ye + 1;
				let Xe = !1,
					Ie = 0;
				const Ve = new Array(Ye);
				for (G = 0; G < Ye; G++) Ve[G] = 0;
				for (G = me; G <= ne; G++) {
					const Qe = L[G];
					if (Le >= Ye) {
						Ae(Qe, K, re, !0);
						continue;
					}
					let Be;
					if (Qe.key != null) Be = De.get(Qe.key);
					else
						for (ve = ye; ve <= _e; ve++)
							if (Ve[ve - ye] === 0 && vc(Qe, D[ve])) {
								Be = ve;
								break;
							}
					Be === void 0
						? Ae(Qe, K, re, !0)
						: ((Ve[Be - ye] = G + 1), Be >= Ie ? (Ie = Be) : (Xe = !0), v(Qe, D[Be], z, null, K, re, O, T, V), Le++);
				}
				const it = Xe ? lR(Ve) : Dl;
				for (ve = it.length - 1, G = Ye - 1; G >= 0; G--) {
					const Qe = ye + G,
						Be = D[Qe],
						j = Qe + 1 < ee ? D[Qe + 1].el : Y;
					Ve[G] === 0 ? v(null, Be, z, j, K, re, O, T, V) : Xe && (ve < 0 || G !== it[ve] ? Te(Be, z, j, 2) : ve--);
				}
			}
		},
		Te = (L, D, z, Y, K = null) => {
			const { el: re, type: O, transition: T, children: V, shapeFlag: G } = L;
			if (G & 6) {
				Te(L.component.subTree, D, z, Y);
				return;
			}
			if (G & 128) {
				L.suspense.move(D, z, Y);
				return;
			}
			if (G & 64) {
				O.move(L, D, z, H);
				return;
			}
			if (O === hr) {
				n(re, D, z);
				for (let ne = 0; ne < V.length; ne++) Te(V[ne], D, z, Y);
				n(L.anchor, D, z);
				return;
			}
			if (O === Df) {
				_(L, D, z);
				return;
			}
			if (Y !== 2 && G & 1 && T)
				if (Y === 0) T.beforeEnter(re), n(re, D, z), pi(() => T.enter(re), K);
				else {
					const { leave: ne, delayLeave: _e, afterLeave: me } = T,
						ye = () => n(re, D, z),
						De = () => {
							ne(re, () => {
								ye(), me && me();
							});
						};
					_e ? _e(re, ye, De) : De();
				}
			else n(re, D, z);
		},
		Ae = (L, D, z, Y = !1, K = !1) => {
			const {
				type: re,
				props: O,
				ref: T,
				children: V,
				dynamicChildren: G,
				shapeFlag: ee,
				patchFlag: ne,
				dirs: _e,
				cacheIndex: me,
			} = L;
			if ((ne === -2 && (K = !1), T != null && yg(T, null, z, L, !0), me != null && (D.renderCache[me] = void 0), ee & 256)) {
				D.ctx.deactivate(L);
				return;
			}
			const ye = ee & 1 && _e,
				De = !Pd(L);
			let ve;
			if ((De && (ve = O && O.onVnodeBeforeUnmount) && Ps(ve, D, L), ee & 6)) Se(L.component, z, Y);
			else {
				if (ee & 128) {
					L.suspense.unmount(z, Y);
					return;
				}
				ye && Oo(L, null, D, 'beforeUnmount'),
					ee & 64
						? L.type.remove(L, D, z, H, Y)
						: G && !G.hasOnce && (re !== hr || (ne > 0 && ne & 64))
						? we(G, D, z, !1, !0)
						: ((re === hr && ne & 384) || (!K && ee & 16)) && we(V, D, z),
					Y && We(L);
			}
			((De && (ve = O && O.onVnodeUnmounted)) || ye) &&
				pi(() => {
					ve && Ps(ve, D, L), ye && Oo(L, null, D, 'unmounted');
				}, z);
		},
		We = (L) => {
			const { type: D, el: z, anchor: Y, transition: K } = L;
			if (D === hr) {
				se(z, Y);
				return;
			}
			if (D === Df) {
				x(L);
				return;
			}
			const re = () => {
				s(z), K && !K.persisted && K.afterLeave && K.afterLeave();
			};
			if (L.shapeFlag & 1 && K && !K.persisted) {
				const { leave: O, delayLeave: T } = K,
					V = () => O(z, re);
				T ? T(L.el, re, V) : V();
			} else re();
		},
		se = (L, D) => {
			let z;
			for (; L !== D; ) (z = d(L)), s(L), (L = z);
			s(D);
		},
		Se = (L, D, z) => {
			const { bum: Y, scope: K, update: re, subTree: O, um: T, m: V, a: G } = L;
			py(V),
				py(G),
				Y && Rf(Y),
				K.stop(),
				re && ((re.active = !1), Ae(O, L, D, z)),
				T && pi(T, D),
				pi(() => {
					L.isUnmounted = !0;
				}, D),
				D &&
					D.pendingBranch &&
					!D.isUnmounted &&
					L.asyncDep &&
					!L.asyncResolved &&
					L.suspenseId === D.pendingId &&
					(D.deps--, D.deps === 0 && D.resolve());
		},
		we = (L, D, z, Y = !1, K = !1, re = 0) => {
			for (let O = re; O < L.length; O++) Ae(L[O], D, z, Y, K);
		},
		X = (L) => {
			if (L.shapeFlag & 6) return X(L.component.subTree);
			if (L.shapeFlag & 128) return L.suspense.next();
			const D = d(L.anchor || L.el),
				z = D && D[iR];
			return z ? d(z) : D;
		};
	let ge = !1;
	const be = (L, D, z) => {
			L == null ? D._vnode && Ae(D._vnode, null, null, !0) : v(D._vnode || null, L, D, null, null, null, z),
				(D._vnode = L),
				ge || ((ge = !0), ay(), wS(), (ge = !1));
		},
		H = { p: v, um: Ae, m: Te, r: We, mt: W, mc: P, pc: Z, pbc: M, n: X, o: i };
	let Ne, oe;
	return { render: be, hydrate: Ne, createApp: $C(be, Ne) };
}
function Lf({ type: i, props: e }, t) {
	return (t === 'svg' && i === 'foreignObject') ||
		(t === 'mathml' && i === 'annotation-xml' && e && e.encoding && e.encoding.includes('html'))
		? void 0
		: t;
}
function Uo({ effect: i, update: e }, t) {
	i.allowRecurse = e.allowRecurse = t;
}
function aR(i, e) {
	return (!i || (i && !i.pendingBranch)) && e && !e.persisted;
}
function zS(i, e, t = !1) {
	const n = i.children,
		s = e.children;
	if (nt(n) && nt(s))
		for (let r = 0; r < n.length; r++) {
			const o = n[r];
			let a = s[r];
			a.shapeFlag & 1 &&
				!a.dynamicChildren &&
				((a.patchFlag <= 0 || a.patchFlag === 32) && ((a = s[r] = Kr(s[r])), (a.el = o.el)), !t && a.patchFlag !== -2 && zS(o, a)),
				a.type === Pp && (a.el = o.el);
		}
}
function lR(i) {
	const e = i.slice(),
		t = [0];
	let n, s, r, o, a;
	const l = i.length;
	for (n = 0; n < l; n++) {
		const c = i[n];
		if (c !== 0) {
			if (((s = t[t.length - 1]), i[s] < c)) {
				(e[n] = s), t.push(n);
				continue;
			}
			for (r = 0, o = t.length - 1; r < o; ) (a = (r + o) >> 1), i[t[a]] < c ? (r = a + 1) : (o = a);
			c < i[t[r]] && (r > 0 && (e[n] = t[r - 1]), (t[r] = n));
		}
	}
	for (r = t.length, o = t[r - 1]; r-- > 0; ) (t[r] = o), (o = e[o]);
	return t;
}
function VS(i) {
	const e = i.subTree.component;
	if (e) return e.asyncDep && !e.asyncResolved ? e : VS(e);
}
function py(i) {
	if (i) for (let e = 0; e < i.length; e++) i[e].active = !1;
}
const cR = Symbol.for('v-scx'),
	hR = () => mr(cR),
	Cu = {};
function Id(i, e, t) {
	return HS(i, e, t);
}
function HS(i, e, { immediate: t, deep: n, flush: s, once: r, onTrack: o, onTrigger: a } = en) {
	if (e && r) {
		const w = e;
		e = (...C) => {
			w(...C), E();
		};
	}
	const l = si,
		c = (w) => (n === !0 ? w : sa(w, n === !1 ? 1 : void 0));
	let h,
		u = !1,
		d = !1;
	if (
		(wi(i)
			? ((h = () => i.value), (u = Wl(i)))
			: Zc(i)
			? ((h = () => c(i)), (u = !0))
			: nt(i)
			? ((d = !0),
			  (u = i.some((w) => Zc(w) || Wl(w))),
			  (h = () =>
					i.map((w) => {
						if (wi(w)) return w.value;
						if (Zc(w)) return c(w);
						if (ct(w)) return lo(w, l, 2);
					})))
			: ct(i)
			? e
				? (h = () => lo(i, l, 2))
				: (h = () => (p && p(), ws(i, l, 3, [g])))
			: (h = Qi),
		e && n)
	) {
		const w = h;
		h = () => sa(w());
	}
	let p,
		g = (w) => {
			p = _.onStop = () => {
				lo(w, l, 4), (p = _.onStop = void 0);
			};
		},
		v;
	if (Ip)
		if (((g = Qi), e ? t && ws(e, l, 3, [h(), d ? [] : void 0, g]) : h(), s === 'sync')) {
			const w = hR();
			v = w.__watcherHandles || (w.__watcherHandles = []);
		} else return Qi;
	let m = d ? new Array(i.length).fill(Cu) : Cu;
	const f = () => {
		if (!(!_.active || !_.dirty))
			if (e) {
				const w = _.run();
				(n || u || (d ? w.some((C, P) => vo(C, m[P])) : vo(w, m))) &&
					(p && p(), ws(e, l, 3, [w, m === Cu ? void 0 : d && m[0] === Cu ? [] : m, g]), (m = w));
			} else _.run();
	};
	f.allowRecurse = !!e;
	let y;
	s === 'sync' ? (y = f) : s === 'post' ? (y = () => pi(f, l && l.suspense)) : ((f.pre = !0), l && (f.id = l.uid), (y = () => Qv(f)));
	const _ = new Xv(h, Qi, y),
		x = tC(),
		E = () => {
			_.stop(), x && Hv(x.effects, _);
		};
	return e ? (t ? f() : (m = _.run())) : s === 'post' ? pi(_.run.bind(_), l && l.suspense) : _.run(), v && v.push(E), E;
}
function uR(i, e, t) {
	const n = this.proxy,
		s = zn(i) ? (i.includes('.') ? GS(n, i) : () => n[i]) : i.bind(n, n);
	let r;
	ct(e) ? (r = e) : ((r = e.handler), (t = e));
	const o = jh(this),
		a = HS(s, r.bind(n), t);
	return o(), a;
}
function GS(i, e) {
	const t = e.split('.');
	return () => {
		let n = i;
		for (let s = 0; s < t.length && n; s++) n = n[t[s]];
		return n;
	};
}
function sa(i, e = 1 / 0, t) {
	if (e <= 0 || !_n(i) || i.__v_skip || ((t = t || new Set()), t.has(i))) return i;
	if ((t.add(i), e--, wi(i))) sa(i.value, e, t);
	else if (nt(i)) for (let n = 0; n < i.length; n++) sa(i[n], e, t);
	else if (zA(i) || Kc(i))
		i.forEach((n) => {
			sa(n, e, t);
		});
	else if (GA(i)) {
		for (const n in i) sa(i[n], e, t);
		for (const n of Object.getOwnPropertySymbols(i)) Object.prototype.propertyIsEnumerable.call(i, n) && sa(i[n], e, t);
	}
	return i;
}
const dR = (i, e) =>
	e === 'modelValue' || e === 'model-value'
		? i.modelModifiers
		: i[''.concat(e, 'Modifiers')] || i[''.concat(Ma(e), 'Modifiers')] || i[''.concat(Fa(e), 'Modifiers')];
function pR(i, e, ...t) {
	if (i.isUnmounted) return;
	const n = i.vnode.props || en;
	let s = t;
	const r = e.startsWith('update:'),
		o = r && dR(n, e.slice(7));
	o && (o.trim && (s = t.map((h) => (zn(h) ? h.trim() : h))), o.number && (s = t.map(qA)));
	let a,
		l = n[(a = Cf(e))] || n[(a = Cf(Ma(e)))];
	!l && r && (l = n[(a = Cf(Fa(e)))]), l && ws(l, i, 6, s);
	const c = n[a + 'Once'];
	if (c) {
		if (!i.emitted) i.emitted = {};
		else if (i.emitted[a]) return;
		(i.emitted[a] = !0), ws(c, i, 6, s);
	}
}
function WS(i, e, t = !1) {
	const n = e.emitsCache,
		s = n.get(i);
	if (s !== void 0) return s;
	const r = i.emits;
	let o = {},
		a = !1;
	if (!ct(i)) {
		const l = (c) => {
			const h = WS(c, e, !0);
			h && ((a = !0), Zn(o, h));
		};
		!t && e.mixins.length && e.mixins.forEach(l), i.extends && l(i.extends), i.mixins && i.mixins.forEach(l);
	}
	return !r && !a ? (_n(i) && n.set(i, null), null) : (nt(r) ? r.forEach((l) => (o[l] = null)) : Zn(o, r), _n(i) && n.set(i, o), o);
}
function Rp(i, e) {
	return !i || !_p(e) ? !1 : ((e = e.slice(2).replace(/Once$/, '')), xt(i, e[0].toLowerCase() + e.slice(1)) || xt(i, Fa(e)) || xt(i, e));
}
function If(i) {
	const {
			type: e,
			vnode: t,
			proxy: n,
			withProxy: s,
			propsOptions: [r],
			slots: o,
			attrs: a,
			emit: l,
			render: c,
			renderCache: h,
			props: u,
			data: d,
			setupState: p,
			ctx: g,
			inheritAttrs: v,
		} = i,
		m = jd(i);
	let f, y;
	try {
		if (t.shapeFlag & 4) {
			const x = s || n,
				E = x;
			(f = Fs(c.call(E, x, h, u, p, d, g))), (y = a);
		} else {
			const x = e;
			(f = Fs(x.length > 1 ? x(u, { attrs: a, slots: o, emit: l }) : x(u, null))), (y = e.props ? a : fR(a));
		}
	} catch (x) {
		(Qc.length = 0), Ep(x, i, 1), (f = es(ph));
	}
	let _ = f;
	if (y && v !== !1) {
		const x = Object.keys(y),
			{ shapeFlag: E } = _;
		x.length && E & 7 && (r && x.some(Vv) && (y = mR(y, r)), (_ = Xl(_, y, !1, !0)));
	}
	return (
		t.dirs && ((_ = Xl(_, null, !1, !0)), (_.dirs = _.dirs ? _.dirs.concat(t.dirs) : t.dirs)),
		t.transition && (_.transition = t.transition),
		(f = _),
		jd(m),
		f
	);
}
const fR = (i) => {
		let e;
		for (const t in i) (t === 'class' || t === 'style' || _p(t)) && ((e || (e = {}))[t] = i[t]);
		return e;
	},
	mR = (i, e) => {
		const t = {};
		for (const n in i) (!Vv(n) || !(n.slice(9) in e)) && (t[n] = i[n]);
		return t;
	};
function gR(i, e, t) {
	const { props: n, children: s, component: r } = i,
		{ props: o, children: a, patchFlag: l } = e,
		c = r.emitsOptions;
	if (e.dirs || e.transition) return !0;
	if (t && l >= 0) {
		if (l & 1024) return !0;
		if (l & 16) return n ? fy(n, o, c) : !!o;
		if (l & 8) {
			const h = e.dynamicProps;
			for (let u = 0; u < h.length; u++) {
				const d = h[u];
				if (o[d] !== n[d] && !Rp(c, d)) return !0;
			}
		}
	} else return (s || a) && (!a || !a.$stable) ? !0 : n === o ? !1 : n ? (o ? fy(n, o, c) : !0) : !!o;
	return !1;
}
function fy(i, e, t) {
	const n = Object.keys(e);
	if (n.length !== Object.keys(i).length) return !0;
	for (let s = 0; s < n.length; s++) {
		const r = n[s];
		if (e[r] !== i[r] && !Rp(t, r)) return !0;
	}
	return !1;
}
function vR({ vnode: i, parent: e }, t) {
	for (; e; ) {
		const n = e.subTree;
		if ((n.suspense && n.suspense.activeBranch === i && (n.el = i.el), n === i)) ((i = e.vnode).el = t), (e = e.parent);
		else break;
	}
}
const _R = (i) => i.__isSuspense;
function yR(i, e) {
	e && e.pendingBranch ? (nt(i) ? e.effects.push(...i) : e.effects.push(i)) : RC(i);
}
const hr = Symbol.for('v-fgt'),
	Pp = Symbol.for('v-txt'),
	ph = Symbol.for('v-cmt'),
	Df = Symbol.for('v-stc'),
	Qc = [];
let Di = null;
function Lp(i = !1) {
	Qc.push((Di = i ? null : []));
}
function xR() {
	Qc.pop(), (Di = Qc[Qc.length - 1] || null);
}
let fh = 1;
function my(i) {
	(fh += i), i < 0 && Di && (Di.hasOnce = !0);
}
function XS(i) {
	return (i.dynamicChildren = fh > 0 ? Di || Dl : null), xR(), fh > 0 && Di && Di.push(i), i;
}
function n_(i, e, t, n, s, r) {
	return XS($d(i, e, t, n, s, r, !0));
}
function bR(i, e, t, n, s) {
	return XS(es(i, e, t, n, s, !0));
}
function xg(i) {
	return i ? i.__v_isVNode === !0 : !1;
}
function vc(i, e) {
	return i.type === e.type && i.key === e.key;
}
const qS = ({ key: i }) => (i != null ? i : null),
	Dd = ({ ref: i, ref_key: e, ref_for: t }) => (
		typeof i == 'number' && (i = '' + i), i != null ? (zn(i) || wi(i) || ct(i) ? { i: zs, r: i, k: e, f: !!t } : i) : null
	);
function $d(i, e = null, t = null, n = 0, s = null, r = i === hr ? 0 : 1, o = !1, a = !1) {
	const l = {
		__v_isVNode: !0,
		__v_skip: !0,
		type: i,
		props: e,
		key: e && qS(e),
		ref: e && Dd(e),
		scopeId: MS,
		slotScopeIds: null,
		children: t,
		component: null,
		suspense: null,
		ssContent: null,
		ssFallback: null,
		dirs: null,
		transition: null,
		el: null,
		anchor: null,
		target: null,
		targetStart: null,
		targetAnchor: null,
		staticCount: 0,
		shapeFlag: r,
		patchFlag: n,
		dynamicProps: s,
		dynamicChildren: null,
		appContext: null,
		ctx: zs,
	};
	return (
		a ? (i_(l, t), r & 128 && i.normalize(l)) : t && (l.shapeFlag |= zn(t) ? 8 : 16),
		fh > 0 && !o && Di && (l.patchFlag > 0 || r & 6) && l.patchFlag !== 32 && Di.push(l),
		l
	);
}
const es = wR;
function wR(i, e = null, t = null, n = 0, s = null, r = !1) {
	if (((!i || i === HC) && (i = ph), xg(i))) {
		const a = Xl(i, e, !0);
		return t && i_(a, t), fh > 0 && !r && Di && (a.shapeFlag & 6 ? (Di[Di.indexOf(i)] = a) : Di.push(a)), (a.patchFlag = -2), a;
	}
	if ((DR(i) && (i = i.__vccOpts), e)) {
		e = SR(e);
		let { class: a, style: l } = e;
		a && !zn(a) && (e.class = bp(a)), _n(l) && (fS(l) && !nt(l) && (l = Zn({}, l)), (e.style = Wv(l)));
	}
	const o = zn(i) ? 1 : _R(i) ? 128 : sR(i) ? 64 : _n(i) ? 4 : ct(i) ? 2 : 0;
	return $d(i, e, t, n, s, o, r, !0);
}
function SR(i) {
	return i ? (fS(i) || DS(i) ? Zn({}, i) : i) : null;
}
function Xl(i, e, t = !1, n = !1) {
	const { props: s, ref: r, patchFlag: o, children: a, transition: l } = i,
		c = e ? ER(s || {}, e) : s,
		h = {
			__v_isVNode: !0,
			__v_skip: !0,
			type: i.type,
			props: c,
			key: c && qS(c),
			ref: e && e.ref ? (t && r ? (nt(r) ? r.concat(Dd(e)) : [r, Dd(e)]) : Dd(e)) : r,
			scopeId: i.scopeId,
			slotScopeIds: i.slotScopeIds,
			children: a,
			target: i.target,
			targetStart: i.targetStart,
			targetAnchor: i.targetAnchor,
			staticCount: i.staticCount,
			shapeFlag: i.shapeFlag,
			patchFlag: e && i.type !== hr ? (o === -1 ? 16 : o | 16) : o,
			dynamicProps: i.dynamicProps,
			dynamicChildren: i.dynamicChildren,
			appContext: i.appContext,
			dirs: i.dirs,
			transition: l,
			component: i.component,
			suspense: i.suspense,
			ssContent: i.ssContent && Xl(i.ssContent),
			ssFallback: i.ssFallback && Xl(i.ssFallback),
			el: i.el,
			anchor: i.anchor,
			ctx: i.ctx,
			ce: i.ce,
		};
	return l && n && ES(h, l.clone(h)), h;
}
function MR(i = ' ', e = 0) {
	return es(Pp, null, i, e);
}
function Fs(i) {
	return i == null || typeof i == 'boolean'
		? es(ph)
		: nt(i)
		? es(hr, null, i.slice())
		: typeof i == 'object'
		? Kr(i)
		: es(Pp, null, String(i));
}
function Kr(i) {
	return (i.el === null && i.patchFlag !== -1) || i.memo ? i : Xl(i);
}
function i_(i, e) {
	let t = 0;
	const { shapeFlag: n } = i;
	if (e == null) e = null;
	else if (nt(e)) t = 16;
	else if (typeof e == 'object')
		if (n & 65) {
			const s = e.default;
			s && (s._c && (s._d = !1), i_(i, s()), s._c && (s._d = !0));
			return;
		} else {
			t = 32;
			const s = e._;
			!s && !DS(e) ? (e._ctx = zs) : s === 3 && zs && (zs.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (i.patchFlag |= 1024)));
		}
	else ct(e) ? ((e = { default: e, _ctx: zs }), (t = 32)) : ((e = String(e)), n & 64 ? ((t = 16), (e = [MR(e)])) : (t = 8));
	(i.children = e), (i.shapeFlag |= t);
}
function ER(...i) {
	const e = {};
	for (let t = 0; t < i.length; t++) {
		const n = i[t];
		for (const s in n)
			if (s === 'class') e.class !== n.class && (e.class = bp([e.class, n.class]));
			else if (s === 'style') e.style = Wv([e.style, n.style]);
			else if (_p(s)) {
				const r = e[s],
					o = n[s];
				o && r !== o && !(nt(r) && r.includes(o)) && (e[s] = r ? [].concat(r, o) : o);
			} else s !== '' && (e[s] = n[s]);
	}
	return e;
}
function Ps(i, e, t, n = null) {
	ws(i, e, 7, [t, n]);
}
const TR = PS();
let AR = 0;
function CR(i, e, t) {
	const n = i.type,
		s = (e ? e.appContext : i.appContext) || TR,
		r = {
			uid: AR++,
			vnode: i,
			type: n,
			parent: e,
			appContext: s,
			root: null,
			next: null,
			subTree: null,
			effect: null,
			update: null,
			scope: new QA(!0),
			render: null,
			proxy: null,
			exposed: null,
			exposeProxy: null,
			withProxy: null,
			provides: e ? e.provides : Object.create(s.provides),
			accessCache: null,
			renderCache: [],
			components: null,
			directives: null,
			propsOptions: US(n, s),
			emitsOptions: WS(n, s),
			emit: null,
			emitted: null,
			propsDefaults: en,
			inheritAttrs: n.inheritAttrs,
			ctx: en,
			data: en,
			props: en,
			attrs: en,
			slots: en,
			refs: en,
			setupState: en,
			setupContext: null,
			suspense: t,
			suspenseId: t ? t.pendingId : 0,
			asyncDep: null,
			asyncResolved: !1,
			isMounted: !1,
			isUnmounted: !1,
			isDeactivated: !1,
			bc: null,
			c: null,
			bm: null,
			m: null,
			bu: null,
			u: null,
			um: null,
			bum: null,
			da: null,
			a: null,
			rtg: null,
			rtc: null,
			ec: null,
			sp: null,
		};
	return (r.ctx = { _: r }), (r.root = e ? e.root : r), (r.emit = pR.bind(null, r)), i.ce && i.ce(r), r;
}
let si = null,
	Zd,
	bg;
{
	const i = Qw(),
		e = (t, n) => {
			let s;
			return (
				(s = i[t]) || (s = i[t] = []),
				s.push(n),
				(r) => {
					s.length > 1 ? s.forEach((o) => o(r)) : s[0](r);
				}
			);
		};
	(Zd = e('__VUE_INSTANCE_SETTERS__', (t) => (si = t))), (bg = e('__VUE_SSR_SETTERS__', (t) => (Ip = t)));
}
const jh = (i) => {
		const e = si;
		return (
			Zd(i),
			i.scope.on(),
			() => {
				i.scope.off(), Zd(e);
			}
		);
	},
	gy = () => {
		si && si.scope.off(), Zd(null);
	};
function YS(i) {
	return i.vnode.shapeFlag & 4;
}
let Ip = !1;
function RR(i, e = !1, t = !1) {
	e && bg(e);
	const { props: n, children: s } = i.vnode,
		r = YS(i);
	ZC(i, n, r, e), tR(i, s, t);
	const o = r ? PR(i, e) : void 0;
	return e && bg(!1), o;
}
function PR(i, e) {
	const t = i.type;
	(i.accessCache = Object.create(null)), (i.proxy = new Proxy(i.ctx, GC));
	const { setup: n } = t;
	if (n) {
		const s = (i.setupContext = n.length > 1 ? IR(i) : null),
			r = jh(i);
		To();
		const o = lo(n, i, 0, [i.props, s]);
		if ((Ao(), r(), $w(o))) {
			if ((o.then(gy, gy), e))
				return o
					.then((a) => {
						vy(i, a, e);
					})
					.catch((a) => {
						Ep(a, i, 0);
					});
			i.asyncDep = o;
		} else vy(i, o, e);
	} else jS(i, e);
}
function vy(i, e, t) {
	ct(e) ? (i.type.__ssrInlineRender ? (i.ssrRender = e) : (i.render = e)) : _n(e) && (i.setupState = _S(e)), jS(i, t);
}
let _y;
function jS(i, e, t) {
	const n = i.type;
	if (!i.render) {
		if (!e && _y && !n.render) {
			const s = n.template || e_(i).template;
			if (s) {
				const { isCustomElement: r, compilerOptions: o } = i.appContext.config,
					{ delimiters: a, compilerOptions: l } = n,
					c = Zn(Zn({ isCustomElement: r, delimiters: a }, o), l);
				n.render = _y(s, c);
			}
		}
		i.render = n.render || Qi;
	}
	{
		const s = jh(i);
		To();
		try {
			WC(i);
		} finally {
			Ao(), s();
		}
	}
}
const LR = {
	get(i, e) {
		return bi(i, 'get', ''), i[e];
	},
};
function IR(i) {
	const e = (t) => {
		i.exposed = t || {};
	};
	return { attrs: new Proxy(i.attrs, LR), slots: i.slots, emit: i.emit, expose: e };
}
function s_(i) {
	return i.exposed
		? i.exposeProxy ||
				(i.exposeProxy = new Proxy(_S(bC(i.exposed)), {
					get(e, t) {
						if (t in e) return e[t];
						if (t in Jc) return Jc[t](i);
					},
					has(e, t) {
						return t in e || t in Jc;
					},
				}))
		: i.proxy;
}
function DR(i) {
	return ct(i) && '__vccOpts' in i;
}
const ys = (i, e) => wC(i, e, Ip);
function KS(i, e, t) {
	const n = arguments.length;
	return n === 2
		? _n(e) && !nt(e)
			? xg(e)
				? es(i, null, [e])
				: es(i, e)
			: es(i, null, e)
		: (n > 3 ? (t = Array.prototype.slice.call(arguments, 2)) : n === 3 && xg(t) && (t = [t]), es(i, e, t));
}
const OR = '3.4.38';
/**
 * @vue/runtime-dom v3.4.38
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ const UR = 'http://www.w3.org/2000/svg',
	NR = 'http://www.w3.org/1998/Math/MathML',
	ar = typeof document < 'u' ? document : null,
	yy = ar && ar.createElement('template'),
	FR = {
		insert: (i, e, t) => {
			e.insertBefore(i, t || null);
		},
		remove: (i) => {
			const e = i.parentNode;
			e && e.removeChild(i);
		},
		createElement: (i, e, t, n) => {
			const s =
				e === 'svg'
					? ar.createElementNS(UR, i)
					: e === 'mathml'
					? ar.createElementNS(NR, i)
					: t
					? ar.createElement(i, { is: t })
					: ar.createElement(i);
			return i === 'select' && n && n.multiple != null && s.setAttribute('multiple', n.multiple), s;
		},
		createText: (i) => ar.createTextNode(i),
		createComment: (i) => ar.createComment(i),
		setText: (i, e) => {
			i.nodeValue = e;
		},
		setElementText: (i, e) => {
			i.textContent = e;
		},
		parentNode: (i) => i.parentNode,
		nextSibling: (i) => i.nextSibling,
		querySelector: (i) => ar.querySelector(i),
		setScopeId(i, e) {
			i.setAttribute(e, '');
		},
		insertStaticContent(i, e, t, n, s, r) {
			const o = t ? t.previousSibling : e.lastChild;
			if (s && (s === r || s.nextSibling)) for (; e.insertBefore(s.cloneNode(!0), t), !(s === r || !(s = s.nextSibling)); );
			else {
				yy.innerHTML = n === 'svg' ? '<svg>'.concat(i, '</svg>') : n === 'mathml' ? '<math>'.concat(i, '</math>') : i;
				const a = yy.content;
				if (n === 'svg' || n === 'mathml') {
					const l = a.firstChild;
					for (; l.firstChild; ) a.appendChild(l.firstChild);
					a.removeChild(l);
				}
				e.insertBefore(a, t);
			}
			return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild];
		},
	},
	BR = Symbol('_vtc');
function kR(i, e, t) {
	const n = i[BR];
	n && (e = (e ? [e, ...n] : [...n]).join(' ')),
		e == null ? i.removeAttribute('class') : t ? i.setAttribute('class', e) : (i.className = e);
}
const xy = Symbol('_vod'),
	zR = Symbol('_vsh'),
	VR = Symbol(''),
	HR = /(^|;)\s*display\s*:/;
function GR(i, e, t) {
	const n = i.style,
		s = zn(t);
	let r = !1;
	if (t && !s) {
		if (e)
			if (zn(e))
				for (const o of e.split(';')) {
					const a = o.slice(0, o.indexOf(':')).trim();
					t[a] == null && Od(n, a, '');
				}
			else for (const o in e) t[o] == null && Od(n, o, '');
		for (const o in t) o === 'display' && (r = !0), Od(n, o, t[o]);
	} else if (s) {
		if (e !== t) {
			const o = n[VR];
			o && (t += ';' + o), (n.cssText = t), (r = HR.test(t));
		}
	} else e && i.removeAttribute('style');
	xy in i && ((i[xy] = r ? n.display : ''), i[zR] && (n.display = 'none'));
}
const by = /\s*!important$/;
function Od(i, e, t) {
	if (nt(t)) t.forEach((n) => Od(i, e, n));
	else if ((t == null && (t = ''), e.startsWith('--'))) i.setProperty(e, t);
	else {
		const n = WR(i, e);
		by.test(t) ? i.setProperty(Fa(n), t.replace(by, ''), 'important') : (i[n] = t);
	}
}
const wy = ['Webkit', 'Moz', 'ms'],
	Of = {};
function WR(i, e) {
	const t = Of[e];
	if (t) return t;
	let n = Ma(e);
	if (n !== 'filter' && n in i) return (Of[e] = n);
	n = Zw(n);
	for (let s = 0; s < wy.length; s++) {
		const r = wy[s] + n;
		if (r in i) return (Of[e] = r);
	}
	return e;
}
const Sy = 'http://www.w3.org/1999/xlink';
function My(i, e, t, n, s, r = JA(e)) {
	n && e.startsWith('xlink:')
		? t == null
			? i.removeAttributeNS(Sy, e.slice(6, e.length))
			: i.setAttributeNS(Sy, e, t)
		: t == null || (r && !eS(t))
		? i.removeAttribute(e)
		: i.setAttribute(e, r ? '' : oc(t) ? String(t) : t);
}
function XR(i, e, t, n) {
	if (e === 'innerHTML' || e === 'textContent') {
		if (t == null) return;
		i[e] = t;
		return;
	}
	const s = i.tagName;
	if (e === 'value' && s !== 'PROGRESS' && !s.includes('-')) {
		const o = s === 'OPTION' ? i.getAttribute('value') || '' : i.value,
			a = t == null ? '' : String(t);
		(o !== a || !('_value' in i)) && (i.value = a), t == null && i.removeAttribute(e), (i._value = t);
		return;
	}
	let r = !1;
	if (t === '' || t == null) {
		const o = typeof i[e];
		o === 'boolean' ? (t = eS(t)) : t == null && o === 'string' ? ((t = ''), (r = !0)) : o === 'number' && ((t = 0), (r = !0));
	}
	try {
		i[e] = t;
	} catch (o) {}
	r && i.removeAttribute(e);
}
function qR(i, e, t, n) {
	i.addEventListener(e, t, n);
}
function YR(i, e, t, n) {
	i.removeEventListener(e, t, n);
}
const Ey = Symbol('_vei');
function jR(i, e, t, n, s = null) {
	const r = i[Ey] || (i[Ey] = {}),
		o = r[e];
	if (n && o) o.value = n;
	else {
		const [a, l] = KR(e);
		if (n) {
			const c = (r[e] = JR(n, s));
			qR(i, a, c, l);
		} else o && (YR(i, a, o, l), (r[e] = void 0));
	}
}
const Ty = /(?:Once|Passive|Capture)$/;
function KR(i) {
	let e;
	if (Ty.test(i)) {
		e = {};
		let n;
		for (; (n = i.match(Ty)); ) (i = i.slice(0, i.length - n[0].length)), (e[n[0].toLowerCase()] = !0);
	}
	return [i[2] === ':' ? i.slice(3) : Fa(i.slice(2)), e];
}
let Uf = 0;
const $R = Promise.resolve(),
	ZR = () => Uf || ($R.then(() => (Uf = 0)), (Uf = Date.now()));
function JR(i, e) {
	const t = (n) => {
		if (!n._vts) n._vts = Date.now();
		else if (n._vts <= t.attached) return;
		ws(QR(n, t.value), e, 5, [n]);
	};
	return (t.value = i), (t.attached = ZR()), t;
}
function QR(i, e) {
	if (nt(e)) {
		const t = i.stopImmediatePropagation;
		return (
			(i.stopImmediatePropagation = () => {
				t.call(i), (i._stopped = !0);
			}),
			e.map((n) => (s) => !s._stopped && n && n(s))
		);
	} else return e;
}
const Ay = (i) => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && i.charCodeAt(2) > 96 && i.charCodeAt(2) < 123,
	eP = (i, e, t, n, s, r) => {
		const o = s === 'svg';
		e === 'class'
			? kR(i, n, o)
			: e === 'style'
			? GR(i, t, n)
			: _p(e)
			? Vv(e) || jR(i, e, t, n, r)
			: (e[0] === '.' ? ((e = e.slice(1)), !0) : e[0] === '^' ? ((e = e.slice(1)), !1) : tP(i, e, n, o))
			? (XR(i, e, n),
			  !i.tagName.includes('-') && (e === 'value' || e === 'checked' || e === 'selected') && My(i, e, n, o, r, e !== 'value'))
			: (e === 'true-value' ? (i._trueValue = n) : e === 'false-value' && (i._falseValue = n), My(i, e, n, o));
	};
function tP(i, e, t, n) {
	if (n) return !!(e === 'innerHTML' || e === 'textContent' || (e in i && Ay(e) && ct(t)));
	if (
		e === 'spellcheck' ||
		e === 'draggable' ||
		e === 'translate' ||
		e === 'form' ||
		(e === 'list' && i.tagName === 'INPUT') ||
		(e === 'type' && i.tagName === 'TEXTAREA')
	)
		return !1;
	if (e === 'width' || e === 'height') {
		const s = i.tagName;
		if (s === 'IMG' || s === 'VIDEO' || s === 'CANVAS' || s === 'SOURCE') return !1;
	}
	return Ay(e) && zn(t) ? !1 : e in i;
}
const nP = Zn({ patchProp: eP }, FR);
let Cy;
function iP() {
	return Cy || (Cy = rR(nP));
}
const sP = (...i) => {
	const e = iP().createApp(...i),
		{ mount: t } = e;
	return (
		(e.mount = (n) => {
			const s = oP(n);
			if (!s) return;
			const r = e._component;
			!ct(r) && !r.render && !r.template && (r.template = s.innerHTML), (s.innerHTML = '');
			const o = t(s, !1, rP(s));
			return s instanceof Element && (s.removeAttribute('v-cloak'), s.setAttribute('data-v-app', '')), o;
		}),
		e
	);
};
function rP(i) {
	if (i instanceof SVGElement) return 'svg';
	if (typeof MathMLElement == 'function' && i instanceof MathMLElement) return 'mathml';
}
function oP(i) {
	return zn(i) ? document.querySelector(i) : i;
}
/*!
 * vue-router v4.4.3
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */ const Al = typeof document < 'u';
function aP(i) {
	return i.__esModule || i[Symbol.toStringTag] === 'Module';
}
const Nt = Object.assign;
function Nf(i, e) {
	const t = {};
	for (const n in e) {
		const s = e[n];
		t[n] = Ss(s) ? s.map(i) : i(s);
	}
	return t;
}
const eh = () => {},
	Ss = Array.isArray,
	$S = /#/g,
	lP = /&/g,
	cP = /\//g,
	hP = /=/g,
	uP = /\?/g,
	ZS = /\+/g,
	dP = /%5B/g,
	pP = /%5D/g,
	JS = /%5E/g,
	fP = /%60/g,
	QS = /%7B/g,
	mP = /%7C/g,
	eM = /%7D/g,
	gP = /%20/g;
function r_(i) {
	return encodeURI('' + i)
		.replace(mP, '|')
		.replace(dP, '[')
		.replace(pP, ']');
}
function vP(i) {
	return r_(i).replace(QS, '{').replace(eM, '}').replace(JS, '^');
}
function wg(i) {
	return r_(i)
		.replace(ZS, '%2B')
		.replace(gP, '+')
		.replace($S, '%23')
		.replace(lP, '%26')
		.replace(fP, '`')
		.replace(QS, '{')
		.replace(eM, '}')
		.replace(JS, '^');
}
function _P(i) {
	return wg(i).replace(hP, '%3D');
}
function yP(i) {
	return r_(i).replace($S, '%23').replace(uP, '%3F');
}
function xP(i) {
	return i == null ? '' : yP(i).replace(cP, '%2F');
}
function mh(i) {
	try {
		return decodeURIComponent('' + i);
	} catch (e) {}
	return '' + i;
}
const bP = /\/$/,
	wP = (i) => i.replace(bP, '');
function Ff(i, e, t = '/') {
	let n,
		s = {},
		r = '',
		o = '';
	const a = e.indexOf('#');
	let l = e.indexOf('?');
	return (
		a < l && a >= 0 && (l = -1),
		l > -1 && ((n = e.slice(0, l)), (r = e.slice(l + 1, a > -1 ? a : e.length)), (s = i(r))),
		a > -1 && ((n = n || e.slice(0, a)), (o = e.slice(a, e.length))),
		(n = TP(n != null ? n : e, t)),
		{ fullPath: n + (r && '?') + r + o, path: n, query: s, hash: mh(o) }
	);
}
function SP(i, e) {
	const t = e.query ? i(e.query) : '';
	return e.path + (t && '?') + t + (e.hash || '');
}
function Ry(i, e) {
	return !e || !i.toLowerCase().startsWith(e.toLowerCase()) ? i : i.slice(e.length) || '/';
}
function MP(i, e, t) {
	const n = e.matched.length - 1,
		s = t.matched.length - 1;
	return n > -1 && n === s && ql(e.matched[n], t.matched[s]) && tM(e.params, t.params) && i(e.query) === i(t.query) && e.hash === t.hash;
}
function ql(i, e) {
	return (i.aliasOf || i) === (e.aliasOf || e);
}
function tM(i, e) {
	if (Object.keys(i).length !== Object.keys(e).length) return !1;
	for (const t in i) if (!EP(i[t], e[t])) return !1;
	return !0;
}
function EP(i, e) {
	return Ss(i) ? Py(i, e) : Ss(e) ? Py(e, i) : i === e;
}
function Py(i, e) {
	return Ss(e) ? i.length === e.length && i.every((t, n) => t === e[n]) : i.length === 1 && i[0] === e;
}
function TP(i, e) {
	if (i.startsWith('/')) return i;
	if (!i) return e;
	const t = e.split('/'),
		n = i.split('/'),
		s = n[n.length - 1];
	(s === '..' || s === '.') && n.push('');
	let r = t.length - 1,
		o,
		a;
	for (o = 0; o < n.length; o++)
		if (((a = n[o]), a !== '.'))
			if (a === '..') r > 1 && r--;
			else break;
	return t.slice(0, r).join('/') + '/' + n.slice(o).join('/');
}
const Pr = { path: '/', name: void 0, params: {}, query: {}, hash: '', fullPath: '/', matched: [], meta: {}, redirectedFrom: void 0 };
var gh;
(function (i) {
	(i.pop = 'pop'), (i.push = 'push');
})(gh || (gh = {}));
var th;
(function (i) {
	(i.back = 'back'), (i.forward = 'forward'), (i.unknown = '');
})(th || (th = {}));
function AP(i) {
	if (!i)
		if (Al) {
			const e = document.querySelector('base');
			(i = (e && e.getAttribute('href')) || '/'), (i = i.replace(/^\w+:\/\/[^\/]+/, ''));
		} else i = '/';
	return i[0] !== '/' && i[0] !== '#' && (i = '/' + i), wP(i);
}
const CP = /^[^#]+#/;
function RP(i, e) {
	return i.replace(CP, '#') + e;
}
function PP(i, e) {
	const t = document.documentElement.getBoundingClientRect(),
		n = i.getBoundingClientRect();
	return { behavior: e.behavior, left: n.left - t.left - (e.left || 0), top: n.top - t.top - (e.top || 0) };
}
const Dp = () => ({ left: window.scrollX, top: window.scrollY });
function LP(i) {
	let e;
	if ('el' in i) {
		const t = i.el,
			n = typeof t == 'string' && t.startsWith('#'),
			s = typeof t == 'string' ? (n ? document.getElementById(t.slice(1)) : document.querySelector(t)) : t;
		if (!s) return;
		e = PP(s, i);
	} else e = i;
	'scrollBehavior' in document.documentElement.style
		? window.scrollTo(e)
		: window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY);
}
function Ly(i, e) {
	return (history.state ? history.state.position - e : -1) + i;
}
const Sg = new Map();
function IP(i, e) {
	Sg.set(i, e);
}
function DP(i) {
	const e = Sg.get(i);
	return Sg.delete(i), e;
}
let OP = () => location.protocol + '//' + location.host;
function nM(i, e) {
	const { pathname: t, search: n, hash: s } = e,
		r = i.indexOf('#');
	if (r > -1) {
		let a = s.includes(i.slice(r)) ? i.slice(r).length : 1,
			l = s.slice(a);
		return l[0] !== '/' && (l = '/' + l), Ry(l, '');
	}
	return Ry(t, i) + n + s;
}
function UP(i, e, t, n) {
	let s = [],
		r = [],
		o = null;
	const a = ({ state: d }) => {
		const p = nM(i, location),
			g = t.value,
			v = e.value;
		let m = 0;
		if (d) {
			if (((t.value = p), (e.value = d), o && o === g)) {
				o = null;
				return;
			}
			m = v ? d.position - v.position : 0;
		} else n(p);
		s.forEach((f) => {
			f(t.value, g, { delta: m, type: gh.pop, direction: m ? (m > 0 ? th.forward : th.back) : th.unknown });
		});
	};
	function l() {
		o = t.value;
	}
	function c(d) {
		s.push(d);
		const p = () => {
			const g = s.indexOf(d);
			g > -1 && s.splice(g, 1);
		};
		return r.push(p), p;
	}
	function h() {
		const { history: d } = window;
		d.state && d.replaceState(Nt({}, d.state, { scroll: Dp() }), '');
	}
	function u() {
		for (const d of r) d();
		(r = []), window.removeEventListener('popstate', a), window.removeEventListener('beforeunload', h);
	}
	return (
		window.addEventListener('popstate', a),
		window.addEventListener('beforeunload', h, { passive: !0 }),
		{ pauseListeners: l, listen: c, destroy: u }
	);
}
function Iy(i, e, t, n = !1, s = !1) {
	return { back: i, current: e, forward: t, replaced: n, position: window.history.length, scroll: s ? Dp() : null };
}
function NP(i) {
	const { history: e, location: t } = window,
		n = { value: nM(i, t) },
		s = { value: e.state };
	s.value || r(n.value, { back: null, current: n.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0);
	function r(l, c, h) {
		const u = i.indexOf('#'),
			d = u > -1 ? (t.host && document.querySelector('base') ? i : i.slice(u)) + l : OP() + i + l;
		try {
			e[h ? 'replaceState' : 'pushState'](c, '', d), (s.value = c);
		} catch (p) {
			console.error(p), t[h ? 'replace' : 'assign'](d);
		}
	}
	function o(l, c) {
		const h = Nt({}, e.state, Iy(s.value.back, l, s.value.forward, !0), c, { position: s.value.position });
		r(l, h, !0), (n.value = l);
	}
	function a(l, c) {
		const h = Nt({}, s.value, e.state, { forward: l, scroll: Dp() });
		r(h.current, h, !0);
		const u = Nt({}, Iy(n.value, l, null), { position: h.position + 1 }, c);
		r(l, u, !1), (n.value = l);
	}
	return { location: n, state: s, push: a, replace: o };
}
function FP(i) {
	i = AP(i);
	const e = NP(i),
		t = UP(i, e.state, e.location, e.replace);
	function n(r, o = !0) {
		o || t.pauseListeners(), history.go(r);
	}
	const s = Nt({ location: '', base: i, go: n, createHref: RP.bind(null, i) }, e, t);
	return (
		Object.defineProperty(s, 'location', { enumerable: !0, get: () => e.location.value }),
		Object.defineProperty(s, 'state', { enumerable: !0, get: () => e.state.value }),
		s
	);
}
function BP(i) {
	return typeof i == 'string' || (i && typeof i == 'object');
}
function iM(i) {
	return typeof i == 'string' || typeof i == 'symbol';
}
const sM = Symbol('');
var Dy;
(function (i) {
	(i[(i.aborted = 4)] = 'aborted'), (i[(i.cancelled = 8)] = 'cancelled'), (i[(i.duplicated = 16)] = 'duplicated');
})(Dy || (Dy = {}));
function Yl(i, e) {
	return Nt(new Error(), { type: i, [sM]: !0 }, e);
}
function Qs(i, e) {
	return i instanceof Error && sM in i && (e == null || !!(i.type & e));
}
const Oy = '[^/]+?',
	kP = { sensitive: !1, strict: !1, start: !0, end: !0 },
	zP = /[.+*?^${}()[\]/\\]/g;
function VP(i, e) {
	const t = Nt({}, kP, e),
		n = [];
	let s = t.start ? '^' : '';
	const r = [];
	for (const c of i) {
		const h = c.length ? [] : [90];
		t.strict && !c.length && (s += '/');
		for (let u = 0; u < c.length; u++) {
			const d = c[u];
			let p = 40 + (t.sensitive ? 0.25 : 0);
			if (d.type === 0) u || (s += '/'), (s += d.value.replace(zP, '\\$&')), (p += 40);
			else if (d.type === 1) {
				const { value: g, repeatable: v, optional: m, regexp: f } = d;
				r.push({ name: g, repeatable: v, optional: m });
				const y = f || Oy;
				if (y !== Oy) {
					p += 10;
					try {
						new RegExp('('.concat(y, ')'));
					} catch (x) {
						throw new Error('Invalid custom RegExp for param "'.concat(g, '" (').concat(y, '): ') + x.message);
					}
				}
				let _ = v ? '((?:'.concat(y, ')(?:/(?:').concat(y, '))*)') : '('.concat(y, ')');
				u || (_ = m && c.length < 2 ? '(?:/'.concat(_, ')') : '/' + _),
					m && (_ += '?'),
					(s += _),
					(p += 20),
					m && (p += -8),
					v && (p += -20),
					y === '.*' && (p += -50);
			}
			h.push(p);
		}
		n.push(h);
	}
	if (t.strict && t.end) {
		const c = n.length - 1;
		n[c][n[c].length - 1] += 0.7000000000000001;
	}
	t.strict || (s += '/?'), t.end ? (s += '$') : t.strict && (s += '(?:/|$)');
	const o = new RegExp(s, t.sensitive ? '' : 'i');
	function a(c) {
		const h = c.match(o),
			u = {};
		if (!h) return null;
		for (let d = 1; d < h.length; d++) {
			const p = h[d] || '',
				g = r[d - 1];
			u[g.name] = p && g.repeatable ? p.split('/') : p;
		}
		return u;
	}
	function l(c) {
		let h = '',
			u = !1;
		for (const d of i) {
			(!u || !h.endsWith('/')) && (h += '/'), (u = !1);
			for (const p of d)
				if (p.type === 0) h += p.value;
				else if (p.type === 1) {
					const { value: g, repeatable: v, optional: m } = p,
						f = g in c ? c[g] : '';
					if (Ss(f) && !v)
						throw new Error('Provided param "'.concat(g, '" is an array but it is not repeatable (* or + modifiers)'));
					const y = Ss(f) ? f.join('/') : f;
					if (!y)
						if (m) d.length < 2 && (h.endsWith('/') ? (h = h.slice(0, -1)) : (u = !0));
						else throw new Error('Missing required param "'.concat(g, '"'));
					h += y;
				}
		}
		return h || '/';
	}
	return { re: o, score: n, keys: r, parse: a, stringify: l };
}
function HP(i, e) {
	let t = 0;
	for (; t < i.length && t < e.length; ) {
		const n = e[t] - i[t];
		if (n) return n;
		t++;
	}
	return i.length < e.length
		? i.length === 1 && i[0] === 80
			? -1
			: 1
		: i.length > e.length
		? e.length === 1 && e[0] === 80
			? 1
			: -1
		: 0;
}
function rM(i, e) {
	let t = 0;
	const n = i.score,
		s = e.score;
	for (; t < n.length && t < s.length; ) {
		const r = HP(n[t], s[t]);
		if (r) return r;
		t++;
	}
	if (Math.abs(s.length - n.length) === 1) {
		if (Uy(n)) return 1;
		if (Uy(s)) return -1;
	}
	return s.length - n.length;
}
function Uy(i) {
	const e = i[i.length - 1];
	return i.length > 0 && e[e.length - 1] < 0;
}
const GP = { type: 0, value: '' },
	WP = /[a-zA-Z0-9_]/;
function XP(i) {
	if (!i) return [[]];
	if (i === '/') return [[GP]];
	if (!i.startsWith('/')) throw new Error('Invalid path "'.concat(i, '"'));
	function e(p) {
		throw new Error('ERR ('.concat(t, ')/"').concat(c, '": ').concat(p));
	}
	let t = 0,
		n = t;
	const s = [];
	let r;
	function o() {
		r && s.push(r), (r = []);
	}
	let a = 0,
		l,
		c = '',
		h = '';
	function u() {
		c &&
			(t === 0
				? r.push({ type: 0, value: c })
				: t === 1 || t === 2 || t === 3
				? (r.length > 1 &&
						(l === '*' || l === '+') &&
						e('A repeatable param ('.concat(c, ") must be alone in its segment. eg: '/:ids+.")),
				  r.push({ type: 1, value: c, regexp: h, repeatable: l === '*' || l === '+', optional: l === '*' || l === '?' }))
				: e('Invalid state to consume buffer'),
			(c = ''));
	}
	function d() {
		c += l;
	}
	for (; a < i.length; ) {
		if (((l = i[a++]), l === '\\' && t !== 2)) {
			(n = t), (t = 4);
			continue;
		}
		switch (t) {
			case 0:
				l === '/' ? (c && u(), o()) : l === ':' ? (u(), (t = 1)) : d();
				break;
			case 4:
				d(), (t = n);
				break;
			case 1:
				l === '(' ? (t = 2) : WP.test(l) ? d() : (u(), (t = 0), l !== '*' && l !== '?' && l !== '+' && a--);
				break;
			case 2:
				l === ')' ? (h[h.length - 1] == '\\' ? (h = h.slice(0, -1) + l) : (t = 3)) : (h += l);
				break;
			case 3:
				u(), (t = 0), l !== '*' && l !== '?' && l !== '+' && a--, (h = '');
				break;
			default:
				e('Unknown state');
				break;
		}
	}
	return t === 2 && e('Unfinished custom RegExp for param "'.concat(c, '"')), u(), o(), s;
}
function qP(i, e, t) {
	const n = VP(XP(i.path), t),
		s = Nt(n, { record: i, parent: e, children: [], alias: [] });
	return e && !s.record.aliasOf == !e.record.aliasOf && e.children.push(s), s;
}
function YP(i, e) {
	const t = [],
		n = new Map();
	e = By({ strict: !1, end: !0, sensitive: !1 }, e);
	function s(u) {
		return n.get(u);
	}
	function r(u, d, p) {
		const g = !p,
			v = jP(u);
		v.aliasOf = p && p.record;
		const m = By(e, u),
			f = [v];
		if ('alias' in u) {
			const x = typeof u.alias == 'string' ? [u.alias] : u.alias;
			for (const E of x)
				f.push(Nt({}, v, { components: p ? p.record.components : v.components, path: E, aliasOf: p ? p.record : v }));
		}
		let y, _;
		for (const x of f) {
			const { path: E } = x;
			if (d && E[0] !== '/') {
				const w = d.record.path,
					C = w[w.length - 1] === '/' ? '' : '/';
				x.path = d.record.path + (E && C + E);
			}
			if (
				((y = qP(x, d, m)),
				p ? p.alias.push(y) : ((_ = _ || y), _ !== y && _.alias.push(y), g && u.name && !Fy(y) && o(u.name)),
				oM(y) && l(y),
				v.children)
			) {
				const w = v.children;
				for (let C = 0; C < w.length; C++) r(w[C], y, p && p.children[C]);
			}
			p = p || y;
		}
		return _
			? () => {
					o(_);
			  }
			: eh;
	}
	function o(u) {
		if (iM(u)) {
			const d = n.get(u);
			d && (n.delete(u), t.splice(t.indexOf(d), 1), d.children.forEach(o), d.alias.forEach(o));
		} else {
			const d = t.indexOf(u);
			d > -1 && (t.splice(d, 1), u.record.name && n.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o));
		}
	}
	function a() {
		return t;
	}
	function l(u) {
		const d = ZP(u, t);
		t.splice(d, 0, u), u.record.name && !Fy(u) && n.set(u.record.name, u);
	}
	function c(u, d) {
		let p,
			g = {},
			v,
			m;
		if ('name' in u && u.name) {
			if (((p = n.get(u.name)), !p)) throw Yl(1, { location: u });
			(m = p.record.name),
				(g = Nt(
					Ny(
						d.params,
						p.keys
							.filter((_) => !_.optional)
							.concat(p.parent ? p.parent.keys.filter((_) => _.optional) : [])
							.map((_) => _.name)
					),
					u.params &&
						Ny(
							u.params,
							p.keys.map((_) => _.name)
						)
				)),
				(v = p.stringify(g));
		} else if (u.path != null) (v = u.path), (p = t.find((_) => _.re.test(v))), p && ((g = p.parse(v)), (m = p.record.name));
		else {
			if (((p = d.name ? n.get(d.name) : t.find((_) => _.re.test(d.path))), !p)) throw Yl(1, { location: u, currentLocation: d });
			(m = p.record.name), (g = Nt({}, d.params, u.params)), (v = p.stringify(g));
		}
		const f = [];
		let y = p;
		for (; y; ) f.unshift(y.record), (y = y.parent);
		return { name: m, path: v, params: g, matched: f, meta: $P(f) };
	}
	i.forEach((u) => r(u));
	function h() {
		(t.length = 0), n.clear();
	}
	return { addRoute: r, resolve: c, removeRoute: o, clearRoutes: h, getRoutes: a, getRecordMatcher: s };
}
function Ny(i, e) {
	const t = {};
	for (const n of e) n in i && (t[n] = i[n]);
	return t;
}
function jP(i) {
	return {
		path: i.path,
		redirect: i.redirect,
		name: i.name,
		meta: i.meta || {},
		aliasOf: void 0,
		beforeEnter: i.beforeEnter,
		props: KP(i),
		children: i.children || [],
		instances: {},
		leaveGuards: new Set(),
		updateGuards: new Set(),
		enterCallbacks: {},
		components: 'components' in i ? i.components || null : i.component && { default: i.component },
	};
}
function KP(i) {
	const e = {},
		t = i.props || !1;
	if ('component' in i) e.default = t;
	else for (const n in i.components) e[n] = typeof t == 'object' ? t[n] : t;
	return e;
}
function Fy(i) {
	for (; i; ) {
		if (i.record.aliasOf) return !0;
		i = i.parent;
	}
	return !1;
}
function $P(i) {
	return i.reduce((e, t) => Nt(e, t.meta), {});
}
function By(i, e) {
	const t = {};
	for (const n in i) t[n] = n in e ? e[n] : i[n];
	return t;
}
function ZP(i, e) {
	let t = 0,
		n = e.length;
	for (; t !== n; ) {
		const r = (t + n) >> 1;
		rM(i, e[r]) < 0 ? (n = r) : (t = r + 1);
	}
	const s = JP(i);
	return s && (n = e.lastIndexOf(s, n - 1)), n;
}
function JP(i) {
	let e = i;
	for (; (e = e.parent); ) if (oM(e) && rM(i, e) === 0) return e;
}
function oM({ record: i }) {
	return !!(i.name || (i.components && Object.keys(i.components).length) || i.redirect);
}
function QP(i) {
	const e = {};
	if (i === '' || i === '?') return e;
	const n = (i[0] === '?' ? i.slice(1) : i).split('&');
	for (let s = 0; s < n.length; ++s) {
		const r = n[s].replace(ZS, ' '),
			o = r.indexOf('='),
			a = mh(o < 0 ? r : r.slice(0, o)),
			l = o < 0 ? null : mh(r.slice(o + 1));
		if (a in e) {
			let c = e[a];
			Ss(c) || (c = e[a] = [c]), c.push(l);
		} else e[a] = l;
	}
	return e;
}
function ky(i) {
	let e = '';
	for (let t in i) {
		const n = i[t];
		if (((t = _P(t)), n == null)) {
			n !== void 0 && (e += (e.length ? '&' : '') + t);
			continue;
		}
		(Ss(n) ? n.map((r) => r && wg(r)) : [n && wg(n)]).forEach((r) => {
			r !== void 0 && ((e += (e.length ? '&' : '') + t), r != null && (e += '=' + r));
		});
	}
	return e;
}
function eL(i) {
	const e = {};
	for (const t in i) {
		const n = i[t];
		n !== void 0 && (e[t] = Ss(n) ? n.map((s) => (s == null ? null : '' + s)) : n == null ? n : '' + n);
	}
	return e;
}
const tL = Symbol(''),
	zy = Symbol(''),
	o_ = Symbol(''),
	aM = Symbol(''),
	Mg = Symbol('');
function _c() {
	let i = [];
	function e(n) {
		return (
			i.push(n),
			() => {
				const s = i.indexOf(n);
				s > -1 && i.splice(s, 1);
			}
		);
	}
	function t() {
		i = [];
	}
	return { add: e, list: () => i.slice(), reset: t };
}
function $r(i, e, t, n, s, r = (o) => o()) {
	const o = n && (n.enterCallbacks[s] = n.enterCallbacks[s] || []);
	return () =>
		new Promise((a, l) => {
			const c = (d) => {
					d === !1
						? l(Yl(4, { from: t, to: e }))
						: d instanceof Error
						? l(d)
						: BP(d)
						? l(Yl(2, { from: e, to: d }))
						: (o && n.enterCallbacks[s] === o && typeof d == 'function' && o.push(d), a());
				},
				h = r(() => i.call(n && n.instances[s], e, t, c));
			let u = Promise.resolve(h);
			i.length < 3 && (u = u.then(c)), u.catch((d) => l(d));
		});
}
function Bf(i, e, t, n, s = (r) => r()) {
	const r = [];
	for (const o of i)
		for (const a in o.components) {
			let l = o.components[a];
			if (!(e !== 'beforeRouteEnter' && !o.instances[a]))
				if (nL(l)) {
					const h = (l.__vccOpts || l)[e];
					h && r.push($r(h, t, n, o, a, s));
				} else {
					let c = l();
					r.push(() =>
						c.then((h) => {
							if (!h)
								return Promise.reject(new Error('Couldn\'t resolve component "'.concat(a, '" at "').concat(o.path, '"')));
							const u = aP(h) ? h.default : h;
							o.components[a] = u;
							const p = (u.__vccOpts || u)[e];
							return p && $r(p, t, n, o, a, s)();
						})
					);
				}
		}
	return r;
}
function nL(i) {
	return typeof i == 'object' || 'displayName' in i || 'props' in i || '__vccOpts' in i;
}
function Vy(i) {
	const e = mr(o_),
		t = mr(aM),
		n = ys(() => {
			const l = ao(i.to);
			return e.resolve(l);
		}),
		s = ys(() => {
			const { matched: l } = n.value,
				{ length: c } = l,
				h = l[c - 1],
				u = t.matched;
			if (!h || !u.length) return -1;
			const d = u.findIndex(ql.bind(null, h));
			if (d > -1) return d;
			const p = Hy(l[c - 2]);
			return c > 1 && Hy(h) === p && u[u.length - 1].path !== p ? u.findIndex(ql.bind(null, l[c - 2])) : d;
		}),
		r = ys(() => s.value > -1 && oL(t.params, n.value.params)),
		o = ys(() => s.value > -1 && s.value === t.matched.length - 1 && tM(t.params, n.value.params));
	function a(l = {}) {
		return rL(l) ? e[ao(i.replace) ? 'replace' : 'push'](ao(i.to)).catch(eh) : Promise.resolve();
	}
	return { route: n, href: ys(() => n.value.href), isActive: r, isExactActive: o, navigate: a };
}
const iL = ac({
		name: 'RouterLink',
		compatConfig: { MODE: 3 },
		props: {
			to: { type: [String, Object], required: !0 },
			replace: Boolean,
			activeClass: String,
			exactActiveClass: String,
			custom: Boolean,
			ariaCurrentValue: { type: String, default: 'page' },
		},
		useLink: Vy,
		setup(i, { slots: e }) {
			const t = Sp(Vy(i)),
				{ options: n } = mr(o_),
				s = ys(() => ({
					[Gy(i.activeClass, n.linkActiveClass, 'router-link-active')]: t.isActive,
					[Gy(i.exactActiveClass, n.linkExactActiveClass, 'router-link-exact-active')]: t.isExactActive,
				}));
			return () => {
				const r = e.default && e.default(t);
				return i.custom
					? r
					: KS(
							'a',
							{
								'aria-current': t.isExactActive ? i.ariaCurrentValue : null,
								href: t.href,
								onClick: t.navigate,
								class: s.value,
							},
							r
					  );
			};
		},
	}),
	sL = iL;
function rL(i) {
	if (!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey) && !i.defaultPrevented && !(i.button !== void 0 && i.button !== 0)) {
		if (i.currentTarget && i.currentTarget.getAttribute) {
			const e = i.currentTarget.getAttribute('target');
			if (/\b_blank\b/i.test(e)) return;
		}
		return i.preventDefault && i.preventDefault(), !0;
	}
}
function oL(i, e) {
	for (const t in e) {
		const n = e[t],
			s = i[t];
		if (typeof n == 'string') {
			if (n !== s) return !1;
		} else if (!Ss(s) || s.length !== n.length || n.some((r, o) => r !== s[o])) return !1;
	}
	return !0;
}
function Hy(i) {
	return i ? (i.aliasOf ? i.aliasOf.path : i.path) : '';
}
const Gy = (i, e, t) => (i != null ? i : e != null ? e : t),
	aL = ac({
		name: 'RouterView',
		inheritAttrs: !1,
		props: { name: { type: String, default: 'default' }, route: Object },
		compatConfig: { MODE: 3 },
		setup(i, { attrs: e, slots: t }) {
			const n = mr(Mg),
				s = ys(() => i.route || n.value),
				r = mr(zy, 0),
				o = ys(() => {
					let c = ao(r);
					const { matched: h } = s.value;
					let u;
					for (; (u = h[c]) && !u.components; ) c++;
					return c;
				}),
				a = ys(() => s.value.matched[o.value]);
			Ld(
				zy,
				ys(() => o.value + 1)
			),
				Ld(tL, a),
				Ld(Mg, s);
			const l = Mp();
			return (
				Id(
					() => [l.value, a.value, i.name],
					([c, h, u], [d, p, g]) => {
						h &&
							((h.instances[u] = c),
							p &&
								p !== h &&
								c &&
								c === d &&
								(h.leaveGuards.size || (h.leaveGuards = p.leaveGuards),
								h.updateGuards.size || (h.updateGuards = p.updateGuards))),
							c && h && (!p || !ql(h, p) || !d) && (h.enterCallbacks[u] || []).forEach((v) => v(c));
					},
					{ flush: 'post' }
				),
				() => {
					const c = s.value,
						h = i.name,
						u = a.value,
						d = u && u.components[h];
					if (!d) return Wy(t.default, { Component: d, route: c });
					const p = u.props[h],
						g = p ? (p === !0 ? c.params : typeof p == 'function' ? p(c) : p) : null,
						m = KS(
							d,
							Nt({}, g, e, {
								onVnodeUnmounted: (f) => {
									f.component.isUnmounted && (u.instances[h] = null);
								},
								ref: l,
							})
						);
					return Wy(t.default, { Component: m, route: c }) || m;
				}
			);
		},
	});
function Wy(i, e) {
	if (!i) return null;
	const t = i(e);
	return t.length === 1 ? t[0] : t;
}
const lM = aL;
function lL(i) {
	const e = YP(i.routes, i),
		t = i.parseQuery || QP,
		n = i.stringifyQuery || ky,
		s = i.history,
		r = _c(),
		o = _c(),
		a = _c(),
		l = SC(Pr);
	let c = Pr;
	Al && i.scrollBehavior && 'scrollRestoration' in history && (history.scrollRestoration = 'manual');
	const h = Nf.bind(null, (X) => '' + X),
		u = Nf.bind(null, xP),
		d = Nf.bind(null, mh);
	function p(X, ge) {
		let be, H;
		return iM(X) ? ((be = e.getRecordMatcher(X)), (H = ge)) : (H = X), e.addRoute(H, be);
	}
	function g(X) {
		const ge = e.getRecordMatcher(X);
		ge && e.removeRoute(ge);
	}
	function v() {
		return e.getRoutes().map((X) => X.record);
	}
	function m(X) {
		return !!e.getRecordMatcher(X);
	}
	function f(X, ge) {
		if (((ge = Nt({}, ge || l.value)), typeof X == 'string')) {
			const D = Ff(t, X, ge.path),
				z = e.resolve({ path: D.path }, ge),
				Y = s.createHref(D.fullPath);
			return Nt(D, z, { params: d(z.params), hash: mh(D.hash), redirectedFrom: void 0, href: Y });
		}
		let be;
		if (X.path != null) be = Nt({}, X, { path: Ff(t, X.path, ge.path).path });
		else {
			const D = Nt({}, X.params);
			for (const z in D) D[z] == null && delete D[z];
			(be = Nt({}, X, { params: u(D) })), (ge.params = u(ge.params));
		}
		const H = e.resolve(be, ge),
			Ne = X.hash || '';
		H.params = h(d(H.params));
		const oe = SP(n, Nt({}, X, { hash: vP(Ne), path: H.path })),
			L = s.createHref(oe);
		return Nt({ fullPath: oe, hash: Ne, query: n === ky ? eL(X.query) : X.query || {} }, H, { redirectedFrom: void 0, href: L });
	}
	function y(X) {
		return typeof X == 'string' ? Ff(t, X, l.value.path) : Nt({}, X);
	}
	function _(X, ge) {
		if (c !== X) return Yl(8, { from: ge, to: X });
	}
	function x(X) {
		return C(X);
	}
	function E(X) {
		return x(Nt(y(X), { replace: !0 }));
	}
	function w(X) {
		const ge = X.matched[X.matched.length - 1];
		if (ge && ge.redirect) {
			const { redirect: be } = ge;
			let H = typeof be == 'function' ? be(X) : be;
			return (
				typeof H == 'string' && ((H = H.includes('?') || H.includes('#') ? (H = y(H)) : { path: H }), (H.params = {})),
				Nt({ query: X.query, hash: X.hash, params: H.path != null ? {} : X.params }, H)
			);
		}
	}
	function C(X, ge) {
		const be = (c = f(X)),
			H = l.value,
			Ne = X.state,
			oe = X.force,
			L = X.replace === !0,
			D = w(be);
		if (D) return C(Nt(y(D), { state: typeof D == 'object' ? Nt({}, Ne, D.state) : Ne, force: oe, replace: L }), ge || be);
		const z = be;
		z.redirectedFrom = ge;
		let Y;
		return (
			!oe && MP(n, H, be) && ((Y = Yl(16, { to: z, from: H })), Te(H, H, !0, !1)),
			(Y ? Promise.resolve(Y) : M(z, H))
				.catch((K) => (Qs(K) ? (Qs(K, 2) ? K : ue(K)) : Z(K, z, H)))
				.then((K) => {
					if (K) {
						if (Qs(K, 2))
							return C(
								Nt({ replace: L }, y(K.to), { state: typeof K.to == 'object' ? Nt({}, Ne, K.to.state) : Ne, force: oe }),
								ge || z
							);
					} else K = q(z, H, !0, L, Ne);
					return k(z, H, K), K;
				})
		);
	}
	function P(X, ge) {
		const be = _(X, ge);
		return be ? Promise.reject(be) : Promise.resolve();
	}
	function S(X) {
		const ge = se.values().next().value;
		return ge && typeof ge.runWithContext == 'function' ? ge.runWithContext(X) : X();
	}
	function M(X, ge) {
		let be;
		const [H, Ne, oe] = cL(X, ge);
		be = Bf(H.reverse(), 'beforeRouteLeave', X, ge);
		for (const D of H)
			D.leaveGuards.forEach((z) => {
				be.push($r(z, X, ge));
			});
		const L = P.bind(null, X, ge);
		return (
			be.push(L),
			we(be)
				.then(() => {
					be = [];
					for (const D of r.list()) be.push($r(D, X, ge));
					return be.push(L), we(be);
				})
				.then(() => {
					be = Bf(Ne, 'beforeRouteUpdate', X, ge);
					for (const D of Ne)
						D.updateGuards.forEach((z) => {
							be.push($r(z, X, ge));
						});
					return be.push(L), we(be);
				})
				.then(() => {
					be = [];
					for (const D of oe)
						if (D.beforeEnter)
							if (Ss(D.beforeEnter)) for (const z of D.beforeEnter) be.push($r(z, X, ge));
							else be.push($r(D.beforeEnter, X, ge));
					return be.push(L), we(be);
				})
				.then(
					() => (
						X.matched.forEach((D) => (D.enterCallbacks = {})), (be = Bf(oe, 'beforeRouteEnter', X, ge, S)), be.push(L), we(be)
					)
				)
				.then(() => {
					be = [];
					for (const D of o.list()) be.push($r(D, X, ge));
					return be.push(L), we(be);
				})
				.catch((D) => (Qs(D, 8) ? D : Promise.reject(D)))
		);
	}
	function k(X, ge, be) {
		a.list().forEach((H) => S(() => H(X, ge, be)));
	}
	function q(X, ge, be, H, Ne) {
		const oe = _(X, ge);
		if (oe) return oe;
		const L = ge === Pr,
			D = Al ? history.state : {};
		be && (H || L ? s.replace(X.fullPath, Nt({ scroll: L && D && D.scroll }, Ne)) : s.push(X.fullPath, Ne)),
			(l.value = X),
			Te(X, ge, be, L),
			ue();
	}
	let B;
	function W() {
		B ||
			(B = s.listen((X, ge, be) => {
				if (!Se.listening) return;
				const H = f(X),
					Ne = w(H);
				if (Ne) {
					C(Nt(Ne, { replace: !0 }), H).catch(eh);
					return;
				}
				c = H;
				const oe = l.value;
				Al && IP(Ly(oe.fullPath, be.delta), Dp()),
					M(H, oe)
						.catch((L) =>
							Qs(L, 12)
								? L
								: Qs(L, 2)
								? (C(L.to, H)
										.then((D) => {
											Qs(D, 20) && !be.delta && be.type === gh.pop && s.go(-1, !1);
										})
										.catch(eh),
								  Promise.reject())
								: (be.delta && s.go(-be.delta, !1), Z(L, H, oe))
						)
						.then((L) => {
							(L = L || q(H, oe, !1)),
								L && (be.delta && !Qs(L, 8) ? s.go(-be.delta, !1) : be.type === gh.pop && Qs(L, 20) && s.go(-1, !1)),
								k(H, oe, L);
						})
						.catch(eh);
			}));
	}
	let Q = _c(),
		$ = _c(),
		le;
	function Z(X, ge, be) {
		ue(X);
		const H = $.list();
		return H.length ? H.forEach((Ne) => Ne(X, ge, be)) : console.error(X), Promise.reject(X);
	}
	function xe() {
		return le && l.value !== Pr
			? Promise.resolve()
			: new Promise((X, ge) => {
					Q.add([X, ge]);
			  });
	}
	function ue(X) {
		return le || ((le = !X), W(), Q.list().forEach(([ge, be]) => (X ? be(X) : ge())), Q.reset()), X;
	}
	function Te(X, ge, be, H) {
		const { scrollBehavior: Ne } = i;
		if (!Al || !Ne) return Promise.resolve();
		const oe = (!be && DP(Ly(X.fullPath, 0))) || ((H || !be) && history.state && history.state.scroll) || null;
		return xS()
			.then(() => Ne(X, ge, oe))
			.then((L) => L && LP(L))
			.catch((L) => Z(L, X, ge));
	}
	const Ae = (X) => s.go(X);
	let We;
	const se = new Set(),
		Se = {
			currentRoute: l,
			listening: !0,
			addRoute: p,
			removeRoute: g,
			clearRoutes: e.clearRoutes,
			hasRoute: m,
			getRoutes: v,
			resolve: f,
			options: i,
			push: x,
			replace: E,
			go: Ae,
			back: () => Ae(-1),
			forward: () => Ae(1),
			beforeEach: r.add,
			beforeResolve: o.add,
			afterEach: a.add,
			onError: $.add,
			isReady: xe,
			install(X) {
				const ge = this;
				X.component('RouterLink', sL),
					X.component('RouterView', lM),
					(X.config.globalProperties.$router = ge),
					Object.defineProperty(X.config.globalProperties, '$route', { enumerable: !0, get: () => ao(l) }),
					Al && !We && l.value === Pr && ((We = !0), x(s.location).catch((Ne) => {}));
				const be = {};
				for (const Ne in Pr) Object.defineProperty(be, Ne, { get: () => l.value[Ne], enumerable: !0 });
				X.provide(o_, ge), X.provide(aM, dS(be)), X.provide(Mg, l);
				const H = X.unmount;
				se.add(X),
					(X.unmount = function () {
						se.delete(X), se.size < 1 && ((c = Pr), B && B(), (B = null), (l.value = Pr), (We = !1), (le = !1)), H();
					});
			},
		};
	function we(X) {
		return X.reduce((ge, be) => ge.then(() => S(be)), Promise.resolve());
	}
	return Se;
}
function cL(i, e) {
	const t = [],
		n = [],
		s = [],
		r = Math.max(e.matched.length, i.matched.length);
	for (let o = 0; o < r; o++) {
		const a = e.matched[o];
		a && (i.matched.find((c) => ql(c, a)) ? n.push(a) : t.push(a));
		const l = i.matched[o];
		l && (e.matched.find((c) => ql(c, l)) || s.push(l));
	}
	return [t, n, s];
}
const hL = ac({
	__name: 'App',
	setup(i) {
		return (e, t) => (Lp(), bR(ao(lM)));
	},
});
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Co = '164',
	uL = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
	dL = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
	cM = 0,
	Eg = 1,
	hM = 2,
	pL = 3,
	fL = 0,
	a_ = 1,
	uM = 2,
	Us = 3,
	Ms = 0,
	gn = 1,
	mn = 2,
	jn = 0,
	co = 1,
	bs = 2,
	Tg = 3,
	Ag = 4,
	dM = 5,
	Jr = 100,
	pM = 101,
	fM = 102,
	mM = 103,
	gM = 104,
	vM = 200,
	_M = 201,
	yM = 202,
	xM = 203,
	Jd = 204,
	Qd = 205,
	bM = 206,
	wM = 207,
	SM = 208,
	MM = 209,
	EM = 210,
	TM = 211,
	AM = 212,
	CM = 213,
	RM = 214,
	l_ = 0,
	c_ = 1,
	ep = 2,
	jl = 3,
	vh = 4,
	h_ = 5,
	u_ = 6,
	Op = 7,
	Kh = 0,
	PM = 1,
	LM = 2,
	Xs = 0,
	Up = 1,
	d_ = 2,
	p_ = 3,
	f_ = 4,
	IM = 5,
	DM = 6,
	OM = 7,
	Cg = 'attached',
	UM = 'detached',
	Np = 300,
	_r = 301,
	_o = 302,
	_h = 303,
	yh = 304,
	lc = 306,
	rs = 1e3,
	Oi = 1001,
	Kl = 1002,
	It = 1003,
	Fp = 1004,
	mL = 1004,
	oa = 1005,
	gL = 1005,
	Tt = 1006,
	Nl = 1007,
	vL = 1007,
	ts = 1008,
	_L = 1008,
	Vn = 1009,
	NM = 1010,
	FM = 1011,
	m_ = 1012,
	g_ = 1013,
	yo = 1014,
	On = 1015,
	fi = 1016,
	v_ = 1017,
	__ = 1018,
	Ba = 1020,
	BM = 35902,
	kM = 1021,
	zM = 1022,
	mi = 1023,
	VM = 1024,
	HM = 1025,
	ga = 1026,
	Ta = 1027,
	Bp = 1028,
	y_ = 1029,
	GM = 1030,
	x_ = 1031,
	b_ = 1033,
	Ud = 33776,
	Nd = 33777,
	Fd = 33778,
	Bd = 33779,
	Rg = 35840,
	Pg = 35841,
	Lg = 35842,
	Ig = 35843,
	Dg = 36196,
	Og = 37492,
	Ug = 37496,
	Ng = 37808,
	Fg = 37809,
	Bg = 37810,
	kg = 37811,
	zg = 37812,
	Vg = 37813,
	Hg = 37814,
	Gg = 37815,
	Wg = 37816,
	Xg = 37817,
	qg = 37818,
	Yg = 37819,
	jg = 37820,
	Kg = 37821,
	kd = 36492,
	$g = 36494,
	Zg = 36495,
	WM = 36283,
	Jg = 36284,
	Qg = 36285,
	ev = 36286,
	XM = 2200,
	qM = 2201,
	YM = 2202,
	$l = 2300,
	Aa = 2301,
	zd = 2302,
	aa = 2400,
	la = 2401,
	xh = 2402,
	kp = 2500,
	w_ = 2501,
	jM = 0,
	S_ = 1,
	tp = 2,
	yr = 3200,
	zp = 3201,
	Ro = 0,
	KM = 1,
	xs = '',
	ot = 'srgb',
	Es = 'srgb-linear',
	Vp = 'display-p3',
	$h = 'display-p3-linear',
	bh = 'linear',
	Wt = 'srgb',
	wh = 'rec709',
	Sh = 'p3',
	yL = 0,
	ea = 7680,
	xL = 7681,
	bL = 7682,
	wL = 7683,
	SL = 34055,
	ML = 34056,
	EL = 5386,
	TL = 512,
	AL = 513,
	CL = 514,
	RL = 515,
	PL = 516,
	LL = 517,
	IL = 518,
	tv = 519,
	$M = 512,
	ZM = 513,
	JM = 514,
	M_ = 515,
	QM = 516,
	eE = 517,
	tE = 518,
	nE = 519,
	Mh = 35044,
	DL = 35048,
	OL = 35040,
	UL = 35045,
	NL = 35049,
	FL = 35041,
	BL = 35046,
	kL = 35050,
	zL = 35042,
	VL = '100',
	nv = '300 es',
	Vs = 2e3,
	Eh = 2001;
let Hi = class {
	addEventListener(e, t) {
		this._listeners === void 0 && (this._listeners = {});
		const n = this._listeners;
		n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
	}
	hasEventListener(e, t) {
		if (this._listeners === void 0) return !1;
		const n = this._listeners;
		return n[e] !== void 0 && n[e].indexOf(t) !== -1;
	}
	removeEventListener(e, t) {
		if (this._listeners === void 0) return;
		const s = this._listeners[e];
		if (s !== void 0) {
			const r = s.indexOf(t);
			r !== -1 && s.splice(r, 1);
		}
	}
	dispatchEvent(e) {
		if (this._listeners === void 0) return;
		const n = this._listeners[e.type];
		if (n !== void 0) {
			e.target = this;
			const s = n.slice(0);
			for (let r = 0, o = s.length; r < o; r++) s[r].call(this, e);
			e.target = null;
		}
	}
};
const Gn = [
	'00',
	'01',
	'02',
	'03',
	'04',
	'05',
	'06',
	'07',
	'08',
	'09',
	'0a',
	'0b',
	'0c',
	'0d',
	'0e',
	'0f',
	'10',
	'11',
	'12',
	'13',
	'14',
	'15',
	'16',
	'17',
	'18',
	'19',
	'1a',
	'1b',
	'1c',
	'1d',
	'1e',
	'1f',
	'20',
	'21',
	'22',
	'23',
	'24',
	'25',
	'26',
	'27',
	'28',
	'29',
	'2a',
	'2b',
	'2c',
	'2d',
	'2e',
	'2f',
	'30',
	'31',
	'32',
	'33',
	'34',
	'35',
	'36',
	'37',
	'38',
	'39',
	'3a',
	'3b',
	'3c',
	'3d',
	'3e',
	'3f',
	'40',
	'41',
	'42',
	'43',
	'44',
	'45',
	'46',
	'47',
	'48',
	'49',
	'4a',
	'4b',
	'4c',
	'4d',
	'4e',
	'4f',
	'50',
	'51',
	'52',
	'53',
	'54',
	'55',
	'56',
	'57',
	'58',
	'59',
	'5a',
	'5b',
	'5c',
	'5d',
	'5e',
	'5f',
	'60',
	'61',
	'62',
	'63',
	'64',
	'65',
	'66',
	'67',
	'68',
	'69',
	'6a',
	'6b',
	'6c',
	'6d',
	'6e',
	'6f',
	'70',
	'71',
	'72',
	'73',
	'74',
	'75',
	'76',
	'77',
	'78',
	'79',
	'7a',
	'7b',
	'7c',
	'7d',
	'7e',
	'7f',
	'80',
	'81',
	'82',
	'83',
	'84',
	'85',
	'86',
	'87',
	'88',
	'89',
	'8a',
	'8b',
	'8c',
	'8d',
	'8e',
	'8f',
	'90',
	'91',
	'92',
	'93',
	'94',
	'95',
	'96',
	'97',
	'98',
	'99',
	'9a',
	'9b',
	'9c',
	'9d',
	'9e',
	'9f',
	'a0',
	'a1',
	'a2',
	'a3',
	'a4',
	'a5',
	'a6',
	'a7',
	'a8',
	'a9',
	'aa',
	'ab',
	'ac',
	'ad',
	'ae',
	'af',
	'b0',
	'b1',
	'b2',
	'b3',
	'b4',
	'b5',
	'b6',
	'b7',
	'b8',
	'b9',
	'ba',
	'bb',
	'bc',
	'bd',
	'be',
	'bf',
	'c0',
	'c1',
	'c2',
	'c3',
	'c4',
	'c5',
	'c6',
	'c7',
	'c8',
	'c9',
	'ca',
	'cb',
	'cc',
	'cd',
	'ce',
	'cf',
	'd0',
	'd1',
	'd2',
	'd3',
	'd4',
	'd5',
	'd6',
	'd7',
	'd8',
	'd9',
	'da',
	'db',
	'dc',
	'dd',
	'de',
	'df',
	'e0',
	'e1',
	'e2',
	'e3',
	'e4',
	'e5',
	'e6',
	'e7',
	'e8',
	'e9',
	'ea',
	'eb',
	'ec',
	'ed',
	'ee',
	'ef',
	'f0',
	'f1',
	'f2',
	'f3',
	'f4',
	'f5',
	'f6',
	'f7',
	'f8',
	'f9',
	'fa',
	'fb',
	'fc',
	'fd',
	'fe',
	'ff',
];
let Xy = 1234567;
const va = Math.PI / 180,
	Zl = 180 / Math.PI;
function Bi() {
	const i = (Math.random() * 4294967295) | 0,
		e = (Math.random() * 4294967295) | 0,
		t = (Math.random() * 4294967295) | 0,
		n = (Math.random() * 4294967295) | 0;
	return (
		Gn[i & 255] +
		Gn[(i >> 8) & 255] +
		Gn[(i >> 16) & 255] +
		Gn[(i >> 24) & 255] +
		'-' +
		Gn[e & 255] +
		Gn[(e >> 8) & 255] +
		'-' +
		Gn[((e >> 16) & 15) | 64] +
		Gn[(e >> 24) & 255] +
		'-' +
		Gn[(t & 63) | 128] +
		Gn[(t >> 8) & 255] +
		'-' +
		Gn[(t >> 16) & 255] +
		Gn[(t >> 24) & 255] +
		Gn[n & 255] +
		Gn[(n >> 8) & 255] +
		Gn[(n >> 16) & 255] +
		Gn[(n >> 24) & 255]
	).toLowerCase();
}
function ln(i, e, t) {
	return Math.max(e, Math.min(t, i));
}
function E_(i, e) {
	return ((i % e) + e) % e;
}
function HL(i, e, t, n, s) {
	return n + ((i - e) * (s - n)) / (t - e);
}
function GL(i, e, t) {
	return i !== e ? (t - i) / (e - i) : 0;
}
function nh(i, e, t) {
	return (1 - t) * i + t * e;
}
function WL(i, e, t, n) {
	return nh(i, e, 1 - Math.exp(-t * n));
}
function XL(i, e = 1) {
	return e - Math.abs(E_(i, e * 2) - e);
}
function qL(i, e, t) {
	return i <= e ? 0 : i >= t ? 1 : ((i = (i - e) / (t - e)), i * i * (3 - 2 * i));
}
function YL(i, e, t) {
	return i <= e ? 0 : i >= t ? 1 : ((i = (i - e) / (t - e)), i * i * i * (i * (i * 6 - 15) + 10));
}
function jL(i, e) {
	return i + Math.floor(Math.random() * (e - i + 1));
}
function KL(i, e) {
	return i + Math.random() * (e - i);
}
function $L(i) {
	return i * (0.5 - Math.random());
}
function ZL(i) {
	i !== void 0 && (Xy = i);
	let e = (Xy += 1831565813);
	return (e = Math.imul(e ^ (e >>> 15), e | 1)), (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)), ((e ^ (e >>> 14)) >>> 0) / 4294967296;
}
function JL(i) {
	return i * va;
}
function QL(i) {
	return i * Zl;
}
function eI(i) {
	return (i & (i - 1)) === 0 && i !== 0;
}
function tI(i) {
	return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function nI(i) {
	return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function iI(i, e, t, n, s) {
	const r = Math.cos,
		o = Math.sin,
		a = r(t / 2),
		l = o(t / 2),
		c = r((e + n) / 2),
		h = o((e + n) / 2),
		u = r((e - n) / 2),
		d = o((e - n) / 2),
		p = r((n - e) / 2),
		g = o((n - e) / 2);
	switch (s) {
		case 'XYX':
			i.set(a * h, l * u, l * d, a * c);
			break;
		case 'YZY':
			i.set(l * d, a * h, l * u, a * c);
			break;
		case 'ZXZ':
			i.set(l * u, l * d, a * h, a * c);
			break;
		case 'XZX':
			i.set(a * h, l * g, l * p, a * c);
			break;
		case 'YXY':
			i.set(l * p, a * h, l * g, a * c);
			break;
		case 'ZYZ':
			i.set(l * g, l * p, a * h, a * c);
			break;
		default:
			console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + s);
	}
}
function ri(i, e) {
	switch (e.constructor) {
		case Float32Array:
			return i;
		case Uint32Array:
			return i / 4294967295;
		case Uint16Array:
			return i / 65535;
		case Uint8Array:
			return i / 255;
		case Int32Array:
			return Math.max(i / 2147483647, -1);
		case Int16Array:
			return Math.max(i / 32767, -1);
		case Int8Array:
			return Math.max(i / 127, -1);
		default:
			throw new Error('Invalid component type.');
	}
}
function tt(i, e) {
	switch (e.constructor) {
		case Float32Array:
			return i;
		case Uint32Array:
			return Math.round(i * 4294967295);
		case Uint16Array:
			return Math.round(i * 65535);
		case Uint8Array:
			return Math.round(i * 255);
		case Int32Array:
			return Math.round(i * 2147483647);
		case Int16Array:
			return Math.round(i * 32767);
		case Int8Array:
			return Math.round(i * 127);
		default:
			throw new Error('Invalid component type.');
	}
}
const Dn = {
	DEG2RAD: va,
	RAD2DEG: Zl,
	generateUUID: Bi,
	clamp: ln,
	euclideanModulo: E_,
	mapLinear: HL,
	inverseLerp: GL,
	lerp: nh,
	damp: WL,
	pingpong: XL,
	smoothstep: qL,
	smootherstep: YL,
	randInt: jL,
	randFloat: KL,
	randFloatSpread: $L,
	seededRandom: ZL,
	degToRad: JL,
	radToDeg: QL,
	isPowerOfTwo: eI,
	ceilPowerOfTwo: tI,
	floorPowerOfTwo: nI,
	setQuaternionFromProperEuler: iI,
	normalize: tt,
	denormalize: ri,
};
class ce {
	constructor(e = 0, t = 0) {
		(ce.prototype.isVector2 = !0), (this.x = e), (this.y = t);
	}
	get width() {
		return this.x;
	}
	set width(e) {
		this.x = e;
	}
	get height() {
		return this.y;
	}
	set height(e) {
		this.y = e;
	}
	set(e, t) {
		return (this.x = e), (this.y = t), this;
	}
	setScalar(e) {
		return (this.x = e), (this.y = e), this;
	}
	setX(e) {
		return (this.x = e), this;
	}
	setY(e) {
		return (this.y = e), this;
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			default:
				throw new Error('index is out of range: ' + e);
		}
		return this;
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw new Error('index is out of range: ' + e);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y);
	}
	copy(e) {
		return (this.x = e.x), (this.y = e.y), this;
	}
	add(e) {
		return (this.x += e.x), (this.y += e.y), this;
	}
	addScalar(e) {
		return (this.x += e), (this.y += e), this;
	}
	addVectors(e, t) {
		return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
	}
	addScaledVector(e, t) {
		return (this.x += e.x * t), (this.y += e.y * t), this;
	}
	sub(e) {
		return (this.x -= e.x), (this.y -= e.y), this;
	}
	subScalar(e) {
		return (this.x -= e), (this.y -= e), this;
	}
	subVectors(e, t) {
		return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
	}
	multiply(e) {
		return (this.x *= e.x), (this.y *= e.y), this;
	}
	multiplyScalar(e) {
		return (this.x *= e), (this.y *= e), this;
	}
	divide(e) {
		return (this.x /= e.x), (this.y /= e.y), this;
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e);
	}
	applyMatrix3(e) {
		const t = this.x,
			n = this.y,
			s = e.elements;
		return (this.x = s[0] * t + s[3] * n + s[6]), (this.y = s[1] * t + s[4] * n + s[7]), this;
	}
	min(e) {
		return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this;
	}
	max(e) {
		return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this;
	}
	clamp(e, t) {
		return (this.x = Math.max(e.x, Math.min(t.x, this.x))), (this.y = Math.max(e.y, Math.min(t.y, this.y))), this;
	}
	clampScalar(e, t) {
		return (this.x = Math.max(e, Math.min(t, this.x))), (this.y = Math.max(e, Math.min(t, this.y))), this;
	}
	clampLength(e, t) {
		const n = this.length();
		return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
	}
	floor() {
		return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
	}
	ceil() {
		return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
	}
	round() {
		return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
	}
	roundToZero() {
		return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
	}
	negate() {
		return (this.x = -this.x), (this.y = -this.y), this;
	}
	dot(e) {
		return this.x * e.x + this.y * e.y;
	}
	cross(e) {
		return this.x * e.y - this.y * e.x;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI;
	}
	angleTo(e) {
		const t = Math.sqrt(this.lengthSq() * e.lengthSq());
		if (t === 0) return Math.PI / 2;
		const n = this.dot(e) / t;
		return Math.acos(ln(n, -1, 1));
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e));
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			n = this.y - e.y;
		return t * t + n * n;
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e);
	}
	lerp(e, t) {
		return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
	}
	lerpVectors(e, t, n) {
		return (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this;
	}
	equals(e) {
		return e.x === this.x && e.y === this.y;
	}
	fromArray(e, t = 0) {
		return (this.x = e[t]), (this.y = e[t + 1]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.x), (e[t + 1] = this.y), e;
	}
	fromBufferAttribute(e, t) {
		return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
	}
	rotateAround(e, t) {
		const n = Math.cos(t),
			s = Math.sin(t),
			r = this.x - e.x,
			o = this.y - e.y;
		return (this.x = r * n - o * s + e.x), (this.y = r * s + o * n + e.y), this;
	}
	random() {
		return (this.x = Math.random()), (this.y = Math.random()), this;
	}
	*[Symbol.iterator]() {
		yield this.x, yield this.y;
	}
}
class et {
	constructor(e, t, n, s, r, o, a, l, c) {
		(et.prototype.isMatrix3 = !0), (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]), e !== void 0 && this.set(e, t, n, s, r, o, a, l, c);
	}
	set(e, t, n, s, r, o, a, l, c) {
		const h = this.elements;
		return (h[0] = e), (h[1] = s), (h[2] = a), (h[3] = t), (h[4] = r), (h[5] = l), (h[6] = n), (h[7] = o), (h[8] = c), this;
	}
	identity() {
		return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
	}
	copy(e) {
		const t = this.elements,
			n = e.elements;
		return (
			(t[0] = n[0]),
			(t[1] = n[1]),
			(t[2] = n[2]),
			(t[3] = n[3]),
			(t[4] = n[4]),
			(t[5] = n[5]),
			(t[6] = n[6]),
			(t[7] = n[7]),
			(t[8] = n[8]),
			this
		);
	}
	extractBasis(e, t, n) {
		return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
	}
	setFromMatrix4(e) {
		const t = e.elements;
		return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
	}
	multiply(e) {
		return this.multiplyMatrices(this, e);
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this);
	}
	multiplyMatrices(e, t) {
		const n = e.elements,
			s = t.elements,
			r = this.elements,
			o = n[0],
			a = n[3],
			l = n[6],
			c = n[1],
			h = n[4],
			u = n[7],
			d = n[2],
			p = n[5],
			g = n[8],
			v = s[0],
			m = s[3],
			f = s[6],
			y = s[1],
			_ = s[4],
			x = s[7],
			E = s[2],
			w = s[5],
			C = s[8];
		return (
			(r[0] = o * v + a * y + l * E),
			(r[3] = o * m + a * _ + l * w),
			(r[6] = o * f + a * x + l * C),
			(r[1] = c * v + h * y + u * E),
			(r[4] = c * m + h * _ + u * w),
			(r[7] = c * f + h * x + u * C),
			(r[2] = d * v + p * y + g * E),
			(r[5] = d * m + p * _ + g * w),
			(r[8] = d * f + p * x + g * C),
			this
		);
	}
	multiplyScalar(e) {
		const t = this.elements;
		return (t[0] *= e), (t[3] *= e), (t[6] *= e), (t[1] *= e), (t[4] *= e), (t[7] *= e), (t[2] *= e), (t[5] *= e), (t[8] *= e), this;
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			n = e[1],
			s = e[2],
			r = e[3],
			o = e[4],
			a = e[5],
			l = e[6],
			c = e[7],
			h = e[8];
		return t * o * h - t * a * c - n * r * h + n * a * l + s * r * c - s * o * l;
	}
	invert() {
		const e = this.elements,
			t = e[0],
			n = e[1],
			s = e[2],
			r = e[3],
			o = e[4],
			a = e[5],
			l = e[6],
			c = e[7],
			h = e[8],
			u = h * o - a * c,
			d = a * l - h * r,
			p = c * r - o * l,
			g = t * u + n * d + s * p;
		if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		const v = 1 / g;
		return (
			(e[0] = u * v),
			(e[1] = (s * c - h * n) * v),
			(e[2] = (a * n - s * o) * v),
			(e[3] = d * v),
			(e[4] = (h * t - s * l) * v),
			(e[5] = (s * r - a * t) * v),
			(e[6] = p * v),
			(e[7] = (n * l - c * t) * v),
			(e[8] = (o * t - n * r) * v),
			this
		);
	}
	transpose() {
		let e;
		const t = this.elements;
		return (e = t[1]), (t[1] = t[3]), (t[3] = e), (e = t[2]), (t[2] = t[6]), (t[6] = e), (e = t[5]), (t[5] = t[7]), (t[7] = e), this;
	}
	getNormalMatrix(e) {
		return this.setFromMatrix4(e).invert().transpose();
	}
	transposeIntoArray(e) {
		const t = this.elements;
		return (
			(e[0] = t[0]),
			(e[1] = t[3]),
			(e[2] = t[6]),
			(e[3] = t[1]),
			(e[4] = t[4]),
			(e[5] = t[7]),
			(e[6] = t[2]),
			(e[7] = t[5]),
			(e[8] = t[8]),
			this
		);
	}
	setUvTransform(e, t, n, s, r, o, a) {
		const l = Math.cos(r),
			c = Math.sin(r);
		return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -s * c, s * l, -s * (-c * o + l * a) + a + t, 0, 0, 1), this;
	}
	scale(e, t) {
		return this.premultiply(kf.makeScale(e, t)), this;
	}
	rotate(e) {
		return this.premultiply(kf.makeRotation(-e)), this;
	}
	translate(e, t) {
		return this.premultiply(kf.makeTranslation(e, t)), this;
	}
	makeTranslation(e, t) {
		return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
	}
	makeRotation(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
	}
	makeScale(e, t) {
		return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
	}
	equals(e) {
		const t = this.elements,
			n = e.elements;
		for (let s = 0; s < 9; s++) if (t[s] !== n[s]) return !1;
		return !0;
	}
	fromArray(e, t = 0) {
		for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
		return this;
	}
	toArray(e = [], t = 0) {
		const n = this.elements;
		return (
			(e[t] = n[0]),
			(e[t + 1] = n[1]),
			(e[t + 2] = n[2]),
			(e[t + 3] = n[3]),
			(e[t + 4] = n[4]),
			(e[t + 5] = n[5]),
			(e[t + 6] = n[6]),
			(e[t + 7] = n[7]),
			(e[t + 8] = n[8]),
			e
		);
	}
	clone() {
		return new this.constructor().fromArray(this.elements);
	}
}
const kf = new et();
function iE(i) {
	for (let e = i.length - 1; e >= 0; --e) if (i[e] >= 65535) return !0;
	return !1;
}
const sI = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function Cl(i, e) {
	return new sI[i](e);
}
function Th(i) {
	return document.createElementNS('http://www.w3.org/1999/xhtml', i);
}
function sE() {
	const i = Th('canvas');
	return (i.style.display = 'block'), i;
}
const qy = {};
function rE(i) {
	i in qy || ((qy[i] = !0), console.warn(i));
}
const Yy = new et().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199),
	jy = new et().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735),
	Ru = {
		[Es]: { transfer: bh, primaries: wh, toReference: (i) => i, fromReference: (i) => i },
		[ot]: { transfer: Wt, primaries: wh, toReference: (i) => i.convertSRGBToLinear(), fromReference: (i) => i.convertLinearToSRGB() },
		[$h]: { transfer: bh, primaries: Sh, toReference: (i) => i.applyMatrix3(jy), fromReference: (i) => i.applyMatrix3(Yy) },
		[Vp]: {
			transfer: Wt,
			primaries: Sh,
			toReference: (i) => i.convertSRGBToLinear().applyMatrix3(jy),
			fromReference: (i) => i.applyMatrix3(Yy).convertLinearToSRGB(),
		},
	},
	rI = new Set([Es, $h]),
	Ft = {
		enabled: !0,
		_workingColorSpace: Es,
		get workingColorSpace() {
			return this._workingColorSpace;
		},
		set workingColorSpace(i) {
			if (!rI.has(i)) throw new Error('Unsupported working color space, "'.concat(i, '".'));
			this._workingColorSpace = i;
		},
		convert: function (i, e, t) {
			if (this.enabled === !1 || e === t || !e || !t) return i;
			const n = Ru[e].toReference,
				s = Ru[t].fromReference;
			return s(n(i));
		},
		fromWorkingColorSpace: function (i, e) {
			return this.convert(i, this._workingColorSpace, e);
		},
		toWorkingColorSpace: function (i, e) {
			return this.convert(i, e, this._workingColorSpace);
		},
		getPrimaries: function (i) {
			return Ru[i].primaries;
		},
		getTransfer: function (i) {
			return i === xs ? bh : Ru[i].transfer;
		},
	};
function Fl(i) {
	return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function zf(i) {
	return i < 0.0031308 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let Ka;
class oE {
	static getDataURL(e) {
		if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > 'u') return e.src;
		let t;
		if (e instanceof HTMLCanvasElement) t = e;
		else {
			Ka === void 0 && (Ka = Th('canvas')), (Ka.width = e.width), (Ka.height = e.height);
			const n = Ka.getContext('2d');
			e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), (t = Ka);
		}
		return t.width > 2048 || t.height > 2048
			? (console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', e),
			  t.toDataURL('image/jpeg', 0.6))
			: t.toDataURL('image/png');
	}
	static sRGBToLinear(e) {
		if (
			(typeof HTMLImageElement < 'u' && e instanceof HTMLImageElement) ||
			(typeof HTMLCanvasElement < 'u' && e instanceof HTMLCanvasElement) ||
			(typeof ImageBitmap < 'u' && e instanceof ImageBitmap)
		) {
			const t = Th('canvas');
			(t.width = e.width), (t.height = e.height);
			const n = t.getContext('2d');
			n.drawImage(e, 0, 0, e.width, e.height);
			const s = n.getImageData(0, 0, e.width, e.height),
				r = s.data;
			for (let o = 0; o < r.length; o++) r[o] = Fl(r[o] / 255) * 255;
			return n.putImageData(s, 0, 0), t;
		} else if (e.data) {
			const t = e.data.slice(0);
			for (let n = 0; n < t.length; n++)
				t instanceof Uint8Array || t instanceof Uint8ClampedArray ? (t[n] = Math.floor(Fl(t[n] / 255) * 255)) : (t[n] = Fl(t[n]));
			return { data: t, width: e.width, height: e.height };
		} else return console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.'), e;
	}
}
let oI = 0;
class ca {
	constructor(e = null) {
		(this.isSource = !0),
			Object.defineProperty(this, 'id', { value: oI++ }),
			(this.uuid = Bi()),
			(this.data = e),
			(this.dataReady = !0),
			(this.version = 0);
	}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string';
		if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
		const n = { uuid: this.uuid, url: '' },
			s = this.data;
		if (s !== null) {
			let r;
			if (Array.isArray(s)) {
				r = [];
				for (let o = 0, a = s.length; o < a; o++) s[o].isDataTexture ? r.push(Vf(s[o].image)) : r.push(Vf(s[o]));
			} else r = Vf(s);
			n.url = r;
		}
		return t || (e.images[this.uuid] = n), n;
	}
}
function Vf(i) {
	return (typeof HTMLImageElement < 'u' && i instanceof HTMLImageElement) ||
		(typeof HTMLCanvasElement < 'u' && i instanceof HTMLCanvasElement) ||
		(typeof ImageBitmap < 'u' && i instanceof ImageBitmap)
		? oE.getDataURL(i)
		: i.data
		? { data: Array.from(i.data), width: i.width, height: i.height, type: i.data.constructor.name }
		: (console.warn('THREE.Texture: Unable to serialize Texture.'), {});
}
let aI = 0;
class zt extends Hi {
	constructor(
		e = zt.DEFAULT_IMAGE,
		t = zt.DEFAULT_MAPPING,
		n = Oi,
		s = Oi,
		r = Tt,
		o = ts,
		a = mi,
		l = Vn,
		c = zt.DEFAULT_ANISOTROPY,
		h = xs
	) {
		super(),
			(this.isTexture = !0),
			Object.defineProperty(this, 'id', { value: aI++ }),
			(this.uuid = Bi()),
			(this.name = ''),
			(this.source = new ca(e)),
			(this.mipmaps = []),
			(this.mapping = t),
			(this.channel = 0),
			(this.wrapS = n),
			(this.wrapT = s),
			(this.magFilter = r),
			(this.minFilter = o),
			(this.anisotropy = c),
			(this.format = a),
			(this.internalFormat = null),
			(this.type = l),
			(this.offset = new ce(0, 0)),
			(this.repeat = new ce(1, 1)),
			(this.center = new ce(0, 0)),
			(this.rotation = 0),
			(this.matrixAutoUpdate = !0),
			(this.matrix = new et()),
			(this.generateMipmaps = !0),
			(this.premultiplyAlpha = !1),
			(this.flipY = !0),
			(this.unpackAlignment = 4),
			(this.colorSpace = h),
			(this.userData = {}),
			(this.version = 0),
			(this.onUpdate = null),
			(this.isRenderTargetTexture = !1),
			(this.pmremVersion = 0);
	}
	get image() {
		return this.source.data;
	}
	set image(e = null) {
		this.source.data = e;
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return (
			(this.name = e.name),
			(this.source = e.source),
			(this.mipmaps = e.mipmaps.slice(0)),
			(this.mapping = e.mapping),
			(this.channel = e.channel),
			(this.wrapS = e.wrapS),
			(this.wrapT = e.wrapT),
			(this.magFilter = e.magFilter),
			(this.minFilter = e.minFilter),
			(this.anisotropy = e.anisotropy),
			(this.format = e.format),
			(this.internalFormat = e.internalFormat),
			(this.type = e.type),
			this.offset.copy(e.offset),
			this.repeat.copy(e.repeat),
			this.center.copy(e.center),
			(this.rotation = e.rotation),
			(this.matrixAutoUpdate = e.matrixAutoUpdate),
			this.matrix.copy(e.matrix),
			(this.generateMipmaps = e.generateMipmaps),
			(this.premultiplyAlpha = e.premultiplyAlpha),
			(this.flipY = e.flipY),
			(this.unpackAlignment = e.unpackAlignment),
			(this.colorSpace = e.colorSpace),
			(this.userData = JSON.parse(JSON.stringify(e.userData))),
			(this.needsUpdate = !0),
			this
		);
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string';
		if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
		const n = {
			metadata: { version: 4.6, type: 'Texture', generator: 'Texture.toJSON' },
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(e).uuid,
			mapping: this.mapping,
			channel: this.channel,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment,
		};
		return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
	transformUv(e) {
		if (this.mapping !== Np) return e;
		if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
			switch (this.wrapS) {
				case rs:
					e.x = e.x - Math.floor(e.x);
					break;
				case Oi:
					e.x = e.x < 0 ? 0 : 1;
					break;
				case Kl:
					Math.abs(Math.floor(e.x) % 2) === 1 ? (e.x = Math.ceil(e.x) - e.x) : (e.x = e.x - Math.floor(e.x));
					break;
			}
		if (e.y < 0 || e.y > 1)
			switch (this.wrapT) {
				case rs:
					e.y = e.y - Math.floor(e.y);
					break;
				case Oi:
					e.y = e.y < 0 ? 0 : 1;
					break;
				case Kl:
					Math.abs(Math.floor(e.y) % 2) === 1 ? (e.y = Math.ceil(e.y) - e.y) : (e.y = e.y - Math.floor(e.y));
					break;
			}
		return this.flipY && (e.y = 1 - e.y), e;
	}
	set needsUpdate(e) {
		e === !0 && (this.version++, (this.source.needsUpdate = !0));
	}
	set needsPMREMUpdate(e) {
		e === !0 && this.pmremVersion++;
	}
}
zt.DEFAULT_IMAGE = null;
zt.DEFAULT_MAPPING = Np;
zt.DEFAULT_ANISOTROPY = 1;
class Pt {
	constructor(e = 0, t = 0, n = 0, s = 1) {
		(Pt.prototype.isVector4 = !0), (this.x = e), (this.y = t), (this.z = n), (this.w = s);
	}
	get width() {
		return this.z;
	}
	set width(e) {
		this.z = e;
	}
	get height() {
		return this.w;
	}
	set height(e) {
		this.w = e;
	}
	set(e, t, n, s) {
		return (this.x = e), (this.y = t), (this.z = n), (this.w = s), this;
	}
	setScalar(e) {
		return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
	}
	setX(e) {
		return (this.x = e), this;
	}
	setY(e) {
		return (this.y = e), this;
	}
	setZ(e) {
		return (this.z = e), this;
	}
	setW(e) {
		return (this.w = e), this;
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			case 2:
				this.z = t;
				break;
			case 3:
				this.w = t;
				break;
			default:
				throw new Error('index is out of range: ' + e);
		}
		return this;
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw new Error('index is out of range: ' + e);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w);
	}
	copy(e) {
		return (this.x = e.x), (this.y = e.y), (this.z = e.z), (this.w = e.w !== void 0 ? e.w : 1), this;
	}
	add(e) {
		return (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this;
	}
	addScalar(e) {
		return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
	}
	addVectors(e, t) {
		return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), (this.w = e.w + t.w), this;
	}
	addScaledVector(e, t) {
		return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), (this.w += e.w * t), this;
	}
	sub(e) {
		return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this;
	}
	subScalar(e) {
		return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
	}
	subVectors(e, t) {
		return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), (this.w = e.w - t.w), this;
	}
	multiply(e) {
		return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this;
	}
	multiplyScalar(e) {
		return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
	}
	applyMatrix4(e) {
		const t = this.x,
			n = this.y,
			s = this.z,
			r = this.w,
			o = e.elements;
		return (
			(this.x = o[0] * t + o[4] * n + o[8] * s + o[12] * r),
			(this.y = o[1] * t + o[5] * n + o[9] * s + o[13] * r),
			(this.z = o[2] * t + o[6] * n + o[10] * s + o[14] * r),
			(this.w = o[3] * t + o[7] * n + o[11] * s + o[15] * r),
			this
		);
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e);
	}
	setAxisAngleFromQuaternion(e) {
		this.w = 2 * Math.acos(e.w);
		const t = Math.sqrt(1 - e.w * e.w);
		return t < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)), this;
	}
	setAxisAngleFromRotationMatrix(e) {
		let t, n, s, r;
		const l = e.elements,
			c = l[0],
			h = l[4],
			u = l[8],
			d = l[1],
			p = l[5],
			g = l[9],
			v = l[2],
			m = l[6],
			f = l[10];
		if (Math.abs(h - d) < 0.01 && Math.abs(u - v) < 0.01 && Math.abs(g - m) < 0.01) {
			if (Math.abs(h + d) < 0.1 && Math.abs(u + v) < 0.1 && Math.abs(g + m) < 0.1 && Math.abs(c + p + f - 3) < 0.1)
				return this.set(1, 0, 0, 0), this;
			t = Math.PI;
			const _ = (c + 1) / 2,
				x = (p + 1) / 2,
				E = (f + 1) / 2,
				w = (h + d) / 4,
				C = (u + v) / 4,
				P = (g + m) / 4;
			return (
				_ > x && _ > E
					? _ < 0.01
						? ((n = 0), (s = 0.707106781), (r = 0.707106781))
						: ((n = Math.sqrt(_)), (s = w / n), (r = C / n))
					: x > E
					? x < 0.01
						? ((n = 0.707106781), (s = 0), (r = 0.707106781))
						: ((s = Math.sqrt(x)), (n = w / s), (r = P / s))
					: E < 0.01
					? ((n = 0.707106781), (s = 0.707106781), (r = 0))
					: ((r = Math.sqrt(E)), (n = C / r), (s = P / r)),
				this.set(n, s, r, t),
				this
			);
		}
		let y = Math.sqrt((m - g) * (m - g) + (u - v) * (u - v) + (d - h) * (d - h));
		return (
			Math.abs(y) < 0.001 && (y = 1),
			(this.x = (m - g) / y),
			(this.y = (u - v) / y),
			(this.z = (d - h) / y),
			(this.w = Math.acos((c + p + f - 1) / 2)),
			this
		);
	}
	min(e) {
		return (
			(this.x = Math.min(this.x, e.x)),
			(this.y = Math.min(this.y, e.y)),
			(this.z = Math.min(this.z, e.z)),
			(this.w = Math.min(this.w, e.w)),
			this
		);
	}
	max(e) {
		return (
			(this.x = Math.max(this.x, e.x)),
			(this.y = Math.max(this.y, e.y)),
			(this.z = Math.max(this.z, e.z)),
			(this.w = Math.max(this.w, e.w)),
			this
		);
	}
	clamp(e, t) {
		return (
			(this.x = Math.max(e.x, Math.min(t.x, this.x))),
			(this.y = Math.max(e.y, Math.min(t.y, this.y))),
			(this.z = Math.max(e.z, Math.min(t.z, this.z))),
			(this.w = Math.max(e.w, Math.min(t.w, this.w))),
			this
		);
	}
	clampScalar(e, t) {
		return (
			(this.x = Math.max(e, Math.min(t, this.x))),
			(this.y = Math.max(e, Math.min(t, this.y))),
			(this.z = Math.max(e, Math.min(t, this.z))),
			(this.w = Math.max(e, Math.min(t, this.w))),
			this
		);
	}
	clampLength(e, t) {
		const n = this.length();
		return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
	}
	floor() {
		return (
			(this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), (this.w = Math.floor(this.w)), this
		);
	}
	ceil() {
		return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), (this.w = Math.ceil(this.w)), this;
	}
	round() {
		return (
			(this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), (this.w = Math.round(this.w)), this
		);
	}
	roundToZero() {
		return (
			(this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), (this.z = Math.trunc(this.z)), (this.w = Math.trunc(this.w)), this
		);
	}
	negate() {
		return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e);
	}
	lerp(e, t) {
		return (
			(this.x += (e.x - this.x) * t),
			(this.y += (e.y - this.y) * t),
			(this.z += (e.z - this.z) * t),
			(this.w += (e.w - this.w) * t),
			this
		);
	}
	lerpVectors(e, t, n) {
		return (
			(this.x = e.x + (t.x - e.x) * n),
			(this.y = e.y + (t.y - e.y) * n),
			(this.z = e.z + (t.z - e.z) * n),
			(this.w = e.w + (t.w - e.w) * n),
			this
		);
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
	}
	fromArray(e, t = 0) {
		return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), (this.w = e[t + 3]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), (e[t + 3] = this.w), e;
	}
	fromBufferAttribute(e, t) {
		return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), (this.w = e.getW(t)), this;
	}
	random() {
		return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this;
	}
	*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z, yield this.w;
	}
}
class aE extends Hi {
	constructor(e = 1, t = 1, n = {}) {
		super(),
			(this.isRenderTarget = !0),
			(this.width = e),
			(this.height = t),
			(this.depth = 1),
			(this.scissor = new Pt(0, 0, e, t)),
			(this.scissorTest = !1),
			(this.viewport = new Pt(0, 0, e, t));
		const s = { width: e, height: t, depth: 1 };
		n = Object.assign(
			{
				generateMipmaps: !1,
				internalFormat: null,
				minFilter: Tt,
				depthBuffer: !0,
				stencilBuffer: !1,
				resolveDepthBuffer: !0,
				resolveStencilBuffer: !0,
				depthTexture: null,
				samples: 0,
				count: 1,
			},
			n
		);
		const r = new zt(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
		(r.flipY = !1), (r.generateMipmaps = n.generateMipmaps), (r.internalFormat = n.internalFormat), (this.textures = []);
		const o = n.count;
		for (let a = 0; a < o; a++) (this.textures[a] = r.clone()), (this.textures[a].isRenderTargetTexture = !0);
		(this.depthBuffer = n.depthBuffer),
			(this.stencilBuffer = n.stencilBuffer),
			(this.resolveDepthBuffer = n.resolveDepthBuffer),
			(this.resolveStencilBuffer = n.resolveStencilBuffer),
			(this.depthTexture = n.depthTexture),
			(this.samples = n.samples);
	}
	get texture() {
		return this.textures[0];
	}
	set texture(e) {
		this.textures[0] = e;
	}
	setSize(e, t, n = 1) {
		if (this.width !== e || this.height !== t || this.depth !== n) {
			(this.width = e), (this.height = t), (this.depth = n);
			for (let s = 0, r = this.textures.length; s < r; s++)
				(this.textures[s].image.width = e), (this.textures[s].image.height = t), (this.textures[s].image.depth = n);
			this.dispose();
		}
		this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		(this.width = e.width),
			(this.height = e.height),
			(this.depth = e.depth),
			this.scissor.copy(e.scissor),
			(this.scissorTest = e.scissorTest),
			this.viewport.copy(e.viewport),
			(this.textures.length = 0);
		for (let n = 0, s = e.textures.length; n < s; n++)
			(this.textures[n] = e.textures[n].clone()), (this.textures[n].isRenderTargetTexture = !0);
		const t = Object.assign({}, e.texture.image);
		return (
			(this.texture.source = new ca(t)),
			(this.depthBuffer = e.depthBuffer),
			(this.stencilBuffer = e.stencilBuffer),
			(this.resolveDepthBuffer = e.resolveDepthBuffer),
			(this.resolveStencilBuffer = e.resolveStencilBuffer),
			e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
			(this.samples = e.samples),
			this
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
}
class yn extends aE {
	constructor(e = 1, t = 1, n = {}) {
		super(e, t, n), (this.isWebGLRenderTarget = !0);
	}
}
class Hp extends zt {
	constructor(e = null, t = 1, n = 1, s = 1) {
		super(null),
			(this.isDataArrayTexture = !0),
			(this.image = { data: e, width: t, height: n, depth: s }),
			(this.magFilter = It),
			(this.minFilter = It),
			(this.wrapR = Oi),
			(this.generateMipmaps = !1),
			(this.flipY = !1),
			(this.unpackAlignment = 1);
	}
}
class lI extends yn {
	constructor(e = 1, t = 1, n = 1, s = {}) {
		super(e, t, s),
			(this.isWebGLArrayRenderTarget = !0),
			(this.depth = n),
			(this.texture = new Hp(null, e, t, n)),
			(this.texture.isRenderTargetTexture = !0);
	}
}
class T_ extends zt {
	constructor(e = null, t = 1, n = 1, s = 1) {
		super(null),
			(this.isData3DTexture = !0),
			(this.image = { data: e, width: t, height: n, depth: s }),
			(this.magFilter = It),
			(this.minFilter = It),
			(this.wrapR = Oi),
			(this.generateMipmaps = !1),
			(this.flipY = !1),
			(this.unpackAlignment = 1);
	}
}
class cI extends yn {
	constructor(e = 1, t = 1, n = 1, s = {}) {
		super(e, t, s),
			(this.isWebGL3DRenderTarget = !0),
			(this.depth = n),
			(this.texture = new T_(null, e, t, n)),
			(this.texture.isRenderTargetTexture = !0);
	}
}
class kn {
	constructor(e = 0, t = 0, n = 0, s = 1) {
		(this.isQuaternion = !0), (this._x = e), (this._y = t), (this._z = n), (this._w = s);
	}
	static slerpFlat(e, t, n, s, r, o, a) {
		let l = n[s + 0],
			c = n[s + 1],
			h = n[s + 2],
			u = n[s + 3];
		const d = r[o + 0],
			p = r[o + 1],
			g = r[o + 2],
			v = r[o + 3];
		if (a === 0) {
			(e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
			return;
		}
		if (a === 1) {
			(e[t + 0] = d), (e[t + 1] = p), (e[t + 2] = g), (e[t + 3] = v);
			return;
		}
		if (u !== v || l !== d || c !== p || h !== g) {
			let m = 1 - a;
			const f = l * d + c * p + h * g + u * v,
				y = f >= 0 ? 1 : -1,
				_ = 1 - f * f;
			if (_ > Number.EPSILON) {
				const E = Math.sqrt(_),
					w = Math.atan2(E, f * y);
				(m = Math.sin(m * w) / E), (a = Math.sin(a * w) / E);
			}
			const x = a * y;
			if (((l = l * m + d * x), (c = c * m + p * x), (h = h * m + g * x), (u = u * m + v * x), m === 1 - a)) {
				const E = 1 / Math.sqrt(l * l + c * c + h * h + u * u);
				(l *= E), (c *= E), (h *= E), (u *= E);
			}
		}
		(e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = u);
	}
	static multiplyQuaternionsFlat(e, t, n, s, r, o) {
		const a = n[s],
			l = n[s + 1],
			c = n[s + 2],
			h = n[s + 3],
			u = r[o],
			d = r[o + 1],
			p = r[o + 2],
			g = r[o + 3];
		return (
			(e[t] = a * g + h * u + l * p - c * d),
			(e[t + 1] = l * g + h * d + c * u - a * p),
			(e[t + 2] = c * g + h * p + a * d - l * u),
			(e[t + 3] = h * g - a * u - l * d - c * p),
			e
		);
	}
	get x() {
		return this._x;
	}
	set x(e) {
		(this._x = e), this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(e) {
		(this._y = e), this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(e) {
		(this._z = e), this._onChangeCallback();
	}
	get w() {
		return this._w;
	}
	set w(e) {
		(this._w = e), this._onChangeCallback();
	}
	set(e, t, n, s) {
		return (this._x = e), (this._y = t), (this._z = n), (this._w = s), this._onChangeCallback(), this;
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w);
	}
	copy(e) {
		return (this._x = e.x), (this._y = e.y), (this._z = e.z), (this._w = e.w), this._onChangeCallback(), this;
	}
	setFromEuler(e, t = !0) {
		const n = e._x,
			s = e._y,
			r = e._z,
			o = e._order,
			a = Math.cos,
			l = Math.sin,
			c = a(n / 2),
			h = a(s / 2),
			u = a(r / 2),
			d = l(n / 2),
			p = l(s / 2),
			g = l(r / 2);
		switch (o) {
			case 'XYZ':
				(this._x = d * h * u + c * p * g),
					(this._y = c * p * u - d * h * g),
					(this._z = c * h * g + d * p * u),
					(this._w = c * h * u - d * p * g);
				break;
			case 'YXZ':
				(this._x = d * h * u + c * p * g),
					(this._y = c * p * u - d * h * g),
					(this._z = c * h * g - d * p * u),
					(this._w = c * h * u + d * p * g);
				break;
			case 'ZXY':
				(this._x = d * h * u - c * p * g),
					(this._y = c * p * u + d * h * g),
					(this._z = c * h * g + d * p * u),
					(this._w = c * h * u - d * p * g);
				break;
			case 'ZYX':
				(this._x = d * h * u - c * p * g),
					(this._y = c * p * u + d * h * g),
					(this._z = c * h * g - d * p * u),
					(this._w = c * h * u + d * p * g);
				break;
			case 'YZX':
				(this._x = d * h * u + c * p * g),
					(this._y = c * p * u + d * h * g),
					(this._z = c * h * g - d * p * u),
					(this._w = c * h * u - d * p * g);
				break;
			case 'XZY':
				(this._x = d * h * u - c * p * g),
					(this._y = c * p * u - d * h * g),
					(this._z = c * h * g + d * p * u),
					(this._w = c * h * u + d * p * g);
				break;
			default:
				console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + o);
		}
		return t === !0 && this._onChangeCallback(), this;
	}
	setFromAxisAngle(e, t) {
		const n = t / 2,
			s = Math.sin(n);
		return (this._x = e.x * s), (this._y = e.y * s), (this._z = e.z * s), (this._w = Math.cos(n)), this._onChangeCallback(), this;
	}
	setFromRotationMatrix(e) {
		const t = e.elements,
			n = t[0],
			s = t[4],
			r = t[8],
			o = t[1],
			a = t[5],
			l = t[9],
			c = t[2],
			h = t[6],
			u = t[10],
			d = n + a + u;
		if (d > 0) {
			const p = 0.5 / Math.sqrt(d + 1);
			(this._w = 0.25 / p), (this._x = (h - l) * p), (this._y = (r - c) * p), (this._z = (o - s) * p);
		} else if (n > a && n > u) {
			const p = 2 * Math.sqrt(1 + n - a - u);
			(this._w = (h - l) / p), (this._x = 0.25 * p), (this._y = (s + o) / p), (this._z = (r + c) / p);
		} else if (a > u) {
			const p = 2 * Math.sqrt(1 + a - n - u);
			(this._w = (r - c) / p), (this._x = (s + o) / p), (this._y = 0.25 * p), (this._z = (l + h) / p);
		} else {
			const p = 2 * Math.sqrt(1 + u - n - a);
			(this._w = (o - s) / p), (this._x = (r + c) / p), (this._y = (l + h) / p), (this._z = 0.25 * p);
		}
		return this._onChangeCallback(), this;
	}
	setFromUnitVectors(e, t) {
		let n = e.dot(t) + 1;
		return (
			n < Number.EPSILON
				? ((n = 0),
				  Math.abs(e.x) > Math.abs(e.z)
						? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
						: ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
				: ((this._x = e.y * t.z - e.z * t.y), (this._y = e.z * t.x - e.x * t.z), (this._z = e.x * t.y - e.y * t.x), (this._w = n)),
			this.normalize()
		);
	}
	angleTo(e) {
		return 2 * Math.acos(Math.abs(ln(this.dot(e), -1, 1)));
	}
	rotateTowards(e, t) {
		const n = this.angleTo(e);
		if (n === 0) return this;
		const s = Math.min(1, t / n);
		return this.slerp(e, s), this;
	}
	identity() {
		return this.set(0, 0, 0, 1);
	}
	invert() {
		return this.conjugate();
	}
	conjugate() {
		return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
	}
	dot(e) {
		return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
	}
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	}
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	}
	normalize() {
		let e = this.length();
		return (
			e === 0
				? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
				: ((e = 1 / e), (this._x = this._x * e), (this._y = this._y * e), (this._z = this._z * e), (this._w = this._w * e)),
			this._onChangeCallback(),
			this
		);
	}
	multiply(e) {
		return this.multiplyQuaternions(this, e);
	}
	premultiply(e) {
		return this.multiplyQuaternions(e, this);
	}
	multiplyQuaternions(e, t) {
		const n = e._x,
			s = e._y,
			r = e._z,
			o = e._w,
			a = t._x,
			l = t._y,
			c = t._z,
			h = t._w;
		return (
			(this._x = n * h + o * a + s * c - r * l),
			(this._y = s * h + o * l + r * a - n * c),
			(this._z = r * h + o * c + n * l - s * a),
			(this._w = o * h - n * a - s * l - r * c),
			this._onChangeCallback(),
			this
		);
	}
	slerp(e, t) {
		if (t === 0) return this;
		if (t === 1) return this.copy(e);
		const n = this._x,
			s = this._y,
			r = this._z,
			o = this._w;
		let a = o * e._w + n * e._x + s * e._y + r * e._z;
		if ((a < 0 ? ((this._w = -e._w), (this._x = -e._x), (this._y = -e._y), (this._z = -e._z), (a = -a)) : this.copy(e), a >= 1))
			return (this._w = o), (this._x = n), (this._y = s), (this._z = r), this;
		const l = 1 - a * a;
		if (l <= Number.EPSILON) {
			const p = 1 - t;
			return (
				(this._w = p * o + t * this._w),
				(this._x = p * n + t * this._x),
				(this._y = p * s + t * this._y),
				(this._z = p * r + t * this._z),
				this.normalize(),
				this
			);
		}
		const c = Math.sqrt(l),
			h = Math.atan2(c, a),
			u = Math.sin((1 - t) * h) / c,
			d = Math.sin(t * h) / c;
		return (
			(this._w = o * u + this._w * d),
			(this._x = n * u + this._x * d),
			(this._y = s * u + this._y * d),
			(this._z = r * u + this._z * d),
			this._onChangeCallback(),
			this
		);
	}
	slerpQuaternions(e, t, n) {
		return this.copy(e).slerp(t, n);
	}
	random() {
		const e = 2 * Math.PI * Math.random(),
			t = 2 * Math.PI * Math.random(),
			n = Math.random(),
			s = Math.sqrt(1 - n),
			r = Math.sqrt(n);
		return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t));
	}
	equals(e) {
		return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
	}
	fromArray(e, t = 0) {
		return (this._x = e[t]), (this._y = e[t + 1]), (this._z = e[t + 2]), (this._w = e[t + 3]), this._onChangeCallback(), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._w), e;
	}
	fromBufferAttribute(e, t) {
		return (this._x = e.getX(t)), (this._y = e.getY(t)), (this._z = e.getZ(t)), (this._w = e.getW(t)), this._onChangeCallback(), this;
	}
	toJSON() {
		return this.toArray();
	}
	_onChange(e) {
		return (this._onChangeCallback = e), this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._w;
	}
}
class I {
	constructor(e = 0, t = 0, n = 0) {
		(I.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
	}
	set(e, t, n) {
		return n === void 0 && (n = this.z), (this.x = e), (this.y = t), (this.z = n), this;
	}
	setScalar(e) {
		return (this.x = e), (this.y = e), (this.z = e), this;
	}
	setX(e) {
		return (this.x = e), this;
	}
	setY(e) {
		return (this.y = e), this;
	}
	setZ(e) {
		return (this.z = e), this;
	}
	setComponent(e, t) {
		switch (e) {
			case 0:
				this.x = t;
				break;
			case 1:
				this.y = t;
				break;
			case 2:
				this.z = t;
				break;
			default:
				throw new Error('index is out of range: ' + e);
		}
		return this;
	}
	getComponent(e) {
		switch (e) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw new Error('index is out of range: ' + e);
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z);
	}
	copy(e) {
		return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
	}
	add(e) {
		return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
	}
	addScalar(e) {
		return (this.x += e), (this.y += e), (this.z += e), this;
	}
	addVectors(e, t) {
		return (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this;
	}
	addScaledVector(e, t) {
		return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
	}
	sub(e) {
		return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
	}
	subScalar(e) {
		return (this.x -= e), (this.y -= e), (this.z -= e), this;
	}
	subVectors(e, t) {
		return (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this;
	}
	multiply(e) {
		return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
	}
	multiplyScalar(e) {
		return (this.x *= e), (this.y *= e), (this.z *= e), this;
	}
	multiplyVectors(e, t) {
		return (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this;
	}
	applyEuler(e) {
		return this.applyQuaternion(Ky.setFromEuler(e));
	}
	applyAxisAngle(e, t) {
		return this.applyQuaternion(Ky.setFromAxisAngle(e, t));
	}
	applyMatrix3(e) {
		const t = this.x,
			n = this.y,
			s = this.z,
			r = e.elements;
		return (
			(this.x = r[0] * t + r[3] * n + r[6] * s),
			(this.y = r[1] * t + r[4] * n + r[7] * s),
			(this.z = r[2] * t + r[5] * n + r[8] * s),
			this
		);
	}
	applyNormalMatrix(e) {
		return this.applyMatrix3(e).normalize();
	}
	applyMatrix4(e) {
		const t = this.x,
			n = this.y,
			s = this.z,
			r = e.elements,
			o = 1 / (r[3] * t + r[7] * n + r[11] * s + r[15]);
		return (
			(this.x = (r[0] * t + r[4] * n + r[8] * s + r[12]) * o),
			(this.y = (r[1] * t + r[5] * n + r[9] * s + r[13]) * o),
			(this.z = (r[2] * t + r[6] * n + r[10] * s + r[14]) * o),
			this
		);
	}
	applyQuaternion(e) {
		const t = this.x,
			n = this.y,
			s = this.z,
			r = e.x,
			o = e.y,
			a = e.z,
			l = e.w,
			c = 2 * (o * s - a * n),
			h = 2 * (a * t - r * s),
			u = 2 * (r * n - o * t);
		return (this.x = t + l * c + o * u - a * h), (this.y = n + l * h + a * c - r * u), (this.z = s + l * u + r * h - o * c), this;
	}
	project(e) {
		return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
	}
	unproject(e) {
		return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
	}
	transformDirection(e) {
		const t = this.x,
			n = this.y,
			s = this.z,
			r = e.elements;
		return (
			(this.x = r[0] * t + r[4] * n + r[8] * s),
			(this.y = r[1] * t + r[5] * n + r[9] * s),
			(this.z = r[2] * t + r[6] * n + r[10] * s),
			this.normalize()
		);
	}
	divide(e) {
		return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
	}
	divideScalar(e) {
		return this.multiplyScalar(1 / e);
	}
	min(e) {
		return (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), (this.z = Math.min(this.z, e.z)), this;
	}
	max(e) {
		return (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), (this.z = Math.max(this.z, e.z)), this;
	}
	clamp(e, t) {
		return (
			(this.x = Math.max(e.x, Math.min(t.x, this.x))),
			(this.y = Math.max(e.y, Math.min(t.y, this.y))),
			(this.z = Math.max(e.z, Math.min(t.z, this.z))),
			this
		);
	}
	clampScalar(e, t) {
		return (
			(this.x = Math.max(e, Math.min(t, this.x))),
			(this.y = Math.max(e, Math.min(t, this.y))),
			(this.z = Math.max(e, Math.min(t, this.z))),
			this
		);
	}
	clampLength(e, t) {
		const n = this.length();
		return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
	}
	floor() {
		return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
	}
	ceil() {
		return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
	}
	round() {
		return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
	}
	roundToZero() {
		return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), (this.z = Math.trunc(this.z)), this;
	}
	negate() {
		return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
	}
	dot(e) {
		return this.x * e.x + this.y * e.y + this.z * e.z;
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	}
	normalize() {
		return this.divideScalar(this.length() || 1);
	}
	setLength(e) {
		return this.normalize().multiplyScalar(e);
	}
	lerp(e, t) {
		return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), (this.z += (e.z - this.z) * t), this;
	}
	lerpVectors(e, t, n) {
		return (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), (this.z = e.z + (t.z - e.z) * n), this;
	}
	cross(e) {
		return this.crossVectors(this, e);
	}
	crossVectors(e, t) {
		const n = e.x,
			s = e.y,
			r = e.z,
			o = t.x,
			a = t.y,
			l = t.z;
		return (this.x = s * l - r * a), (this.y = r * o - n * l), (this.z = n * a - s * o), this;
	}
	projectOnVector(e) {
		const t = e.lengthSq();
		if (t === 0) return this.set(0, 0, 0);
		const n = e.dot(this) / t;
		return this.copy(e).multiplyScalar(n);
	}
	projectOnPlane(e) {
		return Hf.copy(this).projectOnVector(e), this.sub(Hf);
	}
	reflect(e) {
		return this.sub(Hf.copy(e).multiplyScalar(2 * this.dot(e)));
	}
	angleTo(e) {
		const t = Math.sqrt(this.lengthSq() * e.lengthSq());
		if (t === 0) return Math.PI / 2;
		const n = this.dot(e) / t;
		return Math.acos(ln(n, -1, 1));
	}
	distanceTo(e) {
		return Math.sqrt(this.distanceToSquared(e));
	}
	distanceToSquared(e) {
		const t = this.x - e.x,
			n = this.y - e.y,
			s = this.z - e.z;
		return t * t + n * n + s * s;
	}
	manhattanDistanceTo(e) {
		return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
	}
	setFromSpherical(e) {
		return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
	}
	setFromSphericalCoords(e, t, n) {
		const s = Math.sin(t) * e;
		return (this.x = s * Math.sin(n)), (this.y = Math.cos(t) * e), (this.z = s * Math.cos(n)), this;
	}
	setFromCylindrical(e) {
		return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
	}
	setFromCylindricalCoords(e, t, n) {
		return (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this;
	}
	setFromMatrixPosition(e) {
		const t = e.elements;
		return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
	}
	setFromMatrixScale(e) {
		const t = this.setFromMatrixColumn(e, 0).length(),
			n = this.setFromMatrixColumn(e, 1).length(),
			s = this.setFromMatrixColumn(e, 2).length();
		return (this.x = t), (this.y = n), (this.z = s), this;
	}
	setFromMatrixColumn(e, t) {
		return this.fromArray(e.elements, t * 4);
	}
	setFromMatrix3Column(e, t) {
		return this.fromArray(e.elements, t * 3);
	}
	setFromEuler(e) {
		return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
	}
	setFromColor(e) {
		return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
	}
	equals(e) {
		return e.x === this.x && e.y === this.y && e.z === this.z;
	}
	fromArray(e, t = 0) {
		return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
	}
	fromBufferAttribute(e, t) {
		return (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this;
	}
	random() {
		return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
	}
	randomDirection() {
		const e = Math.random() * Math.PI * 2,
			t = Math.random() * 2 - 1,
			n = Math.sqrt(1 - t * t);
		return (this.x = n * Math.cos(e)), (this.y = t), (this.z = n * Math.sin(e)), this;
	}
	*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z;
	}
}
const Hf = new I(),
	Ky = new kn();
class An {
	constructor(e = new I(1 / 0, 1 / 0, 1 / 0), t = new I(-1 / 0, -1 / 0, -1 / 0)) {
		(this.isBox3 = !0), (this.min = e), (this.max = t);
	}
	set(e, t) {
		return this.min.copy(e), this.max.copy(t), this;
	}
	setFromArray(e) {
		this.makeEmpty();
		for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(hs.fromArray(e, t));
		return this;
	}
	setFromBufferAttribute(e) {
		this.makeEmpty();
		for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(hs.fromBufferAttribute(e, t));
		return this;
	}
	setFromPoints(e) {
		this.makeEmpty();
		for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
		return this;
	}
	setFromCenterAndSize(e, t) {
		const n = hs.copy(t).multiplyScalar(0.5);
		return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
	}
	setFromObject(e, t = !1) {
		return this.makeEmpty(), this.expandByObject(e, t);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return this.min.copy(e.min), this.max.copy(e.max), this;
	}
	makeEmpty() {
		return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
	}
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	}
	getCenter(e) {
		return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(e) {
		return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
	}
	expandByPoint(e) {
		return this.min.min(e), this.max.max(e), this;
	}
	expandByVector(e) {
		return this.min.sub(e), this.max.add(e), this;
	}
	expandByScalar(e) {
		return this.min.addScalar(-e), this.max.addScalar(e), this;
	}
	expandByObject(e, t = !1) {
		e.updateWorldMatrix(!1, !1);
		const n = e.geometry;
		if (n !== void 0) {
			const r = n.getAttribute('position');
			if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
				for (let o = 0, a = r.count; o < a; o++)
					e.isMesh === !0 ? e.getVertexPosition(o, hs) : hs.fromBufferAttribute(r, o),
						hs.applyMatrix4(e.matrixWorld),
						this.expandByPoint(hs);
			else
				e.boundingBox !== void 0
					? (e.boundingBox === null && e.computeBoundingBox(), Pu.copy(e.boundingBox))
					: (n.boundingBox === null && n.computeBoundingBox(), Pu.copy(n.boundingBox)),
					Pu.applyMatrix4(e.matrixWorld),
					this.union(Pu);
		}
		const s = e.children;
		for (let r = 0, o = s.length; r < o; r++) this.expandByObject(s[r], t);
		return this;
	}
	containsPoint(e) {
		return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
	}
	containsBox(e) {
		return (
			this.min.x <= e.min.x &&
			e.max.x <= this.max.x &&
			this.min.y <= e.min.y &&
			e.max.y <= this.max.y &&
			this.min.z <= e.min.z &&
			e.max.z <= this.max.z
		);
	}
	getParameter(e, t) {
		return t.set(
			(e.x - this.min.x) / (this.max.x - this.min.x),
			(e.y - this.min.y) / (this.max.y - this.min.y),
			(e.z - this.min.z) / (this.max.z - this.min.z)
		);
	}
	intersectsBox(e) {
		return !(
			e.max.x < this.min.x ||
			e.min.x > this.max.x ||
			e.max.y < this.min.y ||
			e.min.y > this.max.y ||
			e.max.z < this.min.z ||
			e.min.z > this.max.z
		);
	}
	intersectsSphere(e) {
		return this.clampPoint(e.center, hs), hs.distanceToSquared(e.center) <= e.radius * e.radius;
	}
	intersectsPlane(e) {
		let t, n;
		return (
			e.normal.x > 0
				? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
				: ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
			e.normal.y > 0
				? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
				: ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
			e.normal.z > 0
				? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
				: ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
			t <= -e.constant && n >= -e.constant
		);
	}
	intersectsTriangle(e) {
		if (this.isEmpty()) return !1;
		this.getCenter(yc),
			Lu.subVectors(this.max, yc),
			$a.subVectors(e.a, yc),
			Za.subVectors(e.b, yc),
			Ja.subVectors(e.c, yc),
			Lr.subVectors(Za, $a),
			Ir.subVectors(Ja, Za),
			No.subVectors($a, Ja);
		let t = [
			0,
			-Lr.z,
			Lr.y,
			0,
			-Ir.z,
			Ir.y,
			0,
			-No.z,
			No.y,
			Lr.z,
			0,
			-Lr.x,
			Ir.z,
			0,
			-Ir.x,
			No.z,
			0,
			-No.x,
			-Lr.y,
			Lr.x,
			0,
			-Ir.y,
			Ir.x,
			0,
			-No.y,
			No.x,
			0,
		];
		return !Gf(t, $a, Za, Ja, Lu) || ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Gf(t, $a, Za, Ja, Lu))
			? !1
			: (Iu.crossVectors(Lr, Ir), (t = [Iu.x, Iu.y, Iu.z]), Gf(t, $a, Za, Ja, Lu));
	}
	clampPoint(e, t) {
		return t.copy(e).clamp(this.min, this.max);
	}
	distanceToPoint(e) {
		return this.clampPoint(e, hs).distanceTo(e);
	}
	getBoundingSphere(e) {
		return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), (e.radius = this.getSize(hs).length() * 0.5)), e;
	}
	intersect(e) {
		return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
	}
	union(e) {
		return this.min.min(e.min), this.max.max(e.max), this;
	}
	applyMatrix4(e) {
		return this.isEmpty()
			? this
			: (er[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
			  er[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
			  er[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
			  er[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
			  er[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
			  er[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
			  er[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
			  er[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
			  this.setFromPoints(er),
			  this);
	}
	translate(e) {
		return this.min.add(e), this.max.add(e), this;
	}
	equals(e) {
		return e.min.equals(this.min) && e.max.equals(this.max);
	}
}
const er = [new I(), new I(), new I(), new I(), new I(), new I(), new I(), new I()],
	hs = new I(),
	Pu = new An(),
	$a = new I(),
	Za = new I(),
	Ja = new I(),
	Lr = new I(),
	Ir = new I(),
	No = new I(),
	yc = new I(),
	Lu = new I(),
	Iu = new I(),
	Fo = new I();
function Gf(i, e, t, n, s) {
	for (let r = 0, o = i.length - 3; r <= o; r += 3) {
		Fo.fromArray(i, r);
		const a = s.x * Math.abs(Fo.x) + s.y * Math.abs(Fo.y) + s.z * Math.abs(Fo.z),
			l = e.dot(Fo),
			c = t.dot(Fo),
			h = n.dot(Fo);
		if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
	}
	return !0;
}
const hI = new An(),
	xc = new I(),
	Wf = new I();
class un {
	constructor(e = new I(), t = -1) {
		(this.isSphere = !0), (this.center = e), (this.radius = t);
	}
	set(e, t) {
		return this.center.copy(e), (this.radius = t), this;
	}
	setFromPoints(e, t) {
		const n = this.center;
		t !== void 0 ? n.copy(t) : hI.setFromPoints(e).getCenter(n);
		let s = 0;
		for (let r = 0, o = e.length; r < o; r++) s = Math.max(s, n.distanceToSquared(e[r]));
		return (this.radius = Math.sqrt(s)), this;
	}
	copy(e) {
		return this.center.copy(e.center), (this.radius = e.radius), this;
	}
	isEmpty() {
		return this.radius < 0;
	}
	makeEmpty() {
		return this.center.set(0, 0, 0), (this.radius = -1), this;
	}
	containsPoint(e) {
		return e.distanceToSquared(this.center) <= this.radius * this.radius;
	}
	distanceToPoint(e) {
		return e.distanceTo(this.center) - this.radius;
	}
	intersectsSphere(e) {
		const t = this.radius + e.radius;
		return e.center.distanceToSquared(this.center) <= t * t;
	}
	intersectsBox(e) {
		return e.intersectsSphere(this);
	}
	intersectsPlane(e) {
		return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
	}
	clampPoint(e, t) {
		const n = this.center.distanceToSquared(e);
		return (
			t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
		);
	}
	getBoundingBox(e) {
		return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
	}
	applyMatrix4(e) {
		return this.center.applyMatrix4(e), (this.radius = this.radius * e.getMaxScaleOnAxis()), this;
	}
	translate(e) {
		return this.center.add(e), this;
	}
	expandByPoint(e) {
		if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
		xc.subVectors(e, this.center);
		const t = xc.lengthSq();
		if (t > this.radius * this.radius) {
			const n = Math.sqrt(t),
				s = (n - this.radius) * 0.5;
			this.center.addScaledVector(xc, s / n), (this.radius += s);
		}
		return this;
	}
	union(e) {
		return e.isEmpty()
			? this
			: this.isEmpty()
			? (this.copy(e), this)
			: (this.center.equals(e.center) === !0
					? (this.radius = Math.max(this.radius, e.radius))
					: (Wf.subVectors(e.center, this.center).setLength(e.radius),
					  this.expandByPoint(xc.copy(e.center).add(Wf)),
					  this.expandByPoint(xc.copy(e.center).sub(Wf))),
			  this);
	}
	equals(e) {
		return e.center.equals(this.center) && e.radius === this.radius;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const tr = new I(),
	Xf = new I(),
	Du = new I(),
	Dr = new I(),
	qf = new I(),
	Ou = new I(),
	Yf = new I();
class ka {
	constructor(e = new I(), t = new I(0, 0, -1)) {
		(this.origin = e), (this.direction = t);
	}
	set(e, t) {
		return this.origin.copy(e), this.direction.copy(t), this;
	}
	copy(e) {
		return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
	}
	at(e, t) {
		return t.copy(this.origin).addScaledVector(this.direction, e);
	}
	lookAt(e) {
		return this.direction.copy(e).sub(this.origin).normalize(), this;
	}
	recast(e) {
		return this.origin.copy(this.at(e, tr)), this;
	}
	closestPointToPoint(e, t) {
		t.subVectors(e, this.origin);
		const n = t.dot(this.direction);
		return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
	}
	distanceToPoint(e) {
		return Math.sqrt(this.distanceSqToPoint(e));
	}
	distanceSqToPoint(e) {
		const t = tr.subVectors(e, this.origin).dot(this.direction);
		return t < 0
			? this.origin.distanceToSquared(e)
			: (tr.copy(this.origin).addScaledVector(this.direction, t), tr.distanceToSquared(e));
	}
	distanceSqToSegment(e, t, n, s) {
		Xf.copy(e).add(t).multiplyScalar(0.5), Du.copy(t).sub(e).normalize(), Dr.copy(this.origin).sub(Xf);
		const r = e.distanceTo(t) * 0.5,
			o = -this.direction.dot(Du),
			a = Dr.dot(this.direction),
			l = -Dr.dot(Du),
			c = Dr.lengthSq(),
			h = Math.abs(1 - o * o);
		let u, d, p, g;
		if (h > 0)
			if (((u = o * l - a), (d = o * a - l), (g = r * h), u >= 0))
				if (d >= -g)
					if (d <= g) {
						const v = 1 / h;
						(u *= v), (d *= v), (p = u * (u + o * d + 2 * a) + d * (o * u + d + 2 * l) + c);
					} else (d = r), (u = Math.max(0, -(o * d + a))), (p = -u * u + d * (d + 2 * l) + c);
				else (d = -r), (u = Math.max(0, -(o * d + a))), (p = -u * u + d * (d + 2 * l) + c);
			else
				d <= -g
					? ((u = Math.max(0, -(-o * r + a))),
					  (d = u > 0 ? -r : Math.min(Math.max(-r, -l), r)),
					  (p = -u * u + d * (d + 2 * l) + c))
					: d <= g
					? ((u = 0), (d = Math.min(Math.max(-r, -l), r)), (p = d * (d + 2 * l) + c))
					: ((u = Math.max(0, -(o * r + a))),
					  (d = u > 0 ? r : Math.min(Math.max(-r, -l), r)),
					  (p = -u * u + d * (d + 2 * l) + c));
		else (d = o > 0 ? -r : r), (u = Math.max(0, -(o * d + a))), (p = -u * u + d * (d + 2 * l) + c);
		return n && n.copy(this.origin).addScaledVector(this.direction, u), s && s.copy(Xf).addScaledVector(Du, d), p;
	}
	intersectSphere(e, t) {
		tr.subVectors(e.center, this.origin);
		const n = tr.dot(this.direction),
			s = tr.dot(tr) - n * n,
			r = e.radius * e.radius;
		if (s > r) return null;
		const o = Math.sqrt(r - s),
			a = n - o,
			l = n + o;
		return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
	}
	intersectsSphere(e) {
		return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
	}
	distanceToPlane(e) {
		const t = e.normal.dot(this.direction);
		if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
		const n = -(this.origin.dot(e.normal) + e.constant) / t;
		return n >= 0 ? n : null;
	}
	intersectPlane(e, t) {
		const n = this.distanceToPlane(e);
		return n === null ? null : this.at(n, t);
	}
	intersectsPlane(e) {
		const t = e.distanceToPoint(this.origin);
		return t === 0 || e.normal.dot(this.direction) * t < 0;
	}
	intersectBox(e, t) {
		let n, s, r, o, a, l;
		const c = 1 / this.direction.x,
			h = 1 / this.direction.y,
			u = 1 / this.direction.z,
			d = this.origin;
		return (
			c >= 0 ? ((n = (e.min.x - d.x) * c), (s = (e.max.x - d.x) * c)) : ((n = (e.max.x - d.x) * c), (s = (e.min.x - d.x) * c)),
			h >= 0 ? ((r = (e.min.y - d.y) * h), (o = (e.max.y - d.y) * h)) : ((r = (e.max.y - d.y) * h), (o = (e.min.y - d.y) * h)),
			n > o ||
			r > s ||
			((r > n || isNaN(n)) && (n = r),
			(o < s || isNaN(s)) && (s = o),
			u >= 0 ? ((a = (e.min.z - d.z) * u), (l = (e.max.z - d.z) * u)) : ((a = (e.max.z - d.z) * u), (l = (e.min.z - d.z) * u)),
			n > l || a > s) ||
			((a > n || n !== n) && (n = a), (l < s || s !== s) && (s = l), s < 0)
				? null
				: this.at(n >= 0 ? n : s, t)
		);
	}
	intersectsBox(e) {
		return this.intersectBox(e, tr) !== null;
	}
	intersectTriangle(e, t, n, s, r) {
		qf.subVectors(t, e), Ou.subVectors(n, e), Yf.crossVectors(qf, Ou);
		let o = this.direction.dot(Yf),
			a;
		if (o > 0) {
			if (s) return null;
			a = 1;
		} else if (o < 0) (a = -1), (o = -o);
		else return null;
		Dr.subVectors(this.origin, e);
		const l = a * this.direction.dot(Ou.crossVectors(Dr, Ou));
		if (l < 0) return null;
		const c = a * this.direction.dot(qf.cross(Dr));
		if (c < 0 || l + c > o) return null;
		const h = -a * Dr.dot(Yf);
		return h < 0 ? null : this.at(h / o, r);
	}
	applyMatrix4(e) {
		return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
	}
	equals(e) {
		return e.origin.equals(this.origin) && e.direction.equals(this.direction);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
class He {
	constructor(e, t, n, s, r, o, a, l, c, h, u, d, p, g, v, m) {
		(He.prototype.isMatrix4 = !0),
			(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
			e !== void 0 && this.set(e, t, n, s, r, o, a, l, c, h, u, d, p, g, v, m);
	}
	set(e, t, n, s, r, o, a, l, c, h, u, d, p, g, v, m) {
		const f = this.elements;
		return (
			(f[0] = e),
			(f[4] = t),
			(f[8] = n),
			(f[12] = s),
			(f[1] = r),
			(f[5] = o),
			(f[9] = a),
			(f[13] = l),
			(f[2] = c),
			(f[6] = h),
			(f[10] = u),
			(f[14] = d),
			(f[3] = p),
			(f[7] = g),
			(f[11] = v),
			(f[15] = m),
			this
		);
	}
	identity() {
		return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
	}
	clone() {
		return new He().fromArray(this.elements);
	}
	copy(e) {
		const t = this.elements,
			n = e.elements;
		return (
			(t[0] = n[0]),
			(t[1] = n[1]),
			(t[2] = n[2]),
			(t[3] = n[3]),
			(t[4] = n[4]),
			(t[5] = n[5]),
			(t[6] = n[6]),
			(t[7] = n[7]),
			(t[8] = n[8]),
			(t[9] = n[9]),
			(t[10] = n[10]),
			(t[11] = n[11]),
			(t[12] = n[12]),
			(t[13] = n[13]),
			(t[14] = n[14]),
			(t[15] = n[15]),
			this
		);
	}
	copyPosition(e) {
		const t = this.elements,
			n = e.elements;
		return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
	}
	setFromMatrix3(e) {
		const t = e.elements;
		return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
	}
	extractBasis(e, t, n) {
		return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
	}
	makeBasis(e, t, n) {
		return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this;
	}
	extractRotation(e) {
		const t = this.elements,
			n = e.elements,
			s = 1 / Qa.setFromMatrixColumn(e, 0).length(),
			r = 1 / Qa.setFromMatrixColumn(e, 1).length(),
			o = 1 / Qa.setFromMatrixColumn(e, 2).length();
		return (
			(t[0] = n[0] * s),
			(t[1] = n[1] * s),
			(t[2] = n[2] * s),
			(t[3] = 0),
			(t[4] = n[4] * r),
			(t[5] = n[5] * r),
			(t[6] = n[6] * r),
			(t[7] = 0),
			(t[8] = n[8] * o),
			(t[9] = n[9] * o),
			(t[10] = n[10] * o),
			(t[11] = 0),
			(t[12] = 0),
			(t[13] = 0),
			(t[14] = 0),
			(t[15] = 1),
			this
		);
	}
	makeRotationFromEuler(e) {
		const t = this.elements,
			n = e.x,
			s = e.y,
			r = e.z,
			o = Math.cos(n),
			a = Math.sin(n),
			l = Math.cos(s),
			c = Math.sin(s),
			h = Math.cos(r),
			u = Math.sin(r);
		if (e.order === 'XYZ') {
			const d = o * h,
				p = o * u,
				g = a * h,
				v = a * u;
			(t[0] = l * h),
				(t[4] = -l * u),
				(t[8] = c),
				(t[1] = p + g * c),
				(t[5] = d - v * c),
				(t[9] = -a * l),
				(t[2] = v - d * c),
				(t[6] = g + p * c),
				(t[10] = o * l);
		} else if (e.order === 'YXZ') {
			const d = l * h,
				p = l * u,
				g = c * h,
				v = c * u;
			(t[0] = d + v * a),
				(t[4] = g * a - p),
				(t[8] = o * c),
				(t[1] = o * u),
				(t[5] = o * h),
				(t[9] = -a),
				(t[2] = p * a - g),
				(t[6] = v + d * a),
				(t[10] = o * l);
		} else if (e.order === 'ZXY') {
			const d = l * h,
				p = l * u,
				g = c * h,
				v = c * u;
			(t[0] = d - v * a),
				(t[4] = -o * u),
				(t[8] = g + p * a),
				(t[1] = p + g * a),
				(t[5] = o * h),
				(t[9] = v - d * a),
				(t[2] = -o * c),
				(t[6] = a),
				(t[10] = o * l);
		} else if (e.order === 'ZYX') {
			const d = o * h,
				p = o * u,
				g = a * h,
				v = a * u;
			(t[0] = l * h),
				(t[4] = g * c - p),
				(t[8] = d * c + v),
				(t[1] = l * u),
				(t[5] = v * c + d),
				(t[9] = p * c - g),
				(t[2] = -c),
				(t[6] = a * l),
				(t[10] = o * l);
		} else if (e.order === 'YZX') {
			const d = o * l,
				p = o * c,
				g = a * l,
				v = a * c;
			(t[0] = l * h),
				(t[4] = v - d * u),
				(t[8] = g * u + p),
				(t[1] = u),
				(t[5] = o * h),
				(t[9] = -a * h),
				(t[2] = -c * h),
				(t[6] = p * u + g),
				(t[10] = d - v * u);
		} else if (e.order === 'XZY') {
			const d = o * l,
				p = o * c,
				g = a * l,
				v = a * c;
			(t[0] = l * h),
				(t[4] = -u),
				(t[8] = c * h),
				(t[1] = d * u + v),
				(t[5] = o * h),
				(t[9] = p * u - g),
				(t[2] = g * u - p),
				(t[6] = a * h),
				(t[10] = v * u + d);
		}
		return (t[3] = 0), (t[7] = 0), (t[11] = 0), (t[12] = 0), (t[13] = 0), (t[14] = 0), (t[15] = 1), this;
	}
	makeRotationFromQuaternion(e) {
		return this.compose(uI, e, dI);
	}
	lookAt(e, t, n) {
		const s = this.elements;
		return (
			Ci.subVectors(e, t),
			Ci.lengthSq() === 0 && (Ci.z = 1),
			Ci.normalize(),
			Or.crossVectors(n, Ci),
			Or.lengthSq() === 0 && (Math.abs(n.z) === 1 ? (Ci.x += 1e-4) : (Ci.z += 1e-4), Ci.normalize(), Or.crossVectors(n, Ci)),
			Or.normalize(),
			Uu.crossVectors(Ci, Or),
			(s[0] = Or.x),
			(s[4] = Uu.x),
			(s[8] = Ci.x),
			(s[1] = Or.y),
			(s[5] = Uu.y),
			(s[9] = Ci.y),
			(s[2] = Or.z),
			(s[6] = Uu.z),
			(s[10] = Ci.z),
			this
		);
	}
	multiply(e) {
		return this.multiplyMatrices(this, e);
	}
	premultiply(e) {
		return this.multiplyMatrices(e, this);
	}
	multiplyMatrices(e, t) {
		const n = e.elements,
			s = t.elements,
			r = this.elements,
			o = n[0],
			a = n[4],
			l = n[8],
			c = n[12],
			h = n[1],
			u = n[5],
			d = n[9],
			p = n[13],
			g = n[2],
			v = n[6],
			m = n[10],
			f = n[14],
			y = n[3],
			_ = n[7],
			x = n[11],
			E = n[15],
			w = s[0],
			C = s[4],
			P = s[8],
			S = s[12],
			M = s[1],
			k = s[5],
			q = s[9],
			B = s[13],
			W = s[2],
			Q = s[6],
			$ = s[10],
			le = s[14],
			Z = s[3],
			xe = s[7],
			ue = s[11],
			Te = s[15];
		return (
			(r[0] = o * w + a * M + l * W + c * Z),
			(r[4] = o * C + a * k + l * Q + c * xe),
			(r[8] = o * P + a * q + l * $ + c * ue),
			(r[12] = o * S + a * B + l * le + c * Te),
			(r[1] = h * w + u * M + d * W + p * Z),
			(r[5] = h * C + u * k + d * Q + p * xe),
			(r[9] = h * P + u * q + d * $ + p * ue),
			(r[13] = h * S + u * B + d * le + p * Te),
			(r[2] = g * w + v * M + m * W + f * Z),
			(r[6] = g * C + v * k + m * Q + f * xe),
			(r[10] = g * P + v * q + m * $ + f * ue),
			(r[14] = g * S + v * B + m * le + f * Te),
			(r[3] = y * w + _ * M + x * W + E * Z),
			(r[7] = y * C + _ * k + x * Q + E * xe),
			(r[11] = y * P + _ * q + x * $ + E * ue),
			(r[15] = y * S + _ * B + x * le + E * Te),
			this
		);
	}
	multiplyScalar(e) {
		const t = this.elements;
		return (
			(t[0] *= e),
			(t[4] *= e),
			(t[8] *= e),
			(t[12] *= e),
			(t[1] *= e),
			(t[5] *= e),
			(t[9] *= e),
			(t[13] *= e),
			(t[2] *= e),
			(t[6] *= e),
			(t[10] *= e),
			(t[14] *= e),
			(t[3] *= e),
			(t[7] *= e),
			(t[11] *= e),
			(t[15] *= e),
			this
		);
	}
	determinant() {
		const e = this.elements,
			t = e[0],
			n = e[4],
			s = e[8],
			r = e[12],
			o = e[1],
			a = e[5],
			l = e[9],
			c = e[13],
			h = e[2],
			u = e[6],
			d = e[10],
			p = e[14],
			g = e[3],
			v = e[7],
			m = e[11],
			f = e[15];
		return (
			g * (+r * l * u - s * c * u - r * a * d + n * c * d + s * a * p - n * l * p) +
			v * (+t * l * p - t * c * d + r * o * d - s * o * p + s * c * h - r * l * h) +
			m * (+t * c * u - t * a * p - r * o * u + n * o * p + r * a * h - n * c * h) +
			f * (-s * a * h - t * l * u + t * a * d + s * o * u - n * o * d + n * l * h)
		);
	}
	transpose() {
		const e = this.elements;
		let t;
		return (
			(t = e[1]),
			(e[1] = e[4]),
			(e[4] = t),
			(t = e[2]),
			(e[2] = e[8]),
			(e[8] = t),
			(t = e[6]),
			(e[6] = e[9]),
			(e[9] = t),
			(t = e[3]),
			(e[3] = e[12]),
			(e[12] = t),
			(t = e[7]),
			(e[7] = e[13]),
			(e[13] = t),
			(t = e[11]),
			(e[11] = e[14]),
			(e[14] = t),
			this
		);
	}
	setPosition(e, t, n) {
		const s = this.elements;
		return e.isVector3 ? ((s[12] = e.x), (s[13] = e.y), (s[14] = e.z)) : ((s[12] = e), (s[13] = t), (s[14] = n)), this;
	}
	invert() {
		const e = this.elements,
			t = e[0],
			n = e[1],
			s = e[2],
			r = e[3],
			o = e[4],
			a = e[5],
			l = e[6],
			c = e[7],
			h = e[8],
			u = e[9],
			d = e[10],
			p = e[11],
			g = e[12],
			v = e[13],
			m = e[14],
			f = e[15],
			y = u * m * c - v * d * c + v * l * p - a * m * p - u * l * f + a * d * f,
			_ = g * d * c - h * m * c - g * l * p + o * m * p + h * l * f - o * d * f,
			x = h * v * c - g * u * c + g * a * p - o * v * p - h * a * f + o * u * f,
			E = g * u * l - h * v * l - g * a * d + o * v * d + h * a * m - o * u * m,
			w = t * y + n * _ + s * x + r * E;
		if (w === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		const C = 1 / w;
		return (
			(e[0] = y * C),
			(e[1] = (v * d * r - u * m * r - v * s * p + n * m * p + u * s * f - n * d * f) * C),
			(e[2] = (a * m * r - v * l * r + v * s * c - n * m * c - a * s * f + n * l * f) * C),
			(e[3] = (u * l * r - a * d * r - u * s * c + n * d * c + a * s * p - n * l * p) * C),
			(e[4] = _ * C),
			(e[5] = (h * m * r - g * d * r + g * s * p - t * m * p - h * s * f + t * d * f) * C),
			(e[6] = (g * l * r - o * m * r - g * s * c + t * m * c + o * s * f - t * l * f) * C),
			(e[7] = (o * d * r - h * l * r + h * s * c - t * d * c - o * s * p + t * l * p) * C),
			(e[8] = x * C),
			(e[9] = (g * u * r - h * v * r - g * n * p + t * v * p + h * n * f - t * u * f) * C),
			(e[10] = (o * v * r - g * a * r + g * n * c - t * v * c - o * n * f + t * a * f) * C),
			(e[11] = (h * a * r - o * u * r - h * n * c + t * u * c + o * n * p - t * a * p) * C),
			(e[12] = E * C),
			(e[13] = (h * v * s - g * u * s + g * n * d - t * v * d - h * n * m + t * u * m) * C),
			(e[14] = (g * a * s - o * v * s - g * n * l + t * v * l + o * n * m - t * a * m) * C),
			(e[15] = (o * u * s - h * a * s + h * n * l - t * u * l - o * n * d + t * a * d) * C),
			this
		);
	}
	scale(e) {
		const t = this.elements,
			n = e.x,
			s = e.y,
			r = e.z;
		return (
			(t[0] *= n),
			(t[4] *= s),
			(t[8] *= r),
			(t[1] *= n),
			(t[5] *= s),
			(t[9] *= r),
			(t[2] *= n),
			(t[6] *= s),
			(t[10] *= r),
			(t[3] *= n),
			(t[7] *= s),
			(t[11] *= r),
			this
		);
	}
	getMaxScaleOnAxis() {
		const e = this.elements,
			t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
			n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
			s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
		return Math.sqrt(Math.max(t, n, s));
	}
	makeTranslation(e, t, n) {
		return (
			e.isVector3
				? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
				: this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
			this
		);
	}
	makeRotationX(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
	}
	makeRotationY(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
	}
	makeRotationZ(e) {
		const t = Math.cos(e),
			n = Math.sin(e);
		return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
	}
	makeRotationAxis(e, t) {
		const n = Math.cos(t),
			s = Math.sin(t),
			r = 1 - n,
			o = e.x,
			a = e.y,
			l = e.z,
			c = r * o,
			h = r * a;
		return (
			this.set(
				c * o + n,
				c * a - s * l,
				c * l + s * a,
				0,
				c * a + s * l,
				h * a + n,
				h * l - s * o,
				0,
				c * l - s * a,
				h * l + s * o,
				r * l * l + n,
				0,
				0,
				0,
				0,
				1
			),
			this
		);
	}
	makeScale(e, t, n) {
		return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
	}
	makeShear(e, t, n, s, r, o) {
		return this.set(1, n, r, 0, e, 1, o, 0, t, s, 1, 0, 0, 0, 0, 1), this;
	}
	compose(e, t, n) {
		const s = this.elements,
			r = t._x,
			o = t._y,
			a = t._z,
			l = t._w,
			c = r + r,
			h = o + o,
			u = a + a,
			d = r * c,
			p = r * h,
			g = r * u,
			v = o * h,
			m = o * u,
			f = a * u,
			y = l * c,
			_ = l * h,
			x = l * u,
			E = n.x,
			w = n.y,
			C = n.z;
		return (
			(s[0] = (1 - (v + f)) * E),
			(s[1] = (p + x) * E),
			(s[2] = (g - _) * E),
			(s[3] = 0),
			(s[4] = (p - x) * w),
			(s[5] = (1 - (d + f)) * w),
			(s[6] = (m + y) * w),
			(s[7] = 0),
			(s[8] = (g + _) * C),
			(s[9] = (m - y) * C),
			(s[10] = (1 - (d + v)) * C),
			(s[11] = 0),
			(s[12] = e.x),
			(s[13] = e.y),
			(s[14] = e.z),
			(s[15] = 1),
			this
		);
	}
	decompose(e, t, n) {
		const s = this.elements;
		let r = Qa.set(s[0], s[1], s[2]).length();
		const o = Qa.set(s[4], s[5], s[6]).length(),
			a = Qa.set(s[8], s[9], s[10]).length();
		this.determinant() < 0 && (r = -r), (e.x = s[12]), (e.y = s[13]), (e.z = s[14]), us.copy(this);
		const c = 1 / r,
			h = 1 / o,
			u = 1 / a;
		return (
			(us.elements[0] *= c),
			(us.elements[1] *= c),
			(us.elements[2] *= c),
			(us.elements[4] *= h),
			(us.elements[5] *= h),
			(us.elements[6] *= h),
			(us.elements[8] *= u),
			(us.elements[9] *= u),
			(us.elements[10] *= u),
			t.setFromRotationMatrix(us),
			(n.x = r),
			(n.y = o),
			(n.z = a),
			this
		);
	}
	makePerspective(e, t, n, s, r, o, a = Vs) {
		const l = this.elements,
			c = (2 * r) / (t - e),
			h = (2 * r) / (n - s),
			u = (t + e) / (t - e),
			d = (n + s) / (n - s);
		let p, g;
		if (a === Vs) (p = -(o + r) / (o - r)), (g = (-2 * o * r) / (o - r));
		else if (a === Eh) (p = -o / (o - r)), (g = (-o * r) / (o - r));
		else throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + a);
		return (
			(l[0] = c),
			(l[4] = 0),
			(l[8] = u),
			(l[12] = 0),
			(l[1] = 0),
			(l[5] = h),
			(l[9] = d),
			(l[13] = 0),
			(l[2] = 0),
			(l[6] = 0),
			(l[10] = p),
			(l[14] = g),
			(l[3] = 0),
			(l[7] = 0),
			(l[11] = -1),
			(l[15] = 0),
			this
		);
	}
	makeOrthographic(e, t, n, s, r, o, a = Vs) {
		const l = this.elements,
			c = 1 / (t - e),
			h = 1 / (n - s),
			u = 1 / (o - r),
			d = (t + e) * c,
			p = (n + s) * h;
		let g, v;
		if (a === Vs) (g = (o + r) * u), (v = -2 * u);
		else if (a === Eh) (g = r * u), (v = -1 * u);
		else throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + a);
		return (
			(l[0] = 2 * c),
			(l[4] = 0),
			(l[8] = 0),
			(l[12] = -d),
			(l[1] = 0),
			(l[5] = 2 * h),
			(l[9] = 0),
			(l[13] = -p),
			(l[2] = 0),
			(l[6] = 0),
			(l[10] = v),
			(l[14] = -g),
			(l[3] = 0),
			(l[7] = 0),
			(l[11] = 0),
			(l[15] = 1),
			this
		);
	}
	equals(e) {
		const t = this.elements,
			n = e.elements;
		for (let s = 0; s < 16; s++) if (t[s] !== n[s]) return !1;
		return !0;
	}
	fromArray(e, t = 0) {
		for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
		return this;
	}
	toArray(e = [], t = 0) {
		const n = this.elements;
		return (
			(e[t] = n[0]),
			(e[t + 1] = n[1]),
			(e[t + 2] = n[2]),
			(e[t + 3] = n[3]),
			(e[t + 4] = n[4]),
			(e[t + 5] = n[5]),
			(e[t + 6] = n[6]),
			(e[t + 7] = n[7]),
			(e[t + 8] = n[8]),
			(e[t + 9] = n[9]),
			(e[t + 10] = n[10]),
			(e[t + 11] = n[11]),
			(e[t + 12] = n[12]),
			(e[t + 13] = n[13]),
			(e[t + 14] = n[14]),
			(e[t + 15] = n[15]),
			e
		);
	}
}
const Qa = new I(),
	us = new He(),
	uI = new I(0, 0, 0),
	dI = new I(1, 1, 1),
	Or = new I(),
	Uu = new I(),
	Ci = new I(),
	$y = new He(),
	Zy = new kn();
class zi {
	constructor(e = 0, t = 0, n = 0, s = zi.DEFAULT_ORDER) {
		(this.isEuler = !0), (this._x = e), (this._y = t), (this._z = n), (this._order = s);
	}
	get x() {
		return this._x;
	}
	set x(e) {
		(this._x = e), this._onChangeCallback();
	}
	get y() {
		return this._y;
	}
	set y(e) {
		(this._y = e), this._onChangeCallback();
	}
	get z() {
		return this._z;
	}
	set z(e) {
		(this._z = e), this._onChangeCallback();
	}
	get order() {
		return this._order;
	}
	set order(e) {
		(this._order = e), this._onChangeCallback();
	}
	set(e, t, n, s = this._order) {
		return (this._x = e), (this._y = t), (this._z = n), (this._order = s), this._onChangeCallback(), this;
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order);
	}
	copy(e) {
		return (this._x = e._x), (this._y = e._y), (this._z = e._z), (this._order = e._order), this._onChangeCallback(), this;
	}
	setFromRotationMatrix(e, t = this._order, n = !0) {
		const s = e.elements,
			r = s[0],
			o = s[4],
			a = s[8],
			l = s[1],
			c = s[5],
			h = s[9],
			u = s[2],
			d = s[6],
			p = s[10];
		switch (t) {
			case 'XYZ':
				(this._y = Math.asin(ln(a, -1, 1))),
					Math.abs(a) < 0.9999999
						? ((this._x = Math.atan2(-h, p)), (this._z = Math.atan2(-o, r)))
						: ((this._x = Math.atan2(d, c)), (this._z = 0));
				break;
			case 'YXZ':
				(this._x = Math.asin(-ln(h, -1, 1))),
					Math.abs(h) < 0.9999999
						? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(l, c)))
						: ((this._y = Math.atan2(-u, r)), (this._z = 0));
				break;
			case 'ZXY':
				(this._x = Math.asin(ln(d, -1, 1))),
					Math.abs(d) < 0.9999999
						? ((this._y = Math.atan2(-u, p)), (this._z = Math.atan2(-o, c)))
						: ((this._y = 0), (this._z = Math.atan2(l, r)));
				break;
			case 'ZYX':
				(this._y = Math.asin(-ln(u, -1, 1))),
					Math.abs(u) < 0.9999999
						? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(l, r)))
						: ((this._x = 0), (this._z = Math.atan2(-o, c)));
				break;
			case 'YZX':
				(this._z = Math.asin(ln(l, -1, 1))),
					Math.abs(l) < 0.9999999
						? ((this._x = Math.atan2(-h, c)), (this._y = Math.atan2(-u, r)))
						: ((this._x = 0), (this._y = Math.atan2(a, p)));
				break;
			case 'XZY':
				(this._z = Math.asin(-ln(o, -1, 1))),
					Math.abs(o) < 0.9999999
						? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, r)))
						: ((this._x = Math.atan2(-h, p)), (this._y = 0));
				break;
			default:
				console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + t);
		}
		return (this._order = t), n === !0 && this._onChangeCallback(), this;
	}
	setFromQuaternion(e, t, n) {
		return $y.makeRotationFromQuaternion(e), this.setFromRotationMatrix($y, t, n);
	}
	setFromVector3(e, t = this._order) {
		return this.set(e.x, e.y, e.z, t);
	}
	reorder(e) {
		return Zy.setFromEuler(this), this.setFromQuaternion(Zy, e);
	}
	equals(e) {
		return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
	}
	fromArray(e) {
		return (
			(this._x = e[0]), (this._y = e[1]), (this._z = e[2]), e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
		);
	}
	toArray(e = [], t = 0) {
		return (e[t] = this._x), (e[t + 1] = this._y), (e[t + 2] = this._z), (e[t + 3] = this._order), e;
	}
	_onChange(e) {
		return (this._onChangeCallback = e), this;
	}
	_onChangeCallback() {}
	*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._order;
	}
}
zi.DEFAULT_ORDER = 'XYZ';
class Gp {
	constructor() {
		this.mask = 1;
	}
	set(e) {
		this.mask = ((1 << e) | 0) >>> 0;
	}
	enable(e) {
		this.mask |= (1 << e) | 0;
	}
	enableAll() {
		this.mask = -1;
	}
	toggle(e) {
		this.mask ^= (1 << e) | 0;
	}
	disable(e) {
		this.mask &= ~((1 << e) | 0);
	}
	disableAll() {
		this.mask = 0;
	}
	test(e) {
		return (this.mask & e.mask) !== 0;
	}
	isEnabled(e) {
		return (this.mask & ((1 << e) | 0)) !== 0;
	}
}
let pI = 0;
const Jy = new I(),
	el = new kn(),
	nr = new He(),
	Nu = new I(),
	bc = new I(),
	fI = new I(),
	mI = new kn(),
	Qy = new I(1, 0, 0),
	ex = new I(0, 1, 0),
	tx = new I(0, 0, 1),
	nx = { type: 'added' },
	gI = { type: 'removed' },
	tl = { type: 'childadded', child: null },
	jf = { type: 'childremoved', child: null };
class ft extends Hi {
	constructor() {
		super(),
			(this.isObject3D = !0),
			Object.defineProperty(this, 'id', { value: pI++ }),
			(this.uuid = Bi()),
			(this.name = ''),
			(this.type = 'Object3D'),
			(this.parent = null),
			(this.children = []),
			(this.up = ft.DEFAULT_UP.clone());
		const e = new I(),
			t = new zi(),
			n = new kn(),
			s = new I(1, 1, 1);
		function r() {
			n.setFromEuler(t, !1);
		}
		function o() {
			t.setFromQuaternion(n, void 0, !1);
		}
		t._onChange(r),
			n._onChange(o),
			Object.defineProperties(this, {
				position: { configurable: !0, enumerable: !0, value: e },
				rotation: { configurable: !0, enumerable: !0, value: t },
				quaternion: { configurable: !0, enumerable: !0, value: n },
				scale: { configurable: !0, enumerable: !0, value: s },
				modelViewMatrix: { value: new He() },
				normalMatrix: { value: new et() },
			}),
			(this.matrix = new He()),
			(this.matrixWorld = new He()),
			(this.matrixAutoUpdate = ft.DEFAULT_MATRIX_AUTO_UPDATE),
			(this.matrixWorldAutoUpdate = ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
			(this.matrixWorldNeedsUpdate = !1),
			(this.layers = new Gp()),
			(this.visible = !0),
			(this.castShadow = !1),
			(this.receiveShadow = !1),
			(this.frustumCulled = !0),
			(this.renderOrder = 0),
			(this.animations = []),
			(this.userData = {});
	}
	onBeforeShadow() {}
	onAfterShadow() {}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(e) {
		this.matrixAutoUpdate && this.updateMatrix(),
			this.matrix.premultiply(e),
			this.matrix.decompose(this.position, this.quaternion, this.scale);
	}
	applyQuaternion(e) {
		return this.quaternion.premultiply(e), this;
	}
	setRotationFromAxisAngle(e, t) {
		this.quaternion.setFromAxisAngle(e, t);
	}
	setRotationFromEuler(e) {
		this.quaternion.setFromEuler(e, !0);
	}
	setRotationFromMatrix(e) {
		this.quaternion.setFromRotationMatrix(e);
	}
	setRotationFromQuaternion(e) {
		this.quaternion.copy(e);
	}
	rotateOnAxis(e, t) {
		return el.setFromAxisAngle(e, t), this.quaternion.multiply(el), this;
	}
	rotateOnWorldAxis(e, t) {
		return el.setFromAxisAngle(e, t), this.quaternion.premultiply(el), this;
	}
	rotateX(e) {
		return this.rotateOnAxis(Qy, e);
	}
	rotateY(e) {
		return this.rotateOnAxis(ex, e);
	}
	rotateZ(e) {
		return this.rotateOnAxis(tx, e);
	}
	translateOnAxis(e, t) {
		return Jy.copy(e).applyQuaternion(this.quaternion), this.position.add(Jy.multiplyScalar(t)), this;
	}
	translateX(e) {
		return this.translateOnAxis(Qy, e);
	}
	translateY(e) {
		return this.translateOnAxis(ex, e);
	}
	translateZ(e) {
		return this.translateOnAxis(tx, e);
	}
	localToWorld(e) {
		return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
	}
	worldToLocal(e) {
		return this.updateWorldMatrix(!0, !1), e.applyMatrix4(nr.copy(this.matrixWorld).invert());
	}
	lookAt(e, t, n) {
		e.isVector3 ? Nu.copy(e) : Nu.set(e, t, n);
		const s = this.parent;
		this.updateWorldMatrix(!0, !1),
			bc.setFromMatrixPosition(this.matrixWorld),
			this.isCamera || this.isLight ? nr.lookAt(bc, Nu, this.up) : nr.lookAt(Nu, bc, this.up),
			this.quaternion.setFromRotationMatrix(nr),
			s && (nr.extractRotation(s.matrixWorld), el.setFromRotationMatrix(nr), this.quaternion.premultiply(el.invert()));
	}
	add(e) {
		if (arguments.length > 1) {
			for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
			return this;
		}
		return e === this
			? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this)
			: (e && e.isObject3D
					? (e.removeFromParent(),
					  (e.parent = this),
					  this.children.push(e),
					  e.dispatchEvent(nx),
					  (tl.child = e),
					  this.dispatchEvent(tl),
					  (tl.child = null))
					: console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', e),
			  this);
	}
	remove(e) {
		if (arguments.length > 1) {
			for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
			return this;
		}
		const t = this.children.indexOf(e);
		return (
			t !== -1 &&
				((e.parent = null),
				this.children.splice(t, 1),
				e.dispatchEvent(gI),
				(jf.child = e),
				this.dispatchEvent(jf),
				(jf.child = null)),
			this
		);
	}
	removeFromParent() {
		const e = this.parent;
		return e !== null && e.remove(this), this;
	}
	clear() {
		return this.remove(...this.children);
	}
	attach(e) {
		return (
			this.updateWorldMatrix(!0, !1),
			nr.copy(this.matrixWorld).invert(),
			e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), nr.multiply(e.parent.matrixWorld)),
			e.applyMatrix4(nr),
			e.removeFromParent(),
			(e.parent = this),
			this.children.push(e),
			e.updateWorldMatrix(!1, !0),
			e.dispatchEvent(nx),
			(tl.child = e),
			this.dispatchEvent(tl),
			(tl.child = null),
			this
		);
	}
	getObjectById(e) {
		return this.getObjectByProperty('id', e);
	}
	getObjectByName(e) {
		return this.getObjectByProperty('name', e);
	}
	getObjectByProperty(e, t) {
		if (this[e] === t) return this;
		for (let n = 0, s = this.children.length; n < s; n++) {
			const o = this.children[n].getObjectByProperty(e, t);
			if (o !== void 0) return o;
		}
	}
	getObjectsByProperty(e, t, n = []) {
		this[e] === t && n.push(this);
		const s = this.children;
		for (let r = 0, o = s.length; r < o; r++) s[r].getObjectsByProperty(e, t, n);
		return n;
	}
	getWorldPosition(e) {
		return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
	}
	getWorldQuaternion(e) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(bc, e, fI), e;
	}
	getWorldScale(e) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(bc, mI, e), e;
	}
	getWorldDirection(e) {
		this.updateWorldMatrix(!0, !1);
		const t = this.matrixWorld.elements;
		return e.set(t[8], t[9], t[10]).normalize();
	}
	raycast() {}
	traverse(e) {
		e(this);
		const t = this.children;
		for (let n = 0, s = t.length; n < s; n++) t[n].traverse(e);
	}
	traverseVisible(e) {
		if (this.visible === !1) return;
		e(this);
		const t = this.children;
		for (let n = 0, s = t.length; n < s; n++) t[n].traverseVisible(e);
	}
	traverseAncestors(e) {
		const t = this.parent;
		t !== null && (e(t), t.traverseAncestors(e));
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
	}
	updateMatrixWorld(e) {
		this.matrixAutoUpdate && this.updateMatrix(),
			(this.matrixWorldNeedsUpdate || e) &&
				(this.parent === null
					? this.matrixWorld.copy(this.matrix)
					: this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
				(this.matrixWorldNeedsUpdate = !1),
				(e = !0));
		const t = this.children;
		for (let n = 0, s = t.length; n < s; n++) {
			const r = t[n];
			(r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
		}
	}
	updateWorldMatrix(e, t) {
		const n = this.parent;
		if (
			(e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1),
			this.matrixAutoUpdate && this.updateMatrix(),
			this.parent === null
				? this.matrixWorld.copy(this.matrix)
				: this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
			t === !0)
		) {
			const s = this.children;
			for (let r = 0, o = s.length; r < o; r++) {
				const a = s[r];
				a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
			}
		}
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string',
			n = {};
		t &&
			((e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }),
			(n.metadata = { version: 4.6, type: 'Object', generator: 'Object3D.toJSON' }));
		const s = {};
		(s.uuid = this.uuid),
			(s.type = this.type),
			this.name !== '' && (s.name = this.name),
			this.castShadow === !0 && (s.castShadow = !0),
			this.receiveShadow === !0 && (s.receiveShadow = !0),
			this.visible === !1 && (s.visible = !1),
			this.frustumCulled === !1 && (s.frustumCulled = !1),
			this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
			Object.keys(this.userData).length > 0 && (s.userData = this.userData),
			(s.layers = this.layers.mask),
			(s.matrix = this.matrix.toArray()),
			(s.up = this.up.toArray()),
			this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
			this.isInstancedMesh &&
				((s.type = 'InstancedMesh'),
				(s.count = this.count),
				(s.instanceMatrix = this.instanceMatrix.toJSON()),
				this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())),
			this.isBatchedMesh &&
				((s.type = 'BatchedMesh'),
				(s.perObjectFrustumCulled = this.perObjectFrustumCulled),
				(s.sortObjects = this.sortObjects),
				(s.drawRanges = this._drawRanges),
				(s.reservedRanges = this._reservedRanges),
				(s.visibility = this._visibility),
				(s.active = this._active),
				(s.bounds = this._bounds.map((a) => ({
					boxInitialized: a.boxInitialized,
					boxMin: a.box.min.toArray(),
					boxMax: a.box.max.toArray(),
					sphereInitialized: a.sphereInitialized,
					sphereRadius: a.sphere.radius,
					sphereCenter: a.sphere.center.toArray(),
				}))),
				(s.maxGeometryCount = this._maxGeometryCount),
				(s.maxVertexCount = this._maxVertexCount),
				(s.maxIndexCount = this._maxIndexCount),
				(s.geometryInitialized = this._geometryInitialized),
				(s.geometryCount = this._geometryCount),
				(s.matricesTexture = this._matricesTexture.toJSON(e)),
				this.boundingSphere !== null &&
					(s.boundingSphere = { center: s.boundingSphere.center.toArray(), radius: s.boundingSphere.radius }),
				this.boundingBox !== null && (s.boundingBox = { min: s.boundingBox.min.toArray(), max: s.boundingBox.max.toArray() }));
		function r(a, l) {
			return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
		}
		if (this.isScene)
			this.background &&
				(this.background.isColor
					? (s.background = this.background.toJSON())
					: this.background.isTexture && (s.background = this.background.toJSON(e).uuid)),
				this.environment &&
					this.environment.isTexture &&
					this.environment.isRenderTargetTexture !== !0 &&
					(s.environment = this.environment.toJSON(e).uuid);
		else if (this.isMesh || this.isLine || this.isPoints) {
			s.geometry = r(e.geometries, this.geometry);
			const a = this.geometry.parameters;
			if (a !== void 0 && a.shapes !== void 0) {
				const l = a.shapes;
				if (Array.isArray(l))
					for (let c = 0, h = l.length; c < h; c++) {
						const u = l[c];
						r(e.shapes, u);
					}
				else r(e.shapes, l);
			}
		}
		if (
			(this.isSkinnedMesh &&
				((s.bindMode = this.bindMode),
				(s.bindMatrix = this.bindMatrix.toArray()),
				this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), (s.skeleton = this.skeleton.uuid))),
			this.material !== void 0)
		)
			if (Array.isArray(this.material)) {
				const a = [];
				for (let l = 0, c = this.material.length; l < c; l++) a.push(r(e.materials, this.material[l]));
				s.material = a;
			} else s.material = r(e.materials, this.material);
		if (this.children.length > 0) {
			s.children = [];
			for (let a = 0; a < this.children.length; a++) s.children.push(this.children[a].toJSON(e).object);
		}
		if (this.animations.length > 0) {
			s.animations = [];
			for (let a = 0; a < this.animations.length; a++) {
				const l = this.animations[a];
				s.animations.push(r(e.animations, l));
			}
		}
		if (t) {
			const a = o(e.geometries),
				l = o(e.materials),
				c = o(e.textures),
				h = o(e.images),
				u = o(e.shapes),
				d = o(e.skeletons),
				p = o(e.animations),
				g = o(e.nodes);
			a.length > 0 && (n.geometries = a),
				l.length > 0 && (n.materials = l),
				c.length > 0 && (n.textures = c),
				h.length > 0 && (n.images = h),
				u.length > 0 && (n.shapes = u),
				d.length > 0 && (n.skeletons = d),
				p.length > 0 && (n.animations = p),
				g.length > 0 && (n.nodes = g);
		}
		return (n.object = s), n;
		function o(a) {
			const l = [];
			for (const c in a) {
				const h = a[c];
				delete h.metadata, l.push(h);
			}
			return l;
		}
	}
	clone(e) {
		return new this.constructor().copy(this, e);
	}
	copy(e, t = !0) {
		if (
			((this.name = e.name),
			this.up.copy(e.up),
			this.position.copy(e.position),
			(this.rotation.order = e.rotation.order),
			this.quaternion.copy(e.quaternion),
			this.scale.copy(e.scale),
			this.matrix.copy(e.matrix),
			this.matrixWorld.copy(e.matrixWorld),
			(this.matrixAutoUpdate = e.matrixAutoUpdate),
			(this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
			(this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
			(this.layers.mask = e.layers.mask),
			(this.visible = e.visible),
			(this.castShadow = e.castShadow),
			(this.receiveShadow = e.receiveShadow),
			(this.frustumCulled = e.frustumCulled),
			(this.renderOrder = e.renderOrder),
			(this.animations = e.animations.slice()),
			(this.userData = JSON.parse(JSON.stringify(e.userData))),
			t === !0)
		)
			for (let n = 0; n < e.children.length; n++) {
				const s = e.children[n];
				this.add(s.clone());
			}
		return this;
	}
}
ft.DEFAULT_UP = new I(0, 1, 0);
ft.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ds = new I(),
	ir = new I(),
	Kf = new I(),
	sr = new I(),
	nl = new I(),
	il = new I(),
	ix = new I(),
	$f = new I(),
	Zf = new I(),
	Jf = new I();
class Li {
	constructor(e = new I(), t = new I(), n = new I()) {
		(this.a = e), (this.b = t), (this.c = n);
	}
	static getNormal(e, t, n, s) {
		s.subVectors(n, t), ds.subVectors(e, t), s.cross(ds);
		const r = s.lengthSq();
		return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0);
	}
	static getBarycoord(e, t, n, s, r) {
		ds.subVectors(s, t), ir.subVectors(n, t), Kf.subVectors(e, t);
		const o = ds.dot(ds),
			a = ds.dot(ir),
			l = ds.dot(Kf),
			c = ir.dot(ir),
			h = ir.dot(Kf),
			u = o * c - a * a;
		if (u === 0) return r.set(0, 0, 0), null;
		const d = 1 / u,
			p = (c * l - a * h) * d,
			g = (o * h - a * l) * d;
		return r.set(1 - p - g, g, p);
	}
	static containsPoint(e, t, n, s) {
		return this.getBarycoord(e, t, n, s, sr) === null ? !1 : sr.x >= 0 && sr.y >= 0 && sr.x + sr.y <= 1;
	}
	static getInterpolation(e, t, n, s, r, o, a, l) {
		return this.getBarycoord(e, t, n, s, sr) === null
			? ((l.x = 0), (l.y = 0), 'z' in l && (l.z = 0), 'w' in l && (l.w = 0), null)
			: (l.setScalar(0), l.addScaledVector(r, sr.x), l.addScaledVector(o, sr.y), l.addScaledVector(a, sr.z), l);
	}
	static isFrontFacing(e, t, n, s) {
		return ds.subVectors(n, t), ir.subVectors(e, t), ds.cross(ir).dot(s) < 0;
	}
	set(e, t, n) {
		return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
	}
	setFromPointsAndIndices(e, t, n, s) {
		return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[s]), this;
	}
	setFromAttributeAndIndices(e, t, n, s) {
		return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, s), this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
	}
	getArea() {
		return ds.subVectors(this.c, this.b), ir.subVectors(this.a, this.b), ds.cross(ir).length() * 0.5;
	}
	getMidpoint(e) {
		return e
			.addVectors(this.a, this.b)
			.add(this.c)
			.multiplyScalar(1 / 3);
	}
	getNormal(e) {
		return Li.getNormal(this.a, this.b, this.c, e);
	}
	getPlane(e) {
		return e.setFromCoplanarPoints(this.a, this.b, this.c);
	}
	getBarycoord(e, t) {
		return Li.getBarycoord(e, this.a, this.b, this.c, t);
	}
	getInterpolation(e, t, n, s, r) {
		return Li.getInterpolation(e, this.a, this.b, this.c, t, n, s, r);
	}
	containsPoint(e) {
		return Li.containsPoint(e, this.a, this.b, this.c);
	}
	isFrontFacing(e) {
		return Li.isFrontFacing(this.a, this.b, this.c, e);
	}
	intersectsBox(e) {
		return e.intersectsTriangle(this);
	}
	closestPointToPoint(e, t) {
		const n = this.a,
			s = this.b,
			r = this.c;
		let o, a;
		nl.subVectors(s, n), il.subVectors(r, n), $f.subVectors(e, n);
		const l = nl.dot($f),
			c = il.dot($f);
		if (l <= 0 && c <= 0) return t.copy(n);
		Zf.subVectors(e, s);
		const h = nl.dot(Zf),
			u = il.dot(Zf);
		if (h >= 0 && u <= h) return t.copy(s);
		const d = l * u - h * c;
		if (d <= 0 && l >= 0 && h <= 0) return (o = l / (l - h)), t.copy(n).addScaledVector(nl, o);
		Jf.subVectors(e, r);
		const p = nl.dot(Jf),
			g = il.dot(Jf);
		if (g >= 0 && p <= g) return t.copy(r);
		const v = p * c - l * g;
		if (v <= 0 && c >= 0 && g <= 0) return (a = c / (c - g)), t.copy(n).addScaledVector(il, a);
		const m = h * g - p * u;
		if (m <= 0 && u - h >= 0 && p - g >= 0)
			return ix.subVectors(r, s), (a = (u - h) / (u - h + (p - g))), t.copy(s).addScaledVector(ix, a);
		const f = 1 / (m + v + d);
		return (o = v * f), (a = d * f), t.copy(n).addScaledVector(nl, o).addScaledVector(il, a);
	}
	equals(e) {
		return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
	}
}
const lE = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074,
	},
	Ur = { h: 0, s: 0, l: 0 },
	Fu = { h: 0, s: 0, l: 0 };
function Qf(i, e, t) {
	return (
		t < 0 && (t += 1),
		t > 1 && (t -= 1),
		t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i
	);
}
class Ee {
	constructor(e, t, n) {
		return (this.isColor = !0), (this.r = 1), (this.g = 1), (this.b = 1), this.set(e, t, n);
	}
	set(e, t, n) {
		if (t === void 0 && n === void 0) {
			const s = e;
			s && s.isColor ? this.copy(s) : typeof s == 'number' ? this.setHex(s) : typeof s == 'string' && this.setStyle(s);
		} else this.setRGB(e, t, n);
		return this;
	}
	setScalar(e) {
		return (this.r = e), (this.g = e), (this.b = e), this;
	}
	setHex(e, t = ot) {
		return (
			(e = Math.floor(e)),
			(this.r = ((e >> 16) & 255) / 255),
			(this.g = ((e >> 8) & 255) / 255),
			(this.b = (e & 255) / 255),
			Ft.toWorkingColorSpace(this, t),
			this
		);
	}
	setRGB(e, t, n, s = Ft.workingColorSpace) {
		return (this.r = e), (this.g = t), (this.b = n), Ft.toWorkingColorSpace(this, s), this;
	}
	setHSL(e, t, n, s = Ft.workingColorSpace) {
		if (((e = E_(e, 1)), (t = ln(t, 0, 1)), (n = ln(n, 0, 1)), t === 0)) this.r = this.g = this.b = n;
		else {
			const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
				o = 2 * n - r;
			(this.r = Qf(o, r, e + 1 / 3)), (this.g = Qf(o, r, e)), (this.b = Qf(o, r, e - 1 / 3));
		}
		return Ft.toWorkingColorSpace(this, s), this;
	}
	setStyle(e, t = ot) {
		function n(r) {
			r !== void 0 && parseFloat(r) < 1 && console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.');
		}
		let s;
		if ((s = /^(\w+)\(([^\)]*)\)/.exec(e))) {
			let r;
			const o = s[1],
				a = s[2];
			switch (o) {
				case 'rgb':
				case 'rgba':
					if ((r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
						return (
							n(r[4]),
							this.setRGB(
								Math.min(255, parseInt(r[1], 10)) / 255,
								Math.min(255, parseInt(r[2], 10)) / 255,
								Math.min(255, parseInt(r[3], 10)) / 255,
								t
							)
						);
					if ((r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
						return (
							n(r[4]),
							this.setRGB(
								Math.min(100, parseInt(r[1], 10)) / 100,
								Math.min(100, parseInt(r[2], 10)) / 100,
								Math.min(100, parseInt(r[3], 10)) / 100,
								t
							)
						);
					break;
				case 'hsl':
				case 'hsla':
					if ((r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)))
						return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
					break;
				default:
					console.warn('THREE.Color: Unknown color model ' + e);
			}
		} else if ((s = /^\#([A-Fa-f\d]+)$/.exec(e))) {
			const r = s[1],
				o = r.length;
			if (o === 3)
				return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
			if (o === 6) return this.setHex(parseInt(r, 16), t);
			console.warn('THREE.Color: Invalid hex color ' + e);
		} else if (e && e.length > 0) return this.setColorName(e, t);
		return this;
	}
	setColorName(e, t = ot) {
		const n = lE[e.toLowerCase()];
		return n !== void 0 ? this.setHex(n, t) : console.warn('THREE.Color: Unknown color ' + e), this;
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b);
	}
	copy(e) {
		return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
	}
	copySRGBToLinear(e) {
		return (this.r = Fl(e.r)), (this.g = Fl(e.g)), (this.b = Fl(e.b)), this;
	}
	copyLinearToSRGB(e) {
		return (this.r = zf(e.r)), (this.g = zf(e.g)), (this.b = zf(e.b)), this;
	}
	convertSRGBToLinear() {
		return this.copySRGBToLinear(this), this;
	}
	convertLinearToSRGB() {
		return this.copyLinearToSRGB(this), this;
	}
	getHex(e = ot) {
		return (
			Ft.fromWorkingColorSpace(Wn.copy(this), e),
			Math.round(ln(Wn.r * 255, 0, 255)) * 65536 + Math.round(ln(Wn.g * 255, 0, 255)) * 256 + Math.round(ln(Wn.b * 255, 0, 255))
		);
	}
	getHexString(e = ot) {
		return ('000000' + this.getHex(e).toString(16)).slice(-6);
	}
	getHSL(e, t = Ft.workingColorSpace) {
		Ft.fromWorkingColorSpace(Wn.copy(this), t);
		const n = Wn.r,
			s = Wn.g,
			r = Wn.b,
			o = Math.max(n, s, r),
			a = Math.min(n, s, r);
		let l, c;
		const h = (a + o) / 2;
		if (a === o) (l = 0), (c = 0);
		else {
			const u = o - a;
			switch (((c = h <= 0.5 ? u / (o + a) : u / (2 - o - a)), o)) {
				case n:
					l = (s - r) / u + (s < r ? 6 : 0);
					break;
				case s:
					l = (r - n) / u + 2;
					break;
				case r:
					l = (n - s) / u + 4;
					break;
			}
			l /= 6;
		}
		return (e.h = l), (e.s = c), (e.l = h), e;
	}
	getRGB(e, t = Ft.workingColorSpace) {
		return Ft.fromWorkingColorSpace(Wn.copy(this), t), (e.r = Wn.r), (e.g = Wn.g), (e.b = Wn.b), e;
	}
	getStyle(e = ot) {
		Ft.fromWorkingColorSpace(Wn.copy(this), e);
		const t = Wn.r,
			n = Wn.g,
			s = Wn.b;
		return e !== ot
			? 'color('.concat(e, ' ').concat(t.toFixed(3), ' ').concat(n.toFixed(3), ' ').concat(s.toFixed(3), ')')
			: 'rgb('
					.concat(Math.round(t * 255), ',')
					.concat(Math.round(n * 255), ',')
					.concat(Math.round(s * 255), ')');
	}
	offsetHSL(e, t, n) {
		return this.getHSL(Ur), this.setHSL(Ur.h + e, Ur.s + t, Ur.l + n);
	}
	add(e) {
		return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
	}
	addColors(e, t) {
		return (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this;
	}
	addScalar(e) {
		return (this.r += e), (this.g += e), (this.b += e), this;
	}
	sub(e) {
		return (this.r = Math.max(0, this.r - e.r)), (this.g = Math.max(0, this.g - e.g)), (this.b = Math.max(0, this.b - e.b)), this;
	}
	multiply(e) {
		return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
	}
	multiplyScalar(e) {
		return (this.r *= e), (this.g *= e), (this.b *= e), this;
	}
	lerp(e, t) {
		return (this.r += (e.r - this.r) * t), (this.g += (e.g - this.g) * t), (this.b += (e.b - this.b) * t), this;
	}
	lerpColors(e, t, n) {
		return (this.r = e.r + (t.r - e.r) * n), (this.g = e.g + (t.g - e.g) * n), (this.b = e.b + (t.b - e.b) * n), this;
	}
	lerpHSL(e, t) {
		this.getHSL(Ur), e.getHSL(Fu);
		const n = nh(Ur.h, Fu.h, t),
			s = nh(Ur.s, Fu.s, t),
			r = nh(Ur.l, Fu.l, t);
		return this.setHSL(n, s, r), this;
	}
	setFromVector3(e) {
		return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
	}
	applyMatrix3(e) {
		const t = this.r,
			n = this.g,
			s = this.b,
			r = e.elements;
		return (
			(this.r = r[0] * t + r[3] * n + r[6] * s),
			(this.g = r[1] * t + r[4] * n + r[7] * s),
			(this.b = r[2] * t + r[5] * n + r[8] * s),
			this
		);
	}
	equals(e) {
		return e.r === this.r && e.g === this.g && e.b === this.b;
	}
	fromArray(e, t = 0) {
		return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
	}
	toArray(e = [], t = 0) {
		return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
	}
	fromBufferAttribute(e, t) {
		return (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this;
	}
	toJSON() {
		return this.getHex();
	}
	*[Symbol.iterator]() {
		yield this.r, yield this.g, yield this.b;
	}
}
const Wn = new Ee();
Ee.NAMES = lE;
let vI = 0;
class vn extends Hi {
	constructor() {
		super(),
			(this.isMaterial = !0),
			Object.defineProperty(this, 'id', { value: vI++ }),
			(this.uuid = Bi()),
			(this.name = ''),
			(this.type = 'Material'),
			(this.blending = co),
			(this.side = Ms),
			(this.vertexColors = !1),
			(this.opacity = 1),
			(this.transparent = !1),
			(this.alphaHash = !1),
			(this.blendSrc = Jd),
			(this.blendDst = Qd),
			(this.blendEquation = Jr),
			(this.blendSrcAlpha = null),
			(this.blendDstAlpha = null),
			(this.blendEquationAlpha = null),
			(this.blendColor = new Ee(0, 0, 0)),
			(this.blendAlpha = 0),
			(this.depthFunc = jl),
			(this.depthTest = !0),
			(this.depthWrite = !0),
			(this.stencilWriteMask = 255),
			(this.stencilFunc = tv),
			(this.stencilRef = 0),
			(this.stencilFuncMask = 255),
			(this.stencilFail = ea),
			(this.stencilZFail = ea),
			(this.stencilZPass = ea),
			(this.stencilWrite = !1),
			(this.clippingPlanes = null),
			(this.clipIntersection = !1),
			(this.clipShadows = !1),
			(this.shadowSide = null),
			(this.colorWrite = !0),
			(this.precision = null),
			(this.polygonOffset = !1),
			(this.polygonOffsetFactor = 0),
			(this.polygonOffsetUnits = 0),
			(this.dithering = !1),
			(this.alphaToCoverage = !1),
			(this.premultipliedAlpha = !1),
			(this.forceSinglePass = !1),
			(this.visible = !0),
			(this.toneMapped = !0),
			(this.userData = {}),
			(this.version = 0),
			(this._alphaTest = 0);
	}
	get alphaTest() {
		return this._alphaTest;
	}
	set alphaTest(e) {
		this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
	}
	onBuild() {}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString();
	}
	setValues(e) {
		if (e !== void 0)
			for (const t in e) {
				const n = e[t];
				if (n === void 0) {
					console.warn("THREE.Material: parameter '".concat(t, "' has value of undefined."));
					continue;
				}
				const s = this[t];
				if (s === void 0) {
					console.warn("THREE.Material: '".concat(t, "' is not a property of THREE.").concat(this.type, '.'));
					continue;
				}
				s && s.isColor ? s.set(n) : s && s.isVector3 && n && n.isVector3 ? s.copy(n) : (this[t] = n);
			}
	}
	toJSON(e) {
		const t = e === void 0 || typeof e == 'string';
		t && (e = { textures: {}, images: {} });
		const n = { metadata: { version: 4.6, type: 'Material', generator: 'Material.toJSON' } };
		(n.uuid = this.uuid),
			(n.type = this.type),
			this.name !== '' && (n.name = this.name),
			this.color && this.color.isColor && (n.color = this.color.getHex()),
			this.roughness !== void 0 && (n.roughness = this.roughness),
			this.metalness !== void 0 && (n.metalness = this.metalness),
			this.sheen !== void 0 && (n.sheen = this.sheen),
			this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
			this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
			this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
			this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
			this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
			this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
			this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
			this.shininess !== void 0 && (n.shininess = this.shininess),
			this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
			this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
			this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
			this.clearcoatRoughnessMap &&
				this.clearcoatRoughnessMap.isTexture &&
				(n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
			this.clearcoatNormalMap &&
				this.clearcoatNormalMap.isTexture &&
				((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
				(n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
			this.dispersion !== void 0 && (n.dispersion = this.dispersion),
			this.iridescence !== void 0 && (n.iridescence = this.iridescence),
			this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
			this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
			this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
			this.iridescenceThicknessMap &&
				this.iridescenceThicknessMap.isTexture &&
				(n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
			this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
			this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
			this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
			this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
			this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
			this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
			this.lightMap &&
				this.lightMap.isTexture &&
				((n.lightMap = this.lightMap.toJSON(e).uuid), (n.lightMapIntensity = this.lightMapIntensity)),
			this.aoMap && this.aoMap.isTexture && ((n.aoMap = this.aoMap.toJSON(e).uuid), (n.aoMapIntensity = this.aoMapIntensity)),
			this.bumpMap && this.bumpMap.isTexture && ((n.bumpMap = this.bumpMap.toJSON(e).uuid), (n.bumpScale = this.bumpScale)),
			this.normalMap &&
				this.normalMap.isTexture &&
				((n.normalMap = this.normalMap.toJSON(e).uuid),
				(n.normalMapType = this.normalMapType),
				(n.normalScale = this.normalScale.toArray())),
			this.displacementMap &&
				this.displacementMap.isTexture &&
				((n.displacementMap = this.displacementMap.toJSON(e).uuid),
				(n.displacementScale = this.displacementScale),
				(n.displacementBias = this.displacementBias)),
			this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
			this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
			this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
			this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
			this.specularIntensityMap &&
				this.specularIntensityMap.isTexture &&
				(n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
			this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
			this.envMap &&
				this.envMap.isTexture &&
				((n.envMap = this.envMap.toJSON(e).uuid), this.combine !== void 0 && (n.combine = this.combine)),
			this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
			this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
			this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
			this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
			this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
			this.transmission !== void 0 && (n.transmission = this.transmission),
			this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
			this.thickness !== void 0 && (n.thickness = this.thickness),
			this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
			this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
			this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
			this.size !== void 0 && (n.size = this.size),
			this.shadowSide !== null && (n.shadowSide = this.shadowSide),
			this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
			this.blending !== co && (n.blending = this.blending),
			this.side !== Ms && (n.side = this.side),
			this.vertexColors === !0 && (n.vertexColors = !0),
			this.opacity < 1 && (n.opacity = this.opacity),
			this.transparent === !0 && (n.transparent = !0),
			this.blendSrc !== Jd && (n.blendSrc = this.blendSrc),
			this.blendDst !== Qd && (n.blendDst = this.blendDst),
			this.blendEquation !== Jr && (n.blendEquation = this.blendEquation),
			this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
			this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
			this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
			this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
			this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
			this.depthFunc !== jl && (n.depthFunc = this.depthFunc),
			this.depthTest === !1 && (n.depthTest = this.depthTest),
			this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
			this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
			this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
			this.stencilFunc !== tv && (n.stencilFunc = this.stencilFunc),
			this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
			this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
			this.stencilFail !== ea && (n.stencilFail = this.stencilFail),
			this.stencilZFail !== ea && (n.stencilZFail = this.stencilZFail),
			this.stencilZPass !== ea && (n.stencilZPass = this.stencilZPass),
			this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
			this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
			this.polygonOffset === !0 && (n.polygonOffset = !0),
			this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
			this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
			this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
			this.dashSize !== void 0 && (n.dashSize = this.dashSize),
			this.gapSize !== void 0 && (n.gapSize = this.gapSize),
			this.scale !== void 0 && (n.scale = this.scale),
			this.dithering === !0 && (n.dithering = !0),
			this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
			this.alphaHash === !0 && (n.alphaHash = !0),
			this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
			this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
			this.forceSinglePass === !0 && (n.forceSinglePass = !0),
			this.wireframe === !0 && (n.wireframe = !0),
			this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
			this.wireframeLinecap !== 'round' && (n.wireframeLinecap = this.wireframeLinecap),
			this.wireframeLinejoin !== 'round' && (n.wireframeLinejoin = this.wireframeLinejoin),
			this.flatShading === !0 && (n.flatShading = !0),
			this.visible === !1 && (n.visible = !1),
			this.toneMapped === !1 && (n.toneMapped = !1),
			this.fog === !1 && (n.fog = !1),
			Object.keys(this.userData).length > 0 && (n.userData = this.userData);
		function s(r) {
			const o = [];
			for (const a in r) {
				const l = r[a];
				delete l.metadata, o.push(l);
			}
			return o;
		}
		if (t) {
			const r = s(e.textures),
				o = s(e.images);
			r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
		}
		return n;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		(this.name = e.name),
			(this.blending = e.blending),
			(this.side = e.side),
			(this.vertexColors = e.vertexColors),
			(this.opacity = e.opacity),
			(this.transparent = e.transparent),
			(this.blendSrc = e.blendSrc),
			(this.blendDst = e.blendDst),
			(this.blendEquation = e.blendEquation),
			(this.blendSrcAlpha = e.blendSrcAlpha),
			(this.blendDstAlpha = e.blendDstAlpha),
			(this.blendEquationAlpha = e.blendEquationAlpha),
			this.blendColor.copy(e.blendColor),
			(this.blendAlpha = e.blendAlpha),
			(this.depthFunc = e.depthFunc),
			(this.depthTest = e.depthTest),
			(this.depthWrite = e.depthWrite),
			(this.stencilWriteMask = e.stencilWriteMask),
			(this.stencilFunc = e.stencilFunc),
			(this.stencilRef = e.stencilRef),
			(this.stencilFuncMask = e.stencilFuncMask),
			(this.stencilFail = e.stencilFail),
			(this.stencilZFail = e.stencilZFail),
			(this.stencilZPass = e.stencilZPass),
			(this.stencilWrite = e.stencilWrite);
		const t = e.clippingPlanes;
		let n = null;
		if (t !== null) {
			const s = t.length;
			n = new Array(s);
			for (let r = 0; r !== s; ++r) n[r] = t[r].clone();
		}
		return (
			(this.clippingPlanes = n),
			(this.clipIntersection = e.clipIntersection),
			(this.clipShadows = e.clipShadows),
			(this.shadowSide = e.shadowSide),
			(this.colorWrite = e.colorWrite),
			(this.precision = e.precision),
			(this.polygonOffset = e.polygonOffset),
			(this.polygonOffsetFactor = e.polygonOffsetFactor),
			(this.polygonOffsetUnits = e.polygonOffsetUnits),
			(this.dithering = e.dithering),
			(this.alphaTest = e.alphaTest),
			(this.alphaHash = e.alphaHash),
			(this.alphaToCoverage = e.alphaToCoverage),
			(this.premultipliedAlpha = e.premultipliedAlpha),
			(this.forceSinglePass = e.forceSinglePass),
			(this.visible = e.visible),
			(this.toneMapped = e.toneMapped),
			(this.userData = JSON.parse(JSON.stringify(e.userData))),
			this
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
}
class En extends vn {
	constructor(e) {
		super(),
			(this.isMeshBasicMaterial = !0),
			(this.type = 'MeshBasicMaterial'),
			(this.color = new Ee(16777215)),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.specularMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.envMapRotation = new zi()),
			(this.combine = Kh),
			(this.reflectivity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			(this.specularMap = e.specularMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			this.envMapRotation.copy(e.envMapRotation),
			(this.combine = e.combine),
			(this.reflectivity = e.reflectivity),
			(this.refractionRatio = e.refractionRatio),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.fog = e.fog),
			this
		);
	}
}
const dr = _I();
function _I() {
	const i = new ArrayBuffer(4),
		e = new Float32Array(i),
		t = new Uint32Array(i),
		n = new Uint32Array(512),
		s = new Uint32Array(512);
	for (let l = 0; l < 256; ++l) {
		const c = l - 127;
		c < -27
			? ((n[l] = 0), (n[l | 256] = 32768), (s[l] = 24), (s[l | 256] = 24))
			: c < -14
			? ((n[l] = 1024 >> (-c - 14)), (n[l | 256] = (1024 >> (-c - 14)) | 32768), (s[l] = -c - 1), (s[l | 256] = -c - 1))
			: c <= 15
			? ((n[l] = (c + 15) << 10), (n[l | 256] = ((c + 15) << 10) | 32768), (s[l] = 13), (s[l | 256] = 13))
			: c < 128
			? ((n[l] = 31744), (n[l | 256] = 64512), (s[l] = 24), (s[l | 256] = 24))
			: ((n[l] = 31744), (n[l | 256] = 64512), (s[l] = 13), (s[l | 256] = 13));
	}
	const r = new Uint32Array(2048),
		o = new Uint32Array(64),
		a = new Uint32Array(64);
	for (let l = 1; l < 1024; ++l) {
		let c = l << 13,
			h = 0;
		for (; !(c & 8388608); ) (c <<= 1), (h -= 8388608);
		(c &= -8388609), (h += 947912704), (r[l] = c | h);
	}
	for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + ((l - 1024) << 13);
	for (let l = 1; l < 31; ++l) o[l] = l << 23;
	(o[31] = 1199570944), (o[32] = 2147483648);
	for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
	o[63] = 3347054592;
	for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
	return { floatView: e, uint32View: t, baseTable: n, shiftTable: s, mantissaTable: r, exponentTable: o, offsetTable: a };
}
function di(i) {
	Math.abs(i) > 65504 && console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.'),
		(i = ln(i, -65504, 65504)),
		(dr.floatView[0] = i);
	const e = dr.uint32View[0],
		t = (e >> 23) & 511;
	return dr.baseTable[t] + ((e & 8388607) >> dr.shiftTable[t]);
}
function Xc(i) {
	const e = i >> 10;
	return (dr.uint32View[0] = dr.mantissaTable[dr.offsetTable[e] + (i & 1023)] + dr.exponentTable[e]), dr.floatView[0];
}
const ha = { toHalfFloat: di, fromHalfFloat: Xc },
	wn = new I(),
	Bu = new ce();
class $e {
	constructor(e, t, n = !1) {
		if (Array.isArray(e)) throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
		(this.isBufferAttribute = !0),
			(this.name = ''),
			(this.array = e),
			(this.itemSize = t),
			(this.count = e !== void 0 ? e.length / t : 0),
			(this.normalized = n),
			(this.usage = Mh),
			(this._updateRange = { offset: 0, count: -1 }),
			(this.updateRanges = []),
			(this.gpuType = On),
			(this.version = 0);
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	get updateRange() {
		return (
			rE('THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'),
			this._updateRange
		);
	}
	setUsage(e) {
		return (this.usage = e), this;
	}
	addUpdateRange(e, t) {
		this.updateRanges.push({ start: e, count: t });
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0;
	}
	copy(e) {
		return (
			(this.name = e.name),
			(this.array = new e.array.constructor(e.array)),
			(this.itemSize = e.itemSize),
			(this.count = e.count),
			(this.normalized = e.normalized),
			(this.usage = e.usage),
			(this.gpuType = e.gpuType),
			this
		);
	}
	copyAt(e, t, n) {
		(e *= this.itemSize), (n *= t.itemSize);
		for (let s = 0, r = this.itemSize; s < r; s++) this.array[e + s] = t.array[n + s];
		return this;
	}
	copyArray(e) {
		return this.array.set(e), this;
	}
	applyMatrix3(e) {
		if (this.itemSize === 2)
			for (let t = 0, n = this.count; t < n; t++) Bu.fromBufferAttribute(this, t), Bu.applyMatrix3(e), this.setXY(t, Bu.x, Bu.y);
		else if (this.itemSize === 3)
			for (let t = 0, n = this.count; t < n; t++)
				wn.fromBufferAttribute(this, t), wn.applyMatrix3(e), this.setXYZ(t, wn.x, wn.y, wn.z);
		return this;
	}
	applyMatrix4(e) {
		for (let t = 0, n = this.count; t < n; t++) wn.fromBufferAttribute(this, t), wn.applyMatrix4(e), this.setXYZ(t, wn.x, wn.y, wn.z);
		return this;
	}
	applyNormalMatrix(e) {
		for (let t = 0, n = this.count; t < n; t++)
			wn.fromBufferAttribute(this, t), wn.applyNormalMatrix(e), this.setXYZ(t, wn.x, wn.y, wn.z);
		return this;
	}
	transformDirection(e) {
		for (let t = 0, n = this.count; t < n; t++)
			wn.fromBufferAttribute(this, t), wn.transformDirection(e), this.setXYZ(t, wn.x, wn.y, wn.z);
		return this;
	}
	set(e, t = 0) {
		return this.array.set(e, t), this;
	}
	getComponent(e, t) {
		let n = this.array[e * this.itemSize + t];
		return this.normalized && (n = ri(n, this.array)), n;
	}
	setComponent(e, t, n) {
		return this.normalized && (n = tt(n, this.array)), (this.array[e * this.itemSize + t] = n), this;
	}
	getX(e) {
		let t = this.array[e * this.itemSize];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setX(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize] = t), this;
	}
	getY(e) {
		let t = this.array[e * this.itemSize + 1];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setY(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize + 1] = t), this;
	}
	getZ(e) {
		let t = this.array[e * this.itemSize + 2];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setZ(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize + 2] = t), this;
	}
	getW(e) {
		let t = this.array[e * this.itemSize + 3];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setW(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize + 3] = t), this;
	}
	setXY(e, t, n) {
		return (
			(e *= this.itemSize),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array))),
			(this.array[e + 0] = t),
			(this.array[e + 1] = n),
			this
		);
	}
	setXYZ(e, t, n, s) {
		return (
			(e *= this.itemSize),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array)), (s = tt(s, this.array))),
			(this.array[e + 0] = t),
			(this.array[e + 1] = n),
			(this.array[e + 2] = s),
			this
		);
	}
	setXYZW(e, t, n, s, r) {
		return (
			(e *= this.itemSize),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array)), (s = tt(s, this.array)), (r = tt(r, this.array))),
			(this.array[e + 0] = t),
			(this.array[e + 1] = n),
			(this.array[e + 2] = s),
			(this.array[e + 3] = r),
			this
		);
	}
	onUpload(e) {
		return (this.onUploadCallback = e), this;
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this);
	}
	toJSON() {
		const e = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized,
		};
		return this.name !== '' && (e.name = this.name), this.usage !== Mh && (e.usage = this.usage), e;
	}
}
class yI extends $e {
	constructor(e, t, n) {
		super(new Int8Array(e), t, n);
	}
}
class xI extends $e {
	constructor(e, t, n) {
		super(new Uint8Array(e), t, n);
	}
}
class bI extends $e {
	constructor(e, t, n) {
		super(new Uint8ClampedArray(e), t, n);
	}
}
class wI extends $e {
	constructor(e, t, n) {
		super(new Int16Array(e), t, n);
	}
}
class A_ extends $e {
	constructor(e, t, n) {
		super(new Uint16Array(e), t, n);
	}
}
class SI extends $e {
	constructor(e, t, n) {
		super(new Int32Array(e), t, n);
	}
}
class C_ extends $e {
	constructor(e, t, n) {
		super(new Uint32Array(e), t, n);
	}
}
class MI extends $e {
	constructor(e, t, n) {
		super(new Uint16Array(e), t, n), (this.isFloat16BufferAttribute = !0);
	}
	getX(e) {
		let t = Xc(this.array[e * this.itemSize]);
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setX(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize] = di(t)), this;
	}
	getY(e) {
		let t = Xc(this.array[e * this.itemSize + 1]);
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setY(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize + 1] = di(t)), this;
	}
	getZ(e) {
		let t = Xc(this.array[e * this.itemSize + 2]);
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setZ(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize + 2] = di(t)), this;
	}
	getW(e) {
		let t = Xc(this.array[e * this.itemSize + 3]);
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setW(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.array[e * this.itemSize + 3] = di(t)), this;
	}
	setXY(e, t, n) {
		return (
			(e *= this.itemSize),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array))),
			(this.array[e + 0] = di(t)),
			(this.array[e + 1] = di(n)),
			this
		);
	}
	setXYZ(e, t, n, s) {
		return (
			(e *= this.itemSize),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array)), (s = tt(s, this.array))),
			(this.array[e + 0] = di(t)),
			(this.array[e + 1] = di(n)),
			(this.array[e + 2] = di(s)),
			this
		);
	}
	setXYZW(e, t, n, s, r) {
		return (
			(e *= this.itemSize),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array)), (s = tt(s, this.array)), (r = tt(r, this.array))),
			(this.array[e + 0] = di(t)),
			(this.array[e + 1] = di(n)),
			(this.array[e + 2] = di(s)),
			(this.array[e + 3] = di(r)),
			this
		);
	}
}
class ze extends $e {
	constructor(e, t, n) {
		super(new Float32Array(e), t, n);
	}
}
let EI = 0;
const Yi = new He(),
	em = new ft(),
	sl = new I(),
	Ri = new An(),
	wc = new An(),
	Ln = new I();
class Ze extends Hi {
	constructor() {
		super(),
			(this.isBufferGeometry = !0),
			Object.defineProperty(this, 'id', { value: EI++ }),
			(this.uuid = Bi()),
			(this.name = ''),
			(this.type = 'BufferGeometry'),
			(this.index = null),
			(this.attributes = {}),
			(this.morphAttributes = {}),
			(this.morphTargetsRelative = !1),
			(this.groups = []),
			(this.boundingBox = null),
			(this.boundingSphere = null),
			(this.drawRange = { start: 0, count: 1 / 0 }),
			(this.userData = {});
	}
	getIndex() {
		return this.index;
	}
	setIndex(e) {
		return Array.isArray(e) ? (this.index = new (iE(e) ? C_ : A_)(e, 1)) : (this.index = e), this;
	}
	getAttribute(e) {
		return this.attributes[e];
	}
	setAttribute(e, t) {
		return (this.attributes[e] = t), this;
	}
	deleteAttribute(e) {
		return delete this.attributes[e], this;
	}
	hasAttribute(e) {
		return this.attributes[e] !== void 0;
	}
	addGroup(e, t, n = 0) {
		this.groups.push({ start: e, count: t, materialIndex: n });
	}
	clearGroups() {
		this.groups = [];
	}
	setDrawRange(e, t) {
		(this.drawRange.start = e), (this.drawRange.count = t);
	}
	applyMatrix4(e) {
		const t = this.attributes.position;
		t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
		const n = this.attributes.normal;
		if (n !== void 0) {
			const r = new et().getNormalMatrix(e);
			n.applyNormalMatrix(r), (n.needsUpdate = !0);
		}
		const s = this.attributes.tangent;
		return (
			s !== void 0 && (s.transformDirection(e), (s.needsUpdate = !0)),
			this.boundingBox !== null && this.computeBoundingBox(),
			this.boundingSphere !== null && this.computeBoundingSphere(),
			this
		);
	}
	applyQuaternion(e) {
		return Yi.makeRotationFromQuaternion(e), this.applyMatrix4(Yi), this;
	}
	rotateX(e) {
		return Yi.makeRotationX(e), this.applyMatrix4(Yi), this;
	}
	rotateY(e) {
		return Yi.makeRotationY(e), this.applyMatrix4(Yi), this;
	}
	rotateZ(e) {
		return Yi.makeRotationZ(e), this.applyMatrix4(Yi), this;
	}
	translate(e, t, n) {
		return Yi.makeTranslation(e, t, n), this.applyMatrix4(Yi), this;
	}
	scale(e, t, n) {
		return Yi.makeScale(e, t, n), this.applyMatrix4(Yi), this;
	}
	lookAt(e) {
		return em.lookAt(e), em.updateMatrix(), this.applyMatrix4(em.matrix), this;
	}
	center() {
		return this.computeBoundingBox(), this.boundingBox.getCenter(sl).negate(), this.translate(sl.x, sl.y, sl.z), this;
	}
	setFromPoints(e) {
		const t = [];
		for (let n = 0, s = e.length; n < s; n++) {
			const r = e[n];
			t.push(r.x, r.y, r.z || 0);
		}
		return this.setAttribute('position', new ze(t, 3)), this;
	}
	computeBoundingBox() {
		this.boundingBox === null && (this.boundingBox = new An());
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this),
				this.boundingBox.set(new I(-1 / 0, -1 / 0, -1 / 0), new I(1 / 0, 1 / 0, 1 / 0));
			return;
		}
		if (e !== void 0) {
			if ((this.boundingBox.setFromBufferAttribute(e), t))
				for (let n = 0, s = t.length; n < s; n++) {
					const r = t[n];
					Ri.setFromBufferAttribute(r),
						this.morphTargetsRelative
							? (Ln.addVectors(this.boundingBox.min, Ri.min),
							  this.boundingBox.expandByPoint(Ln),
							  Ln.addVectors(this.boundingBox.max, Ri.max),
							  this.boundingBox.expandByPoint(Ln))
							: (this.boundingBox.expandByPoint(Ri.min), this.boundingBox.expandByPoint(Ri.max));
				}
		} else this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
			console.error(
				'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
				this
			);
	}
	computeBoundingSphere() {
		this.boundingSphere === null && (this.boundingSphere = new un());
		const e = this.attributes.position,
			t = this.morphAttributes.position;
		if (e && e.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this),
				this.boundingSphere.set(new I(), 1 / 0);
			return;
		}
		if (e) {
			const n = this.boundingSphere.center;
			if ((Ri.setFromBufferAttribute(e), t))
				for (let r = 0, o = t.length; r < o; r++) {
					const a = t[r];
					wc.setFromBufferAttribute(a),
						this.morphTargetsRelative
							? (Ln.addVectors(Ri.min, wc.min), Ri.expandByPoint(Ln), Ln.addVectors(Ri.max, wc.max), Ri.expandByPoint(Ln))
							: (Ri.expandByPoint(wc.min), Ri.expandByPoint(wc.max));
				}
			Ri.getCenter(n);
			let s = 0;
			for (let r = 0, o = e.count; r < o; r++) Ln.fromBufferAttribute(e, r), (s = Math.max(s, n.distanceToSquared(Ln)));
			if (t)
				for (let r = 0, o = t.length; r < o; r++) {
					const a = t[r],
						l = this.morphTargetsRelative;
					for (let c = 0, h = a.count; c < h; c++)
						Ln.fromBufferAttribute(a, c),
							l && (sl.fromBufferAttribute(e, c), Ln.add(sl)),
							(s = Math.max(s, n.distanceToSquared(Ln)));
				}
			(this.boundingSphere.radius = Math.sqrt(s)),
				isNaN(this.boundingSphere.radius) &&
					console.error(
						'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
						this
					);
		}
	}
	computeTangents() {
		const e = this.index,
			t = this.attributes;
		if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
			console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
			return;
		}
		const n = t.position,
			s = t.normal,
			r = t.uv;
		this.hasAttribute('tangent') === !1 && this.setAttribute('tangent', new $e(new Float32Array(4 * n.count), 4));
		const o = this.getAttribute('tangent'),
			a = [],
			l = [];
		for (let P = 0; P < n.count; P++) (a[P] = new I()), (l[P] = new I());
		const c = new I(),
			h = new I(),
			u = new I(),
			d = new ce(),
			p = new ce(),
			g = new ce(),
			v = new I(),
			m = new I();
		function f(P, S, M) {
			c.fromBufferAttribute(n, P),
				h.fromBufferAttribute(n, S),
				u.fromBufferAttribute(n, M),
				d.fromBufferAttribute(r, P),
				p.fromBufferAttribute(r, S),
				g.fromBufferAttribute(r, M),
				h.sub(c),
				u.sub(c),
				p.sub(d),
				g.sub(d);
			const k = 1 / (p.x * g.y - g.x * p.y);
			isFinite(k) &&
				(v.copy(h).multiplyScalar(g.y).addScaledVector(u, -p.y).multiplyScalar(k),
				m.copy(u).multiplyScalar(p.x).addScaledVector(h, -g.x).multiplyScalar(k),
				a[P].add(v),
				a[S].add(v),
				a[M].add(v),
				l[P].add(m),
				l[S].add(m),
				l[M].add(m));
		}
		let y = this.groups;
		y.length === 0 && (y = [{ start: 0, count: e.count }]);
		for (let P = 0, S = y.length; P < S; ++P) {
			const M = y[P],
				k = M.start,
				q = M.count;
			for (let B = k, W = k + q; B < W; B += 3) f(e.getX(B + 0), e.getX(B + 1), e.getX(B + 2));
		}
		const _ = new I(),
			x = new I(),
			E = new I(),
			w = new I();
		function C(P) {
			E.fromBufferAttribute(s, P), w.copy(E);
			const S = a[P];
			_.copy(S), _.sub(E.multiplyScalar(E.dot(S))).normalize(), x.crossVectors(w, S);
			const k = x.dot(l[P]) < 0 ? -1 : 1;
			o.setXYZW(P, _.x, _.y, _.z, k);
		}
		for (let P = 0, S = y.length; P < S; ++P) {
			const M = y[P],
				k = M.start,
				q = M.count;
			for (let B = k, W = k + q; B < W; B += 3) C(e.getX(B + 0)), C(e.getX(B + 1)), C(e.getX(B + 2));
		}
	}
	computeVertexNormals() {
		const e = this.index,
			t = this.getAttribute('position');
		if (t !== void 0) {
			let n = this.getAttribute('normal');
			if (n === void 0) (n = new $e(new Float32Array(t.count * 3), 3)), this.setAttribute('normal', n);
			else for (let d = 0, p = n.count; d < p; d++) n.setXYZ(d, 0, 0, 0);
			const s = new I(),
				r = new I(),
				o = new I(),
				a = new I(),
				l = new I(),
				c = new I(),
				h = new I(),
				u = new I();
			if (e)
				for (let d = 0, p = e.count; d < p; d += 3) {
					const g = e.getX(d + 0),
						v = e.getX(d + 1),
						m = e.getX(d + 2);
					s.fromBufferAttribute(t, g),
						r.fromBufferAttribute(t, v),
						o.fromBufferAttribute(t, m),
						h.subVectors(o, r),
						u.subVectors(s, r),
						h.cross(u),
						a.fromBufferAttribute(n, g),
						l.fromBufferAttribute(n, v),
						c.fromBufferAttribute(n, m),
						a.add(h),
						l.add(h),
						c.add(h),
						n.setXYZ(g, a.x, a.y, a.z),
						n.setXYZ(v, l.x, l.y, l.z),
						n.setXYZ(m, c.x, c.y, c.z);
				}
			else
				for (let d = 0, p = t.count; d < p; d += 3)
					s.fromBufferAttribute(t, d + 0),
						r.fromBufferAttribute(t, d + 1),
						o.fromBufferAttribute(t, d + 2),
						h.subVectors(o, r),
						u.subVectors(s, r),
						h.cross(u),
						n.setXYZ(d + 0, h.x, h.y, h.z),
						n.setXYZ(d + 1, h.x, h.y, h.z),
						n.setXYZ(d + 2, h.x, h.y, h.z);
			this.normalizeNormals(), (n.needsUpdate = !0);
		}
	}
	normalizeNormals() {
		const e = this.attributes.normal;
		for (let t = 0, n = e.count; t < n; t++) Ln.fromBufferAttribute(e, t), Ln.normalize(), e.setXYZ(t, Ln.x, Ln.y, Ln.z);
	}
	toNonIndexed() {
		function e(a, l) {
			const c = a.array,
				h = a.itemSize,
				u = a.normalized,
				d = new c.constructor(l.length * h);
			let p = 0,
				g = 0;
			for (let v = 0, m = l.length; v < m; v++) {
				a.isInterleavedBufferAttribute ? (p = l[v] * a.data.stride + a.offset) : (p = l[v] * h);
				for (let f = 0; f < h; f++) d[g++] = c[p++];
			}
			return new $e(d, h, u);
		}
		if (this.index === null) return console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.'), this;
		const t = new Ze(),
			n = this.index.array,
			s = this.attributes;
		for (const a in s) {
			const l = s[a],
				c = e(l, n);
			t.setAttribute(a, c);
		}
		const r = this.morphAttributes;
		for (const a in r) {
			const l = [],
				c = r[a];
			for (let h = 0, u = c.length; h < u; h++) {
				const d = c[h],
					p = e(d, n);
				l.push(p);
			}
			t.morphAttributes[a] = l;
		}
		t.morphTargetsRelative = this.morphTargetsRelative;
		const o = this.groups;
		for (let a = 0, l = o.length; a < l; a++) {
			const c = o[a];
			t.addGroup(c.start, c.count, c.materialIndex);
		}
		return t;
	}
	toJSON() {
		const e = { metadata: { version: 4.6, type: 'BufferGeometry', generator: 'BufferGeometry.toJSON' } };
		if (
			((e.uuid = this.uuid),
			(e.type = this.type),
			this.name !== '' && (e.name = this.name),
			Object.keys(this.userData).length > 0 && (e.userData = this.userData),
			this.parameters !== void 0)
		) {
			const l = this.parameters;
			for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
			return e;
		}
		e.data = { attributes: {} };
		const t = this.index;
		t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
		const n = this.attributes;
		for (const l in n) {
			const c = n[l];
			e.data.attributes[l] = c.toJSON(e.data);
		}
		const s = {};
		let r = !1;
		for (const l in this.morphAttributes) {
			const c = this.morphAttributes[l],
				h = [];
			for (let u = 0, d = c.length; u < d; u++) {
				const p = c[u];
				h.push(p.toJSON(e.data));
			}
			h.length > 0 && ((s[l] = h), (r = !0));
		}
		r && ((e.data.morphAttributes = s), (e.data.morphTargetsRelative = this.morphTargetsRelative));
		const o = this.groups;
		o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
		const a = this.boundingSphere;
		return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		(this.index = null),
			(this.attributes = {}),
			(this.morphAttributes = {}),
			(this.groups = []),
			(this.boundingBox = null),
			(this.boundingSphere = null);
		const t = {};
		this.name = e.name;
		const n = e.index;
		n !== null && this.setIndex(n.clone(t));
		const s = e.attributes;
		for (const c in s) {
			const h = s[c];
			this.setAttribute(c, h.clone(t));
		}
		const r = e.morphAttributes;
		for (const c in r) {
			const h = [],
				u = r[c];
			for (let d = 0, p = u.length; d < p; d++) h.push(u[d].clone(t));
			this.morphAttributes[c] = h;
		}
		this.morphTargetsRelative = e.morphTargetsRelative;
		const o = e.groups;
		for (let c = 0, h = o.length; c < h; c++) {
			const u = o[c];
			this.addGroup(u.start, u.count, u.materialIndex);
		}
		const a = e.boundingBox;
		a !== null && (this.boundingBox = a.clone());
		const l = e.boundingSphere;
		return (
			l !== null && (this.boundingSphere = l.clone()),
			(this.drawRange.start = e.drawRange.start),
			(this.drawRange.count = e.drawRange.count),
			(this.userData = e.userData),
			this
		);
	}
	dispose() {
		this.dispatchEvent({ type: 'dispose' });
	}
}
const sx = new He(),
	Bo = new ka(),
	ku = new un(),
	rx = new I(),
	rl = new I(),
	ol = new I(),
	al = new I(),
	tm = new I(),
	zu = new I(),
	Vu = new ce(),
	Hu = new ce(),
	Gu = new ce(),
	ox = new I(),
	ax = new I(),
	lx = new I(),
	Wu = new I(),
	Xu = new I();
class bt extends ft {
	constructor(e = new Ze(), t = new En()) {
		super(), (this.isMesh = !0), (this.type = 'Mesh'), (this.geometry = e), (this.material = t), this.updateMorphTargets();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
			e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
			(this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
			(this.geometry = e.geometry),
			this
		);
	}
	updateMorphTargets() {
		const t = this.geometry.morphAttributes,
			n = Object.keys(t);
		if (n.length > 0) {
			const s = t[n[0]];
			if (s !== void 0) {
				(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
				for (let r = 0, o = s.length; r < o; r++) {
					const a = s[r].name || String(r);
					this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = r);
				}
			}
		}
	}
	getVertexPosition(e, t) {
		const n = this.geometry,
			s = n.attributes.position,
			r = n.morphAttributes.position,
			o = n.morphTargetsRelative;
		t.fromBufferAttribute(s, e);
		const a = this.morphTargetInfluences;
		if (r && a) {
			zu.set(0, 0, 0);
			for (let l = 0, c = r.length; l < c; l++) {
				const h = a[l],
					u = r[l];
				h !== 0 && (tm.fromBufferAttribute(u, e), o ? zu.addScaledVector(tm, h) : zu.addScaledVector(tm.sub(t), h));
			}
			t.add(zu);
		}
		return t;
	}
	raycast(e, t) {
		const n = this.geometry,
			s = this.material,
			r = this.matrixWorld;
		s !== void 0 &&
			(n.boundingSphere === null && n.computeBoundingSphere(),
			ku.copy(n.boundingSphere),
			ku.applyMatrix4(r),
			Bo.copy(e.ray).recast(e.near),
			!(
				ku.containsPoint(Bo.origin) === !1 &&
				(Bo.intersectSphere(ku, rx) === null || Bo.origin.distanceToSquared(rx) > (e.far - e.near) ** 2)
			) &&
				(sx.copy(r).invert(),
				Bo.copy(e.ray).applyMatrix4(sx),
				!(n.boundingBox !== null && Bo.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Bo)));
	}
	_computeIntersections(e, t, n) {
		let s;
		const r = this.geometry,
			o = this.material,
			a = r.index,
			l = r.attributes.position,
			c = r.attributes.uv,
			h = r.attributes.uv1,
			u = r.attributes.normal,
			d = r.groups,
			p = r.drawRange;
		if (a !== null)
			if (Array.isArray(o))
				for (let g = 0, v = d.length; g < v; g++) {
					const m = d[g],
						f = o[m.materialIndex],
						y = Math.max(m.start, p.start),
						_ = Math.min(a.count, Math.min(m.start + m.count, p.start + p.count));
					for (let x = y, E = _; x < E; x += 3) {
						const w = a.getX(x),
							C = a.getX(x + 1),
							P = a.getX(x + 2);
						(s = qu(this, f, e, n, c, h, u, w, C, P)),
							s && ((s.faceIndex = Math.floor(x / 3)), (s.face.materialIndex = m.materialIndex), t.push(s));
					}
				}
			else {
				const g = Math.max(0, p.start),
					v = Math.min(a.count, p.start + p.count);
				for (let m = g, f = v; m < f; m += 3) {
					const y = a.getX(m),
						_ = a.getX(m + 1),
						x = a.getX(m + 2);
					(s = qu(this, o, e, n, c, h, u, y, _, x)), s && ((s.faceIndex = Math.floor(m / 3)), t.push(s));
				}
			}
		else if (l !== void 0)
			if (Array.isArray(o))
				for (let g = 0, v = d.length; g < v; g++) {
					const m = d[g],
						f = o[m.materialIndex],
						y = Math.max(m.start, p.start),
						_ = Math.min(l.count, Math.min(m.start + m.count, p.start + p.count));
					for (let x = y, E = _; x < E; x += 3) {
						const w = x,
							C = x + 1,
							P = x + 2;
						(s = qu(this, f, e, n, c, h, u, w, C, P)),
							s && ((s.faceIndex = Math.floor(x / 3)), (s.face.materialIndex = m.materialIndex), t.push(s));
					}
				}
			else {
				const g = Math.max(0, p.start),
					v = Math.min(l.count, p.start + p.count);
				for (let m = g, f = v; m < f; m += 3) {
					const y = m,
						_ = m + 1,
						x = m + 2;
					(s = qu(this, o, e, n, c, h, u, y, _, x)), s && ((s.faceIndex = Math.floor(m / 3)), t.push(s));
				}
			}
	}
}
function TI(i, e, t, n, s, r, o, a) {
	let l;
	if ((e.side === gn ? (l = n.intersectTriangle(o, r, s, !0, a)) : (l = n.intersectTriangle(s, r, o, e.side === Ms, a)), l === null))
		return null;
	Xu.copy(a), Xu.applyMatrix4(i.matrixWorld);
	const c = t.ray.origin.distanceTo(Xu);
	return c < t.near || c > t.far ? null : { distance: c, point: Xu.clone(), object: i };
}
function qu(i, e, t, n, s, r, o, a, l, c) {
	i.getVertexPosition(a, rl), i.getVertexPosition(l, ol), i.getVertexPosition(c, al);
	const h = TI(i, e, t, n, rl, ol, al, Wu);
	if (h) {
		s &&
			(Vu.fromBufferAttribute(s, a),
			Hu.fromBufferAttribute(s, l),
			Gu.fromBufferAttribute(s, c),
			(h.uv = Li.getInterpolation(Wu, rl, ol, al, Vu, Hu, Gu, new ce()))),
			r &&
				(Vu.fromBufferAttribute(r, a),
				Hu.fromBufferAttribute(r, l),
				Gu.fromBufferAttribute(r, c),
				(h.uv1 = Li.getInterpolation(Wu, rl, ol, al, Vu, Hu, Gu, new ce()))),
			o &&
				(ox.fromBufferAttribute(o, a),
				ax.fromBufferAttribute(o, l),
				lx.fromBufferAttribute(o, c),
				(h.normal = Li.getInterpolation(Wu, rl, ol, al, ox, ax, lx, new I())),
				h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
		const u = { a, b: l, c, normal: new I(), materialIndex: 0 };
		Li.getNormal(rl, ol, al, u.normal), (h.face = u);
	}
	return h;
}
class za extends Ze {
	constructor(e = 1, t = 1, n = 1, s = 1, r = 1, o = 1) {
		super(),
			(this.type = 'BoxGeometry'),
			(this.parameters = { width: e, height: t, depth: n, widthSegments: s, heightSegments: r, depthSegments: o });
		const a = this;
		(s = Math.floor(s)), (r = Math.floor(r)), (o = Math.floor(o));
		const l = [],
			c = [],
			h = [],
			u = [];
		let d = 0,
			p = 0;
		g('z', 'y', 'x', -1, -1, n, t, e, o, r, 0),
			g('z', 'y', 'x', 1, -1, n, t, -e, o, r, 1),
			g('x', 'z', 'y', 1, 1, e, n, t, s, o, 2),
			g('x', 'z', 'y', 1, -1, e, n, -t, s, o, 3),
			g('x', 'y', 'z', 1, -1, e, t, n, s, r, 4),
			g('x', 'y', 'z', -1, -1, e, t, -n, s, r, 5),
			this.setIndex(l),
			this.setAttribute('position', new ze(c, 3)),
			this.setAttribute('normal', new ze(h, 3)),
			this.setAttribute('uv', new ze(u, 2));
		function g(v, m, f, y, _, x, E, w, C, P, S) {
			const M = x / C,
				k = E / P,
				q = x / 2,
				B = E / 2,
				W = w / 2,
				Q = C + 1,
				$ = P + 1;
			let le = 0,
				Z = 0;
			const xe = new I();
			for (let ue = 0; ue < $; ue++) {
				const Te = ue * k - B;
				for (let Ae = 0; Ae < Q; Ae++) {
					const We = Ae * M - q;
					(xe[v] = We * y),
						(xe[m] = Te * _),
						(xe[f] = W),
						c.push(xe.x, xe.y, xe.z),
						(xe[v] = 0),
						(xe[m] = 0),
						(xe[f] = w > 0 ? 1 : -1),
						h.push(xe.x, xe.y, xe.z),
						u.push(Ae / C),
						u.push(1 - ue / P),
						(le += 1);
				}
			}
			for (let ue = 0; ue < P; ue++)
				for (let Te = 0; Te < C; Te++) {
					const Ae = d + Te + Q * ue,
						We = d + Te + Q * (ue + 1),
						se = d + (Te + 1) + Q * (ue + 1),
						Se = d + (Te + 1) + Q * ue;
					l.push(Ae, We, Se), l.push(We, se, Se), (Z += 6);
				}
			a.addGroup(p, Z, S), (p += Z), (d += le);
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new za(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
	}
}
function Jl(i) {
	const e = {};
	for (const t in i) {
		e[t] = {};
		for (const n in i[t]) {
			const s = i[t][n];
			s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion)
				? s.isRenderTargetTexture
					? (console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().'),
					  (e[t][n] = null))
					: (e[t][n] = s.clone())
				: Array.isArray(s)
				? (e[t][n] = s.slice())
				: (e[t][n] = s);
		}
	}
	return e;
}
function ii(i) {
	const e = {};
	for (let t = 0; t < i.length; t++) {
		const n = Jl(i[t]);
		for (const s in n) e[s] = n[s];
	}
	return e;
}
function AI(i) {
	const e = [];
	for (let t = 0; t < i.length; t++) e.push(i[t].clone());
	return e;
}
function cE(i) {
	const e = i.getRenderTarget();
	return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Ft.workingColorSpace;
}
const hE = { clone: Jl, merge: ii };
var CI = 'void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
	RI = 'void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
class xn extends vn {
	constructor(e) {
		super(),
			(this.isShaderMaterial = !0),
			(this.type = 'ShaderMaterial'),
			(this.defines = {}),
			(this.uniforms = {}),
			(this.uniformsGroups = []),
			(this.vertexShader = CI),
			(this.fragmentShader = RI),
			(this.linewidth = 1),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.fog = !1),
			(this.lights = !1),
			(this.clipping = !1),
			(this.forceSinglePass = !0),
			(this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
			(this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }),
			(this.index0AttributeName = void 0),
			(this.uniformsNeedUpdate = !1),
			(this.glslVersion = null),
			e !== void 0 && this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.fragmentShader = e.fragmentShader),
			(this.vertexShader = e.vertexShader),
			(this.uniforms = Jl(e.uniforms)),
			(this.uniformsGroups = AI(e.uniformsGroups)),
			(this.defines = Object.assign({}, e.defines)),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.fog = e.fog),
			(this.lights = e.lights),
			(this.clipping = e.clipping),
			(this.extensions = Object.assign({}, e.extensions)),
			(this.glslVersion = e.glslVersion),
			this
		);
	}
	toJSON(e) {
		const t = super.toJSON(e);
		(t.glslVersion = this.glslVersion), (t.uniforms = {});
		for (const s in this.uniforms) {
			const o = this.uniforms[s].value;
			o && o.isTexture
				? (t.uniforms[s] = { type: 't', value: o.toJSON(e).uuid })
				: o && o.isColor
				? (t.uniforms[s] = { type: 'c', value: o.getHex() })
				: o && o.isVector2
				? (t.uniforms[s] = { type: 'v2', value: o.toArray() })
				: o && o.isVector3
				? (t.uniforms[s] = { type: 'v3', value: o.toArray() })
				: o && o.isVector4
				? (t.uniforms[s] = { type: 'v4', value: o.toArray() })
				: o && o.isMatrix3
				? (t.uniforms[s] = { type: 'm3', value: o.toArray() })
				: o && o.isMatrix4
				? (t.uniforms[s] = { type: 'm4', value: o.toArray() })
				: (t.uniforms[s] = { value: o });
		}
		Object.keys(this.defines).length > 0 && (t.defines = this.defines),
			(t.vertexShader = this.vertexShader),
			(t.fragmentShader = this.fragmentShader),
			(t.lights = this.lights),
			(t.clipping = this.clipping);
		const n = {};
		for (const s in this.extensions) this.extensions[s] === !0 && (n[s] = !0);
		return Object.keys(n).length > 0 && (t.extensions = n), t;
	}
}
class Zh extends ft {
	constructor() {
		super(),
			(this.isCamera = !0),
			(this.type = 'Camera'),
			(this.matrixWorldInverse = new He()),
			(this.projectionMatrix = new He()),
			(this.projectionMatrixInverse = new He()),
			(this.coordinateSystem = Vs);
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			this.matrixWorldInverse.copy(e.matrixWorldInverse),
			this.projectionMatrix.copy(e.projectionMatrix),
			this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
			(this.coordinateSystem = e.coordinateSystem),
			this
		);
	}
	getWorldDirection(e) {
		return super.getWorldDirection(e).negate();
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	updateWorldMatrix(e, t) {
		super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const Nr = new I(),
	cx = new ce(),
	hx = new ce();
class fn extends Zh {
	constructor(e = 50, t = 1, n = 0.1, s = 2e3) {
		super(),
			(this.isPerspectiveCamera = !0),
			(this.type = 'PerspectiveCamera'),
			(this.fov = e),
			(this.zoom = 1),
			(this.near = n),
			(this.far = s),
			(this.focus = 10),
			(this.aspect = t),
			(this.view = null),
			(this.filmGauge = 35),
			(this.filmOffset = 0),
			this.updateProjectionMatrix();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.fov = e.fov),
			(this.zoom = e.zoom),
			(this.near = e.near),
			(this.far = e.far),
			(this.focus = e.focus),
			(this.aspect = e.aspect),
			(this.view = e.view === null ? null : Object.assign({}, e.view)),
			(this.filmGauge = e.filmGauge),
			(this.filmOffset = e.filmOffset),
			this
		);
	}
	setFocalLength(e) {
		const t = (0.5 * this.getFilmHeight()) / e;
		(this.fov = Zl * 2 * Math.atan(t)), this.updateProjectionMatrix();
	}
	getFocalLength() {
		const e = Math.tan(va * 0.5 * this.fov);
		return (0.5 * this.getFilmHeight()) / e;
	}
	getEffectiveFOV() {
		return Zl * 2 * Math.atan(Math.tan(va * 0.5 * this.fov) / this.zoom);
	}
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1);
	}
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1);
	}
	getViewBounds(e, t, n) {
		Nr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
			t.set(Nr.x, Nr.y).multiplyScalar(-e / Nr.z),
			Nr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
			n.set(Nr.x, Nr.y).multiplyScalar(-e / Nr.z);
	}
	getViewSize(e, t) {
		return this.getViewBounds(e, cx, hx), t.subVectors(hx, cx);
	}
	setViewOffset(e, t, n, s, r, o) {
		(this.aspect = e / t),
			this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
			(this.view.enabled = !0),
			(this.view.fullWidth = e),
			(this.view.fullHeight = t),
			(this.view.offsetX = n),
			(this.view.offsetY = s),
			(this.view.width = r),
			(this.view.height = o),
			this.updateProjectionMatrix();
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const e = this.near;
		let t = (e * Math.tan(va * 0.5 * this.fov)) / this.zoom,
			n = 2 * t,
			s = this.aspect * n,
			r = -0.5 * s;
		const o = this.view;
		if (this.view !== null && this.view.enabled) {
			const l = o.fullWidth,
				c = o.fullHeight;
			(r += (o.offsetX * s) / l), (t -= (o.offsetY * n) / c), (s *= o.width / l), (n *= o.height / c);
		}
		const a = this.filmOffset;
		a !== 0 && (r += (e * a) / this.getFilmWidth()),
			this.projectionMatrix.makePerspective(r, r + s, t, t - n, e, this.far, this.coordinateSystem),
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.fov = this.fov),
			(t.object.zoom = this.zoom),
			(t.object.near = this.near),
			(t.object.far = this.far),
			(t.object.focus = this.focus),
			(t.object.aspect = this.aspect),
			this.view !== null && (t.object.view = Object.assign({}, this.view)),
			(t.object.filmGauge = this.filmGauge),
			(t.object.filmOffset = this.filmOffset),
			t
		);
	}
}
const ll = -90,
	cl = 1;
class uE extends ft {
	constructor(e, t, n) {
		super(), (this.type = 'CubeCamera'), (this.renderTarget = n), (this.coordinateSystem = null), (this.activeMipmapLevel = 0);
		const s = new fn(ll, cl, e, t);
		(s.layers = this.layers), this.add(s);
		const r = new fn(ll, cl, e, t);
		(r.layers = this.layers), this.add(r);
		const o = new fn(ll, cl, e, t);
		(o.layers = this.layers), this.add(o);
		const a = new fn(ll, cl, e, t);
		(a.layers = this.layers), this.add(a);
		const l = new fn(ll, cl, e, t);
		(l.layers = this.layers), this.add(l);
		const c = new fn(ll, cl, e, t);
		(c.layers = this.layers), this.add(c);
	}
	updateCoordinateSystem() {
		const e = this.coordinateSystem,
			t = this.children.concat(),
			[n, s, r, o, a, l] = t;
		for (const c of t) this.remove(c);
		if (e === Vs)
			n.up.set(0, 1, 0),
				n.lookAt(1, 0, 0),
				s.up.set(0, 1, 0),
				s.lookAt(-1, 0, 0),
				r.up.set(0, 0, -1),
				r.lookAt(0, 1, 0),
				o.up.set(0, 0, 1),
				o.lookAt(0, -1, 0),
				a.up.set(0, 1, 0),
				a.lookAt(0, 0, 1),
				l.up.set(0, 1, 0),
				l.lookAt(0, 0, -1);
		else if (e === Eh)
			n.up.set(0, -1, 0),
				n.lookAt(-1, 0, 0),
				s.up.set(0, -1, 0),
				s.lookAt(1, 0, 0),
				r.up.set(0, 0, 1),
				r.lookAt(0, 1, 0),
				o.up.set(0, 0, -1),
				o.lookAt(0, -1, 0),
				a.up.set(0, -1, 0),
				a.lookAt(0, 0, 1),
				l.up.set(0, -1, 0),
				l.lookAt(0, 0, -1);
		else throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + e);
		for (const c of t) this.add(c), c.updateMatrixWorld();
	}
	update(e, t) {
		this.parent === null && this.updateMatrixWorld();
		const { renderTarget: n, activeMipmapLevel: s } = this;
		this.coordinateSystem !== e.coordinateSystem && ((this.coordinateSystem = e.coordinateSystem), this.updateCoordinateSystem());
		const [r, o, a, l, c, h] = this.children,
			u = e.getRenderTarget(),
			d = e.getActiveCubeFace(),
			p = e.getActiveMipmapLevel(),
			g = e.xr.enabled;
		e.xr.enabled = !1;
		const v = n.texture.generateMipmaps;
		(n.texture.generateMipmaps = !1),
			e.setRenderTarget(n, 0, s),
			e.render(t, r),
			e.setRenderTarget(n, 1, s),
			e.render(t, o),
			e.setRenderTarget(n, 2, s),
			e.render(t, a),
			e.setRenderTarget(n, 3, s),
			e.render(t, l),
			e.setRenderTarget(n, 4, s),
			e.render(t, c),
			(n.texture.generateMipmaps = v),
			e.setRenderTarget(n, 5, s),
			e.render(t, h),
			e.setRenderTarget(u, d, p),
			(e.xr.enabled = g),
			(n.texture.needsPMREMUpdate = !0);
	}
}
class Jh extends zt {
	constructor(e, t, n, s, r, o, a, l, c, h) {
		(e = e !== void 0 ? e : []),
			(t = t !== void 0 ? t : _r),
			super(e, t, n, s, r, o, a, l, c, h),
			(this.isCubeTexture = !0),
			(this.flipY = !1);
	}
	get images() {
		return this.image;
	}
	set images(e) {
		this.image = e;
	}
}
class dE extends yn {
	constructor(e = 1, t = {}) {
		super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
		const n = { width: e, height: e, depth: 1 },
			s = [n, n, n, n, n, n];
		(this.texture = new Jh(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace)),
			(this.texture.isRenderTargetTexture = !0),
			(this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
			(this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Tt);
	}
	fromEquirectangularTexture(e, t) {
		(this.texture.type = t.type),
			(this.texture.colorSpace = t.colorSpace),
			(this.texture.generateMipmaps = t.generateMipmaps),
			(this.texture.minFilter = t.minFilter),
			(this.texture.magFilter = t.magFilter);
		const n = {
				uniforms: { tEquirect: { value: null } },
				vertexShader:
					'\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			',
				fragmentShader:
					'\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			',
			},
			s = new za(5, 5, 5),
			r = new xn({
				name: 'CubemapFromEquirect',
				uniforms: Jl(n.uniforms),
				vertexShader: n.vertexShader,
				fragmentShader: n.fragmentShader,
				side: gn,
				blending: jn,
			});
		r.uniforms.tEquirect.value = t;
		const o = new bt(s, r),
			a = t.minFilter;
		return (
			t.minFilter === ts && (t.minFilter = Tt),
			new uE(1, 10, this).update(e, o),
			(t.minFilter = a),
			o.geometry.dispose(),
			o.material.dispose(),
			this
		);
	}
	clear(e, t, n, s) {
		const r = e.getRenderTarget();
		for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, s);
		e.setRenderTarget(r);
	}
}
const nm = new I(),
	PI = new I(),
	LI = new et();
class Zr {
	constructor(e = new I(1, 0, 0), t = 0) {
		(this.isPlane = !0), (this.normal = e), (this.constant = t);
	}
	set(e, t) {
		return this.normal.copy(e), (this.constant = t), this;
	}
	setComponents(e, t, n, s) {
		return this.normal.set(e, t, n), (this.constant = s), this;
	}
	setFromNormalAndCoplanarPoint(e, t) {
		return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
	}
	setFromCoplanarPoints(e, t, n) {
		const s = nm.subVectors(n, t).cross(PI.subVectors(e, t)).normalize();
		return this.setFromNormalAndCoplanarPoint(s, e), this;
	}
	copy(e) {
		return this.normal.copy(e.normal), (this.constant = e.constant), this;
	}
	normalize() {
		const e = 1 / this.normal.length();
		return this.normal.multiplyScalar(e), (this.constant *= e), this;
	}
	negate() {
		return (this.constant *= -1), this.normal.negate(), this;
	}
	distanceToPoint(e) {
		return this.normal.dot(e) + this.constant;
	}
	distanceToSphere(e) {
		return this.distanceToPoint(e.center) - e.radius;
	}
	projectPoint(e, t) {
		return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
	}
	intersectLine(e, t) {
		const n = e.delta(nm),
			s = this.normal.dot(n);
		if (s === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
		const r = -(e.start.dot(this.normal) + this.constant) / s;
		return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
	}
	intersectsLine(e) {
		const t = this.distanceToPoint(e.start),
			n = this.distanceToPoint(e.end);
		return (t < 0 && n > 0) || (n < 0 && t > 0);
	}
	intersectsBox(e) {
		return e.intersectsPlane(this);
	}
	intersectsSphere(e) {
		return e.intersectsPlane(this);
	}
	coplanarPoint(e) {
		return e.copy(this.normal).multiplyScalar(-this.constant);
	}
	applyMatrix4(e, t) {
		const n = t || LI.getNormalMatrix(e),
			s = this.coplanarPoint(nm).applyMatrix4(e),
			r = this.normal.applyMatrix3(n).normalize();
		return (this.constant = -s.dot(r)), this;
	}
	translate(e) {
		return (this.constant -= e.dot(this.normal)), this;
	}
	equals(e) {
		return e.normal.equals(this.normal) && e.constant === this.constant;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const ko = new un(),
	Yu = new I();
class Qh {
	constructor(e = new Zr(), t = new Zr(), n = new Zr(), s = new Zr(), r = new Zr(), o = new Zr()) {
		this.planes = [e, t, n, s, r, o];
	}
	set(e, t, n, s, r, o) {
		const a = this.planes;
		return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(s), a[4].copy(r), a[5].copy(o), this;
	}
	copy(e) {
		const t = this.planes;
		for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
		return this;
	}
	setFromProjectionMatrix(e, t = Vs) {
		const n = this.planes,
			s = e.elements,
			r = s[0],
			o = s[1],
			a = s[2],
			l = s[3],
			c = s[4],
			h = s[5],
			u = s[6],
			d = s[7],
			p = s[8],
			g = s[9],
			v = s[10],
			m = s[11],
			f = s[12],
			y = s[13],
			_ = s[14],
			x = s[15];
		if (
			(n[0].setComponents(l - r, d - c, m - p, x - f).normalize(),
			n[1].setComponents(l + r, d + c, m + p, x + f).normalize(),
			n[2].setComponents(l + o, d + h, m + g, x + y).normalize(),
			n[3].setComponents(l - o, d - h, m - g, x - y).normalize(),
			n[4].setComponents(l - a, d - u, m - v, x - _).normalize(),
			t === Vs)
		)
			n[5].setComponents(l + a, d + u, m + v, x + _).normalize();
		else if (t === Eh) n[5].setComponents(a, u, v, _).normalize();
		else throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + t);
		return this;
	}
	intersectsObject(e) {
		if (e.boundingSphere !== void 0)
			e.boundingSphere === null && e.computeBoundingSphere(), ko.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
		else {
			const t = e.geometry;
			t.boundingSphere === null && t.computeBoundingSphere(), ko.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
		}
		return this.intersectsSphere(ko);
	}
	intersectsSprite(e) {
		return ko.center.set(0, 0, 0), (ko.radius = 0.7071067811865476), ko.applyMatrix4(e.matrixWorld), this.intersectsSphere(ko);
	}
	intersectsSphere(e) {
		const t = this.planes,
			n = e.center,
			s = -e.radius;
		for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(n) < s) return !1;
		return !0;
	}
	intersectsBox(e) {
		const t = this.planes;
		for (let n = 0; n < 6; n++) {
			const s = t[n];
			if (
				((Yu.x = s.normal.x > 0 ? e.max.x : e.min.x),
				(Yu.y = s.normal.y > 0 ? e.max.y : e.min.y),
				(Yu.z = s.normal.z > 0 ? e.max.z : e.min.z),
				s.distanceToPoint(Yu) < 0)
			)
				return !1;
		}
		return !0;
	}
	containsPoint(e) {
		const t = this.planes;
		for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
		return !0;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
function pE() {
	let i = null,
		e = !1,
		t = null,
		n = null;
	function s(r, o) {
		t(r, o), (n = i.requestAnimationFrame(s));
	}
	return {
		start: function () {
			e !== !0 && t !== null && ((n = i.requestAnimationFrame(s)), (e = !0));
		},
		stop: function () {
			i.cancelAnimationFrame(n), (e = !1);
		},
		setAnimationLoop: function (r) {
			t = r;
		},
		setContext: function (r) {
			i = r;
		},
	};
}
function II(i) {
	const e = new WeakMap();
	function t(a, l) {
		const c = a.array,
			h = a.usage,
			u = c.byteLength,
			d = i.createBuffer();
		i.bindBuffer(l, d), i.bufferData(l, c, h), a.onUploadCallback();
		let p;
		if (c instanceof Float32Array) p = i.FLOAT;
		else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? (p = i.HALF_FLOAT) : (p = i.UNSIGNED_SHORT);
		else if (c instanceof Int16Array) p = i.SHORT;
		else if (c instanceof Uint32Array) p = i.UNSIGNED_INT;
		else if (c instanceof Int32Array) p = i.INT;
		else if (c instanceof Int8Array) p = i.BYTE;
		else if (c instanceof Uint8Array) p = i.UNSIGNED_BYTE;
		else if (c instanceof Uint8ClampedArray) p = i.UNSIGNED_BYTE;
		else throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + c);
		return { buffer: d, type: p, bytesPerElement: c.BYTES_PER_ELEMENT, version: a.version, size: u };
	}
	function n(a, l, c) {
		const h = l.array,
			u = l._updateRange,
			d = l.updateRanges;
		if ((i.bindBuffer(c, a), u.count === -1 && d.length === 0 && i.bufferSubData(c, 0, h), d.length !== 0)) {
			for (let p = 0, g = d.length; p < g; p++) {
				const v = d[p];
				i.bufferSubData(c, v.start * h.BYTES_PER_ELEMENT, h, v.start, v.count);
			}
			l.clearUpdateRanges();
		}
		u.count !== -1 && (i.bufferSubData(c, u.offset * h.BYTES_PER_ELEMENT, h, u.offset, u.count), (u.count = -1)), l.onUploadCallback();
	}
	function s(a) {
		return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
	}
	function r(a) {
		a.isInterleavedBufferAttribute && (a = a.data);
		const l = e.get(a);
		l && (i.deleteBuffer(l.buffer), e.delete(a));
	}
	function o(a, l) {
		if (a.isGLBufferAttribute) {
			const h = e.get(a);
			(!h || h.version < a.version) &&
				e.set(a, { buffer: a.buffer, type: a.type, bytesPerElement: a.elementSize, version: a.version });
			return;
		}
		a.isInterleavedBufferAttribute && (a = a.data);
		const c = e.get(a);
		if (c === void 0) e.set(a, t(a, l));
		else if (c.version < a.version) {
			if (c.size !== a.array.byteLength)
				throw new Error(
					"THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
				);
			n(c.buffer, a, l), (c.version = a.version);
		}
	}
	return { get: s, remove: r, update: o };
}
class js extends Ze {
	constructor(e = 1, t = 1, n = 1, s = 1) {
		super(), (this.type = 'PlaneGeometry'), (this.parameters = { width: e, height: t, widthSegments: n, heightSegments: s });
		const r = e / 2,
			o = t / 2,
			a = Math.floor(n),
			l = Math.floor(s),
			c = a + 1,
			h = l + 1,
			u = e / a,
			d = t / l,
			p = [],
			g = [],
			v = [],
			m = [];
		for (let f = 0; f < h; f++) {
			const y = f * d - o;
			for (let _ = 0; _ < c; _++) {
				const x = _ * u - r;
				g.push(x, -y, 0), v.push(0, 0, 1), m.push(_ / a), m.push(1 - f / l);
			}
		}
		for (let f = 0; f < l; f++)
			for (let y = 0; y < a; y++) {
				const _ = y + c * f,
					x = y + c * (f + 1),
					E = y + 1 + c * (f + 1),
					w = y + 1 + c * f;
				p.push(_, x, w), p.push(x, E, w);
			}
		this.setIndex(p),
			this.setAttribute('position', new ze(g, 3)),
			this.setAttribute('normal', new ze(v, 3)),
			this.setAttribute('uv', new ze(m, 2));
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new js(e.width, e.height, e.widthSegments, e.heightSegments);
	}
}
var DI = '#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif',
	OI =
		'#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif',
	UI = '#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif',
	NI = '#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif',
	FI =
		'#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif',
	BI = '#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif',
	kI =
		'#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif',
	zI = '#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif',
	VI =
		'#ifdef USE_BATCHING\n	attribute float batchId;\n	uniform highp sampler2D batchingTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif',
	HI = '#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif',
	GI = 'vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif',
	WI = 'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif',
	XI =
		'float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated',
	qI =
		'#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif',
	YI =
		'#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif',
	jI =
		'#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif',
	KI = '#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif',
	$I = '#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif',
	ZI = '#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif',
	JI = '#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif',
	QI = '#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif',
	e2 =
		'#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif',
	t2 =
		'#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif',
	n2 =
		'#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated',
	i2 =
		'#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif',
	s2 =
		'vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif',
	r2 =
		'#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif',
	o2 =
		'#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif',
	a2 =
		'#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif',
	l2 = '#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif',
	c2 = 'gl_FragColor = linearToOutputTexel( gl_FragColor );',
	h2 =
		'\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}',
	u2 =
		'#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif',
	d2 =
		'#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif',
	p2 =
		'#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif',
	f2 =
		'#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif',
	m2 =
		'#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif',
	g2 = '#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif',
	v2 = '#ifdef USE_FOG\n	varying float vFogDepth;\n#endif',
	_2 =
		'#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif',
	y2 =
		'#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif',
	x2 =
		'#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}',
	b2 = '#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif',
	w2 = 'LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;',
	S2 =
		'varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert',
	M2 =
		'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif',
	E2 =
		'#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif',
	T2 = 'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;',
	A2 =
		'varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon',
	C2 =
		'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;',
	R2 =
		'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong',
	P2 =
		'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif',
	L2 =
		'struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}',
	I2 =
		'\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif',
	D2 =
		'#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif',
	O2 =
		'#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif',
	U2 =
		'#if defined( USE_LOGDEPTHBUF )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
	N2 = '#if defined( USE_LOGDEPTHBUF )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif',
	F2 = '#ifdef USE_LOGDEPTHBUF\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif',
	B2 =
		'#ifdef USE_LOGDEPTHBUF\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif',
	k2 =
		'#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif',
	z2 = '#ifdef USE_MAP\n	uniform sampler2D map;\n#endif',
	V2 =
		'#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif',
	H2 =
		'#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif',
	G2 =
		'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif',
	W2 = '#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif',
	X2 =
		'#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[MORPHTARGETS_COUNT];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif',
	q2 =
		'#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif',
	Y2 =
		'#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif',
	j2 =
		'#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n	#endif\n	#ifdef MORPHTARGETS_TEXTURE\n		#ifndef USE_INSTANCING_MORPH\n			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		#endif\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif',
	K2 =
		'#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif',
	$2 =
		'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;',
	Z2 =
		'#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif',
	J2 = '#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif',
	Q2 = '#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif',
	eD =
		'#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif',
	tD =
		'#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif',
	nD = '#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif',
	iD =
		'#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif',
	sD =
		'#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif',
	rD =
		'#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif',
	oD =
		'#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );',
	aD =
		'vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}',
	lD = '#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif',
	cD =
		'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;',
	hD = '#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif',
	uD =
		'#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif',
	dD =
		'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif',
	pD = '#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif',
	fD =
		'#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		\n		float lightToPositionLength = length( lightToPosition );\n		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;\n			vec3 bd3D = normalize( lightToPosition );\n			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n				shadow = (\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n				) * ( 1.0 / 9.0 );\n			#else\n				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n			#endif\n		}\n		return shadow;\n	}\n#endif',
	mD =
		'#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif',
	gD =
		'#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif',
	vD =
		'float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}',
	_D =
		'#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
	yD =
		'#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif',
	xD =
		'#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif',
	bD =
		'#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif',
	wD =
		'float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif',
	SD = '#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif',
	MD = '#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif',
	ED =
		'#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }',
	TD =
		'#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif',
	AD =
		'#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n		\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n		\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		\n		#else\n		\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif',
	CD =
		'#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif',
	RD =
		'#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif',
	PD =
		'#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif',
	LD =
		'#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif';
const ID =
		'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}',
	DD =
		'uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
	OD =
		'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}',
	UD =
		'#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
	ND =
		'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}',
	FD =
		'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
	BD =
		'#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}',
	kD =
		'#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}',
	zD =
		'#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}',
	VD =
		'#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}',
	HD =
		'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}',
	GD =
		'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}',
	WD =
		'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}',
	XD =
		'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}',
	qD =
		'#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}',
	YD =
		'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
	jD =
		'#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
	KD =
		'#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
	$D =
		'#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}',
	ZD =
		'#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
	JD =
		'#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}',
	QD =
		'#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}',
	eO =
		'#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
	tO =
		'#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
	nO =
		'#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}',
	iO =
		'#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
	sO =
		'#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
	rO =
		'#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}',
	oO =
		'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}',
	aO =
		'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}',
	lO =
		'#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}',
	cO =
		'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}',
	hO =
		'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}',
	uO =
		'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}',
	rt = {
		alphahash_fragment: DI,
		alphahash_pars_fragment: OI,
		alphamap_fragment: UI,
		alphamap_pars_fragment: NI,
		alphatest_fragment: FI,
		alphatest_pars_fragment: BI,
		aomap_fragment: kI,
		aomap_pars_fragment: zI,
		batching_pars_vertex: VI,
		batching_vertex: HI,
		begin_vertex: GI,
		beginnormal_vertex: WI,
		bsdfs: XI,
		iridescence_fragment: qI,
		bumpmap_pars_fragment: YI,
		clipping_planes_fragment: jI,
		clipping_planes_pars_fragment: KI,
		clipping_planes_pars_vertex: $I,
		clipping_planes_vertex: ZI,
		color_fragment: JI,
		color_pars_fragment: QI,
		color_pars_vertex: e2,
		color_vertex: t2,
		common: n2,
		cube_uv_reflection_fragment: i2,
		defaultnormal_vertex: s2,
		displacementmap_pars_vertex: r2,
		displacementmap_vertex: o2,
		emissivemap_fragment: a2,
		emissivemap_pars_fragment: l2,
		colorspace_fragment: c2,
		colorspace_pars_fragment: h2,
		envmap_fragment: u2,
		envmap_common_pars_fragment: d2,
		envmap_pars_fragment: p2,
		envmap_pars_vertex: f2,
		envmap_physical_pars_fragment: E2,
		envmap_vertex: m2,
		fog_vertex: g2,
		fog_pars_vertex: v2,
		fog_fragment: _2,
		fog_pars_fragment: y2,
		gradientmap_pars_fragment: x2,
		lightmap_pars_fragment: b2,
		lights_lambert_fragment: w2,
		lights_lambert_pars_fragment: S2,
		lights_pars_begin: M2,
		lights_toon_fragment: T2,
		lights_toon_pars_fragment: A2,
		lights_phong_fragment: C2,
		lights_phong_pars_fragment: R2,
		lights_physical_fragment: P2,
		lights_physical_pars_fragment: L2,
		lights_fragment_begin: I2,
		lights_fragment_maps: D2,
		lights_fragment_end: O2,
		logdepthbuf_fragment: U2,
		logdepthbuf_pars_fragment: N2,
		logdepthbuf_pars_vertex: F2,
		logdepthbuf_vertex: B2,
		map_fragment: k2,
		map_pars_fragment: z2,
		map_particle_fragment: V2,
		map_particle_pars_fragment: H2,
		metalnessmap_fragment: G2,
		metalnessmap_pars_fragment: W2,
		morphinstance_vertex: X2,
		morphcolor_vertex: q2,
		morphnormal_vertex: Y2,
		morphtarget_pars_vertex: j2,
		morphtarget_vertex: K2,
		normal_fragment_begin: $2,
		normal_fragment_maps: Z2,
		normal_pars_fragment: J2,
		normal_pars_vertex: Q2,
		normal_vertex: eD,
		normalmap_pars_fragment: tD,
		clearcoat_normal_fragment_begin: nD,
		clearcoat_normal_fragment_maps: iD,
		clearcoat_pars_fragment: sD,
		iridescence_pars_fragment: rD,
		opaque_fragment: oD,
		packing: aD,
		premultiplied_alpha_fragment: lD,
		project_vertex: cD,
		dithering_fragment: hD,
		dithering_pars_fragment: uD,
		roughnessmap_fragment: dD,
		roughnessmap_pars_fragment: pD,
		shadowmap_pars_fragment: fD,
		shadowmap_pars_vertex: mD,
		shadowmap_vertex: gD,
		shadowmask_pars_fragment: vD,
		skinbase_vertex: _D,
		skinning_pars_vertex: yD,
		skinning_vertex: xD,
		skinnormal_vertex: bD,
		specularmap_fragment: wD,
		specularmap_pars_fragment: SD,
		tonemapping_fragment: MD,
		tonemapping_pars_fragment: ED,
		transmission_fragment: TD,
		transmission_pars_fragment: AD,
		uv_pars_fragment: CD,
		uv_pars_vertex: RD,
		uv_vertex: PD,
		worldpos_vertex: LD,
		background_vert: ID,
		background_frag: DD,
		backgroundCube_vert: OD,
		backgroundCube_frag: UD,
		cube_vert: ND,
		cube_frag: FD,
		depth_vert: BD,
		depth_frag: kD,
		distanceRGBA_vert: zD,
		distanceRGBA_frag: VD,
		equirect_vert: HD,
		equirect_frag: GD,
		linedashed_vert: WD,
		linedashed_frag: XD,
		meshbasic_vert: qD,
		meshbasic_frag: YD,
		meshlambert_vert: jD,
		meshlambert_frag: KD,
		meshmatcap_vert: $D,
		meshmatcap_frag: ZD,
		meshnormal_vert: JD,
		meshnormal_frag: QD,
		meshphong_vert: eO,
		meshphong_frag: tO,
		meshphysical_vert: nO,
		meshphysical_frag: iO,
		meshtoon_vert: sO,
		meshtoon_frag: rO,
		points_vert: oO,
		points_frag: aO,
		shadow_vert: lO,
		shadow_frag: cO,
		sprite_vert: hO,
		sprite_frag: uO,
	},
	Pe = {
		common: {
			diffuse: { value: new Ee(16777215) },
			opacity: { value: 1 },
			map: { value: null },
			mapTransform: { value: new et() },
			alphaMap: { value: null },
			alphaMapTransform: { value: new et() },
			alphaTest: { value: 0 },
		},
		specularmap: { specularMap: { value: null }, specularMapTransform: { value: new et() } },
		envmap: {
			envMap: { value: null },
			envMapRotation: { value: new et() },
			flipEnvMap: { value: -1 },
			reflectivity: { value: 1 },
			ior: { value: 1.5 },
			refractionRatio: { value: 0.98 },
		},
		aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new et() } },
		lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new et() } },
		bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new et() }, bumpScale: { value: 1 } },
		normalmap: { normalMap: { value: null }, normalMapTransform: { value: new et() }, normalScale: { value: new ce(1, 1) } },
		displacementmap: {
			displacementMap: { value: null },
			displacementMapTransform: { value: new et() },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 },
		},
		emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new et() } },
		metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new et() } },
		roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new et() } },
		gradientmap: { gradientMap: { value: null } },
		fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ee(16777215) } },
		lights: {
			ambientLightColor: { value: [] },
			lightProbe: { value: [] },
			directionalLights: { value: [], properties: { direction: {}, color: {} } },
			directionalLightShadows: {
				value: [],
				properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} },
			},
			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },
			spotLights: {
				value: [],
				properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} },
			},
			spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } },
			spotLightMap: { value: [] },
			spotShadowMap: { value: [] },
			spotLightMatrix: { value: [] },
			pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } },
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {},
				},
			},
			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },
			hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } },
			rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } },
			ltc_1: { value: null },
			ltc_2: { value: null },
		},
		points: {
			diffuse: { value: new Ee(16777215) },
			opacity: { value: 1 },
			size: { value: 1 },
			scale: { value: 1 },
			map: { value: null },
			alphaMap: { value: null },
			alphaMapTransform: { value: new et() },
			alphaTest: { value: 0 },
			uvTransform: { value: new et() },
		},
		sprite: {
			diffuse: { value: new Ee(16777215) },
			opacity: { value: 1 },
			center: { value: new ce(0.5, 0.5) },
			rotation: { value: 0 },
			map: { value: null },
			mapTransform: { value: new et() },
			alphaMap: { value: null },
			alphaMapTransform: { value: new et() },
			alphaTest: { value: 0 },
		},
	},
	_s = {
		basic: {
			uniforms: ii([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.fog]),
			vertexShader: rt.meshbasic_vert,
			fragmentShader: rt.meshbasic_frag,
		},
		lambert: {
			uniforms: ii([
				Pe.common,
				Pe.specularmap,
				Pe.envmap,
				Pe.aomap,
				Pe.lightmap,
				Pe.emissivemap,
				Pe.bumpmap,
				Pe.normalmap,
				Pe.displacementmap,
				Pe.fog,
				Pe.lights,
				{ emissive: { value: new Ee(0) } },
			]),
			vertexShader: rt.meshlambert_vert,
			fragmentShader: rt.meshlambert_frag,
		},
		phong: {
			uniforms: ii([
				Pe.common,
				Pe.specularmap,
				Pe.envmap,
				Pe.aomap,
				Pe.lightmap,
				Pe.emissivemap,
				Pe.bumpmap,
				Pe.normalmap,
				Pe.displacementmap,
				Pe.fog,
				Pe.lights,
				{ emissive: { value: new Ee(0) }, specular: { value: new Ee(1118481) }, shininess: { value: 30 } },
			]),
			vertexShader: rt.meshphong_vert,
			fragmentShader: rt.meshphong_frag,
		},
		standard: {
			uniforms: ii([
				Pe.common,
				Pe.envmap,
				Pe.aomap,
				Pe.lightmap,
				Pe.emissivemap,
				Pe.bumpmap,
				Pe.normalmap,
				Pe.displacementmap,
				Pe.roughnessmap,
				Pe.metalnessmap,
				Pe.fog,
				Pe.lights,
				{ emissive: { value: new Ee(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } },
			]),
			vertexShader: rt.meshphysical_vert,
			fragmentShader: rt.meshphysical_frag,
		},
		toon: {
			uniforms: ii([
				Pe.common,
				Pe.aomap,
				Pe.lightmap,
				Pe.emissivemap,
				Pe.bumpmap,
				Pe.normalmap,
				Pe.displacementmap,
				Pe.gradientmap,
				Pe.fog,
				Pe.lights,
				{ emissive: { value: new Ee(0) } },
			]),
			vertexShader: rt.meshtoon_vert,
			fragmentShader: rt.meshtoon_frag,
		},
		matcap: {
			uniforms: ii([Pe.common, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, { matcap: { value: null } }]),
			vertexShader: rt.meshmatcap_vert,
			fragmentShader: rt.meshmatcap_frag,
		},
		points: { uniforms: ii([Pe.points, Pe.fog]), vertexShader: rt.points_vert, fragmentShader: rt.points_frag },
		dashed: {
			uniforms: ii([Pe.common, Pe.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]),
			vertexShader: rt.linedashed_vert,
			fragmentShader: rt.linedashed_frag,
		},
		depth: { uniforms: ii([Pe.common, Pe.displacementmap]), vertexShader: rt.depth_vert, fragmentShader: rt.depth_frag },
		normal: {
			uniforms: ii([Pe.common, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, { opacity: { value: 1 } }]),
			vertexShader: rt.meshnormal_vert,
			fragmentShader: rt.meshnormal_frag,
		},
		sprite: { uniforms: ii([Pe.sprite, Pe.fog]), vertexShader: rt.sprite_vert, fragmentShader: rt.sprite_frag },
		background: {
			uniforms: { uvTransform: { value: new et() }, t2D: { value: null }, backgroundIntensity: { value: 1 } },
			vertexShader: rt.background_vert,
			fragmentShader: rt.background_frag,
		},
		backgroundCube: {
			uniforms: {
				envMap: { value: null },
				flipEnvMap: { value: -1 },
				backgroundBlurriness: { value: 0 },
				backgroundIntensity: { value: 1 },
				backgroundRotation: { value: new et() },
			},
			vertexShader: rt.backgroundCube_vert,
			fragmentShader: rt.backgroundCube_frag,
		},
		cube: {
			uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
			vertexShader: rt.cube_vert,
			fragmentShader: rt.cube_frag,
		},
		equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: rt.equirect_vert, fragmentShader: rt.equirect_frag },
		distanceRGBA: {
			uniforms: ii([
				Pe.common,
				Pe.displacementmap,
				{ referencePosition: { value: new I() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } },
			]),
			vertexShader: rt.distanceRGBA_vert,
			fragmentShader: rt.distanceRGBA_frag,
		},
		shadow: {
			uniforms: ii([Pe.lights, Pe.fog, { color: { value: new Ee(0) }, opacity: { value: 1 } }]),
			vertexShader: rt.shadow_vert,
			fragmentShader: rt.shadow_frag,
		},
	};
_s.physical = {
	uniforms: ii([
		_s.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatMapTransform: { value: new et() },
			clearcoatNormalMap: { value: null },
			clearcoatNormalMapTransform: { value: new et() },
			clearcoatNormalScale: { value: new ce(1, 1) },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatRoughnessMapTransform: { value: new et() },
			dispersion: { value: 0 },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceMapTransform: { value: new et() },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			iridescenceThicknessMapTransform: { value: new et() },
			sheen: { value: 0 },
			sheenColor: { value: new Ee(0) },
			sheenColorMap: { value: null },
			sheenColorMapTransform: { value: new et() },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			sheenRoughnessMapTransform: { value: new et() },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionMapTransform: { value: new et() },
			transmissionSamplerSize: { value: new ce() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			thicknessMapTransform: { value: new et() },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: new Ee(0) },
			specularColor: { value: new Ee(1, 1, 1) },
			specularColorMap: { value: null },
			specularColorMapTransform: { value: new et() },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularIntensityMapTransform: { value: new et() },
			anisotropyVector: { value: new ce() },
			anisotropyMap: { value: null },
			anisotropyMapTransform: { value: new et() },
		},
	]),
	vertexShader: rt.meshphysical_vert,
	fragmentShader: rt.meshphysical_frag,
};
const ju = { r: 0, b: 0, g: 0 },
	zo = new zi(),
	dO = new He();
function pO(i, e, t, n, s, r, o) {
	const a = new Ee(0);
	let l = r === !0 ? 0 : 1,
		c,
		h,
		u = null,
		d = 0,
		p = null;
	function g(y) {
		let _ = y.isScene === !0 ? y.background : null;
		return _ && _.isTexture && (_ = (y.backgroundBlurriness > 0 ? t : e).get(_)), _;
	}
	function v(y) {
		let _ = !1;
		const x = g(y);
		x === null ? f(a, l) : x && x.isColor && (f(x, 1), (_ = !0));
		const E = i.xr.getEnvironmentBlendMode();
		E === 'additive' ? n.buffers.color.setClear(0, 0, 0, 1, o) : E === 'alpha-blend' && n.buffers.color.setClear(0, 0, 0, 0, o),
			(i.autoClear || _) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil);
	}
	function m(y, _) {
		const x = g(_);
		x && (x.isCubeTexture || x.mapping === lc)
			? (h === void 0 &&
					((h = new bt(
						new za(1, 1, 1),
						new xn({
							name: 'BackgroundCubeMaterial',
							uniforms: Jl(_s.backgroundCube.uniforms),
							vertexShader: _s.backgroundCube.vertexShader,
							fragmentShader: _s.backgroundCube.fragmentShader,
							side: gn,
							depthTest: !1,
							depthWrite: !1,
							fog: !1,
						})
					)),
					h.geometry.deleteAttribute('normal'),
					h.geometry.deleteAttribute('uv'),
					(h.onBeforeRender = function (E, w, C) {
						this.matrixWorld.copyPosition(C.matrixWorld);
					}),
					Object.defineProperty(h.material, 'envMap', {
						get: function () {
							return this.uniforms.envMap.value;
						},
					}),
					s.update(h)),
			  zo.copy(_.backgroundRotation),
			  (zo.x *= -1),
			  (zo.y *= -1),
			  (zo.z *= -1),
			  x.isCubeTexture && x.isRenderTargetTexture === !1 && ((zo.y *= -1), (zo.z *= -1)),
			  (h.material.uniforms.envMap.value = x),
			  (h.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
			  (h.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness),
			  (h.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
			  h.material.uniforms.backgroundRotation.value.setFromMatrix4(dO.makeRotationFromEuler(zo)),
			  (h.material.toneMapped = Ft.getTransfer(x.colorSpace) !== Wt),
			  (u !== x || d !== x.version || p !== i.toneMapping) &&
					((h.material.needsUpdate = !0), (u = x), (d = x.version), (p = i.toneMapping)),
			  h.layers.enableAll(),
			  y.unshift(h, h.geometry, h.material, 0, 0, null))
			: x &&
			  x.isTexture &&
			  (c === void 0 &&
					((c = new bt(
						new js(2, 2),
						new xn({
							name: 'BackgroundMaterial',
							uniforms: Jl(_s.background.uniforms),
							vertexShader: _s.background.vertexShader,
							fragmentShader: _s.background.fragmentShader,
							side: Ms,
							depthTest: !1,
							depthWrite: !1,
							fog: !1,
						})
					)),
					c.geometry.deleteAttribute('normal'),
					Object.defineProperty(c.material, 'map', {
						get: function () {
							return this.uniforms.t2D.value;
						},
					}),
					s.update(c)),
			  (c.material.uniforms.t2D.value = x),
			  (c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity),
			  (c.material.toneMapped = Ft.getTransfer(x.colorSpace) !== Wt),
			  x.matrixAutoUpdate === !0 && x.updateMatrix(),
			  c.material.uniforms.uvTransform.value.copy(x.matrix),
			  (u !== x || d !== x.version || p !== i.toneMapping) &&
					((c.material.needsUpdate = !0), (u = x), (d = x.version), (p = i.toneMapping)),
			  c.layers.enableAll(),
			  y.unshift(c, c.geometry, c.material, 0, 0, null));
	}
	function f(y, _) {
		y.getRGB(ju, cE(i)), n.buffers.color.setClear(ju.r, ju.g, ju.b, _, o);
	}
	return {
		getClearColor: function () {
			return a;
		},
		setClearColor: function (y, _ = 1) {
			a.set(y), (l = _), f(a, l);
		},
		getClearAlpha: function () {
			return l;
		},
		setClearAlpha: function (y) {
			(l = y), f(a, l);
		},
		render: v,
		addToRenderList: m,
	};
}
function fO(i, e) {
	const t = i.getParameter(i.MAX_VERTEX_ATTRIBS),
		n = {},
		s = d(null);
	let r = s,
		o = !1;
	function a(M, k, q, B, W) {
		let Q = !1;
		const $ = u(B, q, k);
		r !== $ && ((r = $), c(r.object)),
			(Q = p(M, B, q, W)),
			Q && g(M, B, q, W),
			W !== null && e.update(W, i.ELEMENT_ARRAY_BUFFER),
			(Q || o) && ((o = !1), x(M, k, q, B), W !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(W).buffer));
	}
	function l() {
		return i.createVertexArray();
	}
	function c(M) {
		return i.bindVertexArray(M);
	}
	function h(M) {
		return i.deleteVertexArray(M);
	}
	function u(M, k, q) {
		const B = q.wireframe === !0;
		let W = n[M.id];
		W === void 0 && ((W = {}), (n[M.id] = W));
		let Q = W[k.id];
		Q === void 0 && ((Q = {}), (W[k.id] = Q));
		let $ = Q[B];
		return $ === void 0 && (($ = d(l())), (Q[B] = $)), $;
	}
	function d(M) {
		const k = [],
			q = [],
			B = [];
		for (let W = 0; W < t; W++) (k[W] = 0), (q[W] = 0), (B[W] = 0);
		return {
			geometry: null,
			program: null,
			wireframe: !1,
			newAttributes: k,
			enabledAttributes: q,
			attributeDivisors: B,
			object: M,
			attributes: {},
			index: null,
		};
	}
	function p(M, k, q, B) {
		const W = r.attributes,
			Q = k.attributes;
		let $ = 0;
		const le = q.getAttributes();
		for (const Z in le)
			if (le[Z].location >= 0) {
				const ue = W[Z];
				let Te = Q[Z];
				if (
					(Te === void 0 &&
						(Z === 'instanceMatrix' && M.instanceMatrix && (Te = M.instanceMatrix),
						Z === 'instanceColor' && M.instanceColor && (Te = M.instanceColor)),
					ue === void 0 || ue.attribute !== Te || (Te && ue.data !== Te.data))
				)
					return !0;
				$++;
			}
		return r.attributesNum !== $ || r.index !== B;
	}
	function g(M, k, q, B) {
		const W = {},
			Q = k.attributes;
		let $ = 0;
		const le = q.getAttributes();
		for (const Z in le)
			if (le[Z].location >= 0) {
				let ue = Q[Z];
				ue === void 0 &&
					(Z === 'instanceMatrix' && M.instanceMatrix && (ue = M.instanceMatrix),
					Z === 'instanceColor' && M.instanceColor && (ue = M.instanceColor));
				const Te = {};
				(Te.attribute = ue), ue && ue.data && (Te.data = ue.data), (W[Z] = Te), $++;
			}
		(r.attributes = W), (r.attributesNum = $), (r.index = B);
	}
	function v() {
		const M = r.newAttributes;
		for (let k = 0, q = M.length; k < q; k++) M[k] = 0;
	}
	function m(M) {
		f(M, 0);
	}
	function f(M, k) {
		const q = r.newAttributes,
			B = r.enabledAttributes,
			W = r.attributeDivisors;
		(q[M] = 1), B[M] === 0 && (i.enableVertexAttribArray(M), (B[M] = 1)), W[M] !== k && (i.vertexAttribDivisor(M, k), (W[M] = k));
	}
	function y() {
		const M = r.newAttributes,
			k = r.enabledAttributes;
		for (let q = 0, B = k.length; q < B; q++) k[q] !== M[q] && (i.disableVertexAttribArray(q), (k[q] = 0));
	}
	function _(M, k, q, B, W, Q, $) {
		$ === !0 ? i.vertexAttribIPointer(M, k, q, W, Q) : i.vertexAttribPointer(M, k, q, B, W, Q);
	}
	function x(M, k, q, B) {
		v();
		const W = B.attributes,
			Q = q.getAttributes(),
			$ = k.defaultAttributeValues;
		for (const le in Q) {
			const Z = Q[le];
			if (Z.location >= 0) {
				let xe = W[le];
				if (
					(xe === void 0 &&
						(le === 'instanceMatrix' && M.instanceMatrix && (xe = M.instanceMatrix),
						le === 'instanceColor' && M.instanceColor && (xe = M.instanceColor)),
					xe !== void 0)
				) {
					const ue = xe.normalized,
						Te = xe.itemSize,
						Ae = e.get(xe);
					if (Ae === void 0) continue;
					const We = Ae.buffer,
						se = Ae.type,
						Se = Ae.bytesPerElement,
						we = se === i.INT || se === i.UNSIGNED_INT || xe.gpuType === g_;
					if (xe.isInterleavedBufferAttribute) {
						const X = xe.data,
							ge = X.stride,
							be = xe.offset;
						if (X.isInstancedInterleavedBuffer) {
							for (let H = 0; H < Z.locationSize; H++) f(Z.location + H, X.meshPerAttribute);
							M.isInstancedMesh !== !0 &&
								B._maxInstanceCount === void 0 &&
								(B._maxInstanceCount = X.meshPerAttribute * X.count);
						} else for (let H = 0; H < Z.locationSize; H++) m(Z.location + H);
						i.bindBuffer(i.ARRAY_BUFFER, We);
						for (let H = 0; H < Z.locationSize; H++)
							_(Z.location + H, Te / Z.locationSize, se, ue, ge * Se, (be + (Te / Z.locationSize) * H) * Se, we);
					} else {
						if (xe.isInstancedBufferAttribute) {
							for (let X = 0; X < Z.locationSize; X++) f(Z.location + X, xe.meshPerAttribute);
							M.isInstancedMesh !== !0 &&
								B._maxInstanceCount === void 0 &&
								(B._maxInstanceCount = xe.meshPerAttribute * xe.count);
						} else for (let X = 0; X < Z.locationSize; X++) m(Z.location + X);
						i.bindBuffer(i.ARRAY_BUFFER, We);
						for (let X = 0; X < Z.locationSize; X++)
							_(Z.location + X, Te / Z.locationSize, se, ue, Te * Se, (Te / Z.locationSize) * X * Se, we);
					}
				} else if ($ !== void 0) {
					const ue = $[le];
					if (ue !== void 0)
						switch (ue.length) {
							case 2:
								i.vertexAttrib2fv(Z.location, ue);
								break;
							case 3:
								i.vertexAttrib3fv(Z.location, ue);
								break;
							case 4:
								i.vertexAttrib4fv(Z.location, ue);
								break;
							default:
								i.vertexAttrib1fv(Z.location, ue);
						}
				}
			}
		}
		y();
	}
	function E() {
		P();
		for (const M in n) {
			const k = n[M];
			for (const q in k) {
				const B = k[q];
				for (const W in B) h(B[W].object), delete B[W];
				delete k[q];
			}
			delete n[M];
		}
	}
	function w(M) {
		if (n[M.id] === void 0) return;
		const k = n[M.id];
		for (const q in k) {
			const B = k[q];
			for (const W in B) h(B[W].object), delete B[W];
			delete k[q];
		}
		delete n[M.id];
	}
	function C(M) {
		for (const k in n) {
			const q = n[k];
			if (q[M.id] === void 0) continue;
			const B = q[M.id];
			for (const W in B) h(B[W].object), delete B[W];
			delete q[M.id];
		}
	}
	function P() {
		S(), (o = !0), r !== s && ((r = s), c(r.object));
	}
	function S() {
		(s.geometry = null), (s.program = null), (s.wireframe = !1);
	}
	return {
		setup: a,
		reset: P,
		resetDefaultState: S,
		dispose: E,
		releaseStatesOfGeometry: w,
		releaseStatesOfProgram: C,
		initAttributes: v,
		enableAttribute: m,
		disableUnusedAttributes: y,
	};
}
function mO(i, e, t) {
	let n;
	function s(c) {
		n = c;
	}
	function r(c, h) {
		i.drawArrays(n, c, h), t.update(h, n, 1);
	}
	function o(c, h, u) {
		u !== 0 && (i.drawArraysInstanced(n, c, h, u), t.update(h, n, u));
	}
	function a(c, h, u) {
		if (u === 0) return;
		const d = e.get('WEBGL_multi_draw');
		if (d === null) for (let p = 0; p < u; p++) this.render(c[p], h[p]);
		else {
			d.multiDrawArraysWEBGL(n, c, 0, h, 0, u);
			let p = 0;
			for (let g = 0; g < u; g++) p += h[g];
			t.update(p, n, 1);
		}
	}
	function l(c, h, u, d) {
		if (u === 0) return;
		const p = e.get('WEBGL_multi_draw');
		if (p === null) for (let g = 0; g < c.length; g++) o(c[g], h[g], d[g]);
		else {
			p.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, d, 0, u);
			let g = 0;
			for (let v = 0; v < u; v++) g += h[v];
			for (let v = 0; v < d.length; v++) t.update(g, n, d[v]);
		}
	}
	(this.setMode = s), (this.render = r), (this.renderInstances = o), (this.renderMultiDraw = a), (this.renderMultiDrawInstances = l);
}
function gO(i, e, t, n) {
	let s;
	function r() {
		if (s !== void 0) return s;
		if (e.has('EXT_texture_filter_anisotropic') === !0) {
			const w = e.get('EXT_texture_filter_anisotropic');
			s = i.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
		} else s = 0;
		return s;
	}
	function o(w) {
		return !(w !== mi && n.convert(w) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT));
	}
	function a(w) {
		const C = w === fi && (e.has('EXT_color_buffer_half_float') || e.has('EXT_color_buffer_float'));
		return !(w !== Vn && n.convert(w) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && w !== On && !C);
	}
	function l(w) {
		if (w === 'highp') {
			if (
				i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 &&
				i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0
			)
				return 'highp';
			w = 'mediump';
		}
		return w === 'mediump' &&
			i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 &&
			i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0
			? 'mediump'
			: 'lowp';
	}
	let c = t.precision !== void 0 ? t.precision : 'highp';
	const h = l(c);
	h !== c && (console.warn('THREE.WebGLRenderer:', c, 'not supported, using', h, 'instead.'), (c = h));
	const u = t.logarithmicDepthBuffer === !0,
		d = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
		p = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
		g = i.getParameter(i.MAX_TEXTURE_SIZE),
		v = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
		m = i.getParameter(i.MAX_VERTEX_ATTRIBS),
		f = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
		y = i.getParameter(i.MAX_VARYING_VECTORS),
		_ = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
		x = p > 0,
		E = i.getParameter(i.MAX_SAMPLES);
	return {
		isWebGL2: !0,
		getMaxAnisotropy: r,
		getMaxPrecision: l,
		textureFormatReadable: o,
		textureTypeReadable: a,
		precision: c,
		logarithmicDepthBuffer: u,
		maxTextures: d,
		maxVertexTextures: p,
		maxTextureSize: g,
		maxCubemapSize: v,
		maxAttributes: m,
		maxVertexUniforms: f,
		maxVaryings: y,
		maxFragmentUniforms: _,
		vertexTextures: x,
		maxSamples: E,
	};
}
function vO(i) {
	const e = this;
	let t = null,
		n = 0,
		s = !1,
		r = !1;
	const o = new Zr(),
		a = new et(),
		l = { value: null, needsUpdate: !1 };
	(this.uniform = l),
		(this.numPlanes = 0),
		(this.numIntersection = 0),
		(this.init = function (u, d) {
			const p = u.length !== 0 || d || n !== 0 || s;
			return (s = d), (n = u.length), p;
		}),
		(this.beginShadows = function () {
			(r = !0), h(null);
		}),
		(this.endShadows = function () {
			r = !1;
		}),
		(this.setGlobalState = function (u, d) {
			t = h(u, d, 0);
		}),
		(this.setState = function (u, d, p) {
			const g = u.clippingPlanes,
				v = u.clipIntersection,
				m = u.clipShadows,
				f = i.get(u);
			if (!s || g === null || g.length === 0 || (r && !m)) r ? h(null) : c();
			else {
				const y = r ? 0 : n,
					_ = y * 4;
				let x = f.clippingState || null;
				(l.value = x), (x = h(g, d, _, p));
				for (let E = 0; E !== _; ++E) x[E] = t[E];
				(f.clippingState = x), (this.numIntersection = v ? this.numPlanes : 0), (this.numPlanes += y);
			}
		});
	function c() {
		l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)), (e.numPlanes = n), (e.numIntersection = 0);
	}
	function h(u, d, p, g) {
		const v = u !== null ? u.length : 0;
		let m = null;
		if (v !== 0) {
			if (((m = l.value), g !== !0 || m === null)) {
				const f = p + v * 4,
					y = d.matrixWorldInverse;
				a.getNormalMatrix(y), (m === null || m.length < f) && (m = new Float32Array(f));
				for (let _ = 0, x = p; _ !== v; ++_, x += 4)
					o.copy(u[_]).applyMatrix4(y, a), o.normal.toArray(m, x), (m[x + 3] = o.constant);
			}
			(l.value = m), (l.needsUpdate = !0);
		}
		return (e.numPlanes = v), (e.numIntersection = 0), m;
	}
}
function _O(i) {
	let e = new WeakMap();
	function t(o, a) {
		return a === _h ? (o.mapping = _r) : a === yh && (o.mapping = _o), o;
	}
	function n(o) {
		if (o && o.isTexture) {
			const a = o.mapping;
			if (a === _h || a === yh)
				if (e.has(o)) {
					const l = e.get(o).texture;
					return t(l, o.mapping);
				} else {
					const l = o.image;
					if (l && l.height > 0) {
						const c = new dE(l.height);
						return c.fromEquirectangularTexture(i, o), e.set(o, c), o.addEventListener('dispose', s), t(c.texture, o.mapping);
					} else return null;
				}
		}
		return o;
	}
	function s(o) {
		const a = o.target;
		a.removeEventListener('dispose', s);
		const l = e.get(a);
		l !== void 0 && (e.delete(a), l.dispose());
	}
	function r() {
		e = new WeakMap();
	}
	return { get: n, dispose: r };
}
class eu extends Zh {
	constructor(e = -1, t = 1, n = 1, s = -1, r = 0.1, o = 2e3) {
		super(),
			(this.isOrthographicCamera = !0),
			(this.type = 'OrthographicCamera'),
			(this.zoom = 1),
			(this.view = null),
			(this.left = e),
			(this.right = t),
			(this.top = n),
			(this.bottom = s),
			(this.near = r),
			(this.far = o),
			this.updateProjectionMatrix();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.left = e.left),
			(this.right = e.right),
			(this.top = e.top),
			(this.bottom = e.bottom),
			(this.near = e.near),
			(this.far = e.far),
			(this.zoom = e.zoom),
			(this.view = e.view === null ? null : Object.assign({}, e.view)),
			this
		);
	}
	setViewOffset(e, t, n, s, r, o) {
		this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }),
			(this.view.enabled = !0),
			(this.view.fullWidth = e),
			(this.view.fullHeight = t),
			(this.view.offsetX = n),
			(this.view.offsetY = s),
			(this.view.width = r),
			(this.view.height = o),
			this.updateProjectionMatrix();
	}
	clearViewOffset() {
		this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
	}
	updateProjectionMatrix() {
		const e = (this.right - this.left) / (2 * this.zoom),
			t = (this.top - this.bottom) / (2 * this.zoom),
			n = (this.right + this.left) / 2,
			s = (this.top + this.bottom) / 2;
		let r = n - e,
			o = n + e,
			a = s + t,
			l = s - t;
		if (this.view !== null && this.view.enabled) {
			const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
				h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			(r += c * this.view.offsetX), (o = r + c * this.view.width), (a -= h * this.view.offsetY), (l = a - h * this.view.height);
		}
		this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem),
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.zoom = this.zoom),
			(t.object.left = this.left),
			(t.object.right = this.right),
			(t.object.top = this.top),
			(t.object.bottom = this.bottom),
			(t.object.near = this.near),
			(t.object.far = this.far),
			this.view !== null && (t.object.view = Object.assign({}, this.view)),
			t
		);
	}
}
const Rl = 4,
	ux = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
	ra = 20,
	im = new eu(),
	dx = new Ee();
let sm = null,
	rm = 0,
	om = 0,
	am = !1;
const ta = (1 + Math.sqrt(5)) / 2,
	hl = 1 / ta,
	px = [
		new I(-ta, hl, 0),
		new I(ta, hl, 0),
		new I(-hl, 0, ta),
		new I(hl, 0, ta),
		new I(0, ta, -hl),
		new I(0, ta, hl),
		new I(-1, 1, -1),
		new I(1, 1, -1),
		new I(-1, 1, 1),
		new I(1, 1, 1),
	];
class Ah {
	constructor(e) {
		(this._renderer = e),
			(this._pingPongRenderTarget = null),
			(this._lodMax = 0),
			(this._cubeSize = 0),
			(this._lodPlanes = []),
			(this._sizeLods = []),
			(this._sigmas = []),
			(this._blurMaterial = null),
			(this._cubemapMaterial = null),
			(this._equirectMaterial = null),
			this._compileMaterial(this._blurMaterial);
	}
	fromScene(e, t = 0, n = 0.1, s = 100) {
		(sm = this._renderer.getRenderTarget()),
			(rm = this._renderer.getActiveCubeFace()),
			(om = this._renderer.getActiveMipmapLevel()),
			(am = this._renderer.xr.enabled),
			(this._renderer.xr.enabled = !1),
			this._setSize(256);
		const r = this._allocateTargets();
		return (
			(r.depthBuffer = !0), this._sceneToCubeUV(e, n, s, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
		);
	}
	fromEquirectangular(e, t = null) {
		return this._fromTexture(e, t);
	}
	fromCubemap(e, t = null) {
		return this._fromTexture(e, t);
	}
	compileCubemapShader() {
		this._cubemapMaterial === null && ((this._cubemapMaterial = gx()), this._compileMaterial(this._cubemapMaterial));
	}
	compileEquirectangularShader() {
		this._equirectMaterial === null && ((this._equirectMaterial = mx()), this._compileMaterial(this._equirectMaterial));
	}
	dispose() {
		this._dispose(),
			this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
			this._equirectMaterial !== null && this._equirectMaterial.dispose();
	}
	_setSize(e) {
		(this._lodMax = Math.floor(Math.log2(e))), (this._cubeSize = Math.pow(2, this._lodMax));
	}
	_dispose() {
		this._blurMaterial !== null && this._blurMaterial.dispose(),
			this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
		for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
	}
	_cleanup(e) {
		this._renderer.setRenderTarget(sm, rm, om), (this._renderer.xr.enabled = am), (e.scissorTest = !1), Ku(e, 0, 0, e.width, e.height);
	}
	_fromTexture(e, t) {
		e.mapping === _r || e.mapping === _o
			? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width)
			: this._setSize(e.image.width / 4),
			(sm = this._renderer.getRenderTarget()),
			(rm = this._renderer.getActiveCubeFace()),
			(om = this._renderer.getActiveMipmapLevel()),
			(am = this._renderer.xr.enabled),
			(this._renderer.xr.enabled = !1);
		const n = t || this._allocateTargets();
		return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
	}
	_allocateTargets() {
		const e = 3 * Math.max(this._cubeSize, 112),
			t = 4 * this._cubeSize,
			n = { magFilter: Tt, minFilter: Tt, generateMipmaps: !1, type: fi, format: mi, colorSpace: Es, depthBuffer: !1 },
			s = fx(e, t, n);
		if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
			this._pingPongRenderTarget !== null && this._dispose(), (this._pingPongRenderTarget = fx(e, t, n));
			const { _lodMax: r } = this;
			({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = yO(r)), (this._blurMaterial = xO(r, e, t));
		}
		return s;
	}
	_compileMaterial(e) {
		const t = new bt(this._lodPlanes[0], e);
		this._renderer.compile(t, im);
	}
	_sceneToCubeUV(e, t, n, s) {
		const a = new fn(90, 1, t, n),
			l = [1, -1, 1, 1, 1, 1],
			c = [1, 1, 1, -1, -1, -1],
			h = this._renderer,
			u = h.autoClear,
			d = h.toneMapping;
		h.getClearColor(dx), (h.toneMapping = Xs), (h.autoClear = !1);
		const p = new En({ name: 'PMREM.Background', side: gn, depthWrite: !1, depthTest: !1 }),
			g = new bt(new za(), p);
		let v = !1;
		const m = e.background;
		m ? m.isColor && (p.color.copy(m), (e.background = null), (v = !0)) : (p.color.copy(dx), (v = !0));
		for (let f = 0; f < 6; f++) {
			const y = f % 3;
			y === 0
				? (a.up.set(0, l[f], 0), a.lookAt(c[f], 0, 0))
				: y === 1
				? (a.up.set(0, 0, l[f]), a.lookAt(0, c[f], 0))
				: (a.up.set(0, l[f], 0), a.lookAt(0, 0, c[f]));
			const _ = this._cubeSize;
			Ku(s, y * _, f > 2 ? _ : 0, _, _), h.setRenderTarget(s), v && h.render(g, a), h.render(e, a);
		}
		g.geometry.dispose(), g.material.dispose(), (h.toneMapping = d), (h.autoClear = u), (e.background = m);
	}
	_textureToCubeUV(e, t) {
		const n = this._renderer,
			s = e.mapping === _r || e.mapping === _o;
		s
			? (this._cubemapMaterial === null && (this._cubemapMaterial = gx()),
			  (this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1))
			: this._equirectMaterial === null && (this._equirectMaterial = mx());
		const r = s ? this._cubemapMaterial : this._equirectMaterial,
			o = new bt(this._lodPlanes[0], r),
			a = r.uniforms;
		a.envMap.value = e;
		const l = this._cubeSize;
		Ku(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, im);
	}
	_applyPMREM(e) {
		const t = this._renderer,
			n = t.autoClear;
		t.autoClear = !1;
		const s = this._lodPlanes.length;
		for (let r = 1; r < s; r++) {
			const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
				a = px[(s - r - 1) % px.length];
			this._blur(e, r - 1, r, o, a);
		}
		t.autoClear = n;
	}
	_blur(e, t, n, s, r) {
		const o = this._pingPongRenderTarget;
		this._halfBlur(e, o, t, n, s, 'latitudinal', r), this._halfBlur(o, e, n, n, s, 'longitudinal', r);
	}
	_halfBlur(e, t, n, s, r, o, a) {
		const l = this._renderer,
			c = this._blurMaterial;
		o !== 'latitudinal' && o !== 'longitudinal' && console.error('blur direction must be either latitudinal or longitudinal!');
		const h = 3,
			u = new bt(this._lodPlanes[s], c),
			d = c.uniforms,
			p = this._sizeLods[n] - 1,
			g = isFinite(r) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * ra - 1),
			v = r / g,
			m = isFinite(r) ? 1 + Math.floor(h * v) : ra;
		m > ra &&
			console.warn(
				'sigmaRadians, '
					.concat(r, ', is too large and will clip, as it requested ')
					.concat(m, ' samples when the maximum is set to ')
					.concat(ra)
			);
		const f = [];
		let y = 0;
		for (let C = 0; C < ra; ++C) {
			const P = C / v,
				S = Math.exp((-P * P) / 2);
			f.push(S), C === 0 ? (y += S) : C < m && (y += 2 * S);
		}
		for (let C = 0; C < f.length; C++) f[C] = f[C] / y;
		(d.envMap.value = e.texture),
			(d.samples.value = m),
			(d.weights.value = f),
			(d.latitudinal.value = o === 'latitudinal'),
			a && (d.poleAxis.value = a);
		const { _lodMax: _ } = this;
		(d.dTheta.value = g), (d.mipInt.value = _ - n);
		const x = this._sizeLods[s],
			E = 3 * x * (s > _ - Rl ? s - _ + Rl : 0),
			w = 4 * (this._cubeSize - x);
		Ku(t, E, w, 3 * x, 2 * x), l.setRenderTarget(t), l.render(u, im);
	}
}
function yO(i) {
	const e = [],
		t = [],
		n = [];
	let s = i;
	const r = i - Rl + 1 + ux.length;
	for (let o = 0; o < r; o++) {
		const a = Math.pow(2, s);
		t.push(a);
		let l = 1 / a;
		o > i - Rl ? (l = ux[o - i + Rl - 1]) : o === 0 && (l = 0), n.push(l);
		const c = 1 / (a - 2),
			h = -c,
			u = 1 + c,
			d = [h, h, u, h, u, u, h, h, u, u, h, u],
			p = 6,
			g = 6,
			v = 3,
			m = 2,
			f = 1,
			y = new Float32Array(v * g * p),
			_ = new Float32Array(m * g * p),
			x = new Float32Array(f * g * p);
		for (let w = 0; w < p; w++) {
			const C = ((w % 3) * 2) / 3 - 1,
				P = w > 2 ? 0 : -1,
				S = [C, P, 0, C + 2 / 3, P, 0, C + 2 / 3, P + 1, 0, C, P, 0, C + 2 / 3, P + 1, 0, C, P + 1, 0];
			y.set(S, v * g * w), _.set(d, m * g * w);
			const M = [w, w, w, w, w, w];
			x.set(M, f * g * w);
		}
		const E = new Ze();
		E.setAttribute('position', new $e(y, v)),
			E.setAttribute('uv', new $e(_, m)),
			E.setAttribute('faceIndex', new $e(x, f)),
			e.push(E),
			s > Rl && s--;
	}
	return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function fx(i, e, t) {
	const n = new yn(i, e, t);
	return (n.texture.mapping = lc), (n.texture.name = 'PMREM.cubeUv'), (n.scissorTest = !0), n;
}
function Ku(i, e, t, n, s) {
	i.viewport.set(e, t, n, s), i.scissor.set(e, t, n, s);
}
function xO(i, e, t) {
	const n = new Float32Array(ra),
		s = new I(0, 1, 0);
	return new xn({
		name: 'SphericalGaussianBlur',
		defines: { n: ra, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: ''.concat(i, '.0') },
		uniforms: {
			envMap: { value: null },
			samples: { value: 1 },
			weights: { value: n },
			latitudinal: { value: !1 },
			dTheta: { value: 0 },
			mipInt: { value: 0 },
			poleAxis: { value: s },
		},
		vertexShader: R_(),
		fragmentShader:
			"\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n			uniform int samples;\n			uniform float weights[ n ];\n			uniform bool latitudinal;\n			uniform float dTheta;\n			uniform float mipInt;\n			uniform vec3 poleAxis;\n\n			#define ENVMAP_TYPE_CUBE_UV\n			#include <cube_uv_reflection_fragment>\n\n			vec3 getSample( float theta, vec3 axis ) {\n\n				float cosTheta = cos( theta );\n				// Rodrigues' axis-angle rotation\n				vec3 sampleDirection = vOutputDirection * cosTheta\n					+ cross( axis, vOutputDirection ) * sin( theta )\n					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n				return bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n			}\n\n			void main() {\n\n				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n				}\n\n				axis = normalize( axis );\n\n				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n				for ( int i = 1; i < n; i++ ) {\n\n					if ( i >= samples ) {\n\n						break;\n\n					}\n\n					float theta = dTheta * float( i );\n					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n				}\n\n			}\n		",
		blending: jn,
		depthTest: !1,
		depthWrite: !1,
	});
}
function mx() {
	return new xn({
		name: 'EquirectangularToCubeUV',
		uniforms: { envMap: { value: null } },
		vertexShader: R_(),
		fragmentShader:
			'\n\n			precision mediump float;\n			precision mediump int;\n\n			varying vec3 vOutputDirection;\n\n			uniform sampler2D envMap;\n\n			#include <common>\n\n			void main() {\n\n				vec3 outputDirection = normalize( vOutputDirection );\n				vec2 uv = equirectUv( outputDirection );\n\n				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n			}\n		',
		blending: jn,
		depthTest: !1,
		depthWrite: !1,
	});
}
function gx() {
	return new xn({
		name: 'CubemapToCubeUV',
		uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
		vertexShader: R_(),
		fragmentShader:
			'\n\n			precision mediump float;\n			precision mediump int;\n\n			uniform float flipEnvMap;\n\n			varying vec3 vOutputDirection;\n\n			uniform samplerCube envMap;\n\n			void main() {\n\n				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n			}\n		',
		blending: jn,
		depthTest: !1,
		depthWrite: !1,
	});
}
function R_() {
	return '\n\n		precision mediump float;\n		precision mediump int;\n\n		attribute float faceIndex;\n\n		varying vec3 vOutputDirection;\n\n		// RH coordinate system; PMREM face-indexing convention\n		vec3 getDirection( vec2 uv, float face ) {\n\n			uv = 2.0 * uv - 1.0;\n\n			vec3 direction = vec3( uv, 1.0 );\n\n			if ( face == 0.0 ) {\n\n				direction = direction.zyx; // ( 1, v, u ) pos x\n\n			} else if ( face == 1.0 ) {\n\n				direction = direction.xzy;\n				direction.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n			} else if ( face == 2.0 ) {\n\n				direction.x *= -1.0; // ( -u, v, 1 ) pos z\n\n			} else if ( face == 3.0 ) {\n\n				direction = direction.zyx;\n				direction.xz *= -1.0; // ( -1, v, -u ) neg x\n\n			} else if ( face == 4.0 ) {\n\n				direction = direction.xzy;\n				direction.xy *= -1.0; // ( -u, -1, v ) neg y\n\n			} else if ( face == 5.0 ) {\n\n				direction.z *= -1.0; // ( u, v, -1 ) neg z\n\n			}\n\n			return direction;\n\n		}\n\n		void main() {\n\n			vOutputDirection = getDirection( uv, faceIndex );\n			gl_Position = vec4( position, 1.0 );\n\n		}\n	';
}
function bO(i) {
	let e = new WeakMap(),
		t = null;
	function n(a) {
		if (a && a.isTexture) {
			const l = a.mapping,
				c = l === _h || l === yh,
				h = l === _r || l === _o;
			if (c || h) {
				let u = e.get(a);
				const d = u !== void 0 ? u.texture.pmremVersion : 0;
				if (a.isRenderTargetTexture && a.pmremVersion !== d)
					return (
						t === null && (t = new Ah(i)),
						(u = c ? t.fromEquirectangular(a, u) : t.fromCubemap(a, u)),
						(u.texture.pmremVersion = a.pmremVersion),
						e.set(a, u),
						u.texture
					);
				if (u !== void 0) return u.texture;
				{
					const p = a.image;
					return (c && p && p.height > 0) || (h && p && s(p))
						? (t === null && (t = new Ah(i)),
						  (u = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
						  (u.texture.pmremVersion = a.pmremVersion),
						  e.set(a, u),
						  a.addEventListener('dispose', r),
						  u.texture)
						: null;
				}
			}
		}
		return a;
	}
	function s(a) {
		let l = 0;
		const c = 6;
		for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
		return l === c;
	}
	function r(a) {
		const l = a.target;
		l.removeEventListener('dispose', r);
		const c = e.get(l);
		c !== void 0 && (e.delete(l), c.dispose());
	}
	function o() {
		(e = new WeakMap()), t !== null && (t.dispose(), (t = null));
	}
	return { get: n, dispose: o };
}
function wO(i) {
	const e = {};
	function t(n) {
		if (e[n] !== void 0) return e[n];
		let s;
		switch (n) {
			case 'WEBGL_depth_texture':
				s =
					i.getExtension('WEBGL_depth_texture') ||
					i.getExtension('MOZ_WEBGL_depth_texture') ||
					i.getExtension('WEBKIT_WEBGL_depth_texture');
				break;
			case 'EXT_texture_filter_anisotropic':
				s =
					i.getExtension('EXT_texture_filter_anisotropic') ||
					i.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
					i.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
				break;
			case 'WEBGL_compressed_texture_s3tc':
				s =
					i.getExtension('WEBGL_compressed_texture_s3tc') ||
					i.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
					i.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
				break;
			case 'WEBGL_compressed_texture_pvrtc':
				s = i.getExtension('WEBGL_compressed_texture_pvrtc') || i.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
				break;
			default:
				s = i.getExtension(n);
		}
		return (e[n] = s), s;
	}
	return {
		has: function (n) {
			return t(n) !== null;
		},
		init: function () {
			t('EXT_color_buffer_float'),
				t('WEBGL_clip_cull_distance'),
				t('OES_texture_float_linear'),
				t('EXT_color_buffer_half_float'),
				t('WEBGL_multisampled_render_to_texture'),
				t('WEBGL_render_shared_exponent');
		},
		get: function (n) {
			const s = t(n);
			return s === null && console.warn('THREE.WebGLRenderer: ' + n + ' extension not supported.'), s;
		},
	};
}
function SO(i, e, t, n) {
	const s = {},
		r = new WeakMap();
	function o(u) {
		const d = u.target;
		d.index !== null && e.remove(d.index);
		for (const g in d.attributes) e.remove(d.attributes[g]);
		for (const g in d.morphAttributes) {
			const v = d.morphAttributes[g];
			for (let m = 0, f = v.length; m < f; m++) e.remove(v[m]);
		}
		d.removeEventListener('dispose', o), delete s[d.id];
		const p = r.get(d);
		p && (e.remove(p), r.delete(d)),
			n.releaseStatesOfGeometry(d),
			d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
			t.memory.geometries--;
	}
	function a(u, d) {
		return s[d.id] === !0 || (d.addEventListener('dispose', o), (s[d.id] = !0), t.memory.geometries++), d;
	}
	function l(u) {
		const d = u.attributes;
		for (const g in d) e.update(d[g], i.ARRAY_BUFFER);
		const p = u.morphAttributes;
		for (const g in p) {
			const v = p[g];
			for (let m = 0, f = v.length; m < f; m++) e.update(v[m], i.ARRAY_BUFFER);
		}
	}
	function c(u) {
		const d = [],
			p = u.index,
			g = u.attributes.position;
		let v = 0;
		if (p !== null) {
			const y = p.array;
			v = p.version;
			for (let _ = 0, x = y.length; _ < x; _ += 3) {
				const E = y[_ + 0],
					w = y[_ + 1],
					C = y[_ + 2];
				d.push(E, w, w, C, C, E);
			}
		} else if (g !== void 0) {
			const y = g.array;
			v = g.version;
			for (let _ = 0, x = y.length / 3 - 1; _ < x; _ += 3) {
				const E = _ + 0,
					w = _ + 1,
					C = _ + 2;
				d.push(E, w, w, C, C, E);
			}
		} else return;
		const m = new (iE(d) ? C_ : A_)(d, 1);
		m.version = v;
		const f = r.get(u);
		f && e.remove(f), r.set(u, m);
	}
	function h(u) {
		const d = r.get(u);
		if (d) {
			const p = u.index;
			p !== null && d.version < p.version && c(u);
		} else c(u);
		return r.get(u);
	}
	return { get: a, update: l, getWireframeAttribute: h };
}
function MO(i, e, t) {
	let n;
	function s(d) {
		n = d;
	}
	let r, o;
	function a(d) {
		(r = d.type), (o = d.bytesPerElement);
	}
	function l(d, p) {
		i.drawElements(n, p, r, d * o), t.update(p, n, 1);
	}
	function c(d, p, g) {
		g !== 0 && (i.drawElementsInstanced(n, p, r, d * o, g), t.update(p, n, g));
	}
	function h(d, p, g) {
		if (g === 0) return;
		const v = e.get('WEBGL_multi_draw');
		if (v === null) for (let m = 0; m < g; m++) this.render(d[m] / o, p[m]);
		else {
			v.multiDrawElementsWEBGL(n, p, 0, r, d, 0, g);
			let m = 0;
			for (let f = 0; f < g; f++) m += p[f];
			t.update(m, n, 1);
		}
	}
	function u(d, p, g, v) {
		if (g === 0) return;
		const m = e.get('WEBGL_multi_draw');
		if (m === null) for (let f = 0; f < d.length; f++) c(d[f] / o, p[f], v[f]);
		else {
			m.multiDrawElementsInstancedWEBGL(n, p, 0, r, d, 0, v, 0, g);
			let f = 0;
			for (let y = 0; y < g; y++) f += p[y];
			for (let y = 0; y < v.length; y++) t.update(f, n, v[y]);
		}
	}
	(this.setMode = s),
		(this.setIndex = a),
		(this.render = l),
		(this.renderInstances = c),
		(this.renderMultiDraw = h),
		(this.renderMultiDrawInstances = u);
}
function EO(i) {
	const e = { geometries: 0, textures: 0 },
		t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
	function n(r, o, a) {
		switch ((t.calls++, o)) {
			case i.TRIANGLES:
				t.triangles += a * (r / 3);
				break;
			case i.LINES:
				t.lines += a * (r / 2);
				break;
			case i.LINE_STRIP:
				t.lines += a * (r - 1);
				break;
			case i.LINE_LOOP:
				t.lines += a * r;
				break;
			case i.POINTS:
				t.points += a * r;
				break;
			default:
				console.error('THREE.WebGLInfo: Unknown draw mode:', o);
				break;
		}
	}
	function s() {
		(t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
	}
	return { memory: e, render: t, programs: null, autoReset: !0, reset: s, update: n };
}
function TO(i, e, t) {
	const n = new WeakMap(),
		s = new Pt();
	function r(o, a, l) {
		const c = o.morphTargetInfluences,
			h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
			u = h !== void 0 ? h.length : 0;
		let d = n.get(a);
		if (d === void 0 || d.count !== u) {
			let S = function () {
				C.dispose(), n.delete(a), a.removeEventListener('dispose', S);
			};
			d !== void 0 && d.texture.dispose();
			const p = a.morphAttributes.position !== void 0,
				g = a.morphAttributes.normal !== void 0,
				v = a.morphAttributes.color !== void 0,
				m = a.morphAttributes.position || [],
				f = a.morphAttributes.normal || [],
				y = a.morphAttributes.color || [];
			let _ = 0;
			p === !0 && (_ = 1), g === !0 && (_ = 2), v === !0 && (_ = 3);
			let x = a.attributes.position.count * _,
				E = 1;
			x > e.maxTextureSize && ((E = Math.ceil(x / e.maxTextureSize)), (x = e.maxTextureSize));
			const w = new Float32Array(x * E * 4 * u),
				C = new Hp(w, x, E, u);
			(C.type = On), (C.needsUpdate = !0);
			const P = _ * 4;
			for (let M = 0; M < u; M++) {
				const k = m[M],
					q = f[M],
					B = y[M],
					W = x * E * 4 * M;
				for (let Q = 0; Q < k.count; Q++) {
					const $ = Q * P;
					p === !0 &&
						(s.fromBufferAttribute(k, Q), (w[W + $ + 0] = s.x), (w[W + $ + 1] = s.y), (w[W + $ + 2] = s.z), (w[W + $ + 3] = 0)),
						g === !0 &&
							(s.fromBufferAttribute(q, Q),
							(w[W + $ + 4] = s.x),
							(w[W + $ + 5] = s.y),
							(w[W + $ + 6] = s.z),
							(w[W + $ + 7] = 0)),
						v === !0 &&
							(s.fromBufferAttribute(B, Q),
							(w[W + $ + 8] = s.x),
							(w[W + $ + 9] = s.y),
							(w[W + $ + 10] = s.z),
							(w[W + $ + 11] = B.itemSize === 4 ? s.w : 1));
				}
			}
			(d = { count: u, texture: C, size: new ce(x, E) }), n.set(a, d), a.addEventListener('dispose', S);
		}
		if (o.isInstancedMesh === !0 && o.morphTexture !== null) l.getUniforms().setValue(i, 'morphTexture', o.morphTexture, t);
		else {
			let p = 0;
			for (let v = 0; v < c.length; v++) p += c[v];
			const g = a.morphTargetsRelative ? 1 : 1 - p;
			l.getUniforms().setValue(i, 'morphTargetBaseInfluence', g), l.getUniforms().setValue(i, 'morphTargetInfluences', c);
		}
		l.getUniforms().setValue(i, 'morphTargetsTexture', d.texture, t), l.getUniforms().setValue(i, 'morphTargetsTextureSize', d.size);
	}
	return { update: r };
}
function AO(i, e, t, n) {
	let s = new WeakMap();
	function r(l) {
		const c = n.render.frame,
			h = l.geometry,
			u = e.get(l, h);
		if (
			(s.get(u) !== c && (e.update(u), s.set(u, c)),
			l.isInstancedMesh &&
				(l.hasEventListener('dispose', a) === !1 && l.addEventListener('dispose', a),
				s.get(l) !== c &&
					(t.update(l.instanceMatrix, i.ARRAY_BUFFER),
					l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER),
					s.set(l, c))),
			l.isSkinnedMesh)
		) {
			const d = l.skeleton;
			s.get(d) !== c && (d.update(), s.set(d, c));
		}
		return u;
	}
	function o() {
		s = new WeakMap();
	}
	function a(l) {
		const c = l.target;
		c.removeEventListener('dispose', a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
	}
	return { update: r, dispose: o };
}
class Wp extends zt {
	constructor(e, t, n, s, r, o, a, l, c, h) {
		if (((h = h !== void 0 ? h : ga), h !== ga && h !== Ta))
			throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
		n === void 0 && h === ga && (n = yo),
			n === void 0 && h === Ta && (n = Ba),
			super(null, s, r, o, a, l, h, n, c),
			(this.isDepthTexture = !0),
			(this.image = { width: e, height: t }),
			(this.magFilter = a !== void 0 ? a : It),
			(this.minFilter = l !== void 0 ? l : It),
			(this.flipY = !1),
			(this.generateMipmaps = !1),
			(this.compareFunction = null);
	}
	copy(e) {
		return super.copy(e), (this.compareFunction = e.compareFunction), this;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
	}
}
const fE = new zt(),
	mE = new Wp(1, 1);
mE.compareFunction = M_;
const gE = new Hp(),
	vE = new T_(),
	_E = new Jh(),
	vx = [],
	_x = [],
	yx = new Float32Array(16),
	xx = new Float32Array(9),
	bx = new Float32Array(4);
function cc(i, e, t) {
	const n = i[0];
	if (n <= 0 || n > 0) return i;
	const s = e * t;
	let r = vx[s];
	if ((r === void 0 && ((r = new Float32Array(s)), (vx[s] = r)), e !== 0)) {
		n.toArray(r, 0);
		for (let o = 1, a = 0; o !== e; ++o) (a += t), i[o].toArray(r, a);
	}
	return r;
}
function Cn(i, e) {
	if (i.length !== e.length) return !1;
	for (let t = 0, n = i.length; t < n; t++) if (i[t] !== e[t]) return !1;
	return !0;
}
function Rn(i, e) {
	for (let t = 0, n = e.length; t < n; t++) i[t] = e[t];
}
function Xp(i, e) {
	let t = _x[e];
	t === void 0 && ((t = new Int32Array(e)), (_x[e] = t));
	for (let n = 0; n !== e; ++n) t[n] = i.allocateTextureUnit();
	return t;
}
function CO(i, e) {
	const t = this.cache;
	t[0] !== e && (i.uniform1f(this.addr, e), (t[0] = e));
}
function RO(i, e) {
	const t = this.cache;
	if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
	else {
		if (Cn(t, e)) return;
		i.uniform2fv(this.addr, e), Rn(t, e);
	}
}
function PO(i, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
	else if (e.r !== void 0)
		(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), (t[0] = e.r), (t[1] = e.g), (t[2] = e.b));
	else {
		if (Cn(t, e)) return;
		i.uniform3fv(this.addr, e), Rn(t, e);
	}
}
function LO(i, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
			(i.uniform4f(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
	else {
		if (Cn(t, e)) return;
		i.uniform4fv(this.addr, e), Rn(t, e);
	}
}
function IO(i, e) {
	const t = this.cache,
		n = e.elements;
	if (n === void 0) {
		if (Cn(t, e)) return;
		i.uniformMatrix2fv(this.addr, !1, e), Rn(t, e);
	} else {
		if (Cn(t, n)) return;
		bx.set(n), i.uniformMatrix2fv(this.addr, !1, bx), Rn(t, n);
	}
}
function DO(i, e) {
	const t = this.cache,
		n = e.elements;
	if (n === void 0) {
		if (Cn(t, e)) return;
		i.uniformMatrix3fv(this.addr, !1, e), Rn(t, e);
	} else {
		if (Cn(t, n)) return;
		xx.set(n), i.uniformMatrix3fv(this.addr, !1, xx), Rn(t, n);
	}
}
function OO(i, e) {
	const t = this.cache,
		n = e.elements;
	if (n === void 0) {
		if (Cn(t, e)) return;
		i.uniformMatrix4fv(this.addr, !1, e), Rn(t, e);
	} else {
		if (Cn(t, n)) return;
		yx.set(n), i.uniformMatrix4fv(this.addr, !1, yx), Rn(t, n);
	}
}
function UO(i, e) {
	const t = this.cache;
	t[0] !== e && (i.uniform1i(this.addr, e), (t[0] = e));
}
function NO(i, e) {
	const t = this.cache;
	if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
	else {
		if (Cn(t, e)) return;
		i.uniform2iv(this.addr, e), Rn(t, e);
	}
}
function FO(i, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
	else {
		if (Cn(t, e)) return;
		i.uniform3iv(this.addr, e), Rn(t, e);
	}
}
function BO(i, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
			(i.uniform4i(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
	else {
		if (Cn(t, e)) return;
		i.uniform4iv(this.addr, e), Rn(t, e);
	}
}
function kO(i, e) {
	const t = this.cache;
	t[0] !== e && (i.uniform1ui(this.addr, e), (t[0] = e));
}
function zO(i, e) {
	const t = this.cache;
	if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
	else {
		if (Cn(t, e)) return;
		i.uniform2uiv(this.addr, e), Rn(t, e);
	}
}
function VO(i, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
			(i.uniform3ui(this.addr, e.x, e.y, e.z), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z));
	else {
		if (Cn(t, e)) return;
		i.uniform3uiv(this.addr, e), Rn(t, e);
	}
}
function HO(i, e) {
	const t = this.cache;
	if (e.x !== void 0)
		(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
			(i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), (t[0] = e.x), (t[1] = e.y), (t[2] = e.z), (t[3] = e.w));
	else {
		if (Cn(t, e)) return;
		i.uniform4uiv(this.addr, e), Rn(t, e);
	}
}
function GO(i, e, t) {
	const n = this.cache,
		s = t.allocateTextureUnit();
	n[0] !== s && (i.uniform1i(this.addr, s), (n[0] = s));
	const r = this.type === i.SAMPLER_2D_SHADOW ? mE : fE;
	t.setTexture2D(e || r, s);
}
function WO(i, e, t) {
	const n = this.cache,
		s = t.allocateTextureUnit();
	n[0] !== s && (i.uniform1i(this.addr, s), (n[0] = s)), t.setTexture3D(e || vE, s);
}
function XO(i, e, t) {
	const n = this.cache,
		s = t.allocateTextureUnit();
	n[0] !== s && (i.uniform1i(this.addr, s), (n[0] = s)), t.setTextureCube(e || _E, s);
}
function qO(i, e, t) {
	const n = this.cache,
		s = t.allocateTextureUnit();
	n[0] !== s && (i.uniform1i(this.addr, s), (n[0] = s)), t.setTexture2DArray(e || gE, s);
}
function YO(i) {
	switch (i) {
		case 5126:
			return CO;
		case 35664:
			return RO;
		case 35665:
			return PO;
		case 35666:
			return LO;
		case 35674:
			return IO;
		case 35675:
			return DO;
		case 35676:
			return OO;
		case 5124:
		case 35670:
			return UO;
		case 35667:
		case 35671:
			return NO;
		case 35668:
		case 35672:
			return FO;
		case 35669:
		case 35673:
			return BO;
		case 5125:
			return kO;
		case 36294:
			return zO;
		case 36295:
			return VO;
		case 36296:
			return HO;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682:
			return GO;
		case 35679:
		case 36299:
		case 36307:
			return WO;
		case 35680:
		case 36300:
		case 36308:
		case 36293:
			return XO;
		case 36289:
		case 36303:
		case 36311:
		case 36292:
			return qO;
	}
}
function jO(i, e) {
	i.uniform1fv(this.addr, e);
}
function KO(i, e) {
	const t = cc(e, this.size, 2);
	i.uniform2fv(this.addr, t);
}
function $O(i, e) {
	const t = cc(e, this.size, 3);
	i.uniform3fv(this.addr, t);
}
function ZO(i, e) {
	const t = cc(e, this.size, 4);
	i.uniform4fv(this.addr, t);
}
function JO(i, e) {
	const t = cc(e, this.size, 4);
	i.uniformMatrix2fv(this.addr, !1, t);
}
function QO(i, e) {
	const t = cc(e, this.size, 9);
	i.uniformMatrix3fv(this.addr, !1, t);
}
function eU(i, e) {
	const t = cc(e, this.size, 16);
	i.uniformMatrix4fv(this.addr, !1, t);
}
function tU(i, e) {
	i.uniform1iv(this.addr, e);
}
function nU(i, e) {
	i.uniform2iv(this.addr, e);
}
function iU(i, e) {
	i.uniform3iv(this.addr, e);
}
function sU(i, e) {
	i.uniform4iv(this.addr, e);
}
function rU(i, e) {
	i.uniform1uiv(this.addr, e);
}
function oU(i, e) {
	i.uniform2uiv(this.addr, e);
}
function aU(i, e) {
	i.uniform3uiv(this.addr, e);
}
function lU(i, e) {
	i.uniform4uiv(this.addr, e);
}
function cU(i, e, t) {
	const n = this.cache,
		s = e.length,
		r = Xp(t, s);
	Cn(n, r) || (i.uniform1iv(this.addr, r), Rn(n, r));
	for (let o = 0; o !== s; ++o) t.setTexture2D(e[o] || fE, r[o]);
}
function hU(i, e, t) {
	const n = this.cache,
		s = e.length,
		r = Xp(t, s);
	Cn(n, r) || (i.uniform1iv(this.addr, r), Rn(n, r));
	for (let o = 0; o !== s; ++o) t.setTexture3D(e[o] || vE, r[o]);
}
function uU(i, e, t) {
	const n = this.cache,
		s = e.length,
		r = Xp(t, s);
	Cn(n, r) || (i.uniform1iv(this.addr, r), Rn(n, r));
	for (let o = 0; o !== s; ++o) t.setTextureCube(e[o] || _E, r[o]);
}
function dU(i, e, t) {
	const n = this.cache,
		s = e.length,
		r = Xp(t, s);
	Cn(n, r) || (i.uniform1iv(this.addr, r), Rn(n, r));
	for (let o = 0; o !== s; ++o) t.setTexture2DArray(e[o] || gE, r[o]);
}
function pU(i) {
	switch (i) {
		case 5126:
			return jO;
		case 35664:
			return KO;
		case 35665:
			return $O;
		case 35666:
			return ZO;
		case 35674:
			return JO;
		case 35675:
			return QO;
		case 35676:
			return eU;
		case 5124:
		case 35670:
			return tU;
		case 35667:
		case 35671:
			return nU;
		case 35668:
		case 35672:
			return iU;
		case 35669:
		case 35673:
			return sU;
		case 5125:
			return rU;
		case 36294:
			return oU;
		case 36295:
			return aU;
		case 36296:
			return lU;
		case 35678:
		case 36198:
		case 36298:
		case 36306:
		case 35682:
			return cU;
		case 35679:
		case 36299:
		case 36307:
			return hU;
		case 35680:
		case 36300:
		case 36308:
		case 36293:
			return uU;
		case 36289:
		case 36303:
		case 36311:
		case 36292:
			return dU;
	}
}
class fU {
	constructor(e, t, n) {
		(this.id = e), (this.addr = n), (this.cache = []), (this.type = t.type), (this.setValue = YO(t.type));
	}
}
class mU {
	constructor(e, t, n) {
		(this.id = e), (this.addr = n), (this.cache = []), (this.type = t.type), (this.size = t.size), (this.setValue = pU(t.type));
	}
}
class gU {
	constructor(e) {
		(this.id = e), (this.seq = []), (this.map = {});
	}
	setValue(e, t, n) {
		const s = this.seq;
		for (let r = 0, o = s.length; r !== o; ++r) {
			const a = s[r];
			a.setValue(e, t[a.id], n);
		}
	}
}
const lm = /(\w+)(\])?(\[|\.)?/g;
function wx(i, e) {
	i.seq.push(e), (i.map[e.id] = e);
}
function vU(i, e, t) {
	const n = i.name,
		s = n.length;
	for (lm.lastIndex = 0; ; ) {
		const r = lm.exec(n),
			o = lm.lastIndex;
		let a = r[1];
		const l = r[2] === ']',
			c = r[3];
		if ((l && (a = a | 0), c === void 0 || (c === '[' && o + 2 === s))) {
			wx(t, c === void 0 ? new fU(a, i, e) : new mU(a, i, e));
			break;
		} else {
			let u = t.map[a];
			u === void 0 && ((u = new gU(a)), wx(t, u)), (t = u);
		}
	}
}
class Vd {
	constructor(e, t) {
		(this.seq = []), (this.map = {});
		const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
		for (let s = 0; s < n; ++s) {
			const r = e.getActiveUniform(t, s),
				o = e.getUniformLocation(t, r.name);
			vU(r, o, this);
		}
	}
	setValue(e, t, n, s) {
		const r = this.map[t];
		r !== void 0 && r.setValue(e, n, s);
	}
	setOptional(e, t, n) {
		const s = t[n];
		s !== void 0 && this.setValue(e, n, s);
	}
	static upload(e, t, n, s) {
		for (let r = 0, o = t.length; r !== o; ++r) {
			const a = t[r],
				l = n[a.id];
			l.needsUpdate !== !1 && a.setValue(e, l.value, s);
		}
	}
	static seqWithValue(e, t) {
		const n = [];
		for (let s = 0, r = e.length; s !== r; ++s) {
			const o = e[s];
			o.id in t && n.push(o);
		}
		return n;
	}
}
function Sx(i, e, t) {
	const n = i.createShader(e);
	return i.shaderSource(n, t), i.compileShader(n), n;
}
const _U = 37297;
let yU = 0;
function xU(i, e) {
	const t = i.split('\n'),
		n = [],
		s = Math.max(e - 6, 0),
		r = Math.min(e + 6, t.length);
	for (let o = s; o < r; o++) {
		const a = o + 1;
		n.push(
			''
				.concat(a === e ? '>' : ' ', ' ')
				.concat(a, ': ')
				.concat(t[o])
		);
	}
	return n.join('\n');
}
function bU(i) {
	const e = Ft.getPrimaries(Ft.workingColorSpace),
		t = Ft.getPrimaries(i);
	let n;
	switch (
		(e === t
			? (n = '')
			: e === Sh && t === wh
			? (n = 'LinearDisplayP3ToLinearSRGB')
			: e === wh && t === Sh && (n = 'LinearSRGBToLinearDisplayP3'),
		i)
	) {
		case Es:
		case $h:
			return [n, 'LinearTransferOETF'];
		case ot:
		case Vp:
			return [n, 'sRGBTransferOETF'];
		default:
			return console.warn('THREE.WebGLProgram: Unsupported color space:', i), [n, 'LinearTransferOETF'];
	}
}
function Mx(i, e, t) {
	const n = i.getShaderParameter(e, i.COMPILE_STATUS),
		s = i.getShaderInfoLog(e).trim();
	if (n && s === '') return '';
	const r = /ERROR: 0:(\d+)/.exec(s);
	if (r) {
		const o = parseInt(r[1]);
		return t.toUpperCase() + '\n\n' + s + '\n\n' + xU(i.getShaderSource(e), o);
	} else return s;
}
function wU(i, e) {
	const t = bU(e);
	return 'vec4 '.concat(i, '( vec4 value ) { return ').concat(t[0], '( ').concat(t[1], '( value ) ); }');
}
function SU(i, e) {
	let t;
	switch (e) {
		case Up:
			t = 'Linear';
			break;
		case d_:
			t = 'Reinhard';
			break;
		case p_:
			t = 'OptimizedCineon';
			break;
		case f_:
			t = 'ACESFilmic';
			break;
		case DM:
			t = 'AgX';
			break;
		case OM:
			t = 'Neutral';
			break;
		case IM:
			t = 'Custom';
			break;
		default:
			console.warn('THREE.WebGLProgram: Unsupported toneMapping:', e), (t = 'Linear');
	}
	return 'vec3 ' + i + '( vec3 color ) { return ' + t + 'ToneMapping( color ); }';
}
function MU(i) {
	return [
		i.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '',
		i.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '',
	]
		.filter(qc)
		.join('\n');
}
function EU(i) {
	const e = [];
	for (const t in i) {
		const n = i[t];
		n !== !1 && e.push('#define ' + t + ' ' + n);
	}
	return e.join('\n');
}
function TU(i, e) {
	const t = {},
		n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
	for (let s = 0; s < n; s++) {
		const r = i.getActiveAttrib(e, s),
			o = r.name;
		let a = 1;
		r.type === i.FLOAT_MAT2 && (a = 2),
			r.type === i.FLOAT_MAT3 && (a = 3),
			r.type === i.FLOAT_MAT4 && (a = 4),
			(t[o] = { type: r.type, location: i.getAttribLocation(e, o), locationSize: a });
	}
	return t;
}
function qc(i) {
	return i !== '';
}
function Ex(i, e) {
	const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
	return i
		.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
		.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
		.replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
		.replace(/NUM_SPOT_LIGHT_COORDS/g, t)
		.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
		.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
		.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
		.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
		.replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
		.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
		.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Tx(i, e) {
	return i
		.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
		.replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const AU = /^[ \t]*#include +<([\w\d./]+)>/gm;
function iv(i) {
	return i.replace(AU, RU);
}
const CU = new Map();
function RU(i, e) {
	let t = rt[e];
	if (t === void 0) {
		const n = CU.get(e);
		if (n !== void 0) (t = rt[n]), console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
		else throw new Error('Can not resolve #include <' + e + '>');
	}
	return iv(t);
}
const PU =
	/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ax(i) {
	return i.replace(PU, LU);
}
function LU(i, e, t, n) {
	let s = '';
	for (let r = parseInt(e); r < parseInt(t); r++) s += n.replace(/\[\s*i\s*\]/g, '[ ' + r + ' ]').replace(/UNROLLED_LOOP_INDEX/g, r);
	return s;
}
function Cx(i) {
	let e = 'precision '
		.concat(i.precision, ' float;\n	precision ')
		.concat(i.precision, ' int;\n	precision ')
		.concat(i.precision, ' sampler2D;\n	precision ')
		.concat(i.precision, ' samplerCube;\n	precision ')
		.concat(i.precision, ' sampler3D;\n	precision ')
		.concat(i.precision, ' sampler2DArray;\n	precision ')
		.concat(i.precision, ' sampler2DShadow;\n	precision ')
		.concat(i.precision, ' samplerCubeShadow;\n	precision ')
		.concat(i.precision, ' sampler2DArrayShadow;\n	precision ')
		.concat(i.precision, ' isampler2D;\n	precision ')
		.concat(i.precision, ' isampler3D;\n	precision ')
		.concat(i.precision, ' isamplerCube;\n	precision ')
		.concat(i.precision, ' isampler2DArray;\n	precision ')
		.concat(i.precision, ' usampler2D;\n	precision ')
		.concat(i.precision, ' usampler3D;\n	precision ')
		.concat(i.precision, ' usamplerCube;\n	precision ')
		.concat(i.precision, ' usampler2DArray;\n	');
	return (
		i.precision === 'highp'
			? (e += '\n#define HIGH_PRECISION')
			: i.precision === 'mediump'
			? (e += '\n#define MEDIUM_PRECISION')
			: i.precision === 'lowp' && (e += '\n#define LOW_PRECISION'),
		e
	);
}
function IU(i) {
	let e = 'SHADOWMAP_TYPE_BASIC';
	return (
		i.shadowMapType === a_
			? (e = 'SHADOWMAP_TYPE_PCF')
			: i.shadowMapType === uM
			? (e = 'SHADOWMAP_TYPE_PCF_SOFT')
			: i.shadowMapType === Us && (e = 'SHADOWMAP_TYPE_VSM'),
		e
	);
}
function DU(i) {
	let e = 'ENVMAP_TYPE_CUBE';
	if (i.envMap)
		switch (i.envMapMode) {
			case _r:
			case _o:
				e = 'ENVMAP_TYPE_CUBE';
				break;
			case lc:
				e = 'ENVMAP_TYPE_CUBE_UV';
				break;
		}
	return e;
}
function OU(i) {
	let e = 'ENVMAP_MODE_REFLECTION';
	if (i.envMap)
		switch (i.envMapMode) {
			case _o:
				e = 'ENVMAP_MODE_REFRACTION';
				break;
		}
	return e;
}
function UU(i) {
	let e = 'ENVMAP_BLENDING_NONE';
	if (i.envMap)
		switch (i.combine) {
			case Kh:
				e = 'ENVMAP_BLENDING_MULTIPLY';
				break;
			case PM:
				e = 'ENVMAP_BLENDING_MIX';
				break;
			case LM:
				e = 'ENVMAP_BLENDING_ADD';
				break;
		}
	return e;
}
function NU(i) {
	const e = i.envMapCubeUVHeight;
	if (e === null) return null;
	const t = Math.log2(e) - 2,
		n = 1 / e;
	return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: n, maxMip: t };
}
function FU(i, e, t, n) {
	const s = i.getContext(),
		r = t.defines;
	let o = t.vertexShader,
		a = t.fragmentShader;
	const l = IU(t),
		c = DU(t),
		h = OU(t),
		u = UU(t),
		d = NU(t),
		p = MU(t),
		g = EU(r),
		v = s.createProgram();
	let m,
		f,
		y = t.glslVersion ? '#version ' + t.glslVersion + '\n' : '';
	t.isRawShaderMaterial
		? ((m = ['#define SHADER_TYPE ' + t.shaderType, '#define SHADER_NAME ' + t.shaderName, g].filter(qc).join('\n')),
		  m.length > 0 && (m += '\n'),
		  (f = ['#define SHADER_TYPE ' + t.shaderType, '#define SHADER_NAME ' + t.shaderName, g].filter(qc).join('\n')),
		  f.length > 0 && (f += '\n'))
		: ((m = [
				Cx(t),
				'#define SHADER_TYPE ' + t.shaderType,
				'#define SHADER_NAME ' + t.shaderName,
				g,
				t.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '',
				t.batching ? '#define USE_BATCHING' : '',
				t.instancing ? '#define USE_INSTANCING' : '',
				t.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
				t.instancingMorph ? '#define USE_INSTANCING_MORPH' : '',
				t.useFog && t.fog ? '#define USE_FOG' : '',
				t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
				t.map ? '#define USE_MAP' : '',
				t.envMap ? '#define USE_ENVMAP' : '',
				t.envMap ? '#define ' + h : '',
				t.lightMap ? '#define USE_LIGHTMAP' : '',
				t.aoMap ? '#define USE_AOMAP' : '',
				t.bumpMap ? '#define USE_BUMPMAP' : '',
				t.normalMap ? '#define USE_NORMALMAP' : '',
				t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				t.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',
				t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				t.anisotropy ? '#define USE_ANISOTROPY' : '',
				t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
				t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
				t.specularMap ? '#define USE_SPECULARMAP' : '',
				t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
				t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				t.metalnessMap ? '#define USE_METALNESSMAP' : '',
				t.alphaMap ? '#define USE_ALPHAMAP' : '',
				t.alphaHash ? '#define USE_ALPHAHASH' : '',
				t.transmission ? '#define USE_TRANSMISSION' : '',
				t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
				t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
				t.mapUv ? '#define MAP_UV ' + t.mapUv : '',
				t.alphaMapUv ? '#define ALPHAMAP_UV ' + t.alphaMapUv : '',
				t.lightMapUv ? '#define LIGHTMAP_UV ' + t.lightMapUv : '',
				t.aoMapUv ? '#define AOMAP_UV ' + t.aoMapUv : '',
				t.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + t.emissiveMapUv : '',
				t.bumpMapUv ? '#define BUMPMAP_UV ' + t.bumpMapUv : '',
				t.normalMapUv ? '#define NORMALMAP_UV ' + t.normalMapUv : '',
				t.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + t.displacementMapUv : '',
				t.metalnessMapUv ? '#define METALNESSMAP_UV ' + t.metalnessMapUv : '',
				t.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + t.roughnessMapUv : '',
				t.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + t.anisotropyMapUv : '',
				t.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + t.clearcoatMapUv : '',
				t.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + t.clearcoatNormalMapUv : '',
				t.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + t.clearcoatRoughnessMapUv : '',
				t.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + t.iridescenceMapUv : '',
				t.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + t.iridescenceThicknessMapUv : '',
				t.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + t.sheenColorMapUv : '',
				t.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + t.sheenRoughnessMapUv : '',
				t.specularMapUv ? '#define SPECULARMAP_UV ' + t.specularMapUv : '',
				t.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + t.specularColorMapUv : '',
				t.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + t.specularIntensityMapUv : '',
				t.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + t.transmissionMapUv : '',
				t.thicknessMapUv ? '#define THICKNESSMAP_UV ' + t.thicknessMapUv : '',
				t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
				t.vertexColors ? '#define USE_COLOR' : '',
				t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				t.vertexUv1s ? '#define USE_UV1' : '',
				t.vertexUv2s ? '#define USE_UV2' : '',
				t.vertexUv3s ? '#define USE_UV3' : '',
				t.pointsUvs ? '#define USE_POINTS_UV' : '',
				t.flatShading ? '#define FLAT_SHADED' : '',
				t.skinning ? '#define USE_SKINNING' : '',
				t.morphTargets ? '#define USE_MORPHTARGETS' : '',
				t.morphNormals && t.flatShading === !1 ? '#define USE_MORPHNORMALS' : '',
				t.morphColors ? '#define USE_MORPHCOLORS' : '',
				t.morphTargetsCount > 0 ? '#define MORPHTARGETS_TEXTURE' : '',
				t.morphTargetsCount > 0 ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + t.morphTextureStride : '',
				t.morphTargetsCount > 0 ? '#define MORPHTARGETS_COUNT ' + t.morphTargetsCount : '',
				t.doubleSided ? '#define DOUBLE_SIDED' : '',
				t.flipSided ? '#define FLIP_SIDED' : '',
				t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				t.shadowMapEnabled ? '#define ' + l : '',
				t.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
				t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
				t.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
				t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',
				'#ifdef USE_INSTANCING',
				'	attribute mat4 instanceMatrix;',
				'#endif',
				'#ifdef USE_INSTANCING_COLOR',
				'	attribute vec3 instanceColor;',
				'#endif',
				'#ifdef USE_INSTANCING_MORPH',
				'	uniform sampler2D morphTexture;',
				'#endif',
				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',
				'#ifdef USE_UV1',
				'	attribute vec2 uv1;',
				'#endif',
				'#ifdef USE_UV2',
				'	attribute vec2 uv2;',
				'#endif',
				'#ifdef USE_UV3',
				'	attribute vec2 uv3;',
				'#endif',
				'#ifdef USE_TANGENT',
				'	attribute vec4 tangent;',
				'#endif',
				'#if defined( USE_COLOR_ALPHA )',
				'	attribute vec4 color;',
				'#elif defined( USE_COLOR )',
				'	attribute vec3 color;',
				'#endif',
				'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',
				'	#ifdef USE_MORPHNORMALS',
				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',
				'	#else',
				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',
				'	#endif',
				'#endif',
				'#ifdef USE_SKINNING',
				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',
				'#endif',
				'\n',
		  ]
				.filter(qc)
				.join('\n')),
		  (f = [
				Cx(t),
				'#define SHADER_TYPE ' + t.shaderType,
				'#define SHADER_NAME ' + t.shaderName,
				g,
				t.useFog && t.fog ? '#define USE_FOG' : '',
				t.useFog && t.fogExp2 ? '#define FOG_EXP2' : '',
				t.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '',
				t.map ? '#define USE_MAP' : '',
				t.matcap ? '#define USE_MATCAP' : '',
				t.envMap ? '#define USE_ENVMAP' : '',
				t.envMap ? '#define ' + c : '',
				t.envMap ? '#define ' + h : '',
				t.envMap ? '#define ' + u : '',
				d ? '#define CUBEUV_TEXEL_WIDTH ' + d.texelWidth : '',
				d ? '#define CUBEUV_TEXEL_HEIGHT ' + d.texelHeight : '',
				d ? '#define CUBEUV_MAX_MIP ' + d.maxMip + '.0' : '',
				t.lightMap ? '#define USE_LIGHTMAP' : '',
				t.aoMap ? '#define USE_AOMAP' : '',
				t.bumpMap ? '#define USE_BUMPMAP' : '',
				t.normalMap ? '#define USE_NORMALMAP' : '',
				t.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',
				t.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',
				t.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				t.anisotropy ? '#define USE_ANISOTROPY' : '',
				t.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',
				t.clearcoat ? '#define USE_CLEARCOAT' : '',
				t.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				t.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				t.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				t.dispersion ? '#define USE_DISPERSION' : '',
				t.iridescence ? '#define USE_IRIDESCENCE' : '',
				t.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
				t.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',
				t.specularMap ? '#define USE_SPECULARMAP' : '',
				t.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',
				t.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',
				t.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				t.metalnessMap ? '#define USE_METALNESSMAP' : '',
				t.alphaMap ? '#define USE_ALPHAMAP' : '',
				t.alphaTest ? '#define USE_ALPHATEST' : '',
				t.alphaHash ? '#define USE_ALPHAHASH' : '',
				t.sheen ? '#define USE_SHEEN' : '',
				t.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',
				t.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',
				t.transmission ? '#define USE_TRANSMISSION' : '',
				t.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
				t.thicknessMap ? '#define USE_THICKNESSMAP' : '',
				t.vertexTangents && t.flatShading === !1 ? '#define USE_TANGENT' : '',
				t.vertexColors || t.instancingColor ? '#define USE_COLOR' : '',
				t.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
				t.vertexUv1s ? '#define USE_UV1' : '',
				t.vertexUv2s ? '#define USE_UV2' : '',
				t.vertexUv3s ? '#define USE_UV3' : '',
				t.pointsUvs ? '#define USE_POINTS_UV' : '',
				t.gradientMap ? '#define USE_GRADIENTMAP' : '',
				t.flatShading ? '#define FLAT_SHADED' : '',
				t.doubleSided ? '#define DOUBLE_SIDED' : '',
				t.flipSided ? '#define FLIP_SIDED' : '',
				t.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				t.shadowMapEnabled ? '#define ' + l : '',
				t.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
				t.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '',
				t.useLegacyLights ? '#define LEGACY_LIGHTS' : '',
				t.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
				t.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',
				t.toneMapping !== Xs ? '#define TONE_MAPPING' : '',
				t.toneMapping !== Xs ? rt.tonemapping_pars_fragment : '',
				t.toneMapping !== Xs ? SU('toneMapping', t.toneMapping) : '',
				t.dithering ? '#define DITHERING' : '',
				t.opaque ? '#define OPAQUE' : '',
				rt.colorspace_pars_fragment,
				wU('linearToOutputTexel', t.outputColorSpace),
				t.useDepthPacking ? '#define DEPTH_PACKING ' + t.depthPacking : '',
				'\n',
		  ]
				.filter(qc)
				.join('\n'))),
		(o = iv(o)),
		(o = Ex(o, t)),
		(o = Tx(o, t)),
		(a = iv(a)),
		(a = Ex(a, t)),
		(a = Tx(a, t)),
		(o = Ax(o)),
		(a = Ax(a)),
		t.isRawShaderMaterial !== !0 &&
			((y = '#version 300 es\n'),
			(m = [p, '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + m),
			(f =
				[
					'#define varying in',
					t.glslVersion === nv ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
					t.glslVersion === nv ? '' : '#define gl_FragColor pc_fragColor',
					'#define gl_FragDepthEXT gl_FragDepth',
					'#define texture2D texture',
					'#define textureCube texture',
					'#define texture2DProj textureProj',
					'#define texture2DLodEXT textureLod',
					'#define texture2DProjLodEXT textureProjLod',
					'#define textureCubeLodEXT textureLod',
					'#define texture2DGradEXT textureGrad',
					'#define texture2DProjGradEXT textureProjGrad',
					'#define textureCubeGradEXT textureGrad',
				].join('\n') +
				'\n' +
				f));
	const _ = y + m + o,
		x = y + f + a,
		E = Sx(s, s.VERTEX_SHADER, _),
		w = Sx(s, s.FRAGMENT_SHADER, x);
	s.attachShader(v, E),
		s.attachShader(v, w),
		t.index0AttributeName !== void 0
			? s.bindAttribLocation(v, 0, t.index0AttributeName)
			: t.morphTargets === !0 && s.bindAttribLocation(v, 0, 'position'),
		s.linkProgram(v);
	function C(k) {
		if (i.debug.checkShaderErrors) {
			const q = s.getProgramInfoLog(v).trim(),
				B = s.getShaderInfoLog(E).trim(),
				W = s.getShaderInfoLog(w).trim();
			let Q = !0,
				$ = !0;
			if (s.getProgramParameter(v, s.LINK_STATUS) === !1)
				if (((Q = !1), typeof i.debug.onShaderError == 'function')) i.debug.onShaderError(s, v, E, w);
				else {
					const le = Mx(s, E, 'vertex'),
						Z = Mx(s, w, 'fragment');
					console.error(
						'THREE.WebGLProgram: Shader Error ' +
							s.getError() +
							' - VALIDATE_STATUS ' +
							s.getProgramParameter(v, s.VALIDATE_STATUS) +
							'\n\nMaterial Name: ' +
							k.name +
							'\nMaterial Type: ' +
							k.type +
							'\n\nProgram Info Log: ' +
							q +
							'\n' +
							le +
							'\n' +
							Z
					);
				}
			else q !== '' ? console.warn('THREE.WebGLProgram: Program Info Log:', q) : (B === '' || W === '') && ($ = !1);
			$ &&
				(k.diagnostics = {
					runnable: Q,
					programLog: q,
					vertexShader: { log: B, prefix: m },
					fragmentShader: { log: W, prefix: f },
				});
		}
		s.deleteShader(E), s.deleteShader(w), (P = new Vd(s, v)), (S = TU(s, v));
	}
	let P;
	this.getUniforms = function () {
		return P === void 0 && C(this), P;
	};
	let S;
	this.getAttributes = function () {
		return S === void 0 && C(this), S;
	};
	let M = t.rendererExtensionParallelShaderCompile === !1;
	return (
		(this.isReady = function () {
			return M === !1 && (M = s.getProgramParameter(v, _U)), M;
		}),
		(this.destroy = function () {
			n.releaseStatesOfProgram(this), s.deleteProgram(v), (this.program = void 0);
		}),
		(this.type = t.shaderType),
		(this.name = t.shaderName),
		(this.id = yU++),
		(this.cacheKey = e),
		(this.usedTimes = 1),
		(this.program = v),
		(this.vertexShader = E),
		(this.fragmentShader = w),
		this
	);
}
let BU = 0;
class kU {
	constructor() {
		(this.shaderCache = new Map()), (this.materialCache = new Map());
	}
	update(e) {
		const t = e.vertexShader,
			n = e.fragmentShader,
			s = this._getShaderStage(t),
			r = this._getShaderStage(n),
			o = this._getShaderCacheForMaterial(e);
		return o.has(s) === !1 && (o.add(s), s.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this;
	}
	remove(e) {
		const t = this.materialCache.get(e);
		for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
		return this.materialCache.delete(e), this;
	}
	getVertexShaderID(e) {
		return this._getShaderStage(e.vertexShader).id;
	}
	getFragmentShaderID(e) {
		return this._getShaderStage(e.fragmentShader).id;
	}
	dispose() {
		this.shaderCache.clear(), this.materialCache.clear();
	}
	_getShaderCacheForMaterial(e) {
		const t = this.materialCache;
		let n = t.get(e);
		return n === void 0 && ((n = new Set()), t.set(e, n)), n;
	}
	_getShaderStage(e) {
		const t = this.shaderCache;
		let n = t.get(e);
		return n === void 0 && ((n = new zU(e)), t.set(e, n)), n;
	}
}
class zU {
	constructor(e) {
		(this.id = BU++), (this.code = e), (this.usedTimes = 0);
	}
}
function VU(i, e, t, n, s, r, o) {
	const a = new Gp(),
		l = new kU(),
		c = new Set(),
		h = [],
		u = s.logarithmicDepthBuffer,
		d = s.vertexTextures;
	let p = s.precision;
	const g = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite',
	};
	function v(S) {
		return c.add(S), S === 0 ? 'uv' : 'uv'.concat(S);
	}
	function m(S, M, k, q, B) {
		const W = q.fog,
			Q = B.geometry,
			$ = S.isMeshStandardMaterial ? q.environment : null,
			le = (S.isMeshStandardMaterial ? t : e).get(S.envMap || $),
			Z = le && le.mapping === lc ? le.image.height : null,
			xe = g[S.type];
		S.precision !== null &&
			((p = s.getMaxPrecision(S.precision)),
			p !== S.precision && console.warn('THREE.WebGLProgram.getParameters:', S.precision, 'not supported, using', p, 'instead.'));
		const ue = Q.morphAttributes.position || Q.morphAttributes.normal || Q.morphAttributes.color,
			Te = ue !== void 0 ? ue.length : 0;
		let Ae = 0;
		Q.morphAttributes.position !== void 0 && (Ae = 1),
			Q.morphAttributes.normal !== void 0 && (Ae = 2),
			Q.morphAttributes.color !== void 0 && (Ae = 3);
		let We, se, Se, we;
		if (xe) {
			const Ct = _s[xe];
			(We = Ct.vertexShader), (se = Ct.fragmentShader);
		} else (We = S.vertexShader), (se = S.fragmentShader), l.update(S), (Se = l.getVertexShaderID(S)), (we = l.getFragmentShaderID(S));
		const X = i.getRenderTarget(),
			ge = B.isInstancedMesh === !0,
			be = B.isBatchedMesh === !0,
			H = !!S.map,
			Ne = !!S.matcap,
			oe = !!le,
			L = !!S.aoMap,
			D = !!S.lightMap,
			z = !!S.bumpMap,
			Y = !!S.normalMap,
			K = !!S.displacementMap,
			re = !!S.emissiveMap,
			O = !!S.metalnessMap,
			T = !!S.roughnessMap,
			V = S.anisotropy > 0,
			G = S.clearcoat > 0,
			ee = S.dispersion > 0,
			ne = S.iridescence > 0,
			_e = S.sheen > 0,
			me = S.transmission > 0,
			ye = V && !!S.anisotropyMap,
			De = G && !!S.clearcoatMap,
			ve = G && !!S.clearcoatNormalMap,
			Le = G && !!S.clearcoatRoughnessMap,
			Ye = ne && !!S.iridescenceMap,
			Xe = ne && !!S.iridescenceThicknessMap,
			Ie = _e && !!S.sheenColorMap,
			Ve = _e && !!S.sheenRoughnessMap,
			it = !!S.specularMap,
			Qe = !!S.specularColorMap,
			Be = !!S.specularIntensityMap,
			j = me && !!S.transmissionMap,
			Me = me && !!S.thicknessMap,
			J = !!S.gradientMap,
			Ce = !!S.alphaMap,
			Fe = S.alphaTest > 0,
			gt = !!S.alphaHash,
			Bt = !!S.extensions;
		let Kt = Xs;
		S.toneMapped && (X === null || X.isXRRenderTarget === !0) && (Kt = i.toneMapping);
		const Pn = {
			shaderID: xe,
			shaderType: S.type,
			shaderName: S.name,
			vertexShader: We,
			fragmentShader: se,
			defines: S.defines,
			customVertexShaderID: Se,
			customFragmentShaderID: we,
			isRawShaderMaterial: S.isRawShaderMaterial === !0,
			glslVersion: S.glslVersion,
			precision: p,
			batching: be,
			instancing: ge,
			instancingColor: ge && B.instanceColor !== null,
			instancingMorph: ge && B.morphTexture !== null,
			supportsVertexTextures: d,
			outputColorSpace: X === null ? i.outputColorSpace : X.isXRRenderTarget === !0 ? X.texture.colorSpace : Es,
			alphaToCoverage: !!S.alphaToCoverage,
			map: H,
			matcap: Ne,
			envMap: oe,
			envMapMode: oe && le.mapping,
			envMapCubeUVHeight: Z,
			aoMap: L,
			lightMap: D,
			bumpMap: z,
			normalMap: Y,
			displacementMap: d && K,
			emissiveMap: re,
			normalMapObjectSpace: Y && S.normalMapType === KM,
			normalMapTangentSpace: Y && S.normalMapType === Ro,
			metalnessMap: O,
			roughnessMap: T,
			anisotropy: V,
			anisotropyMap: ye,
			clearcoat: G,
			clearcoatMap: De,
			clearcoatNormalMap: ve,
			clearcoatRoughnessMap: Le,
			dispersion: ee,
			iridescence: ne,
			iridescenceMap: Ye,
			iridescenceThicknessMap: Xe,
			sheen: _e,
			sheenColorMap: Ie,
			sheenRoughnessMap: Ve,
			specularMap: it,
			specularColorMap: Qe,
			specularIntensityMap: Be,
			transmission: me,
			transmissionMap: j,
			thicknessMap: Me,
			gradientMap: J,
			opaque: S.transparent === !1 && S.blending === co && S.alphaToCoverage === !1,
			alphaMap: Ce,
			alphaTest: Fe,
			alphaHash: gt,
			combine: S.combine,
			mapUv: H && v(S.map.channel),
			aoMapUv: L && v(S.aoMap.channel),
			lightMapUv: D && v(S.lightMap.channel),
			bumpMapUv: z && v(S.bumpMap.channel),
			normalMapUv: Y && v(S.normalMap.channel),
			displacementMapUv: K && v(S.displacementMap.channel),
			emissiveMapUv: re && v(S.emissiveMap.channel),
			metalnessMapUv: O && v(S.metalnessMap.channel),
			roughnessMapUv: T && v(S.roughnessMap.channel),
			anisotropyMapUv: ye && v(S.anisotropyMap.channel),
			clearcoatMapUv: De && v(S.clearcoatMap.channel),
			clearcoatNormalMapUv: ve && v(S.clearcoatNormalMap.channel),
			clearcoatRoughnessMapUv: Le && v(S.clearcoatRoughnessMap.channel),
			iridescenceMapUv: Ye && v(S.iridescenceMap.channel),
			iridescenceThicknessMapUv: Xe && v(S.iridescenceThicknessMap.channel),
			sheenColorMapUv: Ie && v(S.sheenColorMap.channel),
			sheenRoughnessMapUv: Ve && v(S.sheenRoughnessMap.channel),
			specularMapUv: it && v(S.specularMap.channel),
			specularColorMapUv: Qe && v(S.specularColorMap.channel),
			specularIntensityMapUv: Be && v(S.specularIntensityMap.channel),
			transmissionMapUv: j && v(S.transmissionMap.channel),
			thicknessMapUv: Me && v(S.thicknessMap.channel),
			alphaMapUv: Ce && v(S.alphaMap.channel),
			vertexTangents: !!Q.attributes.tangent && (Y || V),
			vertexColors: S.vertexColors,
			vertexAlphas: S.vertexColors === !0 && !!Q.attributes.color && Q.attributes.color.itemSize === 4,
			pointsUvs: B.isPoints === !0 && !!Q.attributes.uv && (H || Ce),
			fog: !!W,
			useFog: S.fog === !0,
			fogExp2: !!W && W.isFogExp2,
			flatShading: S.flatShading === !0,
			sizeAttenuation: S.sizeAttenuation === !0,
			logarithmicDepthBuffer: u,
			skinning: B.isSkinnedMesh === !0,
			morphTargets: Q.morphAttributes.position !== void 0,
			morphNormals: Q.morphAttributes.normal !== void 0,
			morphColors: Q.morphAttributes.color !== void 0,
			morphTargetsCount: Te,
			morphTextureStride: Ae,
			numDirLights: M.directional.length,
			numPointLights: M.point.length,
			numSpotLights: M.spot.length,
			numSpotLightMaps: M.spotLightMap.length,
			numRectAreaLights: M.rectArea.length,
			numHemiLights: M.hemi.length,
			numDirLightShadows: M.directionalShadowMap.length,
			numPointLightShadows: M.pointShadowMap.length,
			numSpotLightShadows: M.spotShadowMap.length,
			numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
			numLightProbes: M.numLightProbes,
			numClippingPlanes: o.numPlanes,
			numClipIntersection: o.numIntersection,
			dithering: S.dithering,
			shadowMapEnabled: i.shadowMap.enabled && k.length > 0,
			shadowMapType: i.shadowMap.type,
			toneMapping: Kt,
			useLegacyLights: i._useLegacyLights,
			decodeVideoTexture: H && S.map.isVideoTexture === !0 && Ft.getTransfer(S.map.colorSpace) === Wt,
			premultipliedAlpha: S.premultipliedAlpha,
			doubleSided: S.side === mn,
			flipSided: S.side === gn,
			useDepthPacking: S.depthPacking >= 0,
			depthPacking: S.depthPacking || 0,
			index0AttributeName: S.index0AttributeName,
			extensionClipCullDistance: Bt && S.extensions.clipCullDistance === !0 && n.has('WEBGL_clip_cull_distance'),
			extensionMultiDraw: Bt && S.extensions.multiDraw === !0 && n.has('WEBGL_multi_draw'),
			rendererExtensionParallelShaderCompile: n.has('KHR_parallel_shader_compile'),
			customProgramCacheKey: S.customProgramCacheKey(),
		};
		return (Pn.vertexUv1s = c.has(1)), (Pn.vertexUv2s = c.has(2)), (Pn.vertexUv3s = c.has(3)), c.clear(), Pn;
	}
	function f(S) {
		const M = [];
		if ((S.shaderID ? M.push(S.shaderID) : (M.push(S.customVertexShaderID), M.push(S.customFragmentShaderID)), S.defines !== void 0))
			for (const k in S.defines) M.push(k), M.push(S.defines[k]);
		return S.isRawShaderMaterial === !1 && (y(M, S), _(M, S), M.push(i.outputColorSpace)), M.push(S.customProgramCacheKey), M.join();
	}
	function y(S, M) {
		S.push(M.precision),
			S.push(M.outputColorSpace),
			S.push(M.envMapMode),
			S.push(M.envMapCubeUVHeight),
			S.push(M.mapUv),
			S.push(M.alphaMapUv),
			S.push(M.lightMapUv),
			S.push(M.aoMapUv),
			S.push(M.bumpMapUv),
			S.push(M.normalMapUv),
			S.push(M.displacementMapUv),
			S.push(M.emissiveMapUv),
			S.push(M.metalnessMapUv),
			S.push(M.roughnessMapUv),
			S.push(M.anisotropyMapUv),
			S.push(M.clearcoatMapUv),
			S.push(M.clearcoatNormalMapUv),
			S.push(M.clearcoatRoughnessMapUv),
			S.push(M.iridescenceMapUv),
			S.push(M.iridescenceThicknessMapUv),
			S.push(M.sheenColorMapUv),
			S.push(M.sheenRoughnessMapUv),
			S.push(M.specularMapUv),
			S.push(M.specularColorMapUv),
			S.push(M.specularIntensityMapUv),
			S.push(M.transmissionMapUv),
			S.push(M.thicknessMapUv),
			S.push(M.combine),
			S.push(M.fogExp2),
			S.push(M.sizeAttenuation),
			S.push(M.morphTargetsCount),
			S.push(M.morphAttributeCount),
			S.push(M.numDirLights),
			S.push(M.numPointLights),
			S.push(M.numSpotLights),
			S.push(M.numSpotLightMaps),
			S.push(M.numHemiLights),
			S.push(M.numRectAreaLights),
			S.push(M.numDirLightShadows),
			S.push(M.numPointLightShadows),
			S.push(M.numSpotLightShadows),
			S.push(M.numSpotLightShadowsWithMaps),
			S.push(M.numLightProbes),
			S.push(M.shadowMapType),
			S.push(M.toneMapping),
			S.push(M.numClippingPlanes),
			S.push(M.numClipIntersection),
			S.push(M.depthPacking);
	}
	function _(S, M) {
		a.disableAll(),
			M.supportsVertexTextures && a.enable(0),
			M.instancing && a.enable(1),
			M.instancingColor && a.enable(2),
			M.instancingMorph && a.enable(3),
			M.matcap && a.enable(4),
			M.envMap && a.enable(5),
			M.normalMapObjectSpace && a.enable(6),
			M.normalMapTangentSpace && a.enable(7),
			M.clearcoat && a.enable(8),
			M.iridescence && a.enable(9),
			M.alphaTest && a.enable(10),
			M.vertexColors && a.enable(11),
			M.vertexAlphas && a.enable(12),
			M.vertexUv1s && a.enable(13),
			M.vertexUv2s && a.enable(14),
			M.vertexUv3s && a.enable(15),
			M.vertexTangents && a.enable(16),
			M.anisotropy && a.enable(17),
			M.alphaHash && a.enable(18),
			M.batching && a.enable(19),
			M.dispersion && a.enable(20),
			S.push(a.mask),
			a.disableAll(),
			M.fog && a.enable(0),
			M.useFog && a.enable(1),
			M.flatShading && a.enable(2),
			M.logarithmicDepthBuffer && a.enable(3),
			M.skinning && a.enable(4),
			M.morphTargets && a.enable(5),
			M.morphNormals && a.enable(6),
			M.morphColors && a.enable(7),
			M.premultipliedAlpha && a.enable(8),
			M.shadowMapEnabled && a.enable(9),
			M.useLegacyLights && a.enable(10),
			M.doubleSided && a.enable(11),
			M.flipSided && a.enable(12),
			M.useDepthPacking && a.enable(13),
			M.dithering && a.enable(14),
			M.transmission && a.enable(15),
			M.sheen && a.enable(16),
			M.opaque && a.enable(17),
			M.pointsUvs && a.enable(18),
			M.decodeVideoTexture && a.enable(19),
			M.alphaToCoverage && a.enable(20),
			S.push(a.mask);
	}
	function x(S) {
		const M = g[S.type];
		let k;
		if (M) {
			const q = _s[M];
			k = hE.clone(q.uniforms);
		} else k = S.uniforms;
		return k;
	}
	function E(S, M) {
		let k;
		for (let q = 0, B = h.length; q < B; q++) {
			const W = h[q];
			if (W.cacheKey === M) {
				(k = W), ++k.usedTimes;
				break;
			}
		}
		return k === void 0 && ((k = new FU(i, M, S, r)), h.push(k)), k;
	}
	function w(S) {
		if (--S.usedTimes === 0) {
			const M = h.indexOf(S);
			(h[M] = h[h.length - 1]), h.pop(), S.destroy();
		}
	}
	function C(S) {
		l.remove(S);
	}
	function P() {
		l.dispose();
	}
	return {
		getParameters: m,
		getProgramCacheKey: f,
		getUniforms: x,
		acquireProgram: E,
		releaseProgram: w,
		releaseShaderCache: C,
		programs: h,
		dispose: P,
	};
}
function HU() {
	let i = new WeakMap();
	function e(r) {
		let o = i.get(r);
		return o === void 0 && ((o = {}), i.set(r, o)), o;
	}
	function t(r) {
		i.delete(r);
	}
	function n(r, o, a) {
		i.get(r)[o] = a;
	}
	function s() {
		i = new WeakMap();
	}
	return { get: e, remove: t, update: n, dispose: s };
}
function GU(i, e) {
	return i.groupOrder !== e.groupOrder
		? i.groupOrder - e.groupOrder
		: i.renderOrder !== e.renderOrder
		? i.renderOrder - e.renderOrder
		: i.material.id !== e.material.id
		? i.material.id - e.material.id
		: i.z !== e.z
		? i.z - e.z
		: i.id - e.id;
}
function Rx(i, e) {
	return i.groupOrder !== e.groupOrder
		? i.groupOrder - e.groupOrder
		: i.renderOrder !== e.renderOrder
		? i.renderOrder - e.renderOrder
		: i.z !== e.z
		? e.z - i.z
		: i.id - e.id;
}
function Px() {
	const i = [];
	let e = 0;
	const t = [],
		n = [],
		s = [];
	function r() {
		(e = 0), (t.length = 0), (n.length = 0), (s.length = 0);
	}
	function o(u, d, p, g, v, m) {
		let f = i[e];
		return (
			f === void 0
				? ((f = { id: u.id, object: u, geometry: d, material: p, groupOrder: g, renderOrder: u.renderOrder, z: v, group: m }),
				  (i[e] = f))
				: ((f.id = u.id),
				  (f.object = u),
				  (f.geometry = d),
				  (f.material = p),
				  (f.groupOrder = g),
				  (f.renderOrder = u.renderOrder),
				  (f.z = v),
				  (f.group = m)),
			e++,
			f
		);
	}
	function a(u, d, p, g, v, m) {
		const f = o(u, d, p, g, v, m);
		p.transmission > 0 ? n.push(f) : p.transparent === !0 ? s.push(f) : t.push(f);
	}
	function l(u, d, p, g, v, m) {
		const f = o(u, d, p, g, v, m);
		p.transmission > 0 ? n.unshift(f) : p.transparent === !0 ? s.unshift(f) : t.unshift(f);
	}
	function c(u, d) {
		t.length > 1 && t.sort(u || GU), n.length > 1 && n.sort(d || Rx), s.length > 1 && s.sort(d || Rx);
	}
	function h() {
		for (let u = e, d = i.length; u < d; u++) {
			const p = i[u];
			if (p.id === null) break;
			(p.id = null), (p.object = null), (p.geometry = null), (p.material = null), (p.group = null);
		}
	}
	return { opaque: t, transmissive: n, transparent: s, init: r, push: a, unshift: l, finish: h, sort: c };
}
function WU() {
	let i = new WeakMap();
	function e(n, s) {
		const r = i.get(n);
		let o;
		return r === void 0 ? ((o = new Px()), i.set(n, [o])) : s >= r.length ? ((o = new Px()), r.push(o)) : (o = r[s]), o;
	}
	function t() {
		i = new WeakMap();
	}
	return { get: e, dispose: t };
}
function XU() {
	const i = {};
	return {
		get: function (e) {
			if (i[e.id] !== void 0) return i[e.id];
			let t;
			switch (e.type) {
				case 'DirectionalLight':
					t = { direction: new I(), color: new Ee() };
					break;
				case 'SpotLight':
					t = { position: new I(), direction: new I(), color: new Ee(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
					break;
				case 'PointLight':
					t = { position: new I(), color: new Ee(), distance: 0, decay: 0 };
					break;
				case 'HemisphereLight':
					t = { direction: new I(), skyColor: new Ee(), groundColor: new Ee() };
					break;
				case 'RectAreaLight':
					t = { color: new Ee(), position: new I(), halfWidth: new I(), halfHeight: new I() };
					break;
			}
			return (i[e.id] = t), t;
		},
	};
}
function qU() {
	const i = {};
	return {
		get: function (e) {
			if (i[e.id] !== void 0) return i[e.id];
			let t;
			switch (e.type) {
				case 'DirectionalLight':
					t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ce() };
					break;
				case 'SpotLight':
					t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new ce() };
					break;
				case 'PointLight':
					t = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new ce(),
						shadowCameraNear: 1,
						shadowCameraFar: 1e3,
					};
					break;
			}
			return (i[e.id] = t), t;
		},
	};
}
let YU = 0;
function jU(i, e) {
	return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
}
function KU(i) {
	const e = new XU(),
		t = qU(),
		n = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1,
				numSpotMaps: -1,
				numLightProbes: -1,
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0,
			numLightProbes: 0,
		};
	for (let c = 0; c < 9; c++) n.probe.push(new I());
	const s = new I(),
		r = new He(),
		o = new He();
	function a(c, h) {
		let u = 0,
			d = 0,
			p = 0;
		for (let k = 0; k < 9; k++) n.probe[k].set(0, 0, 0);
		let g = 0,
			v = 0,
			m = 0,
			f = 0,
			y = 0,
			_ = 0,
			x = 0,
			E = 0,
			w = 0,
			C = 0,
			P = 0;
		c.sort(jU);
		const S = h === !0 ? Math.PI : 1;
		for (let k = 0, q = c.length; k < q; k++) {
			const B = c[k],
				W = B.color,
				Q = B.intensity,
				$ = B.distance,
				le = B.shadow && B.shadow.map ? B.shadow.map.texture : null;
			if (B.isAmbientLight) (u += W.r * Q * S), (d += W.g * Q * S), (p += W.b * Q * S);
			else if (B.isLightProbe) {
				for (let Z = 0; Z < 9; Z++) n.probe[Z].addScaledVector(B.sh.coefficients[Z], Q);
				P++;
			} else if (B.isDirectionalLight) {
				const Z = e.get(B);
				if ((Z.color.copy(B.color).multiplyScalar(B.intensity * S), B.castShadow)) {
					const xe = B.shadow,
						ue = t.get(B);
					(ue.shadowBias = xe.bias),
						(ue.shadowNormalBias = xe.normalBias),
						(ue.shadowRadius = xe.radius),
						(ue.shadowMapSize = xe.mapSize),
						(n.directionalShadow[g] = ue),
						(n.directionalShadowMap[g] = le),
						(n.directionalShadowMatrix[g] = B.shadow.matrix),
						_++;
				}
				(n.directional[g] = Z), g++;
			} else if (B.isSpotLight) {
				const Z = e.get(B);
				Z.position.setFromMatrixPosition(B.matrixWorld),
					Z.color.copy(W).multiplyScalar(Q * S),
					(Z.distance = $),
					(Z.coneCos = Math.cos(B.angle)),
					(Z.penumbraCos = Math.cos(B.angle * (1 - B.penumbra))),
					(Z.decay = B.decay),
					(n.spot[m] = Z);
				const xe = B.shadow;
				if (
					(B.map && ((n.spotLightMap[w] = B.map), w++, xe.updateMatrices(B), B.castShadow && C++),
					(n.spotLightMatrix[m] = xe.matrix),
					B.castShadow)
				) {
					const ue = t.get(B);
					(ue.shadowBias = xe.bias),
						(ue.shadowNormalBias = xe.normalBias),
						(ue.shadowRadius = xe.radius),
						(ue.shadowMapSize = xe.mapSize),
						(n.spotShadow[m] = ue),
						(n.spotShadowMap[m] = le),
						E++;
				}
				m++;
			} else if (B.isRectAreaLight) {
				const Z = e.get(B);
				Z.color.copy(W).multiplyScalar(Q),
					Z.halfWidth.set(B.width * 0.5, 0, 0),
					Z.halfHeight.set(0, B.height * 0.5, 0),
					(n.rectArea[f] = Z),
					f++;
			} else if (B.isPointLight) {
				const Z = e.get(B);
				if ((Z.color.copy(B.color).multiplyScalar(B.intensity * S), (Z.distance = B.distance), (Z.decay = B.decay), B.castShadow)) {
					const xe = B.shadow,
						ue = t.get(B);
					(ue.shadowBias = xe.bias),
						(ue.shadowNormalBias = xe.normalBias),
						(ue.shadowRadius = xe.radius),
						(ue.shadowMapSize = xe.mapSize),
						(ue.shadowCameraNear = xe.camera.near),
						(ue.shadowCameraFar = xe.camera.far),
						(n.pointShadow[v] = ue),
						(n.pointShadowMap[v] = le),
						(n.pointShadowMatrix[v] = B.shadow.matrix),
						x++;
				}
				(n.point[v] = Z), v++;
			} else if (B.isHemisphereLight) {
				const Z = e.get(B);
				Z.skyColor.copy(B.color).multiplyScalar(Q * S),
					Z.groundColor.copy(B.groundColor).multiplyScalar(Q * S),
					(n.hemi[y] = Z),
					y++;
			}
		}
		f > 0 &&
			(i.has('OES_texture_float_linear') === !0
				? ((n.rectAreaLTC1 = Pe.LTC_FLOAT_1), (n.rectAreaLTC2 = Pe.LTC_FLOAT_2))
				: ((n.rectAreaLTC1 = Pe.LTC_HALF_1), (n.rectAreaLTC2 = Pe.LTC_HALF_2))),
			(n.ambient[0] = u),
			(n.ambient[1] = d),
			(n.ambient[2] = p);
		const M = n.hash;
		(M.directionalLength !== g ||
			M.pointLength !== v ||
			M.spotLength !== m ||
			M.rectAreaLength !== f ||
			M.hemiLength !== y ||
			M.numDirectionalShadows !== _ ||
			M.numPointShadows !== x ||
			M.numSpotShadows !== E ||
			M.numSpotMaps !== w ||
			M.numLightProbes !== P) &&
			((n.directional.length = g),
			(n.spot.length = m),
			(n.rectArea.length = f),
			(n.point.length = v),
			(n.hemi.length = y),
			(n.directionalShadow.length = _),
			(n.directionalShadowMap.length = _),
			(n.pointShadow.length = x),
			(n.pointShadowMap.length = x),
			(n.spotShadow.length = E),
			(n.spotShadowMap.length = E),
			(n.directionalShadowMatrix.length = _),
			(n.pointShadowMatrix.length = x),
			(n.spotLightMatrix.length = E + w - C),
			(n.spotLightMap.length = w),
			(n.numSpotLightShadowsWithMaps = C),
			(n.numLightProbes = P),
			(M.directionalLength = g),
			(M.pointLength = v),
			(M.spotLength = m),
			(M.rectAreaLength = f),
			(M.hemiLength = y),
			(M.numDirectionalShadows = _),
			(M.numPointShadows = x),
			(M.numSpotShadows = E),
			(M.numSpotMaps = w),
			(M.numLightProbes = P),
			(n.version = YU++));
	}
	function l(c, h) {
		let u = 0,
			d = 0,
			p = 0,
			g = 0,
			v = 0;
		const m = h.matrixWorldInverse;
		for (let f = 0, y = c.length; f < y; f++) {
			const _ = c[f];
			if (_.isDirectionalLight) {
				const x = n.directional[u];
				x.direction.setFromMatrixPosition(_.matrixWorld),
					s.setFromMatrixPosition(_.target.matrixWorld),
					x.direction.sub(s),
					x.direction.transformDirection(m),
					u++;
			} else if (_.isSpotLight) {
				const x = n.spot[p];
				x.position.setFromMatrixPosition(_.matrixWorld),
					x.position.applyMatrix4(m),
					x.direction.setFromMatrixPosition(_.matrixWorld),
					s.setFromMatrixPosition(_.target.matrixWorld),
					x.direction.sub(s),
					x.direction.transformDirection(m),
					p++;
			} else if (_.isRectAreaLight) {
				const x = n.rectArea[g];
				x.position.setFromMatrixPosition(_.matrixWorld),
					x.position.applyMatrix4(m),
					o.identity(),
					r.copy(_.matrixWorld),
					r.premultiply(m),
					o.extractRotation(r),
					x.halfWidth.set(_.width * 0.5, 0, 0),
					x.halfHeight.set(0, _.height * 0.5, 0),
					x.halfWidth.applyMatrix4(o),
					x.halfHeight.applyMatrix4(o),
					g++;
			} else if (_.isPointLight) {
				const x = n.point[d];
				x.position.setFromMatrixPosition(_.matrixWorld), x.position.applyMatrix4(m), d++;
			} else if (_.isHemisphereLight) {
				const x = n.hemi[v];
				x.direction.setFromMatrixPosition(_.matrixWorld), x.direction.transformDirection(m), v++;
			}
		}
	}
	return { setup: a, setupView: l, state: n };
}
function Lx(i) {
	const e = new KU(i),
		t = [],
		n = [];
	function s(h) {
		(c.camera = h), (t.length = 0), (n.length = 0);
	}
	function r(h) {
		t.push(h);
	}
	function o(h) {
		n.push(h);
	}
	function a(h) {
		e.setup(t, h);
	}
	function l(h) {
		e.setupView(t, h);
	}
	const c = { lightsArray: t, shadowsArray: n, camera: null, lights: e, transmissionRenderTarget: {} };
	return { init: s, state: c, setupLights: a, setupLightsView: l, pushLight: r, pushShadow: o };
}
function $U(i) {
	let e = new WeakMap();
	function t(s, r = 0) {
		const o = e.get(s);
		let a;
		return o === void 0 ? ((a = new Lx(i)), e.set(s, [a])) : r >= o.length ? ((a = new Lx(i)), o.push(a)) : (a = o[r]), a;
	}
	function n() {
		e = new WeakMap();
	}
	return { get: t, dispose: n };
}
class qp extends vn {
	constructor(e) {
		super(),
			(this.isMeshDepthMaterial = !0),
			(this.type = 'MeshDepthMaterial'),
			(this.depthPacking = yr),
			(this.map = null),
			(this.alphaMap = null),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.depthPacking = e.depthPacking),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			this
		);
	}
}
class P_ extends vn {
	constructor(e) {
		super(),
			(this.isMeshDistanceMaterial = !0),
			(this.type = 'MeshDistanceMaterial'),
			(this.map = null),
			(this.alphaMap = null),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			this
		);
	}
}
const ZU = 'void main() {\n	gl_Position = vec4( position, 1.0 );\n}',
	JU =
		'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}';
function QU(i, e, t) {
	let n = new Qh();
	const s = new ce(),
		r = new ce(),
		o = new Pt(),
		a = new qp({ depthPacking: zp }),
		l = new P_(),
		c = {},
		h = t.maxTextureSize,
		u = { [Ms]: gn, [gn]: Ms, [mn]: mn },
		d = new xn({
			defines: { VSM_SAMPLES: 8 },
			uniforms: { shadow_pass: { value: null }, resolution: { value: new ce() }, radius: { value: 4 } },
			vertexShader: ZU,
			fragmentShader: JU,
		}),
		p = d.clone();
	p.defines.HORIZONTAL_PASS = 1;
	const g = new Ze();
	g.setAttribute('position', new $e(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
	const v = new bt(g, d),
		m = this;
	(this.enabled = !1), (this.autoUpdate = !0), (this.needsUpdate = !1), (this.type = a_);
	let f = this.type;
	this.render = function (w, C, P) {
		if (m.enabled === !1 || (m.autoUpdate === !1 && m.needsUpdate === !1) || w.length === 0) return;
		const S = i.getRenderTarget(),
			M = i.getActiveCubeFace(),
			k = i.getActiveMipmapLevel(),
			q = i.state;
		q.setBlending(jn), q.buffers.color.setClear(1, 1, 1, 1), q.buffers.depth.setTest(!0), q.setScissorTest(!1);
		const B = f !== Us && this.type === Us,
			W = f === Us && this.type !== Us;
		for (let Q = 0, $ = w.length; Q < $; Q++) {
			const le = w[Q],
				Z = le.shadow;
			if (Z === void 0) {
				console.warn('THREE.WebGLShadowMap:', le, 'has no shadow.');
				continue;
			}
			if (Z.autoUpdate === !1 && Z.needsUpdate === !1) continue;
			s.copy(Z.mapSize);
			const xe = Z.getFrameExtents();
			if (
				(s.multiply(xe),
				r.copy(Z.mapSize),
				(s.x > h || s.y > h) &&
					(s.x > h && ((r.x = Math.floor(h / xe.x)), (s.x = r.x * xe.x), (Z.mapSize.x = r.x)),
					s.y > h && ((r.y = Math.floor(h / xe.y)), (s.y = r.y * xe.y), (Z.mapSize.y = r.y))),
				Z.map === null || B === !0 || W === !0)
			) {
				const Te = this.type !== Us ? { minFilter: It, magFilter: It } : {};
				Z.map !== null && Z.map.dispose(),
					(Z.map = new yn(s.x, s.y, Te)),
					(Z.map.texture.name = le.name + '.shadowMap'),
					Z.camera.updateProjectionMatrix();
			}
			i.setRenderTarget(Z.map), i.clear();
			const ue = Z.getViewportCount();
			for (let Te = 0; Te < ue; Te++) {
				const Ae = Z.getViewport(Te);
				o.set(r.x * Ae.x, r.y * Ae.y, r.x * Ae.z, r.y * Ae.w),
					q.viewport(o),
					Z.updateMatrices(le, Te),
					(n = Z.getFrustum()),
					x(C, P, Z.camera, le, this.type);
			}
			Z.isPointLightShadow !== !0 && this.type === Us && y(Z, P), (Z.needsUpdate = !1);
		}
		(f = this.type), (m.needsUpdate = !1), i.setRenderTarget(S, M, k);
	};
	function y(w, C) {
		const P = e.update(v);
		d.defines.VSM_SAMPLES !== w.blurSamples &&
			((d.defines.VSM_SAMPLES = w.blurSamples), (p.defines.VSM_SAMPLES = w.blurSamples), (d.needsUpdate = !0), (p.needsUpdate = !0)),
			w.mapPass === null && (w.mapPass = new yn(s.x, s.y)),
			(d.uniforms.shadow_pass.value = w.map.texture),
			(d.uniforms.resolution.value = w.mapSize),
			(d.uniforms.radius.value = w.radius),
			i.setRenderTarget(w.mapPass),
			i.clear(),
			i.renderBufferDirect(C, null, P, d, v, null),
			(p.uniforms.shadow_pass.value = w.mapPass.texture),
			(p.uniforms.resolution.value = w.mapSize),
			(p.uniforms.radius.value = w.radius),
			i.setRenderTarget(w.map),
			i.clear(),
			i.renderBufferDirect(C, null, P, p, v, null);
	}
	function _(w, C, P, S) {
		let M = null;
		const k = P.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
		if (k !== void 0) M = k;
		else if (
			((M = P.isPointLight === !0 ? l : a),
			(i.localClippingEnabled && C.clipShadows === !0 && Array.isArray(C.clippingPlanes) && C.clippingPlanes.length !== 0) ||
				(C.displacementMap && C.displacementScale !== 0) ||
				(C.alphaMap && C.alphaTest > 0) ||
				(C.map && C.alphaTest > 0))
		) {
			const q = M.uuid,
				B = C.uuid;
			let W = c[q];
			W === void 0 && ((W = {}), (c[q] = W));
			let Q = W[B];
			Q === void 0 && ((Q = M.clone()), (W[B] = Q), C.addEventListener('dispose', E)), (M = Q);
		}
		if (
			((M.visible = C.visible),
			(M.wireframe = C.wireframe),
			S === Us
				? (M.side = C.shadowSide !== null ? C.shadowSide : C.side)
				: (M.side = C.shadowSide !== null ? C.shadowSide : u[C.side]),
			(M.alphaMap = C.alphaMap),
			(M.alphaTest = C.alphaTest),
			(M.map = C.map),
			(M.clipShadows = C.clipShadows),
			(M.clippingPlanes = C.clippingPlanes),
			(M.clipIntersection = C.clipIntersection),
			(M.displacementMap = C.displacementMap),
			(M.displacementScale = C.displacementScale),
			(M.displacementBias = C.displacementBias),
			(M.wireframeLinewidth = C.wireframeLinewidth),
			(M.linewidth = C.linewidth),
			P.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
		) {
			const q = i.properties.get(M);
			q.light = P;
		}
		return M;
	}
	function x(w, C, P, S, M) {
		if (w.visible === !1) return;
		if (
			w.layers.test(C.layers) &&
			(w.isMesh || w.isLine || w.isPoints) &&
			(w.castShadow || (w.receiveShadow && M === Us)) &&
			(!w.frustumCulled || n.intersectsObject(w))
		) {
			w.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, w.matrixWorld);
			const B = e.update(w),
				W = w.material;
			if (Array.isArray(W)) {
				const Q = B.groups;
				for (let $ = 0, le = Q.length; $ < le; $++) {
					const Z = Q[$],
						xe = W[Z.materialIndex];
					if (xe && xe.visible) {
						const ue = _(w, xe, S, M);
						w.onBeforeShadow(i, w, C, P, B, ue, Z),
							i.renderBufferDirect(P, null, B, ue, w, Z),
							w.onAfterShadow(i, w, C, P, B, ue, Z);
					}
				}
			} else if (W.visible) {
				const Q = _(w, W, S, M);
				w.onBeforeShadow(i, w, C, P, B, Q, null),
					i.renderBufferDirect(P, null, B, Q, w, null),
					w.onAfterShadow(i, w, C, P, B, Q, null);
			}
		}
		const q = w.children;
		for (let B = 0, W = q.length; B < W; B++) x(q[B], C, P, S, M);
	}
	function E(w) {
		w.target.removeEventListener('dispose', E);
		for (const P in c) {
			const S = c[P],
				M = w.target.uuid;
			M in S && (S[M].dispose(), delete S[M]);
		}
	}
}
function eN(i) {
	function e() {
		let j = !1;
		const Me = new Pt();
		let J = null;
		const Ce = new Pt(0, 0, 0, 0);
		return {
			setMask: function (Fe) {
				J !== Fe && !j && (i.colorMask(Fe, Fe, Fe, Fe), (J = Fe));
			},
			setLocked: function (Fe) {
				j = Fe;
			},
			setClear: function (Fe, gt, Bt, Kt, Pn) {
				Pn === !0 && ((Fe *= Kt), (gt *= Kt), (Bt *= Kt)),
					Me.set(Fe, gt, Bt, Kt),
					Ce.equals(Me) === !1 && (i.clearColor(Fe, gt, Bt, Kt), Ce.copy(Me));
			},
			reset: function () {
				(j = !1), (J = null), Ce.set(-1, 0, 0, 0);
			},
		};
	}
	function t() {
		let j = !1,
			Me = null,
			J = null,
			Ce = null;
		return {
			setTest: function (Fe) {
				Fe ? we(i.DEPTH_TEST) : X(i.DEPTH_TEST);
			},
			setMask: function (Fe) {
				Me !== Fe && !j && (i.depthMask(Fe), (Me = Fe));
			},
			setFunc: function (Fe) {
				if (J !== Fe) {
					switch (Fe) {
						case l_:
							i.depthFunc(i.NEVER);
							break;
						case c_:
							i.depthFunc(i.ALWAYS);
							break;
						case ep:
							i.depthFunc(i.LESS);
							break;
						case jl:
							i.depthFunc(i.LEQUAL);
							break;
						case vh:
							i.depthFunc(i.EQUAL);
							break;
						case h_:
							i.depthFunc(i.GEQUAL);
							break;
						case u_:
							i.depthFunc(i.GREATER);
							break;
						case Op:
							i.depthFunc(i.NOTEQUAL);
							break;
						default:
							i.depthFunc(i.LEQUAL);
					}
					J = Fe;
				}
			},
			setLocked: function (Fe) {
				j = Fe;
			},
			setClear: function (Fe) {
				Ce !== Fe && (i.clearDepth(Fe), (Ce = Fe));
			},
			reset: function () {
				(j = !1), (Me = null), (J = null), (Ce = null);
			},
		};
	}
	function n() {
		let j = !1,
			Me = null,
			J = null,
			Ce = null,
			Fe = null,
			gt = null,
			Bt = null,
			Kt = null,
			Pn = null;
		return {
			setTest: function (Ct) {
				j || (Ct ? we(i.STENCIL_TEST) : X(i.STENCIL_TEST));
			},
			setMask: function (Ct) {
				Me !== Ct && !j && (i.stencilMask(Ct), (Me = Ct));
			},
			setFunc: function (Ct, Xi, Nn) {
				(J !== Ct || Ce !== Xi || Fe !== Nn) && (i.stencilFunc(Ct, Xi, Nn), (J = Ct), (Ce = Xi), (Fe = Nn));
			},
			setOp: function (Ct, Xi, Nn) {
				(gt !== Ct || Bt !== Xi || Kt !== Nn) && (i.stencilOp(Ct, Xi, Nn), (gt = Ct), (Bt = Xi), (Kt = Nn));
			},
			setLocked: function (Ct) {
				j = Ct;
			},
			setClear: function (Ct) {
				Pn !== Ct && (i.clearStencil(Ct), (Pn = Ct));
			},
			reset: function () {
				(j = !1), (Me = null), (J = null), (Ce = null), (Fe = null), (gt = null), (Bt = null), (Kt = null), (Pn = null);
			},
		};
	}
	const s = new e(),
		r = new t(),
		o = new n(),
		a = new WeakMap(),
		l = new WeakMap();
	let c = {},
		h = {},
		u = new WeakMap(),
		d = [],
		p = null,
		g = !1,
		v = null,
		m = null,
		f = null,
		y = null,
		_ = null,
		x = null,
		E = null,
		w = new Ee(0, 0, 0),
		C = 0,
		P = !1,
		S = null,
		M = null,
		k = null,
		q = null,
		B = null;
	const W = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
	let Q = !1,
		$ = 0;
	const le = i.getParameter(i.VERSION);
	le.indexOf('WebGL') !== -1
		? (($ = parseFloat(/^WebGL (\d)/.exec(le)[1])), (Q = $ >= 1))
		: le.indexOf('OpenGL ES') !== -1 && (($ = parseFloat(/^OpenGL ES (\d)/.exec(le)[1])), (Q = $ >= 2));
	let Z = null,
		xe = {};
	const ue = i.getParameter(i.SCISSOR_BOX),
		Te = i.getParameter(i.VIEWPORT),
		Ae = new Pt().fromArray(ue),
		We = new Pt().fromArray(Te);
	function se(j, Me, J, Ce) {
		const Fe = new Uint8Array(4),
			gt = i.createTexture();
		i.bindTexture(j, gt), i.texParameteri(j, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(j, i.TEXTURE_MAG_FILTER, i.NEAREST);
		for (let Bt = 0; Bt < J; Bt++)
			j === i.TEXTURE_3D || j === i.TEXTURE_2D_ARRAY
				? i.texImage3D(Me, 0, i.RGBA, 1, 1, Ce, 0, i.RGBA, i.UNSIGNED_BYTE, Fe)
				: i.texImage2D(Me + Bt, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, Fe);
		return gt;
	}
	const Se = {};
	(Se[i.TEXTURE_2D] = se(i.TEXTURE_2D, i.TEXTURE_2D, 1)),
		(Se[i.TEXTURE_CUBE_MAP] = se(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
		(Se[i.TEXTURE_2D_ARRAY] = se(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1)),
		(Se[i.TEXTURE_3D] = se(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)),
		s.setClear(0, 0, 0, 1),
		r.setClear(1),
		o.setClear(0),
		we(i.DEPTH_TEST),
		r.setFunc(jl),
		z(!1),
		Y(Eg),
		we(i.CULL_FACE),
		L(jn);
	function we(j) {
		c[j] !== !0 && (i.enable(j), (c[j] = !0));
	}
	function X(j) {
		c[j] !== !1 && (i.disable(j), (c[j] = !1));
	}
	function ge(j, Me) {
		return h[j] !== Me
			? (i.bindFramebuffer(j, Me),
			  (h[j] = Me),
			  j === i.DRAW_FRAMEBUFFER && (h[i.FRAMEBUFFER] = Me),
			  j === i.FRAMEBUFFER && (h[i.DRAW_FRAMEBUFFER] = Me),
			  !0)
			: !1;
	}
	function be(j, Me) {
		let J = d,
			Ce = !1;
		if (j) {
			(J = u.get(Me)), J === void 0 && ((J = []), u.set(Me, J));
			const Fe = j.textures;
			if (J.length !== Fe.length || J[0] !== i.COLOR_ATTACHMENT0) {
				for (let gt = 0, Bt = Fe.length; gt < Bt; gt++) J[gt] = i.COLOR_ATTACHMENT0 + gt;
				(J.length = Fe.length), (Ce = !0);
			}
		} else J[0] !== i.BACK && ((J[0] = i.BACK), (Ce = !0));
		Ce && i.drawBuffers(J);
	}
	function H(j) {
		return p !== j ? (i.useProgram(j), (p = j), !0) : !1;
	}
	const Ne = { [Jr]: i.FUNC_ADD, [pM]: i.FUNC_SUBTRACT, [fM]: i.FUNC_REVERSE_SUBTRACT };
	(Ne[mM] = i.MIN), (Ne[gM] = i.MAX);
	const oe = {
		[vM]: i.ZERO,
		[_M]: i.ONE,
		[yM]: i.SRC_COLOR,
		[Jd]: i.SRC_ALPHA,
		[EM]: i.SRC_ALPHA_SATURATE,
		[SM]: i.DST_COLOR,
		[bM]: i.DST_ALPHA,
		[xM]: i.ONE_MINUS_SRC_COLOR,
		[Qd]: i.ONE_MINUS_SRC_ALPHA,
		[MM]: i.ONE_MINUS_DST_COLOR,
		[wM]: i.ONE_MINUS_DST_ALPHA,
		[TM]: i.CONSTANT_COLOR,
		[AM]: i.ONE_MINUS_CONSTANT_COLOR,
		[CM]: i.CONSTANT_ALPHA,
		[RM]: i.ONE_MINUS_CONSTANT_ALPHA,
	};
	function L(j, Me, J, Ce, Fe, gt, Bt, Kt, Pn, Ct) {
		if (j === jn) {
			g === !0 && (X(i.BLEND), (g = !1));
			return;
		}
		if ((g === !1 && (we(i.BLEND), (g = !0)), j !== dM)) {
			if (j !== v || Ct !== P) {
				if (((m !== Jr || _ !== Jr) && (i.blendEquation(i.FUNC_ADD), (m = Jr), (_ = Jr)), Ct))
					switch (j) {
						case co:
							i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
							break;
						case bs:
							i.blendFunc(i.ONE, i.ONE);
							break;
						case Tg:
							i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
							break;
						case Ag:
							i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
							break;
						default:
							console.error('THREE.WebGLState: Invalid blending: ', j);
							break;
					}
				else
					switch (j) {
						case co:
							i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
							break;
						case bs:
							i.blendFunc(i.SRC_ALPHA, i.ONE);
							break;
						case Tg:
							i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
							break;
						case Ag:
							i.blendFunc(i.ZERO, i.SRC_COLOR);
							break;
						default:
							console.error('THREE.WebGLState: Invalid blending: ', j);
							break;
					}
				(f = null), (y = null), (x = null), (E = null), w.set(0, 0, 0), (C = 0), (v = j), (P = Ct);
			}
			return;
		}
		(Fe = Fe || Me),
			(gt = gt || J),
			(Bt = Bt || Ce),
			(Me !== m || Fe !== _) && (i.blendEquationSeparate(Ne[Me], Ne[Fe]), (m = Me), (_ = Fe)),
			(J !== f || Ce !== y || gt !== x || Bt !== E) &&
				(i.blendFuncSeparate(oe[J], oe[Ce], oe[gt], oe[Bt]), (f = J), (y = Ce), (x = gt), (E = Bt)),
			(Kt.equals(w) === !1 || Pn !== C) && (i.blendColor(Kt.r, Kt.g, Kt.b, Pn), w.copy(Kt), (C = Pn)),
			(v = j),
			(P = !1);
	}
	function D(j, Me) {
		j.side === mn ? X(i.CULL_FACE) : we(i.CULL_FACE);
		let J = j.side === gn;
		Me && (J = !J),
			z(J),
			j.blending === co && j.transparent === !1
				? L(jn)
				: L(
						j.blending,
						j.blendEquation,
						j.blendSrc,
						j.blendDst,
						j.blendEquationAlpha,
						j.blendSrcAlpha,
						j.blendDstAlpha,
						j.blendColor,
						j.blendAlpha,
						j.premultipliedAlpha
				  ),
			r.setFunc(j.depthFunc),
			r.setTest(j.depthTest),
			r.setMask(j.depthWrite),
			s.setMask(j.colorWrite);
		const Ce = j.stencilWrite;
		o.setTest(Ce),
			Ce &&
				(o.setMask(j.stencilWriteMask),
				o.setFunc(j.stencilFunc, j.stencilRef, j.stencilFuncMask),
				o.setOp(j.stencilFail, j.stencilZFail, j.stencilZPass)),
			re(j.polygonOffset, j.polygonOffsetFactor, j.polygonOffsetUnits),
			j.alphaToCoverage === !0 ? we(i.SAMPLE_ALPHA_TO_COVERAGE) : X(i.SAMPLE_ALPHA_TO_COVERAGE);
	}
	function z(j) {
		S !== j && (j ? i.frontFace(i.CW) : i.frontFace(i.CCW), (S = j));
	}
	function Y(j) {
		j !== cM
			? (we(i.CULL_FACE), j !== M && (j === Eg ? i.cullFace(i.BACK) : j === hM ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK)))
			: X(i.CULL_FACE),
			(M = j);
	}
	function K(j) {
		j !== k && (Q && i.lineWidth(j), (k = j));
	}
	function re(j, Me, J) {
		j ? (we(i.POLYGON_OFFSET_FILL), (q !== Me || B !== J) && (i.polygonOffset(Me, J), (q = Me), (B = J))) : X(i.POLYGON_OFFSET_FILL);
	}
	function O(j) {
		j ? we(i.SCISSOR_TEST) : X(i.SCISSOR_TEST);
	}
	function T(j) {
		j === void 0 && (j = i.TEXTURE0 + W - 1), Z !== j && (i.activeTexture(j), (Z = j));
	}
	function V(j, Me, J) {
		J === void 0 && (Z === null ? (J = i.TEXTURE0 + W - 1) : (J = Z));
		let Ce = xe[J];
		Ce === void 0 && ((Ce = { type: void 0, texture: void 0 }), (xe[J] = Ce)),
			(Ce.type !== j || Ce.texture !== Me) &&
				(Z !== J && (i.activeTexture(J), (Z = J)), i.bindTexture(j, Me || Se[j]), (Ce.type = j), (Ce.texture = Me));
	}
	function G() {
		const j = xe[Z];
		j !== void 0 && j.type !== void 0 && (i.bindTexture(j.type, null), (j.type = void 0), (j.texture = void 0));
	}
	function ee() {
		try {
			i.compressedTexImage2D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function ne() {
		try {
			i.compressedTexImage3D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function _e() {
		try {
			i.texSubImage2D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function me() {
		try {
			i.texSubImage3D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function ye() {
		try {
			i.compressedTexSubImage2D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function De() {
		try {
			i.compressedTexSubImage3D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function ve() {
		try {
			i.texStorage2D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function Le() {
		try {
			i.texStorage3D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function Ye() {
		try {
			i.texImage2D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function Xe() {
		try {
			i.texImage3D.apply(i, arguments);
		} catch (j) {
			console.error('THREE.WebGLState:', j);
		}
	}
	function Ie(j) {
		Ae.equals(j) === !1 && (i.scissor(j.x, j.y, j.z, j.w), Ae.copy(j));
	}
	function Ve(j) {
		We.equals(j) === !1 && (i.viewport(j.x, j.y, j.z, j.w), We.copy(j));
	}
	function it(j, Me) {
		let J = l.get(Me);
		J === void 0 && ((J = new WeakMap()), l.set(Me, J));
		let Ce = J.get(j);
		Ce === void 0 && ((Ce = i.getUniformBlockIndex(Me, j.name)), J.set(j, Ce));
	}
	function Qe(j, Me) {
		const Ce = l.get(Me).get(j);
		a.get(Me) !== Ce && (i.uniformBlockBinding(Me, Ce, j.__bindingPointIndex), a.set(Me, Ce));
	}
	function Be() {
		i.disable(i.BLEND),
			i.disable(i.CULL_FACE),
			i.disable(i.DEPTH_TEST),
			i.disable(i.POLYGON_OFFSET_FILL),
			i.disable(i.SCISSOR_TEST),
			i.disable(i.STENCIL_TEST),
			i.disable(i.SAMPLE_ALPHA_TO_COVERAGE),
			i.blendEquation(i.FUNC_ADD),
			i.blendFunc(i.ONE, i.ZERO),
			i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO),
			i.blendColor(0, 0, 0, 0),
			i.colorMask(!0, !0, !0, !0),
			i.clearColor(0, 0, 0, 0),
			i.depthMask(!0),
			i.depthFunc(i.LESS),
			i.clearDepth(1),
			i.stencilMask(4294967295),
			i.stencilFunc(i.ALWAYS, 0, 4294967295),
			i.stencilOp(i.KEEP, i.KEEP, i.KEEP),
			i.clearStencil(0),
			i.cullFace(i.BACK),
			i.frontFace(i.CCW),
			i.polygonOffset(0, 0),
			i.activeTexture(i.TEXTURE0),
			i.bindFramebuffer(i.FRAMEBUFFER, null),
			i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null),
			i.bindFramebuffer(i.READ_FRAMEBUFFER, null),
			i.useProgram(null),
			i.lineWidth(1),
			i.scissor(0, 0, i.canvas.width, i.canvas.height),
			i.viewport(0, 0, i.canvas.width, i.canvas.height),
			(c = {}),
			(Z = null),
			(xe = {}),
			(h = {}),
			(u = new WeakMap()),
			(d = []),
			(p = null),
			(g = !1),
			(v = null),
			(m = null),
			(f = null),
			(y = null),
			(_ = null),
			(x = null),
			(E = null),
			(w = new Ee(0, 0, 0)),
			(C = 0),
			(P = !1),
			(S = null),
			(M = null),
			(k = null),
			(q = null),
			(B = null),
			Ae.set(0, 0, i.canvas.width, i.canvas.height),
			We.set(0, 0, i.canvas.width, i.canvas.height),
			s.reset(),
			r.reset(),
			o.reset();
	}
	return {
		buffers: { color: s, depth: r, stencil: o },
		enable: we,
		disable: X,
		bindFramebuffer: ge,
		drawBuffers: be,
		useProgram: H,
		setBlending: L,
		setMaterial: D,
		setFlipSided: z,
		setCullFace: Y,
		setLineWidth: K,
		setPolygonOffset: re,
		setScissorTest: O,
		activeTexture: T,
		bindTexture: V,
		unbindTexture: G,
		compressedTexImage2D: ee,
		compressedTexImage3D: ne,
		texImage2D: Ye,
		texImage3D: Xe,
		updateUBOMapping: it,
		uniformBlockBinding: Qe,
		texStorage2D: ve,
		texStorage3D: Le,
		texSubImage2D: _e,
		texSubImage3D: me,
		compressedTexSubImage2D: ye,
		compressedTexSubImage3D: De,
		scissor: Ie,
		viewport: Ve,
		reset: Be,
	};
}
function tN(i, e, t, n, s, r, o) {
	const a = e.has('WEBGL_multisampled_render_to_texture') ? e.get('WEBGL_multisampled_render_to_texture') : null,
		l = typeof navigator > 'u' ? !1 : /OculusBrowser/g.test(navigator.userAgent),
		c = new ce(),
		h = new WeakMap();
	let u;
	const d = new WeakMap();
	let p = !1;
	try {
		p = typeof OffscreenCanvas < 'u' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
	} catch (O) {}
	function g(O, T) {
		return p ? new OffscreenCanvas(O, T) : Th('canvas');
	}
	function v(O, T, V) {
		let G = 1;
		const ee = re(O);
		if (((ee.width > V || ee.height > V) && (G = V / Math.max(ee.width, ee.height)), G < 1))
			if (
				(typeof HTMLImageElement < 'u' && O instanceof HTMLImageElement) ||
				(typeof HTMLCanvasElement < 'u' && O instanceof HTMLCanvasElement) ||
				(typeof ImageBitmap < 'u' && O instanceof ImageBitmap) ||
				(typeof VideoFrame < 'u' && O instanceof VideoFrame)
			) {
				const ne = Math.floor(G * ee.width),
					_e = Math.floor(G * ee.height);
				u === void 0 && (u = g(ne, _e));
				const me = T ? g(ne, _e) : u;
				return (
					(me.width = ne),
					(me.height = _e),
					me.getContext('2d').drawImage(O, 0, 0, ne, _e),
					console.warn(
						'THREE.WebGLRenderer: Texture has been resized from (' +
							ee.width +
							'x' +
							ee.height +
							') to (' +
							ne +
							'x' +
							_e +
							').'
					),
					me
				);
			} else
				return (
					'data' in O &&
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + ee.width + 'x' + ee.height + ').'),
					O
				);
		return O;
	}
	function m(O) {
		return O.generateMipmaps && O.minFilter !== It && O.minFilter !== Tt;
	}
	function f(O) {
		i.generateMipmap(O);
	}
	function y(O, T, V, G, ee = !1) {
		if (O !== null) {
			if (i[O] !== void 0) return i[O];
			console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'");
		}
		let ne = T;
		if (
			(T === i.RED && (V === i.FLOAT && (ne = i.R32F), V === i.HALF_FLOAT && (ne = i.R16F), V === i.UNSIGNED_BYTE && (ne = i.R8)),
			T === i.RED_INTEGER &&
				(V === i.UNSIGNED_BYTE && (ne = i.R8UI),
				V === i.UNSIGNED_SHORT && (ne = i.R16UI),
				V === i.UNSIGNED_INT && (ne = i.R32UI),
				V === i.BYTE && (ne = i.R8I),
				V === i.SHORT && (ne = i.R16I),
				V === i.INT && (ne = i.R32I)),
			T === i.RG && (V === i.FLOAT && (ne = i.RG32F), V === i.HALF_FLOAT && (ne = i.RG16F), V === i.UNSIGNED_BYTE && (ne = i.RG8)),
			T === i.RG_INTEGER &&
				(V === i.UNSIGNED_BYTE && (ne = i.RG8UI),
				V === i.UNSIGNED_SHORT && (ne = i.RG16UI),
				V === i.UNSIGNED_INT && (ne = i.RG32UI),
				V === i.BYTE && (ne = i.RG8I),
				V === i.SHORT && (ne = i.RG16I),
				V === i.INT && (ne = i.RG32I)),
			T === i.RGB && V === i.UNSIGNED_INT_5_9_9_9_REV && (ne = i.RGB9_E5),
			T === i.RGBA)
		) {
			const _e = ee ? bh : Ft.getTransfer(G);
			V === i.FLOAT && (ne = i.RGBA32F),
				V === i.HALF_FLOAT && (ne = i.RGBA16F),
				V === i.UNSIGNED_BYTE && (ne = _e === Wt ? i.SRGB8_ALPHA8 : i.RGBA8),
				V === i.UNSIGNED_SHORT_4_4_4_4 && (ne = i.RGBA4),
				V === i.UNSIGNED_SHORT_5_5_5_1 && (ne = i.RGB5_A1);
		}
		return (
			(ne === i.R16F || ne === i.R32F || ne === i.RG16F || ne === i.RG32F || ne === i.RGBA16F || ne === i.RGBA32F) &&
				e.get('EXT_color_buffer_float'),
			ne
		);
	}
	function _(O, T) {
		return m(O) === !0 || (O.isFramebufferTexture && O.minFilter !== It && O.minFilter !== Tt)
			? Math.log2(Math.max(T.width, T.height)) + 1
			: O.mipmaps !== void 0 && O.mipmaps.length > 0
			? O.mipmaps.length
			: O.isCompressedTexture && Array.isArray(O.image)
			? T.mipmaps.length
			: 1;
	}
	function x(O) {
		const T = O.target;
		T.removeEventListener('dispose', x), w(T), T.isVideoTexture && h.delete(T);
	}
	function E(O) {
		const T = O.target;
		T.removeEventListener('dispose', E), P(T);
	}
	function w(O) {
		const T = n.get(O);
		if (T.__webglInit === void 0) return;
		const V = O.source,
			G = d.get(V);
		if (G) {
			const ee = G[T.__cacheKey];
			ee.usedTimes--, ee.usedTimes === 0 && C(O), Object.keys(G).length === 0 && d.delete(V);
		}
		n.remove(O);
	}
	function C(O) {
		const T = n.get(O);
		i.deleteTexture(T.__webglTexture);
		const V = O.source,
			G = d.get(V);
		delete G[T.__cacheKey], o.memory.textures--;
	}
	function P(O) {
		const T = n.get(O);
		if ((O.depthTexture && O.depthTexture.dispose(), O.isWebGLCubeRenderTarget))
			for (let G = 0; G < 6; G++) {
				if (Array.isArray(T.__webglFramebuffer[G]))
					for (let ee = 0; ee < T.__webglFramebuffer[G].length; ee++) i.deleteFramebuffer(T.__webglFramebuffer[G][ee]);
				else i.deleteFramebuffer(T.__webglFramebuffer[G]);
				T.__webglDepthbuffer && i.deleteRenderbuffer(T.__webglDepthbuffer[G]);
			}
		else {
			if (Array.isArray(T.__webglFramebuffer))
				for (let G = 0; G < T.__webglFramebuffer.length; G++) i.deleteFramebuffer(T.__webglFramebuffer[G]);
			else i.deleteFramebuffer(T.__webglFramebuffer);
			if (
				(T.__webglDepthbuffer && i.deleteRenderbuffer(T.__webglDepthbuffer),
				T.__webglMultisampledFramebuffer && i.deleteFramebuffer(T.__webglMultisampledFramebuffer),
				T.__webglColorRenderbuffer)
			)
				for (let G = 0; G < T.__webglColorRenderbuffer.length; G++)
					T.__webglColorRenderbuffer[G] && i.deleteRenderbuffer(T.__webglColorRenderbuffer[G]);
			T.__webglDepthRenderbuffer && i.deleteRenderbuffer(T.__webglDepthRenderbuffer);
		}
		const V = O.textures;
		for (let G = 0, ee = V.length; G < ee; G++) {
			const ne = n.get(V[G]);
			ne.__webglTexture && (i.deleteTexture(ne.__webglTexture), o.memory.textures--), n.remove(V[G]);
		}
		n.remove(O);
	}
	let S = 0;
	function M() {
		S = 0;
	}
	function k() {
		const O = S;
		return (
			O >= s.maxTextures &&
				console.warn('THREE.WebGLTextures: Trying to use ' + O + ' texture units while this GPU supports only ' + s.maxTextures),
			(S += 1),
			O
		);
	}
	function q(O) {
		const T = [];
		return (
			T.push(O.wrapS),
			T.push(O.wrapT),
			T.push(O.wrapR || 0),
			T.push(O.magFilter),
			T.push(O.minFilter),
			T.push(O.anisotropy),
			T.push(O.internalFormat),
			T.push(O.format),
			T.push(O.type),
			T.push(O.generateMipmaps),
			T.push(O.premultiplyAlpha),
			T.push(O.flipY),
			T.push(O.unpackAlignment),
			T.push(O.colorSpace),
			T.join()
		);
	}
	function B(O, T) {
		const V = n.get(O);
		if ((O.isVideoTexture && Y(O), O.isRenderTargetTexture === !1 && O.version > 0 && V.__version !== O.version)) {
			const G = O.image;
			if (G === null) console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
			else if (G.complete === !1) console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
			else {
				Ae(V, O, T);
				return;
			}
		}
		t.bindTexture(i.TEXTURE_2D, V.__webglTexture, i.TEXTURE0 + T);
	}
	function W(O, T) {
		const V = n.get(O);
		if (O.version > 0 && V.__version !== O.version) {
			Ae(V, O, T);
			return;
		}
		t.bindTexture(i.TEXTURE_2D_ARRAY, V.__webglTexture, i.TEXTURE0 + T);
	}
	function Q(O, T) {
		const V = n.get(O);
		if (O.version > 0 && V.__version !== O.version) {
			Ae(V, O, T);
			return;
		}
		t.bindTexture(i.TEXTURE_3D, V.__webglTexture, i.TEXTURE0 + T);
	}
	function $(O, T) {
		const V = n.get(O);
		if (O.version > 0 && V.__version !== O.version) {
			We(V, O, T);
			return;
		}
		t.bindTexture(i.TEXTURE_CUBE_MAP, V.__webglTexture, i.TEXTURE0 + T);
	}
	const le = { [rs]: i.REPEAT, [Oi]: i.CLAMP_TO_EDGE, [Kl]: i.MIRRORED_REPEAT },
		Z = {
			[It]: i.NEAREST,
			[Fp]: i.NEAREST_MIPMAP_NEAREST,
			[oa]: i.NEAREST_MIPMAP_LINEAR,
			[Tt]: i.LINEAR,
			[Nl]: i.LINEAR_MIPMAP_NEAREST,
			[ts]: i.LINEAR_MIPMAP_LINEAR,
		},
		xe = {
			[$M]: i.NEVER,
			[nE]: i.ALWAYS,
			[ZM]: i.LESS,
			[M_]: i.LEQUAL,
			[JM]: i.EQUAL,
			[tE]: i.GEQUAL,
			[QM]: i.GREATER,
			[eE]: i.NOTEQUAL,
		};
	function ue(O, T) {
		if (
			(T.type === On &&
				e.has('OES_texture_float_linear') === !1 &&
				(T.magFilter === Tt ||
					T.magFilter === Nl ||
					T.magFilter === oa ||
					T.magFilter === ts ||
					T.minFilter === Tt ||
					T.minFilter === Nl ||
					T.minFilter === oa ||
					T.minFilter === ts) &&
				console.warn(
					'THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.'
				),
			i.texParameteri(O, i.TEXTURE_WRAP_S, le[T.wrapS]),
			i.texParameteri(O, i.TEXTURE_WRAP_T, le[T.wrapT]),
			(O === i.TEXTURE_3D || O === i.TEXTURE_2D_ARRAY) && i.texParameteri(O, i.TEXTURE_WRAP_R, le[T.wrapR]),
			i.texParameteri(O, i.TEXTURE_MAG_FILTER, Z[T.magFilter]),
			i.texParameteri(O, i.TEXTURE_MIN_FILTER, Z[T.minFilter]),
			T.compareFunction &&
				(i.texParameteri(O, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE),
				i.texParameteri(O, i.TEXTURE_COMPARE_FUNC, xe[T.compareFunction])),
			e.has('EXT_texture_filter_anisotropic') === !0)
		) {
			if (
				T.magFilter === It ||
				(T.minFilter !== oa && T.minFilter !== ts) ||
				(T.type === On && e.has('OES_texture_float_linear') === !1)
			)
				return;
			if (T.anisotropy > 1 || n.get(T).__currentAnisotropy) {
				const V = e.get('EXT_texture_filter_anisotropic');
				i.texParameterf(O, V.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(T.anisotropy, s.getMaxAnisotropy())),
					(n.get(T).__currentAnisotropy = T.anisotropy);
			}
		}
	}
	function Te(O, T) {
		let V = !1;
		O.__webglInit === void 0 && ((O.__webglInit = !0), T.addEventListener('dispose', x));
		const G = T.source;
		let ee = d.get(G);
		ee === void 0 && ((ee = {}), d.set(G, ee));
		const ne = q(T);
		if (ne !== O.__cacheKey) {
			ee[ne] === void 0 && ((ee[ne] = { texture: i.createTexture(), usedTimes: 0 }), o.memory.textures++, (V = !0)),
				ee[ne].usedTimes++;
			const _e = ee[O.__cacheKey];
			_e !== void 0 && (ee[O.__cacheKey].usedTimes--, _e.usedTimes === 0 && C(T)),
				(O.__cacheKey = ne),
				(O.__webglTexture = ee[ne].texture);
		}
		return V;
	}
	function Ae(O, T, V) {
		let G = i.TEXTURE_2D;
		(T.isDataArrayTexture || T.isCompressedArrayTexture) && (G = i.TEXTURE_2D_ARRAY), T.isData3DTexture && (G = i.TEXTURE_3D);
		const ee = Te(O, T),
			ne = T.source;
		t.bindTexture(G, O.__webglTexture, i.TEXTURE0 + V);
		const _e = n.get(ne);
		if (ne.version !== _e.__version || ee === !0) {
			t.activeTexture(i.TEXTURE0 + V);
			const me = Ft.getPrimaries(Ft.workingColorSpace),
				ye = T.colorSpace === xs ? null : Ft.getPrimaries(T.colorSpace),
				De = T.colorSpace === xs || me === ye ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
			i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, T.flipY),
				i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha),
				i.pixelStorei(i.UNPACK_ALIGNMENT, T.unpackAlignment),
				i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, De);
			let ve = v(T.image, !1, s.maxTextureSize);
			ve = K(T, ve);
			const Le = r.convert(T.format, T.colorSpace),
				Ye = r.convert(T.type);
			let Xe = y(T.internalFormat, Le, Ye, T.colorSpace, T.isVideoTexture);
			ue(G, T);
			let Ie;
			const Ve = T.mipmaps,
				it = T.isVideoTexture !== !0,
				Qe = _e.__version === void 0 || ee === !0,
				Be = ne.dataReady,
				j = _(T, ve);
			if (T.isDepthTexture)
				(Xe = i.DEPTH_COMPONENT16),
					T.type === On
						? (Xe = i.DEPTH_COMPONENT32F)
						: T.type === yo
						? (Xe = i.DEPTH_COMPONENT24)
						: T.type === Ba && (Xe = i.DEPTH24_STENCIL8),
					Qe &&
						(it
							? t.texStorage2D(i.TEXTURE_2D, 1, Xe, ve.width, ve.height)
							: t.texImage2D(i.TEXTURE_2D, 0, Xe, ve.width, ve.height, 0, Le, Ye, null));
			else if (T.isDataTexture)
				if (Ve.length > 0) {
					it && Qe && t.texStorage2D(i.TEXTURE_2D, j, Xe, Ve[0].width, Ve[0].height);
					for (let Me = 0, J = Ve.length; Me < J; Me++)
						(Ie = Ve[Me]),
							it
								? Be && t.texSubImage2D(i.TEXTURE_2D, Me, 0, 0, Ie.width, Ie.height, Le, Ye, Ie.data)
								: t.texImage2D(i.TEXTURE_2D, Me, Xe, Ie.width, Ie.height, 0, Le, Ye, Ie.data);
					T.generateMipmaps = !1;
				} else
					it
						? (Qe && t.texStorage2D(i.TEXTURE_2D, j, Xe, ve.width, ve.height),
						  Be && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ve.width, ve.height, Le, Ye, ve.data))
						: t.texImage2D(i.TEXTURE_2D, 0, Xe, ve.width, ve.height, 0, Le, Ye, ve.data);
			else if (T.isCompressedTexture)
				if (T.isCompressedArrayTexture) {
					it && Qe && t.texStorage3D(i.TEXTURE_2D_ARRAY, j, Xe, Ve[0].width, Ve[0].height, ve.depth);
					for (let Me = 0, J = Ve.length; Me < J; Me++)
						(Ie = Ve[Me]),
							T.format !== mi
								? Le !== null
									? it
										? Be &&
										  t.compressedTexSubImage3D(
												i.TEXTURE_2D_ARRAY,
												Me,
												0,
												0,
												0,
												Ie.width,
												Ie.height,
												ve.depth,
												Le,
												Ie.data,
												0,
												0
										  )
										: t.compressedTexImage3D(
												i.TEXTURE_2D_ARRAY,
												Me,
												Xe,
												Ie.width,
												Ie.height,
												ve.depth,
												0,
												Ie.data,
												0,
												0
										  )
									: console.warn(
											'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
									  )
								: it
								? Be && t.texSubImage3D(i.TEXTURE_2D_ARRAY, Me, 0, 0, 0, Ie.width, Ie.height, ve.depth, Le, Ye, Ie.data)
								: t.texImage3D(i.TEXTURE_2D_ARRAY, Me, Xe, Ie.width, Ie.height, ve.depth, 0, Le, Ye, Ie.data);
				} else {
					it && Qe && t.texStorage2D(i.TEXTURE_2D, j, Xe, Ve[0].width, Ve[0].height);
					for (let Me = 0, J = Ve.length; Me < J; Me++)
						(Ie = Ve[Me]),
							T.format !== mi
								? Le !== null
									? it
										? Be && t.compressedTexSubImage2D(i.TEXTURE_2D, Me, 0, 0, Ie.width, Ie.height, Le, Ie.data)
										: t.compressedTexImage2D(i.TEXTURE_2D, Me, Xe, Ie.width, Ie.height, 0, Ie.data)
									: console.warn(
											'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
									  )
								: it
								? Be && t.texSubImage2D(i.TEXTURE_2D, Me, 0, 0, Ie.width, Ie.height, Le, Ye, Ie.data)
								: t.texImage2D(i.TEXTURE_2D, Me, Xe, Ie.width, Ie.height, 0, Le, Ye, Ie.data);
				}
			else if (T.isDataArrayTexture)
				it
					? (Qe && t.texStorage3D(i.TEXTURE_2D_ARRAY, j, Xe, ve.width, ve.height, ve.depth),
					  Be && t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ve.width, ve.height, ve.depth, Le, Ye, ve.data))
					: t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Xe, ve.width, ve.height, ve.depth, 0, Le, Ye, ve.data);
			else if (T.isData3DTexture)
				it
					? (Qe && t.texStorage3D(i.TEXTURE_3D, j, Xe, ve.width, ve.height, ve.depth),
					  Be && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, ve.width, ve.height, ve.depth, Le, Ye, ve.data))
					: t.texImage3D(i.TEXTURE_3D, 0, Xe, ve.width, ve.height, ve.depth, 0, Le, Ye, ve.data);
			else if (T.isFramebufferTexture) {
				if (Qe)
					if (it) t.texStorage2D(i.TEXTURE_2D, j, Xe, ve.width, ve.height);
					else {
						let Me = ve.width,
							J = ve.height;
						for (let Ce = 0; Ce < j; Ce++) t.texImage2D(i.TEXTURE_2D, Ce, Xe, Me, J, 0, Le, Ye, null), (Me >>= 1), (J >>= 1);
					}
			} else if (Ve.length > 0) {
				if (it && Qe) {
					const Me = re(Ve[0]);
					t.texStorage2D(i.TEXTURE_2D, j, Xe, Me.width, Me.height);
				}
				for (let Me = 0, J = Ve.length; Me < J; Me++)
					(Ie = Ve[Me]),
						it ? Be && t.texSubImage2D(i.TEXTURE_2D, Me, 0, 0, Le, Ye, Ie) : t.texImage2D(i.TEXTURE_2D, Me, Xe, Le, Ye, Ie);
				T.generateMipmaps = !1;
			} else if (it) {
				if (Qe) {
					const Me = re(ve);
					t.texStorage2D(i.TEXTURE_2D, j, Xe, Me.width, Me.height);
				}
				Be && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, Le, Ye, ve);
			} else t.texImage2D(i.TEXTURE_2D, 0, Xe, Le, Ye, ve);
			m(T) && f(G), (_e.__version = ne.version), T.onUpdate && T.onUpdate(T);
		}
		O.__version = T.version;
	}
	function We(O, T, V) {
		if (T.image.length !== 6) return;
		const G = Te(O, T),
			ee = T.source;
		t.bindTexture(i.TEXTURE_CUBE_MAP, O.__webglTexture, i.TEXTURE0 + V);
		const ne = n.get(ee);
		if (ee.version !== ne.__version || G === !0) {
			t.activeTexture(i.TEXTURE0 + V);
			const _e = Ft.getPrimaries(Ft.workingColorSpace),
				me = T.colorSpace === xs ? null : Ft.getPrimaries(T.colorSpace),
				ye = T.colorSpace === xs || _e === me ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
			i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, T.flipY),
				i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha),
				i.pixelStorei(i.UNPACK_ALIGNMENT, T.unpackAlignment),
				i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ye);
			const De = T.isCompressedTexture || T.image[0].isCompressedTexture,
				ve = T.image[0] && T.image[0].isDataTexture,
				Le = [];
			for (let J = 0; J < 6; J++)
				!De && !ve ? (Le[J] = v(T.image[J], !0, s.maxCubemapSize)) : (Le[J] = ve ? T.image[J].image : T.image[J]),
					(Le[J] = K(T, Le[J]));
			const Ye = Le[0],
				Xe = r.convert(T.format, T.colorSpace),
				Ie = r.convert(T.type),
				Ve = y(T.internalFormat, Xe, Ie, T.colorSpace),
				it = T.isVideoTexture !== !0,
				Qe = ne.__version === void 0 || G === !0,
				Be = ee.dataReady;
			let j = _(T, Ye);
			ue(i.TEXTURE_CUBE_MAP, T);
			let Me;
			if (De) {
				it && Qe && t.texStorage2D(i.TEXTURE_CUBE_MAP, j, Ve, Ye.width, Ye.height);
				for (let J = 0; J < 6; J++) {
					Me = Le[J].mipmaps;
					for (let Ce = 0; Ce < Me.length; Ce++) {
						const Fe = Me[Ce];
						T.format !== mi
							? Xe !== null
								? it
									? Be &&
									  t.compressedTexSubImage2D(
											i.TEXTURE_CUBE_MAP_POSITIVE_X + J,
											Ce,
											0,
											0,
											Fe.width,
											Fe.height,
											Xe,
											Fe.data
									  )
									: t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce, Ve, Fe.width, Fe.height, 0, Fe.data)
								: console.warn(
										'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
								  )
							: it
							? Be && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce, 0, 0, Fe.width, Fe.height, Xe, Ie, Fe.data)
							: t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce, Ve, Fe.width, Fe.height, 0, Xe, Ie, Fe.data);
					}
				}
			} else {
				if (((Me = T.mipmaps), it && Qe)) {
					Me.length > 0 && j++;
					const J = re(Le[0]);
					t.texStorage2D(i.TEXTURE_CUBE_MAP, j, Ve, J.width, J.height);
				}
				for (let J = 0; J < 6; J++)
					if (ve) {
						it
							? Be &&
							  t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, 0, 0, Le[J].width, Le[J].height, Xe, Ie, Le[J].data)
							: t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, Ve, Le[J].width, Le[J].height, 0, Xe, Ie, Le[J].data);
						for (let Ce = 0; Ce < Me.length; Ce++) {
							const gt = Me[Ce].image[J].image;
							it
								? Be &&
								  t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce + 1, 0, 0, gt.width, gt.height, Xe, Ie, gt.data)
								: t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce + 1, Ve, gt.width, gt.height, 0, Xe, Ie, gt.data);
						}
					} else {
						it
							? Be && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, 0, 0, Xe, Ie, Le[J])
							: t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, 0, Ve, Xe, Ie, Le[J]);
						for (let Ce = 0; Ce < Me.length; Ce++) {
							const Fe = Me[Ce];
							it
								? Be && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce + 1, 0, 0, Xe, Ie, Fe.image[J])
								: t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + J, Ce + 1, Ve, Xe, Ie, Fe.image[J]);
						}
					}
			}
			m(T) && f(i.TEXTURE_CUBE_MAP), (ne.__version = ee.version), T.onUpdate && T.onUpdate(T);
		}
		O.__version = T.version;
	}
	function se(O, T, V, G, ee, ne) {
		const _e = r.convert(V.format, V.colorSpace),
			me = r.convert(V.type),
			ye = y(V.internalFormat, _e, me, V.colorSpace);
		if (!n.get(T).__hasExternalTextures) {
			const ve = Math.max(1, T.width >> ne),
				Le = Math.max(1, T.height >> ne);
			ee === i.TEXTURE_3D || ee === i.TEXTURE_2D_ARRAY
				? t.texImage3D(ee, ne, ye, ve, Le, T.depth, 0, _e, me, null)
				: t.texImage2D(ee, ne, ye, ve, Le, 0, _e, me, null);
		}
		t.bindFramebuffer(i.FRAMEBUFFER, O),
			z(T)
				? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, G, ee, n.get(V).__webglTexture, 0, D(T))
				: (ee === i.TEXTURE_2D || (ee >= i.TEXTURE_CUBE_MAP_POSITIVE_X && ee <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
				  i.framebufferTexture2D(i.FRAMEBUFFER, G, ee, n.get(V).__webglTexture, ne),
			t.bindFramebuffer(i.FRAMEBUFFER, null);
	}
	function Se(O, T, V) {
		if ((i.bindRenderbuffer(i.RENDERBUFFER, O), T.depthBuffer && !T.stencilBuffer)) {
			let G = i.DEPTH_COMPONENT24;
			if (V || z(T)) {
				const ee = T.depthTexture;
				ee && ee.isDepthTexture && (ee.type === On ? (G = i.DEPTH_COMPONENT32F) : ee.type === yo && (G = i.DEPTH_COMPONENT24));
				const ne = D(T);
				z(T)
					? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, ne, G, T.width, T.height)
					: i.renderbufferStorageMultisample(i.RENDERBUFFER, ne, G, T.width, T.height);
			} else i.renderbufferStorage(i.RENDERBUFFER, G, T.width, T.height);
			i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, O);
		} else if (T.depthBuffer && T.stencilBuffer) {
			const G = D(T);
			V && z(T) === !1
				? i.renderbufferStorageMultisample(i.RENDERBUFFER, G, i.DEPTH24_STENCIL8, T.width, T.height)
				: z(T)
				? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, G, i.DEPTH24_STENCIL8, T.width, T.height)
				: i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, T.width, T.height),
				i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, O);
		} else {
			const G = T.textures;
			for (let ee = 0; ee < G.length; ee++) {
				const ne = G[ee],
					_e = r.convert(ne.format, ne.colorSpace),
					me = r.convert(ne.type),
					ye = y(ne.internalFormat, _e, me, ne.colorSpace),
					De = D(T);
				V && z(T) === !1
					? i.renderbufferStorageMultisample(i.RENDERBUFFER, De, ye, T.width, T.height)
					: z(T)
					? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, De, ye, T.width, T.height)
					: i.renderbufferStorage(i.RENDERBUFFER, ye, T.width, T.height);
			}
		}
		i.bindRenderbuffer(i.RENDERBUFFER, null);
	}
	function we(O, T) {
		if (T && T.isWebGLCubeRenderTarget) throw new Error('Depth Texture with cube render targets is not supported');
		if ((t.bindFramebuffer(i.FRAMEBUFFER, O), !(T.depthTexture && T.depthTexture.isDepthTexture)))
			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
		(!n.get(T.depthTexture).__webglTexture || T.depthTexture.image.width !== T.width || T.depthTexture.image.height !== T.height) &&
			((T.depthTexture.image.width = T.width), (T.depthTexture.image.height = T.height), (T.depthTexture.needsUpdate = !0)),
			B(T.depthTexture, 0);
		const G = n.get(T.depthTexture).__webglTexture,
			ee = D(T);
		if (T.depthTexture.format === ga)
			z(T)
				? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, G, 0, ee)
				: i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, G, 0);
		else if (T.depthTexture.format === Ta)
			z(T)
				? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, G, 0, ee)
				: i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, G, 0);
		else throw new Error('Unknown depthTexture format');
	}
	function X(O) {
		const T = n.get(O),
			V = O.isWebGLCubeRenderTarget === !0;
		if (O.depthTexture && !T.__autoAllocateDepthBuffer) {
			if (V) throw new Error('target.depthTexture not supported in Cube render targets');
			we(T.__webglFramebuffer, O);
		} else if (V) {
			T.__webglDepthbuffer = [];
			for (let G = 0; G < 6; G++)
				t.bindFramebuffer(i.FRAMEBUFFER, T.__webglFramebuffer[G]),
					(T.__webglDepthbuffer[G] = i.createRenderbuffer()),
					Se(T.__webglDepthbuffer[G], O, !1);
		} else
			t.bindFramebuffer(i.FRAMEBUFFER, T.__webglFramebuffer),
				(T.__webglDepthbuffer = i.createRenderbuffer()),
				Se(T.__webglDepthbuffer, O, !1);
		t.bindFramebuffer(i.FRAMEBUFFER, null);
	}
	function ge(O, T, V) {
		const G = n.get(O);
		T !== void 0 && se(G.__webglFramebuffer, O, O.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), V !== void 0 && X(O);
	}
	function be(O) {
		const T = O.texture,
			V = n.get(O),
			G = n.get(T);
		O.addEventListener('dispose', E);
		const ee = O.textures,
			ne = O.isWebGLCubeRenderTarget === !0,
			_e = ee.length > 1;
		if (
			(_e || (G.__webglTexture === void 0 && (G.__webglTexture = i.createTexture()), (G.__version = T.version), o.memory.textures++),
			ne)
		) {
			V.__webglFramebuffer = [];
			for (let me = 0; me < 6; me++)
				if (T.mipmaps && T.mipmaps.length > 0) {
					V.__webglFramebuffer[me] = [];
					for (let ye = 0; ye < T.mipmaps.length; ye++) V.__webglFramebuffer[me][ye] = i.createFramebuffer();
				} else V.__webglFramebuffer[me] = i.createFramebuffer();
		} else {
			if (T.mipmaps && T.mipmaps.length > 0) {
				V.__webglFramebuffer = [];
				for (let me = 0; me < T.mipmaps.length; me++) V.__webglFramebuffer[me] = i.createFramebuffer();
			} else V.__webglFramebuffer = i.createFramebuffer();
			if (_e)
				for (let me = 0, ye = ee.length; me < ye; me++) {
					const De = n.get(ee[me]);
					De.__webglTexture === void 0 && ((De.__webglTexture = i.createTexture()), o.memory.textures++);
				}
			if (O.samples > 0 && z(O) === !1) {
				(V.__webglMultisampledFramebuffer = i.createFramebuffer()),
					(V.__webglColorRenderbuffer = []),
					t.bindFramebuffer(i.FRAMEBUFFER, V.__webglMultisampledFramebuffer);
				for (let me = 0; me < ee.length; me++) {
					const ye = ee[me];
					(V.__webglColorRenderbuffer[me] = i.createRenderbuffer()),
						i.bindRenderbuffer(i.RENDERBUFFER, V.__webglColorRenderbuffer[me]);
					const De = r.convert(ye.format, ye.colorSpace),
						ve = r.convert(ye.type),
						Le = y(ye.internalFormat, De, ve, ye.colorSpace, O.isXRRenderTarget === !0),
						Ye = D(O);
					i.renderbufferStorageMultisample(i.RENDERBUFFER, Ye, Le, O.width, O.height),
						i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + me, i.RENDERBUFFER, V.__webglColorRenderbuffer[me]);
				}
				i.bindRenderbuffer(i.RENDERBUFFER, null),
					O.depthBuffer && ((V.__webglDepthRenderbuffer = i.createRenderbuffer()), Se(V.__webglDepthRenderbuffer, O, !0)),
					t.bindFramebuffer(i.FRAMEBUFFER, null);
			}
		}
		if (ne) {
			t.bindTexture(i.TEXTURE_CUBE_MAP, G.__webglTexture), ue(i.TEXTURE_CUBE_MAP, T);
			for (let me = 0; me < 6; me++)
				if (T.mipmaps && T.mipmaps.length > 0)
					for (let ye = 0; ye < T.mipmaps.length; ye++)
						se(V.__webglFramebuffer[me][ye], O, T, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + me, ye);
				else se(V.__webglFramebuffer[me], O, T, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + me, 0);
			m(T) && f(i.TEXTURE_CUBE_MAP), t.unbindTexture();
		} else if (_e) {
			for (let me = 0, ye = ee.length; me < ye; me++) {
				const De = ee[me],
					ve = n.get(De);
				t.bindTexture(i.TEXTURE_2D, ve.__webglTexture),
					ue(i.TEXTURE_2D, De),
					se(V.__webglFramebuffer, O, De, i.COLOR_ATTACHMENT0 + me, i.TEXTURE_2D, 0),
					m(De) && f(i.TEXTURE_2D);
			}
			t.unbindTexture();
		} else {
			let me = i.TEXTURE_2D;
			if (
				((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) &&
					(me = O.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY),
				t.bindTexture(me, G.__webglTexture),
				ue(me, T),
				T.mipmaps && T.mipmaps.length > 0)
			)
				for (let ye = 0; ye < T.mipmaps.length; ye++) se(V.__webglFramebuffer[ye], O, T, i.COLOR_ATTACHMENT0, me, ye);
			else se(V.__webglFramebuffer, O, T, i.COLOR_ATTACHMENT0, me, 0);
			m(T) && f(me), t.unbindTexture();
		}
		O.depthBuffer && X(O);
	}
	function H(O) {
		const T = O.textures;
		for (let V = 0, G = T.length; V < G; V++) {
			const ee = T[V];
			if (m(ee)) {
				const ne = O.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D,
					_e = n.get(ee).__webglTexture;
				t.bindTexture(ne, _e), f(ne), t.unbindTexture();
			}
		}
	}
	const Ne = [],
		oe = [];
	function L(O) {
		if (O.samples > 0) {
			if (z(O) === !1) {
				const T = O.textures,
					V = O.width,
					G = O.height;
				let ee = i.COLOR_BUFFER_BIT;
				const ne = O.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT,
					_e = n.get(O),
					me = T.length > 1;
				if (me)
					for (let ye = 0; ye < T.length; ye++)
						t.bindFramebuffer(i.FRAMEBUFFER, _e.__webglMultisampledFramebuffer),
							i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ye, i.RENDERBUFFER, null),
							t.bindFramebuffer(i.FRAMEBUFFER, _e.__webglFramebuffer),
							i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ye, i.TEXTURE_2D, null, 0);
				t.bindFramebuffer(i.READ_FRAMEBUFFER, _e.__webglMultisampledFramebuffer),
					t.bindFramebuffer(i.DRAW_FRAMEBUFFER, _e.__webglFramebuffer);
				for (let ye = 0; ye < T.length; ye++) {
					if (
						(O.resolveDepthBuffer &&
							(O.depthBuffer && (ee |= i.DEPTH_BUFFER_BIT),
							O.stencilBuffer && O.resolveStencilBuffer && (ee |= i.STENCIL_BUFFER_BIT)),
						me)
					) {
						i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, _e.__webglColorRenderbuffer[ye]);
						const De = n.get(T[ye]).__webglTexture;
						i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, De, 0);
					}
					i.blitFramebuffer(0, 0, V, G, 0, 0, V, G, ee, i.NEAREST),
						l === !0 &&
							((Ne.length = 0),
							(oe.length = 0),
							Ne.push(i.COLOR_ATTACHMENT0 + ye),
							O.depthBuffer &&
								O.resolveDepthBuffer === !1 &&
								(Ne.push(ne), oe.push(ne), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, oe)),
							i.invalidateFramebuffer(i.READ_FRAMEBUFFER, Ne));
				}
				if ((t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), me))
					for (let ye = 0; ye < T.length; ye++) {
						t.bindFramebuffer(i.FRAMEBUFFER, _e.__webglMultisampledFramebuffer),
							i.framebufferRenderbuffer(
								i.FRAMEBUFFER,
								i.COLOR_ATTACHMENT0 + ye,
								i.RENDERBUFFER,
								_e.__webglColorRenderbuffer[ye]
							);
						const De = n.get(T[ye]).__webglTexture;
						t.bindFramebuffer(i.FRAMEBUFFER, _e.__webglFramebuffer),
							i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ye, i.TEXTURE_2D, De, 0);
					}
				t.bindFramebuffer(i.DRAW_FRAMEBUFFER, _e.__webglMultisampledFramebuffer);
			} else if (O.depthBuffer && O.resolveDepthBuffer === !1 && l) {
				const T = O.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
				i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [T]);
			}
		}
	}
	function D(O) {
		return Math.min(s.maxSamples, O.samples);
	}
	function z(O) {
		const T = n.get(O);
		return O.samples > 0 && e.has('WEBGL_multisampled_render_to_texture') === !0 && T.__useRenderToTexture !== !1;
	}
	function Y(O) {
		const T = o.render.frame;
		h.get(O) !== T && (h.set(O, T), O.update());
	}
	function K(O, T) {
		const V = O.colorSpace,
			G = O.format,
			ee = O.type;
		return (
			O.isCompressedTexture === !0 ||
				O.isVideoTexture === !0 ||
				(V !== Es &&
					V !== xs &&
					(Ft.getTransfer(V) === Wt
						? (G !== mi || ee !== Vn) &&
						  console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.')
						: console.error('THREE.WebGLTextures: Unsupported texture color space:', V))),
			T
		);
	}
	function re(O) {
		return (
			typeof HTMLImageElement < 'u' && O instanceof HTMLImageElement
				? ((c.width = O.naturalWidth || O.width), (c.height = O.naturalHeight || O.height))
				: typeof VideoFrame < 'u' && O instanceof VideoFrame
				? ((c.width = O.displayWidth), (c.height = O.displayHeight))
				: ((c.width = O.width), (c.height = O.height)),
			c
		);
	}
	(this.allocateTextureUnit = k),
		(this.resetTextureUnits = M),
		(this.setTexture2D = B),
		(this.setTexture2DArray = W),
		(this.setTexture3D = Q),
		(this.setTextureCube = $),
		(this.rebindTextures = ge),
		(this.setupRenderTarget = be),
		(this.updateRenderTargetMipmap = H),
		(this.updateMultisampleRenderTarget = L),
		(this.setupDepthRenderbuffer = X),
		(this.setupFrameBufferTexture = se),
		(this.useMultisampledRTT = z);
}
function yE(i, e) {
	function t(n, s = xs) {
		let r;
		const o = Ft.getTransfer(s);
		if (n === Vn) return i.UNSIGNED_BYTE;
		if (n === v_) return i.UNSIGNED_SHORT_4_4_4_4;
		if (n === __) return i.UNSIGNED_SHORT_5_5_5_1;
		if (n === BM) return i.UNSIGNED_INT_5_9_9_9_REV;
		if (n === NM) return i.BYTE;
		if (n === FM) return i.SHORT;
		if (n === m_) return i.UNSIGNED_SHORT;
		if (n === g_) return i.INT;
		if (n === yo) return i.UNSIGNED_INT;
		if (n === On) return i.FLOAT;
		if (n === fi) return i.HALF_FLOAT;
		if (n === kM) return i.ALPHA;
		if (n === zM) return i.RGB;
		if (n === mi) return i.RGBA;
		if (n === VM) return i.LUMINANCE;
		if (n === HM) return i.LUMINANCE_ALPHA;
		if (n === ga) return i.DEPTH_COMPONENT;
		if (n === Ta) return i.DEPTH_STENCIL;
		if (n === Bp) return i.RED;
		if (n === y_) return i.RED_INTEGER;
		if (n === GM) return i.RG;
		if (n === x_) return i.RG_INTEGER;
		if (n === b_) return i.RGBA_INTEGER;
		if (n === Ud || n === Nd || n === Fd || n === Bd)
			if (o === Wt)
				if (((r = e.get('WEBGL_compressed_texture_s3tc_srgb')), r !== null)) {
					if (n === Ud) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (n === Nd) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (n === Fd) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (n === Bd) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
				} else return null;
			else if (((r = e.get('WEBGL_compressed_texture_s3tc')), r !== null)) {
				if (n === Ud) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (n === Nd) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (n === Fd) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (n === Bd) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
			} else return null;
		if (n === Rg || n === Pg || n === Lg || n === Ig)
			if (((r = e.get('WEBGL_compressed_texture_pvrtc')), r !== null)) {
				if (n === Rg) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (n === Pg) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (n === Lg) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (n === Ig) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
			} else return null;
		if (n === Dg || n === Og || n === Ug)
			if (((r = e.get('WEBGL_compressed_texture_etc')), r !== null)) {
				if (n === Dg || n === Og) return o === Wt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
				if (n === Ug) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC;
			} else return null;
		if (
			n === Ng ||
			n === Fg ||
			n === Bg ||
			n === kg ||
			n === zg ||
			n === Vg ||
			n === Hg ||
			n === Gg ||
			n === Wg ||
			n === Xg ||
			n === qg ||
			n === Yg ||
			n === jg ||
			n === Kg
		)
			if (((r = e.get('WEBGL_compressed_texture_astc')), r !== null)) {
				if (n === Ng) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (n === Fg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (n === Bg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (n === kg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (n === zg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (n === Vg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (n === Hg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (n === Gg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (n === Wg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (n === Xg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (n === qg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (n === Yg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (n === jg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (n === Kg) return o === Wt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
			} else return null;
		if (n === kd || n === $g || n === Zg)
			if (((r = e.get('EXT_texture_compression_bptc')), r !== null)) {
				if (n === kd) return o === Wt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if (n === $g) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if (n === Zg) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
			} else return null;
		if (n === WM || n === Jg || n === Qg || n === ev)
			if (((r = e.get('EXT_texture_compression_rgtc')), r !== null)) {
				if (n === kd) return r.COMPRESSED_RED_RGTC1_EXT;
				if (n === Jg) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if (n === Qg) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if (n === ev) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
			} else return null;
		return n === Ba ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
	}
	return { convert: t };
}
class xE extends fn {
	constructor(e = []) {
		super(), (this.isArrayCamera = !0), (this.cameras = e);
	}
}
class Ui extends ft {
	constructor() {
		super(), (this.isGroup = !0), (this.type = 'Group');
	}
}
const nN = { type: 'move' };
class cm {
	constructor() {
		(this._targetRay = null), (this._grip = null), (this._hand = null);
	}
	getHandSpace() {
		return (
			this._hand === null &&
				((this._hand = new Ui()),
				(this._hand.matrixAutoUpdate = !1),
				(this._hand.visible = !1),
				(this._hand.joints = {}),
				(this._hand.inputState = { pinching: !1 })),
			this._hand
		);
	}
	getTargetRaySpace() {
		return (
			this._targetRay === null &&
				((this._targetRay = new Ui()),
				(this._targetRay.matrixAutoUpdate = !1),
				(this._targetRay.visible = !1),
				(this._targetRay.hasLinearVelocity = !1),
				(this._targetRay.linearVelocity = new I()),
				(this._targetRay.hasAngularVelocity = !1),
				(this._targetRay.angularVelocity = new I())),
			this._targetRay
		);
	}
	getGripSpace() {
		return (
			this._grip === null &&
				((this._grip = new Ui()),
				(this._grip.matrixAutoUpdate = !1),
				(this._grip.visible = !1),
				(this._grip.hasLinearVelocity = !1),
				(this._grip.linearVelocity = new I()),
				(this._grip.hasAngularVelocity = !1),
				(this._grip.angularVelocity = new I())),
			this._grip
		);
	}
	dispatchEvent(e) {
		return (
			this._targetRay !== null && this._targetRay.dispatchEvent(e),
			this._grip !== null && this._grip.dispatchEvent(e),
			this._hand !== null && this._hand.dispatchEvent(e),
			this
		);
	}
	connect(e) {
		if (e && e.hand) {
			const t = this._hand;
			if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
		}
		return this.dispatchEvent({ type: 'connected', data: e }), this;
	}
	disconnect(e) {
		return (
			this.dispatchEvent({ type: 'disconnected', data: e }),
			this._targetRay !== null && (this._targetRay.visible = !1),
			this._grip !== null && (this._grip.visible = !1),
			this._hand !== null && (this._hand.visible = !1),
			this
		);
	}
	update(e, t, n) {
		let s = null,
			r = null,
			o = null;
		const a = this._targetRay,
			l = this._grip,
			c = this._hand;
		if (e && t.session.visibilityState !== 'visible-blurred') {
			if (c && e.hand) {
				o = !0;
				for (const v of e.hand.values()) {
					const m = t.getJointPose(v, n),
						f = this._getHandJoint(c, v);
					m !== null &&
						(f.matrix.fromArray(m.transform.matrix),
						f.matrix.decompose(f.position, f.rotation, f.scale),
						(f.matrixWorldNeedsUpdate = !0),
						(f.jointRadius = m.radius)),
						(f.visible = m !== null);
				}
				const h = c.joints['index-finger-tip'],
					u = c.joints['thumb-tip'],
					d = h.position.distanceTo(u.position),
					p = 0.02,
					g = 0.005;
				c.inputState.pinching && d > p + g
					? ((c.inputState.pinching = !1), this.dispatchEvent({ type: 'pinchend', handedness: e.handedness, target: this }))
					: !c.inputState.pinching &&
					  d <= p - g &&
					  ((c.inputState.pinching = !0), this.dispatchEvent({ type: 'pinchstart', handedness: e.handedness, target: this }));
			} else
				l !== null &&
					e.gripSpace &&
					((r = t.getPose(e.gripSpace, n)),
					r !== null &&
						(l.matrix.fromArray(r.transform.matrix),
						l.matrix.decompose(l.position, l.rotation, l.scale),
						(l.matrixWorldNeedsUpdate = !0),
						r.linearVelocity
							? ((l.hasLinearVelocity = !0), l.linearVelocity.copy(r.linearVelocity))
							: (l.hasLinearVelocity = !1),
						r.angularVelocity
							? ((l.hasAngularVelocity = !0), l.angularVelocity.copy(r.angularVelocity))
							: (l.hasAngularVelocity = !1)));
			a !== null &&
				((s = t.getPose(e.targetRaySpace, n)),
				s === null && r !== null && (s = r),
				s !== null &&
					(a.matrix.fromArray(s.transform.matrix),
					a.matrix.decompose(a.position, a.rotation, a.scale),
					(a.matrixWorldNeedsUpdate = !0),
					s.linearVelocity ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(s.linearVelocity)) : (a.hasLinearVelocity = !1),
					s.angularVelocity
						? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(s.angularVelocity))
						: (a.hasAngularVelocity = !1),
					this.dispatchEvent(nN)));
		}
		return a !== null && (a.visible = s !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
	}
	_getHandJoint(e, t) {
		if (e.joints[t.jointName] === void 0) {
			const n = new Ui();
			(n.matrixAutoUpdate = !1), (n.visible = !1), (e.joints[t.jointName] = n), e.add(n);
		}
		return e.joints[t.jointName];
	}
}
const iN = '\nvoid main() {\n\n	gl_Position = vec4( position, 1.0 );\n\n}',
	sN =
		'\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n	if ( coord.x >= 1.0 ) {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n	} else {\n\n		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n	}\n\n}';
class rN {
	constructor() {
		(this.texture = null), (this.mesh = null), (this.depthNear = 0), (this.depthFar = 0);
	}
	init(e, t, n) {
		if (this.texture === null) {
			const s = new zt(),
				r = e.properties.get(s);
			(r.__webglTexture = t.texture),
				(t.depthNear != n.depthNear || t.depthFar != n.depthFar) && ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
				(this.texture = s);
		}
	}
	render(e, t) {
		if (this.texture !== null) {
			if (this.mesh === null) {
				const n = t.cameras[0].viewport,
					s = new xn({
						vertexShader: iN,
						fragmentShader: sN,
						uniforms: { depthColor: { value: this.texture }, depthWidth: { value: n.z }, depthHeight: { value: n.w } },
					});
				this.mesh = new bt(new js(20, 20), s);
			}
			e.render(this.mesh, t);
		}
	}
	reset() {
		(this.texture = null), (this.mesh = null);
	}
}
class oN extends Hi {
	constructor(e, t) {
		super();
		const n = this;
		let s = null,
			r = 1,
			o = null,
			a = 'local-floor',
			l = 1,
			c = null,
			h = null,
			u = null,
			d = null,
			p = null,
			g = null;
		const v = new rN(),
			m = t.getContextAttributes();
		let f = null,
			y = null;
		const _ = [],
			x = [],
			E = new ce();
		let w = null;
		const C = new fn();
		C.layers.enable(1), (C.viewport = new Pt());
		const P = new fn();
		P.layers.enable(2), (P.viewport = new Pt());
		const S = [C, P],
			M = new xE();
		M.layers.enable(1), M.layers.enable(2);
		let k = null,
			q = null;
		(this.cameraAutoUpdate = !0),
			(this.enabled = !1),
			(this.isPresenting = !1),
			(this.getController = function (se) {
				let Se = _[se];
				return Se === void 0 && ((Se = new cm()), (_[se] = Se)), Se.getTargetRaySpace();
			}),
			(this.getControllerGrip = function (se) {
				let Se = _[se];
				return Se === void 0 && ((Se = new cm()), (_[se] = Se)), Se.getGripSpace();
			}),
			(this.getHand = function (se) {
				let Se = _[se];
				return Se === void 0 && ((Se = new cm()), (_[se] = Se)), Se.getHandSpace();
			});
		function B(se) {
			const Se = x.indexOf(se.inputSource);
			if (Se === -1) return;
			const we = _[Se];
			we !== void 0 && (we.update(se.inputSource, se.frame, c || o), we.dispatchEvent({ type: se.type, data: se.inputSource }));
		}
		function W() {
			s.removeEventListener('select', B),
				s.removeEventListener('selectstart', B),
				s.removeEventListener('selectend', B),
				s.removeEventListener('squeeze', B),
				s.removeEventListener('squeezestart', B),
				s.removeEventListener('squeezeend', B),
				s.removeEventListener('end', W),
				s.removeEventListener('inputsourceschange', Q);
			for (let se = 0; se < _.length; se++) {
				const Se = x[se];
				Se !== null && ((x[se] = null), _[se].disconnect(Se));
			}
			(k = null),
				(q = null),
				v.reset(),
				e.setRenderTarget(f),
				(p = null),
				(d = null),
				(u = null),
				(s = null),
				(y = null),
				We.stop(),
				(n.isPresenting = !1),
				e.setPixelRatio(w),
				e.setSize(E.width, E.height, !1),
				n.dispatchEvent({ type: 'sessionend' });
		}
		(this.setFramebufferScaleFactor = function (se) {
			(r = se), n.isPresenting === !0 && console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
		}),
			(this.setReferenceSpaceType = function (se) {
				(a = se), n.isPresenting === !0 && console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
			}),
			(this.getReferenceSpace = function () {
				return c || o;
			}),
			(this.setReferenceSpace = function (se) {
				c = se;
			}),
			(this.getBaseLayer = function () {
				return d !== null ? d : p;
			}),
			(this.getBinding = function () {
				return u;
			}),
			(this.getFrame = function () {
				return g;
			}),
			(this.getSession = function () {
				return s;
			}),
			(this.setSession = async function (se) {
				if (((s = se), s !== null)) {
					if (
						((f = e.getRenderTarget()),
						s.addEventListener('select', B),
						s.addEventListener('selectstart', B),
						s.addEventListener('selectend', B),
						s.addEventListener('squeeze', B),
						s.addEventListener('squeezestart', B),
						s.addEventListener('squeezeend', B),
						s.addEventListener('end', W),
						s.addEventListener('inputsourceschange', Q),
						m.xrCompatible !== !0 && (await t.makeXRCompatible()),
						(w = e.getPixelRatio()),
						e.getSize(E),
						s.renderState.layers === void 0)
					) {
						const Se = { antialias: m.antialias, alpha: !0, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: r };
						(p = new XRWebGLLayer(s, t, Se)),
							s.updateRenderState({ baseLayer: p }),
							e.setPixelRatio(1),
							e.setSize(p.framebufferWidth, p.framebufferHeight, !1),
							(y = new yn(p.framebufferWidth, p.framebufferHeight, {
								format: mi,
								type: Vn,
								colorSpace: e.outputColorSpace,
								stencilBuffer: m.stencil,
							}));
					} else {
						let Se = null,
							we = null,
							X = null;
						m.depth &&
							((X = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
							(Se = m.stencil ? Ta : ga),
							(we = m.stencil ? Ba : yo));
						const ge = { colorFormat: t.RGBA8, depthFormat: X, scaleFactor: r };
						(u = new XRWebGLBinding(s, t)),
							(d = u.createProjectionLayer(ge)),
							s.updateRenderState({ layers: [d] }),
							e.setPixelRatio(1),
							e.setSize(d.textureWidth, d.textureHeight, !1),
							(y = new yn(d.textureWidth, d.textureHeight, {
								format: mi,
								type: Vn,
								depthTexture: new Wp(
									d.textureWidth,
									d.textureHeight,
									we,
									void 0,
									void 0,
									void 0,
									void 0,
									void 0,
									void 0,
									Se
								),
								stencilBuffer: m.stencil,
								colorSpace: e.outputColorSpace,
								samples: m.antialias ? 4 : 0,
								resolveDepthBuffer: d.ignoreDepthValues === !1,
							}));
					}
					(y.isXRRenderTarget = !0),
						this.setFoveation(l),
						(c = null),
						(o = await s.requestReferenceSpace(a)),
						We.setContext(s),
						We.start(),
						(n.isPresenting = !0),
						n.dispatchEvent({ type: 'sessionstart' });
				}
			}),
			(this.getEnvironmentBlendMode = function () {
				if (s !== null) return s.environmentBlendMode;
			});
		function Q(se) {
			for (let Se = 0; Se < se.removed.length; Se++) {
				const we = se.removed[Se],
					X = x.indexOf(we);
				X >= 0 && ((x[X] = null), _[X].disconnect(we));
			}
			for (let Se = 0; Se < se.added.length; Se++) {
				const we = se.added[Se];
				let X = x.indexOf(we);
				if (X === -1) {
					for (let be = 0; be < _.length; be++)
						if (be >= x.length) {
							x.push(we), (X = be);
							break;
						} else if (x[be] === null) {
							(x[be] = we), (X = be);
							break;
						}
					if (X === -1) break;
				}
				const ge = _[X];
				ge && ge.connect(we);
			}
		}
		const $ = new I(),
			le = new I();
		function Z(se, Se, we) {
			$.setFromMatrixPosition(Se.matrixWorld), le.setFromMatrixPosition(we.matrixWorld);
			const X = $.distanceTo(le),
				ge = Se.projectionMatrix.elements,
				be = we.projectionMatrix.elements,
				H = ge[14] / (ge[10] - 1),
				Ne = ge[14] / (ge[10] + 1),
				oe = (ge[9] + 1) / ge[5],
				L = (ge[9] - 1) / ge[5],
				D = (ge[8] - 1) / ge[0],
				z = (be[8] + 1) / be[0],
				Y = H * D,
				K = H * z,
				re = X / (-D + z),
				O = re * -D;
			Se.matrixWorld.decompose(se.position, se.quaternion, se.scale),
				se.translateX(O),
				se.translateZ(re),
				se.matrixWorld.compose(se.position, se.quaternion, se.scale),
				se.matrixWorldInverse.copy(se.matrixWorld).invert();
			const T = H + re,
				V = Ne + re,
				G = Y - O,
				ee = K + (X - O),
				ne = ((oe * Ne) / V) * T,
				_e = ((L * Ne) / V) * T;
			se.projectionMatrix.makePerspective(G, ee, ne, _e, T, V), se.projectionMatrixInverse.copy(se.projectionMatrix).invert();
		}
		function xe(se, Se) {
			Se === null ? se.matrixWorld.copy(se.matrix) : se.matrixWorld.multiplyMatrices(Se.matrixWorld, se.matrix),
				se.matrixWorldInverse.copy(se.matrixWorld).invert();
		}
		this.updateCamera = function (se) {
			if (s === null) return;
			v.texture !== null && ((se.near = v.depthNear), (se.far = v.depthFar)),
				(M.near = P.near = C.near = se.near),
				(M.far = P.far = C.far = se.far),
				(k !== M.near || q !== M.far) &&
					(s.updateRenderState({ depthNear: M.near, depthFar: M.far }),
					(k = M.near),
					(q = M.far),
					(C.near = k),
					(C.far = q),
					(P.near = k),
					(P.far = q),
					C.updateProjectionMatrix(),
					P.updateProjectionMatrix(),
					se.updateProjectionMatrix());
			const Se = se.parent,
				we = M.cameras;
			xe(M, Se);
			for (let X = 0; X < we.length; X++) xe(we[X], Se);
			we.length === 2 ? Z(M, C, P) : M.projectionMatrix.copy(C.projectionMatrix), ue(se, M, Se);
		};
		function ue(se, Se, we) {
			we === null
				? se.matrix.copy(Se.matrixWorld)
				: (se.matrix.copy(we.matrixWorld), se.matrix.invert(), se.matrix.multiply(Se.matrixWorld)),
				se.matrix.decompose(se.position, se.quaternion, se.scale),
				se.updateMatrixWorld(!0),
				se.projectionMatrix.copy(Se.projectionMatrix),
				se.projectionMatrixInverse.copy(Se.projectionMatrixInverse),
				se.isPerspectiveCamera && ((se.fov = Zl * 2 * Math.atan(1 / se.projectionMatrix.elements[5])), (se.zoom = 1));
		}
		(this.getCamera = function () {
			return M;
		}),
			(this.getFoveation = function () {
				if (!(d === null && p === null)) return l;
			}),
			(this.setFoveation = function (se) {
				(l = se), d !== null && (d.fixedFoveation = se), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = se);
			}),
			(this.hasDepthSensing = function () {
				return v.texture !== null;
			});
		let Te = null;
		function Ae(se, Se) {
			if (((h = Se.getViewerPose(c || o)), (g = Se), h !== null)) {
				const we = h.views;
				p !== null && (e.setRenderTargetFramebuffer(y, p.framebuffer), e.setRenderTarget(y));
				let X = !1;
				we.length !== M.cameras.length && ((M.cameras.length = 0), (X = !0));
				for (let be = 0; be < we.length; be++) {
					const H = we[be];
					let Ne = null;
					if (p !== null) Ne = p.getViewport(H);
					else {
						const L = u.getViewSubImage(d, H);
						(Ne = L.viewport),
							be === 0 &&
								(e.setRenderTargetTextures(y, L.colorTexture, d.ignoreDepthValues ? void 0 : L.depthStencilTexture),
								e.setRenderTarget(y));
					}
					let oe = S[be];
					oe === void 0 && ((oe = new fn()), oe.layers.enable(be), (oe.viewport = new Pt()), (S[be] = oe)),
						oe.matrix.fromArray(H.transform.matrix),
						oe.matrix.decompose(oe.position, oe.quaternion, oe.scale),
						oe.projectionMatrix.fromArray(H.projectionMatrix),
						oe.projectionMatrixInverse.copy(oe.projectionMatrix).invert(),
						oe.viewport.set(Ne.x, Ne.y, Ne.width, Ne.height),
						be === 0 && (M.matrix.copy(oe.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)),
						X === !0 && M.cameras.push(oe);
				}
				const ge = s.enabledFeatures;
				if (ge && ge.includes('depth-sensing')) {
					const be = u.getDepthInformation(we[0]);
					be && be.isValid && be.texture && v.init(e, be, s.renderState);
				}
			}
			for (let we = 0; we < _.length; we++) {
				const X = x[we],
					ge = _[we];
				X !== null && ge !== void 0 && ge.update(X, Se, c || o);
			}
			v.render(e, M), Te && Te(se, Se), Se.detectedPlanes && n.dispatchEvent({ type: 'planesdetected', data: Se }), (g = null);
		}
		const We = new pE();
		We.setAnimationLoop(Ae),
			(this.setAnimationLoop = function (se) {
				Te = se;
			}),
			(this.dispose = function () {});
	}
}
const Vo = new zi(),
	aN = new He();
function lN(i, e) {
	function t(m, f) {
		m.matrixAutoUpdate === !0 && m.updateMatrix(), f.value.copy(m.matrix);
	}
	function n(m, f) {
		f.color.getRGB(m.fogColor.value, cE(i)),
			f.isFog ? ((m.fogNear.value = f.near), (m.fogFar.value = f.far)) : f.isFogExp2 && (m.fogDensity.value = f.density);
	}
	function s(m, f, y, _, x) {
		f.isMeshBasicMaterial || f.isMeshLambertMaterial
			? r(m, f)
			: f.isMeshToonMaterial
			? (r(m, f), u(m, f))
			: f.isMeshPhongMaterial
			? (r(m, f), h(m, f))
			: f.isMeshStandardMaterial
			? (r(m, f), d(m, f), f.isMeshPhysicalMaterial && p(m, f, x))
			: f.isMeshMatcapMaterial
			? (r(m, f), g(m, f))
			: f.isMeshDepthMaterial
			? r(m, f)
			: f.isMeshDistanceMaterial
			? (r(m, f), v(m, f))
			: f.isMeshNormalMaterial
			? r(m, f)
			: f.isLineBasicMaterial
			? (o(m, f), f.isLineDashedMaterial && a(m, f))
			: f.isPointsMaterial
			? l(m, f, y, _)
			: f.isSpriteMaterial
			? c(m, f)
			: f.isShadowMaterial
			? (m.color.value.copy(f.color), (m.opacity.value = f.opacity))
			: f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
	}
	function r(m, f) {
		(m.opacity.value = f.opacity),
			f.color && m.diffuse.value.copy(f.color),
			f.emissive && m.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),
			f.map && ((m.map.value = f.map), t(f.map, m.mapTransform)),
			f.alphaMap && ((m.alphaMap.value = f.alphaMap), t(f.alphaMap, m.alphaMapTransform)),
			f.bumpMap &&
				((m.bumpMap.value = f.bumpMap),
				t(f.bumpMap, m.bumpMapTransform),
				(m.bumpScale.value = f.bumpScale),
				f.side === gn && (m.bumpScale.value *= -1)),
			f.normalMap &&
				((m.normalMap.value = f.normalMap),
				t(f.normalMap, m.normalMapTransform),
				m.normalScale.value.copy(f.normalScale),
				f.side === gn && m.normalScale.value.negate()),
			f.displacementMap &&
				((m.displacementMap.value = f.displacementMap),
				t(f.displacementMap, m.displacementMapTransform),
				(m.displacementScale.value = f.displacementScale),
				(m.displacementBias.value = f.displacementBias)),
			f.emissiveMap && ((m.emissiveMap.value = f.emissiveMap), t(f.emissiveMap, m.emissiveMapTransform)),
			f.specularMap && ((m.specularMap.value = f.specularMap), t(f.specularMap, m.specularMapTransform)),
			f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
		const y = e.get(f),
			_ = y.envMap,
			x = y.envMapRotation;
		if (
			(_ &&
				((m.envMap.value = _),
				Vo.copy(x),
				(Vo.x *= -1),
				(Vo.y *= -1),
				(Vo.z *= -1),
				_.isCubeTexture && _.isRenderTargetTexture === !1 && ((Vo.y *= -1), (Vo.z *= -1)),
				m.envMapRotation.value.setFromMatrix4(aN.makeRotationFromEuler(Vo)),
				(m.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
				(m.reflectivity.value = f.reflectivity),
				(m.ior.value = f.ior),
				(m.refractionRatio.value = f.refractionRatio)),
			f.lightMap)
		) {
			m.lightMap.value = f.lightMap;
			const E = i._useLegacyLights === !0 ? Math.PI : 1;
			(m.lightMapIntensity.value = f.lightMapIntensity * E), t(f.lightMap, m.lightMapTransform);
		}
		f.aoMap && ((m.aoMap.value = f.aoMap), (m.aoMapIntensity.value = f.aoMapIntensity), t(f.aoMap, m.aoMapTransform));
	}
	function o(m, f) {
		m.diffuse.value.copy(f.color), (m.opacity.value = f.opacity), f.map && ((m.map.value = f.map), t(f.map, m.mapTransform));
	}
	function a(m, f) {
		(m.dashSize.value = f.dashSize), (m.totalSize.value = f.dashSize + f.gapSize), (m.scale.value = f.scale);
	}
	function l(m, f, y, _) {
		m.diffuse.value.copy(f.color),
			(m.opacity.value = f.opacity),
			(m.size.value = f.size * y),
			(m.scale.value = _ * 0.5),
			f.map && ((m.map.value = f.map), t(f.map, m.uvTransform)),
			f.alphaMap && ((m.alphaMap.value = f.alphaMap), t(f.alphaMap, m.alphaMapTransform)),
			f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
	}
	function c(m, f) {
		m.diffuse.value.copy(f.color),
			(m.opacity.value = f.opacity),
			(m.rotation.value = f.rotation),
			f.map && ((m.map.value = f.map), t(f.map, m.mapTransform)),
			f.alphaMap && ((m.alphaMap.value = f.alphaMap), t(f.alphaMap, m.alphaMapTransform)),
			f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
	}
	function h(m, f) {
		m.specular.value.copy(f.specular), (m.shininess.value = Math.max(f.shininess, 1e-4));
	}
	function u(m, f) {
		f.gradientMap && (m.gradientMap.value = f.gradientMap);
	}
	function d(m, f) {
		(m.metalness.value = f.metalness),
			f.metalnessMap && ((m.metalnessMap.value = f.metalnessMap), t(f.metalnessMap, m.metalnessMapTransform)),
			(m.roughness.value = f.roughness),
			f.roughnessMap && ((m.roughnessMap.value = f.roughnessMap), t(f.roughnessMap, m.roughnessMapTransform)),
			f.envMap && (m.envMapIntensity.value = f.envMapIntensity);
	}
	function p(m, f, y) {
		(m.ior.value = f.ior),
			f.sheen > 0 &&
				(m.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),
				(m.sheenRoughness.value = f.sheenRoughness),
				f.sheenColorMap && ((m.sheenColorMap.value = f.sheenColorMap), t(f.sheenColorMap, m.sheenColorMapTransform)),
				f.sheenRoughnessMap &&
					((m.sheenRoughnessMap.value = f.sheenRoughnessMap), t(f.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
			f.clearcoat > 0 &&
				((m.clearcoat.value = f.clearcoat),
				(m.clearcoatRoughness.value = f.clearcoatRoughness),
				f.clearcoatMap && ((m.clearcoatMap.value = f.clearcoatMap), t(f.clearcoatMap, m.clearcoatMapTransform)),
				f.clearcoatRoughnessMap &&
					((m.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap),
					t(f.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
				f.clearcoatNormalMap &&
					((m.clearcoatNormalMap.value = f.clearcoatNormalMap),
					t(f.clearcoatNormalMap, m.clearcoatNormalMapTransform),
					m.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),
					f.side === gn && m.clearcoatNormalScale.value.negate())),
			f.dispersion > 0 && (m.dispersion.value = f.dispersion),
			f.iridescence > 0 &&
				((m.iridescence.value = f.iridescence),
				(m.iridescenceIOR.value = f.iridescenceIOR),
				(m.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0]),
				(m.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1]),
				f.iridescenceMap && ((m.iridescenceMap.value = f.iridescenceMap), t(f.iridescenceMap, m.iridescenceMapTransform)),
				f.iridescenceThicknessMap &&
					((m.iridescenceThicknessMap.value = f.iridescenceThicknessMap),
					t(f.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
			f.transmission > 0 &&
				((m.transmission.value = f.transmission),
				(m.transmissionSamplerMap.value = y.texture),
				m.transmissionSamplerSize.value.set(y.width, y.height),
				f.transmissionMap && ((m.transmissionMap.value = f.transmissionMap), t(f.transmissionMap, m.transmissionMapTransform)),
				(m.thickness.value = f.thickness),
				f.thicknessMap && ((m.thicknessMap.value = f.thicknessMap), t(f.thicknessMap, m.thicknessMapTransform)),
				(m.attenuationDistance.value = f.attenuationDistance),
				m.attenuationColor.value.copy(f.attenuationColor)),
			f.anisotropy > 0 &&
				(m.anisotropyVector.value.set(f.anisotropy * Math.cos(f.anisotropyRotation), f.anisotropy * Math.sin(f.anisotropyRotation)),
				f.anisotropyMap && ((m.anisotropyMap.value = f.anisotropyMap), t(f.anisotropyMap, m.anisotropyMapTransform))),
			(m.specularIntensity.value = f.specularIntensity),
			m.specularColor.value.copy(f.specularColor),
			f.specularColorMap && ((m.specularColorMap.value = f.specularColorMap), t(f.specularColorMap, m.specularColorMapTransform)),
			f.specularIntensityMap &&
				((m.specularIntensityMap.value = f.specularIntensityMap), t(f.specularIntensityMap, m.specularIntensityMapTransform));
	}
	function g(m, f) {
		f.matcap && (m.matcap.value = f.matcap);
	}
	function v(m, f) {
		const y = e.get(f).light;
		m.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
			(m.nearDistance.value = y.shadow.camera.near),
			(m.farDistance.value = y.shadow.camera.far);
	}
	return { refreshFogUniforms: n, refreshMaterialUniforms: s };
}
function cN(i, e, t, n) {
	let s = {},
		r = {},
		o = [];
	const a = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
	function l(y, _) {
		const x = _.program;
		n.uniformBlockBinding(y, x);
	}
	function c(y, _) {
		let x = s[y.id];
		x === void 0 && (g(y), (x = h(y)), (s[y.id] = x), y.addEventListener('dispose', m));
		const E = _.program;
		n.updateUBOMapping(y, E);
		const w = e.render.frame;
		r[y.id] !== w && (d(y), (r[y.id] = w));
	}
	function h(y) {
		const _ = u();
		y.__bindingPointIndex = _;
		const x = i.createBuffer(),
			E = y.__size,
			w = y.usage;
		return (
			i.bindBuffer(i.UNIFORM_BUFFER, x),
			i.bufferData(i.UNIFORM_BUFFER, E, w),
			i.bindBuffer(i.UNIFORM_BUFFER, null),
			i.bindBufferBase(i.UNIFORM_BUFFER, _, x),
			x
		);
	}
	function u() {
		for (let y = 0; y < a; y++) if (o.indexOf(y) === -1) return o.push(y), y;
		return console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.'), 0;
	}
	function d(y) {
		const _ = s[y.id],
			x = y.uniforms,
			E = y.__cache;
		i.bindBuffer(i.UNIFORM_BUFFER, _);
		for (let w = 0, C = x.length; w < C; w++) {
			const P = Array.isArray(x[w]) ? x[w] : [x[w]];
			for (let S = 0, M = P.length; S < M; S++) {
				const k = P[S];
				if (p(k, w, S, E) === !0) {
					const q = k.__offset,
						B = Array.isArray(k.value) ? k.value : [k.value];
					let W = 0;
					for (let Q = 0; Q < B.length; Q++) {
						const $ = B[Q],
							le = v($);
						typeof $ == 'number' || typeof $ == 'boolean'
							? ((k.__data[0] = $), i.bufferSubData(i.UNIFORM_BUFFER, q + W, k.__data))
							: $.isMatrix3
							? ((k.__data[0] = $.elements[0]),
							  (k.__data[1] = $.elements[1]),
							  (k.__data[2] = $.elements[2]),
							  (k.__data[3] = 0),
							  (k.__data[4] = $.elements[3]),
							  (k.__data[5] = $.elements[4]),
							  (k.__data[6] = $.elements[5]),
							  (k.__data[7] = 0),
							  (k.__data[8] = $.elements[6]),
							  (k.__data[9] = $.elements[7]),
							  (k.__data[10] = $.elements[8]),
							  (k.__data[11] = 0))
							: ($.toArray(k.__data, W), (W += le.storage / Float32Array.BYTES_PER_ELEMENT));
					}
					i.bufferSubData(i.UNIFORM_BUFFER, q, k.__data);
				}
			}
		}
		i.bindBuffer(i.UNIFORM_BUFFER, null);
	}
	function p(y, _, x, E) {
		const w = y.value,
			C = _ + '_' + x;
		if (E[C] === void 0) return typeof w == 'number' || typeof w == 'boolean' ? (E[C] = w) : (E[C] = w.clone()), !0;
		{
			const P = E[C];
			if (typeof w == 'number' || typeof w == 'boolean') {
				if (P !== w) return (E[C] = w), !0;
			} else if (P.equals(w) === !1) return P.copy(w), !0;
		}
		return !1;
	}
	function g(y) {
		const _ = y.uniforms;
		let x = 0;
		const E = 16;
		for (let C = 0, P = _.length; C < P; C++) {
			const S = Array.isArray(_[C]) ? _[C] : [_[C]];
			for (let M = 0, k = S.length; M < k; M++) {
				const q = S[M],
					B = Array.isArray(q.value) ? q.value : [q.value];
				for (let W = 0, Q = B.length; W < Q; W++) {
					const $ = B[W],
						le = v($),
						Z = x % E;
					Z !== 0 && E - Z < le.boundary && (x += E - Z),
						(q.__data = new Float32Array(le.storage / Float32Array.BYTES_PER_ELEMENT)),
						(q.__offset = x),
						(x += le.storage);
				}
			}
		}
		const w = x % E;
		return w > 0 && (x += E - w), (y.__size = x), (y.__cache = {}), this;
	}
	function v(y) {
		const _ = { boundary: 0, storage: 0 };
		return (
			typeof y == 'number' || typeof y == 'boolean'
				? ((_.boundary = 4), (_.storage = 4))
				: y.isVector2
				? ((_.boundary = 8), (_.storage = 8))
				: y.isVector3 || y.isColor
				? ((_.boundary = 16), (_.storage = 12))
				: y.isVector4
				? ((_.boundary = 16), (_.storage = 16))
				: y.isMatrix3
				? ((_.boundary = 48), (_.storage = 48))
				: y.isMatrix4
				? ((_.boundary = 64), (_.storage = 64))
				: y.isTexture
				? console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.')
				: console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', y),
			_
		);
	}
	function m(y) {
		const _ = y.target;
		_.removeEventListener('dispose', m);
		const x = o.indexOf(_.__bindingPointIndex);
		o.splice(x, 1), i.deleteBuffer(s[_.id]), delete s[_.id], delete r[_.id];
	}
	function f() {
		for (const y in s) i.deleteBuffer(s[y]);
		(o = []), (s = {}), (r = {});
	}
	return { bind: l, update: c, dispose: f };
}
class bE {
	constructor(e = {}) {
		const {
			canvas: t = sE(),
			context: n = null,
			depth: s = !0,
			stencil: r = !1,
			alpha: o = !1,
			antialias: a = !1,
			premultipliedAlpha: l = !0,
			preserveDrawingBuffer: c = !1,
			powerPreference: h = 'default',
			failIfMajorPerformanceCaveat: u = !1,
		} = e;
		this.isWebGLRenderer = !0;
		let d;
		if (n !== null) {
			if (typeof WebGLRenderingContext < 'u' && n instanceof WebGLRenderingContext)
				throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.');
			d = n.getContextAttributes().alpha;
		} else d = o;
		const p = new Uint32Array(4),
			g = new Int32Array(4);
		let v = null,
			m = null;
		const f = [],
			y = [];
		(this.domElement = t),
			(this.debug = { checkShaderErrors: !0, onShaderError: null }),
			(this.autoClear = !0),
			(this.autoClearColor = !0),
			(this.autoClearDepth = !0),
			(this.autoClearStencil = !0),
			(this.sortObjects = !0),
			(this.clippingPlanes = []),
			(this.localClippingEnabled = !1),
			(this._outputColorSpace = ot),
			(this._useLegacyLights = !1),
			(this.toneMapping = Xs),
			(this.toneMappingExposure = 1);
		const _ = this;
		let x = !1,
			E = 0,
			w = 0,
			C = null,
			P = -1,
			S = null;
		const M = new Pt(),
			k = new Pt();
		let q = null;
		const B = new Ee(0);
		let W = 0,
			Q = t.width,
			$ = t.height,
			le = 1,
			Z = null,
			xe = null;
		const ue = new Pt(0, 0, Q, $),
			Te = new Pt(0, 0, Q, $);
		let Ae = !1;
		const We = new Qh();
		let se = !1,
			Se = !1;
		const we = new He(),
			X = new I(),
			ge = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
		function be() {
			return C === null ? le : 1;
		}
		let H = n;
		function Ne(b, R) {
			return t.getContext(b, R);
		}
		try {
			const b = {
				alpha: !0,
				depth: s,
				stencil: r,
				antialias: a,
				premultipliedAlpha: l,
				preserveDrawingBuffer: c,
				powerPreference: h,
				failIfMajorPerformanceCaveat: u,
			};
			if (
				('setAttribute' in t && t.setAttribute('data-engine', 'three.js r'.concat(Co)),
				t.addEventListener('webglcontextlost', j, !1),
				t.addEventListener('webglcontextrestored', Me, !1),
				t.addEventListener('webglcontextcreationerror', J, !1),
				H === null)
			) {
				const R = 'webgl2';
				if (((H = Ne(R, b)), H === null))
					throw Ne(R)
						? new Error('Error creating WebGL context with your selected attributes.')
						: new Error('Error creating WebGL context.');
			}
		} catch (b) {
			throw (console.error('THREE.WebGLRenderer: ' + b.message), b);
		}
		let oe, L, D, z, Y, K, re, O, T, V, G, ee, ne, _e, me, ye, De, ve, Le, Ye, Xe, Ie, Ve, it;
		function Qe() {
			(oe = new wO(H)),
				oe.init(),
				(Ie = new yE(H, oe)),
				(L = new gO(H, oe, e, Ie)),
				(D = new eN(H)),
				(z = new EO(H)),
				(Y = new HU()),
				(K = new tN(H, oe, D, Y, L, Ie, z)),
				(re = new _O(_)),
				(O = new bO(_)),
				(T = new II(H)),
				(Ve = new fO(H, T)),
				(V = new SO(H, T, z, Ve)),
				(G = new AO(H, V, T, z)),
				(Le = new TO(H, L, K)),
				(ye = new vO(Y)),
				(ee = new VU(_, re, O, oe, L, Ve, ye)),
				(ne = new lN(_, Y)),
				(_e = new WU()),
				(me = new $U(oe)),
				(ve = new pO(_, re, O, D, G, d, l)),
				(De = new QU(_, G, L)),
				(it = new cN(H, z, L, D)),
				(Ye = new mO(H, oe, z)),
				(Xe = new MO(H, oe, z)),
				(z.programs = ee.programs),
				(_.capabilities = L),
				(_.extensions = oe),
				(_.properties = Y),
				(_.renderLists = _e),
				(_.shadowMap = De),
				(_.state = D),
				(_.info = z);
		}
		Qe();
		const Be = new oN(_, H);
		(this.xr = Be),
			(this.getContext = function () {
				return H;
			}),
			(this.getContextAttributes = function () {
				return H.getContextAttributes();
			}),
			(this.forceContextLoss = function () {
				const b = oe.get('WEBGL_lose_context');
				b && b.loseContext();
			}),
			(this.forceContextRestore = function () {
				const b = oe.get('WEBGL_lose_context');
				b && b.restoreContext();
			}),
			(this.getPixelRatio = function () {
				return le;
			}),
			(this.setPixelRatio = function (b) {
				b !== void 0 && ((le = b), this.setSize(Q, $, !1));
			}),
			(this.getSize = function (b) {
				return b.set(Q, $);
			}),
			(this.setSize = function (b, R, U = !0) {
				if (Be.isPresenting) {
					console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
					return;
				}
				(Q = b),
					($ = R),
					(t.width = Math.floor(b * le)),
					(t.height = Math.floor(R * le)),
					U === !0 && ((t.style.width = b + 'px'), (t.style.height = R + 'px')),
					this.setViewport(0, 0, b, R);
			}),
			(this.getDrawingBufferSize = function (b) {
				return b.set(Q * le, $ * le).floor();
			}),
			(this.setDrawingBufferSize = function (b, R, U) {
				(Q = b), ($ = R), (le = U), (t.width = Math.floor(b * U)), (t.height = Math.floor(R * U)), this.setViewport(0, 0, b, R);
			}),
			(this.getCurrentViewport = function (b) {
				return b.copy(M);
			}),
			(this.getViewport = function (b) {
				return b.copy(ue);
			}),
			(this.setViewport = function (b, R, U, N) {
				b.isVector4 ? ue.set(b.x, b.y, b.z, b.w) : ue.set(b, R, U, N), D.viewport(M.copy(ue).multiplyScalar(le).round());
			}),
			(this.getScissor = function (b) {
				return b.copy(Te);
			}),
			(this.setScissor = function (b, R, U, N) {
				b.isVector4 ? Te.set(b.x, b.y, b.z, b.w) : Te.set(b, R, U, N), D.scissor(k.copy(Te).multiplyScalar(le).round());
			}),
			(this.getScissorTest = function () {
				return Ae;
			}),
			(this.setScissorTest = function (b) {
				D.setScissorTest((Ae = b));
			}),
			(this.setOpaqueSort = function (b) {
				Z = b;
			}),
			(this.setTransparentSort = function (b) {
				xe = b;
			}),
			(this.getClearColor = function (b) {
				return b.copy(ve.getClearColor());
			}),
			(this.setClearColor = function () {
				ve.setClearColor.apply(ve, arguments);
			}),
			(this.getClearAlpha = function () {
				return ve.getClearAlpha();
			}),
			(this.setClearAlpha = function () {
				ve.setClearAlpha.apply(ve, arguments);
			}),
			(this.clear = function (b = !0, R = !0, U = !0) {
				let N = 0;
				if (b) {
					let F = !1;
					if (C !== null) {
						const te = C.texture.format;
						F = te === b_ || te === x_ || te === y_;
					}
					if (F) {
						const te = C.texture.type,
							ie = te === Vn || te === yo || te === m_ || te === Ba || te === v_ || te === __,
							ae = ve.getClearColor(),
							he = ve.getClearAlpha(),
							fe = ae.r,
							pe = ae.g,
							ke = ae.b;
						ie
							? ((p[0] = fe), (p[1] = pe), (p[2] = ke), (p[3] = he), H.clearBufferuiv(H.COLOR, 0, p))
							: ((g[0] = fe), (g[1] = pe), (g[2] = ke), (g[3] = he), H.clearBufferiv(H.COLOR, 0, g));
					} else N |= H.COLOR_BUFFER_BIT;
				}
				R && (N |= H.DEPTH_BUFFER_BIT),
					U && ((N |= H.STENCIL_BUFFER_BIT), this.state.buffers.stencil.setMask(4294967295)),
					H.clear(N);
			}),
			(this.clearColor = function () {
				this.clear(!0, !1, !1);
			}),
			(this.clearDepth = function () {
				this.clear(!1, !0, !1);
			}),
			(this.clearStencil = function () {
				this.clear(!1, !1, !0);
			}),
			(this.dispose = function () {
				t.removeEventListener('webglcontextlost', j, !1),
					t.removeEventListener('webglcontextrestored', Me, !1),
					t.removeEventListener('webglcontextcreationerror', J, !1),
					_e.dispose(),
					me.dispose(),
					Y.dispose(),
					re.dispose(),
					O.dispose(),
					G.dispose(),
					Ve.dispose(),
					it.dispose(),
					ee.dispose(),
					Be.dispose(),
					Be.removeEventListener('sessionstart', Ct),
					Be.removeEventListener('sessionend', Xi),
					Nn.stop();
			});
		function j(b) {
			b.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (x = !0);
		}
		function Me() {
			console.log('THREE.WebGLRenderer: Context Restored.'), (x = !1);
			const b = z.autoReset,
				R = De.enabled,
				U = De.autoUpdate,
				N = De.needsUpdate,
				F = De.type;
			Qe(), (z.autoReset = b), (De.enabled = R), (De.autoUpdate = U), (De.needsUpdate = N), (De.type = F);
		}
		function J(b) {
			console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', b.statusMessage);
		}
		function Ce(b) {
			const R = b.target;
			R.removeEventListener('dispose', Ce), Fe(R);
		}
		function Fe(b) {
			gt(b), Y.remove(b);
		}
		function gt(b) {
			const R = Y.get(b).programs;
			R !== void 0 &&
				(R.forEach(function (U) {
					ee.releaseProgram(U);
				}),
				b.isShaderMaterial && ee.releaseShaderCache(b));
		}
		this.renderBufferDirect = function (b, R, U, N, F, te) {
			R === null && (R = ge);
			const ie = F.isMesh && F.matrixWorld.determinant() < 0,
				ae = wu(b, R, U, N, F);
			D.setMaterial(N, ie);
			let he = U.index,
				fe = 1;
			if (N.wireframe === !0) {
				if (((he = V.getWireframeAttribute(U)), he === void 0)) return;
				fe = 2;
			}
			const pe = U.drawRange,
				ke = U.attributes.position;
			let Re = pe.start * fe,
				Oe = (pe.start + pe.count) * fe;
			te !== null && ((Re = Math.max(Re, te.start * fe)), (Oe = Math.min(Oe, (te.start + te.count) * fe))),
				he !== null
					? ((Re = Math.max(Re, 0)), (Oe = Math.min(Oe, he.count)))
					: ke != null && ((Re = Math.max(Re, 0)), (Oe = Math.min(Oe, ke.count)));
			const qe = Oe - Re;
			if (qe < 0 || qe === 1 / 0) return;
			Ve.setup(F, N, ae, U, he);
			let je,
				Ge = Ye;
			if ((he !== null && ((je = T.get(he)), (Ge = Xe), Ge.setIndex(je)), F.isMesh))
				N.wireframe === !0 ? (D.setLineWidth(N.wireframeLinewidth * be()), Ge.setMode(H.LINES)) : Ge.setMode(H.TRIANGLES);
			else if (F.isLine) {
				let Ue = N.linewidth;
				Ue === void 0 && (Ue = 1),
					D.setLineWidth(Ue * be()),
					F.isLineSegments ? Ge.setMode(H.LINES) : F.isLineLoop ? Ge.setMode(H.LINE_LOOP) : Ge.setMode(H.LINE_STRIP);
			} else F.isPoints ? Ge.setMode(H.POINTS) : F.isSprite && Ge.setMode(H.TRIANGLES);
			if (F.isBatchedMesh)
				F._multiDrawInstances !== null
					? Ge.renderMultiDrawInstances(F._multiDrawStarts, F._multiDrawCounts, F._multiDrawCount, F._multiDrawInstances)
					: Ge.renderMultiDraw(F._multiDrawStarts, F._multiDrawCounts, F._multiDrawCount);
			else if (F.isInstancedMesh) Ge.renderInstances(Re, qe, F.count);
			else if (U.isInstancedBufferGeometry) {
				const Ue = U._maxInstanceCount !== void 0 ? U._maxInstanceCount : 1 / 0,
					Yt = Math.min(U.instanceCount, Ue);
				Ge.renderInstances(Re, qe, Yt);
			} else Ge.render(Re, qe);
		};
		function Bt(b, R, U) {
			b.transparent === !0 && b.side === mn && b.forceSinglePass === !1
				? ((b.side = gn), (b.needsUpdate = !0), Rs(b, R, U), (b.side = Ms), (b.needsUpdate = !0), Rs(b, R, U), (b.side = mn))
				: Rs(b, R, U);
		}
		(this.compile = function (b, R, U = null) {
			U === null && (U = b),
				(m = me.get(U)),
				m.init(R),
				y.push(m),
				U.traverseVisible(function (F) {
					F.isLight && F.layers.test(R.layers) && (m.pushLight(F), F.castShadow && m.pushShadow(F));
				}),
				b !== U &&
					b.traverseVisible(function (F) {
						F.isLight && F.layers.test(R.layers) && (m.pushLight(F), F.castShadow && m.pushShadow(F));
					}),
				m.setupLights(_._useLegacyLights);
			const N = new Set();
			return (
				b.traverse(function (F) {
					const te = F.material;
					if (te)
						if (Array.isArray(te))
							for (let ie = 0; ie < te.length; ie++) {
								const ae = te[ie];
								Bt(ae, U, F), N.add(ae);
							}
						else Bt(te, U, F), N.add(te);
				}),
				y.pop(),
				(m = null),
				N
			);
		}),
			(this.compileAsync = function (b, R, U = null) {
				const N = this.compile(b, R, U);
				return new Promise((F) => {
					function te() {
						if (
							(N.forEach(function (ie) {
								Y.get(ie).currentProgram.isReady() && N.delete(ie);
							}),
							N.size === 0)
						) {
							F(b);
							return;
						}
						setTimeout(te, 10);
					}
					oe.get('KHR_parallel_shader_compile') !== null ? te() : setTimeout(te, 10);
				});
			});
		let Kt = null;
		function Pn(b) {
			Kt && Kt(b);
		}
		function Ct() {
			Nn.stop();
		}
		function Xi() {
			Nn.start();
		}
		const Nn = new pE();
		Nn.setAnimationLoop(Pn),
			typeof self < 'u' && Nn.setContext(self),
			(this.setAnimationLoop = function (b) {
				(Kt = b), Be.setAnimationLoop(b), b === null ? Nn.stop() : Nn.start();
			}),
			Be.addEventListener('sessionstart', Ct),
			Be.addEventListener('sessionend', Xi),
			(this.render = function (b, R) {
				if (R !== void 0 && R.isCamera !== !0) {
					console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
					return;
				}
				if (x === !0) return;
				b.matrixWorldAutoUpdate === !0 && b.updateMatrixWorld(),
					R.parent === null && R.matrixWorldAutoUpdate === !0 && R.updateMatrixWorld(),
					Be.enabled === !0 && Be.isPresenting === !0 && (Be.cameraAutoUpdate === !0 && Be.updateCamera(R), (R = Be.getCamera())),
					b.isScene === !0 && b.onBeforeRender(_, b, R, C),
					(m = me.get(b, y.length)),
					m.init(R),
					y.push(m),
					we.multiplyMatrices(R.projectionMatrix, R.matrixWorldInverse),
					We.setFromProjectionMatrix(we),
					(Se = this.localClippingEnabled),
					(se = ye.init(this.clippingPlanes, Se)),
					(v = _e.get(b, f.length)),
					v.init(),
					f.push(v),
					_u(b, R, 0, _.sortObjects),
					v.finish(),
					_.sortObjects === !0 && v.sort(Z, xe);
				const U = Be.enabled === !1 || Be.isPresenting === !1 || Be.hasDepthSensing() === !1;
				U && ve.addToRenderList(v, b), this.info.render.frame++, se === !0 && ye.beginShadows();
				const N = m.state.shadowsArray;
				De.render(N, b, R), se === !0 && ye.endShadows(), this.info.autoReset === !0 && this.info.reset();
				const F = v.opaque,
					te = v.transmissive;
				if ((m.setupLights(_._useLegacyLights), R.isArrayCamera)) {
					const ie = R.cameras;
					if (te.length > 0)
						for (let ae = 0, he = ie.length; ae < he; ae++) {
							const fe = ie[ae];
							xu(F, te, b, fe);
						}
					U && ve.render(b);
					for (let ae = 0, he = ie.length; ae < he; ae++) {
						const fe = ie[ae];
						yu(v, b, fe, fe.viewport);
					}
				} else te.length > 0 && xu(F, te, b, R), U && ve.render(b), yu(v, b, R);
				C !== null && (K.updateMultisampleRenderTarget(C), K.updateRenderTargetMipmap(C)),
					b.isScene === !0 && b.onAfterRender(_, b, R),
					Ve.resetDefaultState(),
					(P = -1),
					(S = null),
					y.pop(),
					y.length > 0 ? ((m = y[y.length - 1]), se === !0 && ye.setGlobalState(_.clippingPlanes, m.state.camera)) : (m = null),
					f.pop(),
					f.length > 0 ? (v = f[f.length - 1]) : (v = null);
			});
		function _u(b, R, U, N) {
			if (b.visible === !1) return;
			if (b.layers.test(R.layers)) {
				if (b.isGroup) U = b.renderOrder;
				else if (b.isLOD) b.autoUpdate === !0 && b.update(R);
				else if (b.isLight) m.pushLight(b), b.castShadow && m.pushShadow(b);
				else if (b.isSprite) {
					if (!b.frustumCulled || We.intersectsSprite(b)) {
						N && X.setFromMatrixPosition(b.matrixWorld).applyMatrix4(we);
						const ie = G.update(b),
							ae = b.material;
						ae.visible && v.push(b, ie, ae, U, X.z, null);
					}
				} else if ((b.isMesh || b.isLine || b.isPoints) && (!b.frustumCulled || We.intersectsObject(b))) {
					const ie = G.update(b),
						ae = b.material;
					if (
						(N &&
							(b.boundingSphere !== void 0
								? (b.boundingSphere === null && b.computeBoundingSphere(), X.copy(b.boundingSphere.center))
								: (ie.boundingSphere === null && ie.computeBoundingSphere(), X.copy(ie.boundingSphere.center)),
							X.applyMatrix4(b.matrixWorld).applyMatrix4(we)),
						Array.isArray(ae))
					) {
						const he = ie.groups;
						for (let fe = 0, pe = he.length; fe < pe; fe++) {
							const ke = he[fe],
								Re = ae[ke.materialIndex];
							Re && Re.visible && v.push(b, ie, Re, U, X.z, ke);
						}
					} else ae.visible && v.push(b, ie, ae, U, X.z, null);
				}
			}
			const te = b.children;
			for (let ie = 0, ae = te.length; ie < ae; ie++) _u(te[ie], R, U, N);
		}
		function yu(b, R, U, N) {
			const F = b.opaque,
				te = b.transmissive,
				ie = b.transparent;
			m.setupLightsView(U),
				se === !0 && ye.setGlobalState(_.clippingPlanes, U),
				N && D.viewport(M.copy(N)),
				F.length > 0 && Js(F, R, U),
				te.length > 0 && Js(te, R, U),
				ie.length > 0 && Js(ie, R, U),
				D.buffers.depth.setTest(!0),
				D.buffers.depth.setMask(!0),
				D.buffers.color.setMask(!0),
				D.setPolygonOffset(!1);
		}
		function xu(b, R, U, N) {
			if ((U.isScene === !0 ? U.overrideMaterial : null) !== null) return;
			m.state.transmissionRenderTarget[N.id] === void 0 &&
				(m.state.transmissionRenderTarget[N.id] = new yn(1, 1, {
					generateMipmaps: !0,
					type: oe.has('EXT_color_buffer_half_float') || oe.has('EXT_color_buffer_float') ? fi : Vn,
					minFilter: ts,
					samples: 4,
					stencilBuffer: r,
					resolveDepthBuffer: !1,
					resolveStencilBuffer: !1,
				}));
			const te = m.state.transmissionRenderTarget[N.id],
				ie = N.viewport || M;
			te.setSize(ie.z, ie.w);
			const ae = _.getRenderTarget();
			_.setRenderTarget(te), _.getClearColor(B), (W = _.getClearAlpha()), W < 1 && _.setClearColor(16777215, 0.5), _.clear();
			const he = _.toneMapping;
			_.toneMapping = Xs;
			const fe = N.viewport;
			if (
				(N.viewport !== void 0 && (N.viewport = void 0),
				m.setupLightsView(N),
				se === !0 && ye.setGlobalState(_.clippingPlanes, N),
				Js(b, U, N),
				K.updateMultisampleRenderTarget(te),
				K.updateRenderTargetMipmap(te),
				oe.has('WEBGL_multisampled_render_to_texture') === !1)
			) {
				let pe = !1;
				for (let ke = 0, Re = R.length; ke < Re; ke++) {
					const Oe = R[ke],
						qe = Oe.object,
						je = Oe.geometry,
						Ge = Oe.material,
						Ue = Oe.group;
					if (Ge.side === mn && qe.layers.test(N.layers)) {
						const Yt = Ge.side;
						(Ge.side = gn), (Ge.needsUpdate = !0), bu(qe, U, N, je, Ge, Ue), (Ge.side = Yt), (Ge.needsUpdate = !0), (pe = !0);
					}
				}
				pe === !0 && (K.updateMultisampleRenderTarget(te), K.updateRenderTargetMipmap(te));
			}
			_.setRenderTarget(ae), _.setClearColor(B, W), fe !== void 0 && (N.viewport = fe), (_.toneMapping = he);
		}
		function Js(b, R, U) {
			const N = R.isScene === !0 ? R.overrideMaterial : null;
			for (let F = 0, te = b.length; F < te; F++) {
				const ie = b[F],
					ae = ie.object,
					he = ie.geometry,
					fe = N === null ? ie.material : N,
					pe = ie.group;
				ae.layers.test(U.layers) && bu(ae, R, U, he, fe, pe);
			}
		}
		function bu(b, R, U, N, F, te) {
			b.onBeforeRender(_, R, U, N, F, te),
				b.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, b.matrixWorld),
				b.normalMatrix.getNormalMatrix(b.modelViewMatrix),
				F.onBeforeRender(_, R, U, N, b, te),
				F.transparent === !0 && F.side === mn && F.forceSinglePass === !1
					? ((F.side = gn),
					  (F.needsUpdate = !0),
					  _.renderBufferDirect(U, R, N, F, b, te),
					  (F.side = Ms),
					  (F.needsUpdate = !0),
					  _.renderBufferDirect(U, R, N, F, b, te),
					  (F.side = mn))
					: _.renderBufferDirect(U, R, N, F, b, te),
				b.onAfterRender(_, R, U, N, F, te);
		}
		function Rs(b, R, U) {
			R.isScene !== !0 && (R = ge);
			const N = Y.get(b),
				F = m.state.lights,
				te = m.state.shadowsArray,
				ie = F.state.version,
				ae = ee.getParameters(b, F.state, te, R, U),
				he = ee.getProgramCacheKey(ae);
			let fe = N.programs;
			(N.environment = b.isMeshStandardMaterial ? R.environment : null),
				(N.fog = R.fog),
				(N.envMap = (b.isMeshStandardMaterial ? O : re).get(b.envMap || N.environment)),
				(N.envMapRotation = N.environment !== null && b.envMap === null ? R.environmentRotation : b.envMapRotation),
				fe === void 0 && (b.addEventListener('dispose', Ce), (fe = new Map()), (N.programs = fe));
			let pe = fe.get(he);
			if (pe !== void 0) {
				if (N.currentProgram === pe && N.lightsStateVersion === ie) return dt(b, ae), pe;
			} else
				(ae.uniforms = ee.getUniforms(b)),
					b.onBuild(U, ae, _),
					b.onBeforeCompile(ae, _),
					(pe = ee.acquireProgram(ae, he)),
					fe.set(he, pe),
					(N.uniforms = ae.uniforms);
			const ke = N.uniforms;
			return (
				((!b.isShaderMaterial && !b.isRawShaderMaterial) || b.clipping === !0) && (ke.clippingPlanes = ye.uniform),
				dt(b, ae),
				(N.needsLights = A(b)),
				(N.lightsStateVersion = ie),
				N.needsLights &&
					((ke.ambientLightColor.value = F.state.ambient),
					(ke.lightProbe.value = F.state.probe),
					(ke.directionalLights.value = F.state.directional),
					(ke.directionalLightShadows.value = F.state.directionalShadow),
					(ke.spotLights.value = F.state.spot),
					(ke.spotLightShadows.value = F.state.spotShadow),
					(ke.rectAreaLights.value = F.state.rectArea),
					(ke.ltc_1.value = F.state.rectAreaLTC1),
					(ke.ltc_2.value = F.state.rectAreaLTC2),
					(ke.pointLights.value = F.state.point),
					(ke.pointLightShadows.value = F.state.pointShadow),
					(ke.hemisphereLights.value = F.state.hemi),
					(ke.directionalShadowMap.value = F.state.directionalShadowMap),
					(ke.directionalShadowMatrix.value = F.state.directionalShadowMatrix),
					(ke.spotShadowMap.value = F.state.spotShadowMap),
					(ke.spotLightMatrix.value = F.state.spotLightMatrix),
					(ke.spotLightMap.value = F.state.spotLightMap),
					(ke.pointShadowMap.value = F.state.pointShadowMap),
					(ke.pointShadowMatrix.value = F.state.pointShadowMatrix)),
				(N.currentProgram = pe),
				(N.uniformsList = null),
				pe
			);
		}
		function Ar(b) {
			if (b.uniformsList === null) {
				const R = b.currentProgram.getUniforms();
				b.uniformsList = Vd.seqWithValue(R.seq, b.uniforms);
			}
			return b.uniformsList;
		}
		function dt(b, R) {
			const U = Y.get(b);
			(U.outputColorSpace = R.outputColorSpace),
				(U.batching = R.batching),
				(U.instancing = R.instancing),
				(U.instancingColor = R.instancingColor),
				(U.instancingMorph = R.instancingMorph),
				(U.skinning = R.skinning),
				(U.morphTargets = R.morphTargets),
				(U.morphNormals = R.morphNormals),
				(U.morphColors = R.morphColors),
				(U.morphTargetsCount = R.morphTargetsCount),
				(U.numClippingPlanes = R.numClippingPlanes),
				(U.numIntersection = R.numClipIntersection),
				(U.vertexAlphas = R.vertexAlphas),
				(U.vertexTangents = R.vertexTangents),
				(U.toneMapping = R.toneMapping);
		}
		function wu(b, R, U, N, F) {
			R.isScene !== !0 && (R = ge), K.resetTextureUnits();
			const te = R.fog,
				ie = N.isMeshStandardMaterial ? R.environment : null,
				ae = C === null ? _.outputColorSpace : C.isXRRenderTarget === !0 ? C.texture.colorSpace : Es,
				he = (N.isMeshStandardMaterial ? O : re).get(N.envMap || ie),
				fe = N.vertexColors === !0 && !!U.attributes.color && U.attributes.color.itemSize === 4,
				pe = !!U.attributes.tangent && (!!N.normalMap || N.anisotropy > 0),
				ke = !!U.morphAttributes.position,
				Re = !!U.morphAttributes.normal,
				Oe = !!U.morphAttributes.color;
			let qe = Xs;
			N.toneMapped && (C === null || C.isXRRenderTarget === !0) && (qe = _.toneMapping);
			const je = U.morphAttributes.position || U.morphAttributes.normal || U.morphAttributes.color,
				Ge = je !== void 0 ? je.length : 0,
				Ue = Y.get(N),
				Yt = m.state.lights;
			if (se === !0 && (Se === !0 || b !== S)) {
				const lt = b === S && N.id === P;
				ye.setState(N, b, lt);
			}
			let at = !1;
			N.version === Ue.__version
				? ((Ue.needsLights && Ue.lightsStateVersion !== Yt.state.version) ||
						Ue.outputColorSpace !== ae ||
						(F.isBatchedMesh && Ue.batching === !1) ||
						(!F.isBatchedMesh && Ue.batching === !0) ||
						(F.isInstancedMesh && Ue.instancing === !1) ||
						(!F.isInstancedMesh && Ue.instancing === !0) ||
						(F.isSkinnedMesh && Ue.skinning === !1) ||
						(!F.isSkinnedMesh && Ue.skinning === !0) ||
						(F.isInstancedMesh && Ue.instancingColor === !0 && F.instanceColor === null) ||
						(F.isInstancedMesh && Ue.instancingColor === !1 && F.instanceColor !== null) ||
						(F.isInstancedMesh && Ue.instancingMorph === !0 && F.morphTexture === null) ||
						(F.isInstancedMesh && Ue.instancingMorph === !1 && F.morphTexture !== null) ||
						Ue.envMap !== he ||
						(N.fog === !0 && Ue.fog !== te) ||
						(Ue.numClippingPlanes !== void 0 &&
							(Ue.numClippingPlanes !== ye.numPlanes || Ue.numIntersection !== ye.numIntersection)) ||
						Ue.vertexAlphas !== fe ||
						Ue.vertexTangents !== pe ||
						Ue.morphTargets !== ke ||
						Ue.morphNormals !== Re ||
						Ue.morphColors !== Oe ||
						Ue.toneMapping !== qe ||
						Ue.morphTargetsCount !== Ge) &&
				  (at = !0)
				: ((at = !0), (Ue.__version = N.version));
			let vt = Ue.currentProgram;
			at === !0 && (vt = Rs(N, R, F));
			let Ti = !1,
				Rt = !1,
				on = !1;
			const Vt = vt.getUniforms(),
				ci = Ue.uniforms;
			if ((D.useProgram(vt.program) && ((Ti = !0), (Rt = !0), (on = !0)), N.id !== P && ((P = N.id), (Rt = !0)), Ti || S !== b)) {
				Vt.setValue(H, 'projectionMatrix', b.projectionMatrix), Vt.setValue(H, 'viewMatrix', b.matrixWorldInverse);
				const lt = Vt.map.cameraPosition;
				lt !== void 0 && lt.setValue(H, X.setFromMatrixPosition(b.matrixWorld)),
					L.logarithmicDepthBuffer && Vt.setValue(H, 'logDepthBufFC', 2 / (Math.log(b.far + 1) / Math.LN2)),
					(N.isMeshPhongMaterial ||
						N.isMeshToonMaterial ||
						N.isMeshLambertMaterial ||
						N.isMeshBasicMaterial ||
						N.isMeshStandardMaterial ||
						N.isShaderMaterial) &&
						Vt.setValue(H, 'isOrthographic', b.isOrthographicCamera === !0),
					S !== b && ((S = b), (Rt = !0), (on = !0));
			}
			if (F.isSkinnedMesh) {
				Vt.setOptional(H, F, 'bindMatrix'), Vt.setOptional(H, F, 'bindMatrixInverse');
				const lt = F.skeleton;
				lt && (lt.boneTexture === null && lt.computeBoneTexture(), Vt.setValue(H, 'boneTexture', lt.boneTexture, K));
			}
			F.isBatchedMesh && (Vt.setOptional(H, F, 'batchingTexture'), Vt.setValue(H, 'batchingTexture', F._matricesTexture, K));
			const Hn = U.morphAttributes;
			if (
				((Hn.position !== void 0 || Hn.normal !== void 0 || Hn.color !== void 0) && Le.update(F, U, vt),
				(Rt || Ue.receiveShadow !== F.receiveShadow) &&
					((Ue.receiveShadow = F.receiveShadow), Vt.setValue(H, 'receiveShadow', F.receiveShadow)),
				N.isMeshGouraudMaterial &&
					N.envMap !== null &&
					((ci.envMap.value = he), (ci.flipEnvMap.value = he.isCubeTexture && he.isRenderTargetTexture === !1 ? -1 : 1)),
				N.isMeshStandardMaterial &&
					N.envMap === null &&
					R.environment !== null &&
					(ci.envMapIntensity.value = R.environmentIntensity),
				Rt &&
					(Vt.setValue(H, 'toneMappingExposure', _.toneMappingExposure),
					Ue.needsLights && Af(ci, on),
					te && N.fog === !0 && ne.refreshFogUniforms(ci, te),
					ne.refreshMaterialUniforms(ci, N, le, $, m.state.transmissionRenderTarget[b.id]),
					Vd.upload(H, Ar(Ue), ci, K)),
				N.isShaderMaterial && N.uniformsNeedUpdate === !0 && (Vd.upload(H, Ar(Ue), ci, K), (N.uniformsNeedUpdate = !1)),
				N.isSpriteMaterial && Vt.setValue(H, 'center', F.center),
				Vt.setValue(H, 'modelViewMatrix', F.modelViewMatrix),
				Vt.setValue(H, 'normalMatrix', F.normalMatrix),
				Vt.setValue(H, 'modelMatrix', F.matrixWorld),
				N.isShaderMaterial || N.isRawShaderMaterial)
			) {
				const lt = N.uniformsGroups;
				for (let bn = 0, Ht = lt.length; bn < Ht; bn++) {
					const St = lt[bn];
					it.update(St, vt), it.bind(St, vt);
				}
			}
			return vt;
		}
		function Af(b, R) {
			(b.ambientLightColor.needsUpdate = R),
				(b.lightProbe.needsUpdate = R),
				(b.directionalLights.needsUpdate = R),
				(b.directionalLightShadows.needsUpdate = R),
				(b.pointLights.needsUpdate = R),
				(b.pointLightShadows.needsUpdate = R),
				(b.spotLights.needsUpdate = R),
				(b.spotLightShadows.needsUpdate = R),
				(b.rectAreaLights.needsUpdate = R),
				(b.hemisphereLights.needsUpdate = R);
		}
		function A(b) {
			return (
				b.isMeshLambertMaterial ||
				b.isMeshToonMaterial ||
				b.isMeshPhongMaterial ||
				b.isMeshStandardMaterial ||
				b.isShadowMaterial ||
				(b.isShaderMaterial && b.lights === !0)
			);
		}
		(this.getActiveCubeFace = function () {
			return E;
		}),
			(this.getActiveMipmapLevel = function () {
				return w;
			}),
			(this.getRenderTarget = function () {
				return C;
			}),
			(this.setRenderTargetTextures = function (b, R, U) {
				(Y.get(b.texture).__webglTexture = R), (Y.get(b.depthTexture).__webglTexture = U);
				const N = Y.get(b);
				(N.__hasExternalTextures = !0),
					(N.__autoAllocateDepthBuffer = U === void 0),
					N.__autoAllocateDepthBuffer ||
						(oe.has('WEBGL_multisampled_render_to_texture') === !0 &&
							(console.warn(
								'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided'
							),
							(N.__useRenderToTexture = !1)));
			}),
			(this.setRenderTargetFramebuffer = function (b, R) {
				const U = Y.get(b);
				(U.__webglFramebuffer = R), (U.__useDefaultFramebuffer = R === void 0);
			}),
			(this.setRenderTarget = function (b, R = 0, U = 0) {
				(C = b), (E = R), (w = U);
				let N = !0,
					F = null,
					te = !1,
					ie = !1;
				if (b) {
					const he = Y.get(b);
					he.__useDefaultFramebuffer !== void 0
						? (D.bindFramebuffer(H.FRAMEBUFFER, null), (N = !1))
						: he.__webglFramebuffer === void 0
						? K.setupRenderTarget(b)
						: he.__hasExternalTextures &&
						  K.rebindTextures(b, Y.get(b.texture).__webglTexture, Y.get(b.depthTexture).__webglTexture);
					const fe = b.texture;
					(fe.isData3DTexture || fe.isDataArrayTexture || fe.isCompressedArrayTexture) && (ie = !0);
					const pe = Y.get(b).__webglFramebuffer;
					b.isWebGLCubeRenderTarget
						? (Array.isArray(pe[R]) ? (F = pe[R][U]) : (F = pe[R]), (te = !0))
						: b.samples > 0 && K.useMultisampledRTT(b) === !1
						? (F = Y.get(b).__webglMultisampledFramebuffer)
						: Array.isArray(pe)
						? (F = pe[U])
						: (F = pe),
						M.copy(b.viewport),
						k.copy(b.scissor),
						(q = b.scissorTest);
				} else M.copy(ue).multiplyScalar(le).floor(), k.copy(Te).multiplyScalar(le).floor(), (q = Ae);
				if (
					(D.bindFramebuffer(H.FRAMEBUFFER, F) && N && D.drawBuffers(b, F), D.viewport(M), D.scissor(k), D.setScissorTest(q), te)
				) {
					const he = Y.get(b.texture);
					H.framebufferTexture2D(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, H.TEXTURE_CUBE_MAP_POSITIVE_X + R, he.__webglTexture, U);
				} else if (ie) {
					const he = Y.get(b.texture),
						fe = R || 0;
					H.framebufferTextureLayer(H.FRAMEBUFFER, H.COLOR_ATTACHMENT0, he.__webglTexture, U || 0, fe);
				}
				P = -1;
			}),
			(this.readRenderTargetPixels = function (b, R, U, N, F, te, ie) {
				if (!(b && b.isWebGLRenderTarget)) {
					console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
					return;
				}
				let ae = Y.get(b).__webglFramebuffer;
				if ((b.isWebGLCubeRenderTarget && ie !== void 0 && (ae = ae[ie]), ae)) {
					D.bindFramebuffer(H.FRAMEBUFFER, ae);
					try {
						const he = b.texture,
							fe = he.format,
							pe = he.type;
						if (!L.textureFormatReadable(fe)) {
							console.error(
								'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
							);
							return;
						}
						if (!L.textureTypeReadable(pe)) {
							console.error(
								'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
							);
							return;
						}
						R >= 0 &&
							R <= b.width - N &&
							U >= 0 &&
							U <= b.height - F &&
							H.readPixels(R, U, N, F, Ie.convert(fe), Ie.convert(pe), te);
					} finally {
						const he = C !== null ? Y.get(C).__webglFramebuffer : null;
						D.bindFramebuffer(H.FRAMEBUFFER, he);
					}
				}
			}),
			(this.copyFramebufferToTexture = function (b, R, U = 0) {
				const N = Math.pow(2, -U),
					F = Math.floor(R.image.width * N),
					te = Math.floor(R.image.height * N);
				K.setTexture2D(R, 0), H.copyTexSubImage2D(H.TEXTURE_2D, U, 0, 0, b.x, b.y, F, te), D.unbindTexture();
			}),
			(this.copyTextureToTexture = function (b, R, U, N = 0) {
				const F = R.image.width,
					te = R.image.height,
					ie = Ie.convert(U.format),
					ae = Ie.convert(U.type);
				K.setTexture2D(U, 0),
					H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, U.flipY),
					H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
					H.pixelStorei(H.UNPACK_ALIGNMENT, U.unpackAlignment),
					R.isDataTexture
						? H.texSubImage2D(H.TEXTURE_2D, N, b.x, b.y, F, te, ie, ae, R.image.data)
						: R.isCompressedTexture
						? H.compressedTexSubImage2D(
								H.TEXTURE_2D,
								N,
								b.x,
								b.y,
								R.mipmaps[0].width,
								R.mipmaps[0].height,
								ie,
								R.mipmaps[0].data
						  )
						: H.texSubImage2D(H.TEXTURE_2D, N, b.x, b.y, ie, ae, R.image),
					N === 0 && U.generateMipmaps && H.generateMipmap(H.TEXTURE_2D),
					D.unbindTexture();
			}),
			(this.copyTextureToTexture3D = function (b, R, U, N, F = 0) {
				const te = b.max.x - b.min.x,
					ie = b.max.y - b.min.y,
					ae = b.max.z - b.min.z,
					he = Ie.convert(N.format),
					fe = Ie.convert(N.type);
				let pe;
				if (N.isData3DTexture) K.setTexture3D(N, 0), (pe = H.TEXTURE_3D);
				else if (N.isDataArrayTexture || N.isCompressedArrayTexture) K.setTexture2DArray(N, 0), (pe = H.TEXTURE_2D_ARRAY);
				else {
					console.warn(
						'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
					);
					return;
				}
				H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, N.flipY),
					H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
					H.pixelStorei(H.UNPACK_ALIGNMENT, N.unpackAlignment);
				const ke = H.getParameter(H.UNPACK_ROW_LENGTH),
					Re = H.getParameter(H.UNPACK_IMAGE_HEIGHT),
					Oe = H.getParameter(H.UNPACK_SKIP_PIXELS),
					qe = H.getParameter(H.UNPACK_SKIP_ROWS),
					je = H.getParameter(H.UNPACK_SKIP_IMAGES),
					Ge = U.isCompressedTexture ? U.mipmaps[F] : U.image;
				H.pixelStorei(H.UNPACK_ROW_LENGTH, Ge.width),
					H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Ge.height),
					H.pixelStorei(H.UNPACK_SKIP_PIXELS, b.min.x),
					H.pixelStorei(H.UNPACK_SKIP_ROWS, b.min.y),
					H.pixelStorei(H.UNPACK_SKIP_IMAGES, b.min.z),
					U.isDataTexture || U.isData3DTexture
						? H.texSubImage3D(pe, F, R.x, R.y, R.z, te, ie, ae, he, fe, Ge.data)
						: N.isCompressedArrayTexture
						? H.compressedTexSubImage3D(pe, F, R.x, R.y, R.z, te, ie, ae, he, Ge.data)
						: H.texSubImage3D(pe, F, R.x, R.y, R.z, te, ie, ae, he, fe, Ge),
					H.pixelStorei(H.UNPACK_ROW_LENGTH, ke),
					H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Re),
					H.pixelStorei(H.UNPACK_SKIP_PIXELS, Oe),
					H.pixelStorei(H.UNPACK_SKIP_ROWS, qe),
					H.pixelStorei(H.UNPACK_SKIP_IMAGES, je),
					F === 0 && N.generateMipmaps && H.generateMipmap(pe),
					D.unbindTexture();
			}),
			(this.initTexture = function (b) {
				b.isCubeTexture
					? K.setTextureCube(b, 0)
					: b.isData3DTexture
					? K.setTexture3D(b, 0)
					: b.isDataArrayTexture || b.isCompressedArrayTexture
					? K.setTexture2DArray(b, 0)
					: K.setTexture2D(b, 0),
					D.unbindTexture();
			}),
			(this.resetState = function () {
				(E = 0), (w = 0), (C = null), D.reset(), Ve.reset();
			}),
			typeof __THREE_DEVTOOLS__ < 'u' && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
	}
	get coordinateSystem() {
		return Vs;
	}
	get outputColorSpace() {
		return this._outputColorSpace;
	}
	set outputColorSpace(e) {
		this._outputColorSpace = e;
		const t = this.getContext();
		(t.drawingBufferColorSpace = e === Vp ? 'display-p3' : 'srgb'),
			(t.unpackColorSpace = Ft.workingColorSpace === $h ? 'display-p3' : 'srgb');
	}
	get useLegacyLights() {
		return (
			console.warn(
				'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.'
			),
			this._useLegacyLights
		);
	}
	set useLegacyLights(e) {
		console.warn(
			'THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.'
		),
			(this._useLegacyLights = e);
	}
}
class tu {
	constructor(e, t = 25e-5) {
		(this.isFogExp2 = !0), (this.name = ''), (this.color = new Ee(e)), (this.density = t);
	}
	clone() {
		return new tu(this.color, this.density);
	}
	toJSON() {
		return { type: 'FogExp2', name: this.name, color: this.color.getHex(), density: this.density };
	}
}
class Yp {
	constructor(e, t = 1, n = 1e3) {
		(this.isFog = !0), (this.name = ''), (this.color = new Ee(e)), (this.near = t), (this.far = n);
	}
	clone() {
		return new Yp(this.color, this.near, this.far);
	}
	toJSON() {
		return { type: 'Fog', name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
	}
}
class Ch extends ft {
	constructor() {
		super(),
			(this.isScene = !0),
			(this.type = 'Scene'),
			(this.background = null),
			(this.environment = null),
			(this.fog = null),
			(this.backgroundBlurriness = 0),
			(this.backgroundIntensity = 1),
			(this.backgroundRotation = new zi()),
			(this.environmentIntensity = 1),
			(this.environmentRotation = new zi()),
			(this.overrideMaterial = null),
			typeof __THREE_DEVTOOLS__ < 'u' && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', { detail: this }));
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			e.background !== null && (this.background = e.background.clone()),
			e.environment !== null && (this.environment = e.environment.clone()),
			e.fog !== null && (this.fog = e.fog.clone()),
			(this.backgroundBlurriness = e.backgroundBlurriness),
			(this.backgroundIntensity = e.backgroundIntensity),
			this.backgroundRotation.copy(e.backgroundRotation),
			(this.environmentIntensity = e.environmentIntensity),
			this.environmentRotation.copy(e.environmentRotation),
			e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
			(this.matrixAutoUpdate = e.matrixAutoUpdate),
			this
		);
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			this.fog !== null && (t.object.fog = this.fog.toJSON()),
			this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
			this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
			(t.object.backgroundRotation = this.backgroundRotation.toArray()),
			this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
			(t.object.environmentRotation = this.environmentRotation.toArray()),
			t
		);
	}
}
class nu {
	constructor(e, t) {
		(this.isInterleavedBuffer = !0),
			(this.array = e),
			(this.stride = t),
			(this.count = e !== void 0 ? e.length / t : 0),
			(this.usage = Mh),
			(this._updateRange = { offset: 0, count: -1 }),
			(this.updateRanges = []),
			(this.version = 0),
			(this.uuid = Bi());
	}
	onUploadCallback() {}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	get updateRange() {
		return (
			rE('THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.'),
			this._updateRange
		);
	}
	setUsage(e) {
		return (this.usage = e), this;
	}
	addUpdateRange(e, t) {
		this.updateRanges.push({ start: e, count: t });
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0;
	}
	copy(e) {
		return (
			(this.array = new e.array.constructor(e.array)), (this.count = e.count), (this.stride = e.stride), (this.usage = e.usage), this
		);
	}
	copyAt(e, t, n) {
		(e *= this.stride), (n *= t.stride);
		for (let s = 0, r = this.stride; s < r; s++) this.array[e + s] = t.array[n + s];
		return this;
	}
	set(e, t = 0) {
		return this.array.set(e, t), this;
	}
	clone(e) {
		e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
			this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Bi()),
			e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
		const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
			n = new this.constructor(t, this.stride);
		return n.setUsage(this.usage), n;
	}
	onUpload(e) {
		return (this.onUploadCallback = e), this;
	}
	toJSON(e) {
		return (
			e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
			this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Bi()),
			e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
				(e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
			{ uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride }
		);
	}
}
const ei = new I();
class xo {
	constructor(e, t, n, s = !1) {
		(this.isInterleavedBufferAttribute = !0),
			(this.name = ''),
			(this.data = e),
			(this.itemSize = t),
			(this.offset = n),
			(this.normalized = s);
	}
	get count() {
		return this.data.count;
	}
	get array() {
		return this.data.array;
	}
	set needsUpdate(e) {
		this.data.needsUpdate = e;
	}
	applyMatrix4(e) {
		for (let t = 0, n = this.data.count; t < n; t++)
			ei.fromBufferAttribute(this, t), ei.applyMatrix4(e), this.setXYZ(t, ei.x, ei.y, ei.z);
		return this;
	}
	applyNormalMatrix(e) {
		for (let t = 0, n = this.count; t < n; t++)
			ei.fromBufferAttribute(this, t), ei.applyNormalMatrix(e), this.setXYZ(t, ei.x, ei.y, ei.z);
		return this;
	}
	transformDirection(e) {
		for (let t = 0, n = this.count; t < n; t++)
			ei.fromBufferAttribute(this, t), ei.transformDirection(e), this.setXYZ(t, ei.x, ei.y, ei.z);
		return this;
	}
	getComponent(e, t) {
		let n = this.array[e * this.data.stride + this.offset + t];
		return this.normalized && (n = ri(n, this.array)), n;
	}
	setComponent(e, t, n) {
		return this.normalized && (n = tt(n, this.array)), (this.data.array[e * this.data.stride + this.offset + t] = n), this;
	}
	setX(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.data.array[e * this.data.stride + this.offset] = t), this;
	}
	setY(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 1] = t), this;
	}
	setZ(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 2] = t), this;
	}
	setW(e, t) {
		return this.normalized && (t = tt(t, this.array)), (this.data.array[e * this.data.stride + this.offset + 3] = t), this;
	}
	getX(e) {
		let t = this.data.array[e * this.data.stride + this.offset];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	getY(e) {
		let t = this.data.array[e * this.data.stride + this.offset + 1];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	getZ(e) {
		let t = this.data.array[e * this.data.stride + this.offset + 2];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	getW(e) {
		let t = this.data.array[e * this.data.stride + this.offset + 3];
		return this.normalized && (t = ri(t, this.array)), t;
	}
	setXY(e, t, n) {
		return (
			(e = e * this.data.stride + this.offset),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array))),
			(this.data.array[e + 0] = t),
			(this.data.array[e + 1] = n),
			this
		);
	}
	setXYZ(e, t, n, s) {
		return (
			(e = e * this.data.stride + this.offset),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array)), (s = tt(s, this.array))),
			(this.data.array[e + 0] = t),
			(this.data.array[e + 1] = n),
			(this.data.array[e + 2] = s),
			this
		);
	}
	setXYZW(e, t, n, s, r) {
		return (
			(e = e * this.data.stride + this.offset),
			this.normalized && ((t = tt(t, this.array)), (n = tt(n, this.array)), (s = tt(s, this.array)), (r = tt(r, this.array))),
			(this.data.array[e + 0] = t),
			(this.data.array[e + 1] = n),
			(this.data.array[e + 2] = s),
			(this.data.array[e + 3] = r),
			this
		);
	}
	clone(e) {
		if (e === void 0) {
			console.log(
				'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.'
			);
			const t = [];
			for (let n = 0; n < this.count; n++) {
				const s = n * this.data.stride + this.offset;
				for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r]);
			}
			return new $e(new this.array.constructor(t), this.itemSize, this.normalized);
		} else
			return (
				e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
				e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
				new xo(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
			);
	}
	toJSON(e) {
		if (e === void 0) {
			console.log(
				'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.'
			);
			const t = [];
			for (let n = 0; n < this.count; n++) {
				const s = n * this.data.stride + this.offset;
				for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r]);
			}
			return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
		} else
			return (
				e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
				e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
				{
					isInterleavedBufferAttribute: !0,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized,
				}
			);
	}
}
class L_ extends vn {
	constructor(e) {
		super(),
			(this.isSpriteMaterial = !0),
			(this.type = 'SpriteMaterial'),
			(this.color = new Ee(16777215)),
			(this.map = null),
			(this.alphaMap = null),
			(this.rotation = 0),
			(this.sizeAttenuation = !0),
			(this.transparent = !0),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.rotation = e.rotation),
			(this.sizeAttenuation = e.sizeAttenuation),
			(this.fog = e.fog),
			this
		);
	}
}
let ul;
const Sc = new I(),
	dl = new I(),
	pl = new I(),
	fl = new ce(),
	Mc = new ce(),
	wE = new He(),
	$u = new I(),
	Ec = new I(),
	Zu = new I(),
	Ix = new ce(),
	hm = new ce(),
	Dx = new ce();
class SE extends ft {
	constructor(e = new L_()) {
		if ((super(), (this.isSprite = !0), (this.type = 'Sprite'), ul === void 0)) {
			ul = new Ze();
			const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
				n = new nu(t, 5);
			ul.setIndex([0, 1, 2, 0, 2, 3]), ul.setAttribute('position', new xo(n, 3, 0, !1)), ul.setAttribute('uv', new xo(n, 2, 3, !1));
		}
		(this.geometry = ul), (this.material = e), (this.center = new ce(0.5, 0.5));
	}
	raycast(e, t) {
		e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
			dl.setFromMatrixScale(this.matrixWorld),
			wE.copy(e.camera.matrixWorld),
			this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
			pl.setFromMatrixPosition(this.modelViewMatrix),
			e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && dl.multiplyScalar(-pl.z);
		const n = this.material.rotation;
		let s, r;
		n !== 0 && ((r = Math.cos(n)), (s = Math.sin(n)));
		const o = this.center;
		Ju($u.set(-0.5, -0.5, 0), pl, o, dl, s, r),
			Ju(Ec.set(0.5, -0.5, 0), pl, o, dl, s, r),
			Ju(Zu.set(0.5, 0.5, 0), pl, o, dl, s, r),
			Ix.set(0, 0),
			hm.set(1, 0),
			Dx.set(1, 1);
		let a = e.ray.intersectTriangle($u, Ec, Zu, !1, Sc);
		if (
			a === null &&
			(Ju(Ec.set(-0.5, 0.5, 0), pl, o, dl, s, r), hm.set(0, 1), (a = e.ray.intersectTriangle($u, Zu, Ec, !1, Sc)), a === null)
		)
			return;
		const l = e.ray.origin.distanceTo(Sc);
		l < e.near ||
			l > e.far ||
			t.push({
				distance: l,
				point: Sc.clone(),
				uv: Li.getInterpolation(Sc, $u, Ec, Zu, Ix, hm, Dx, new ce()),
				face: null,
				object: this,
			});
	}
	copy(e, t) {
		return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), (this.material = e.material), this;
	}
}
function Ju(i, e, t, n, s, r) {
	fl.subVectors(i, t).addScalar(0.5).multiply(n),
		s !== void 0 ? ((Mc.x = r * fl.x - s * fl.y), (Mc.y = s * fl.x + r * fl.y)) : Mc.copy(fl),
		i.copy(e),
		(i.x += Mc.x),
		(i.y += Mc.y),
		i.applyMatrix4(wE);
}
const Qu = new I(),
	Ox = new I();
class ME extends ft {
	constructor() {
		super(),
			(this._currentLevel = 0),
			(this.type = 'LOD'),
			Object.defineProperties(this, { levels: { enumerable: !0, value: [] }, isLOD: { value: !0 } }),
			(this.autoUpdate = !0);
	}
	copy(e) {
		super.copy(e, !1);
		const t = e.levels;
		for (let n = 0, s = t.length; n < s; n++) {
			const r = t[n];
			this.addLevel(r.object.clone(), r.distance, r.hysteresis);
		}
		return (this.autoUpdate = e.autoUpdate), this;
	}
	addLevel(e, t = 0, n = 0) {
		t = Math.abs(t);
		const s = this.levels;
		let r;
		for (r = 0; r < s.length && !(t < s[r].distance); r++);
		return s.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
	}
	getCurrentLevel() {
		return this._currentLevel;
	}
	getObjectForDistance(e) {
		const t = this.levels;
		if (t.length > 0) {
			let n, s;
			for (n = 1, s = t.length; n < s; n++) {
				let r = t[n].distance;
				if ((t[n].object.visible && (r -= r * t[n].hysteresis), e < r)) break;
			}
			return t[n - 1].object;
		}
		return null;
	}
	raycast(e, t) {
		if (this.levels.length > 0) {
			Qu.setFromMatrixPosition(this.matrixWorld);
			const s = e.ray.origin.distanceTo(Qu);
			this.getObjectForDistance(s).raycast(e, t);
		}
	}
	update(e) {
		const t = this.levels;
		if (t.length > 1) {
			Qu.setFromMatrixPosition(e.matrixWorld), Ox.setFromMatrixPosition(this.matrixWorld);
			const n = Qu.distanceTo(Ox) / e.zoom;
			t[0].object.visible = !0;
			let s, r;
			for (s = 1, r = t.length; s < r; s++) {
				let o = t[s].distance;
				if ((t[s].object.visible && (o -= o * t[s].hysteresis), n >= o)) (t[s - 1].object.visible = !1), (t[s].object.visible = !0);
				else break;
			}
			for (this._currentLevel = s - 1; s < r; s++) t[s].object.visible = !1;
		}
	}
	toJSON(e) {
		const t = super.toJSON(e);
		this.autoUpdate === !1 && (t.object.autoUpdate = !1), (t.object.levels = []);
		const n = this.levels;
		for (let s = 0, r = n.length; s < r; s++) {
			const o = n[s];
			t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis });
		}
		return t;
	}
}
const Ux = new I(),
	Nx = new Pt(),
	Fx = new Pt(),
	hN = new I(),
	Bx = new He(),
	ed = new I(),
	um = new un(),
	kx = new He(),
	dm = new ka();
class I_ extends bt {
	constructor(e, t) {
		super(e, t),
			(this.isSkinnedMesh = !0),
			(this.type = 'SkinnedMesh'),
			(this.bindMode = Cg),
			(this.bindMatrix = new He()),
			(this.bindMatrixInverse = new He()),
			(this.boundingBox = null),
			(this.boundingSphere = null);
	}
	computeBoundingBox() {
		const e = this.geometry;
		this.boundingBox === null && (this.boundingBox = new An()), this.boundingBox.makeEmpty();
		const t = e.getAttribute('position');
		for (let n = 0; n < t.count; n++) this.getVertexPosition(n, ed), this.boundingBox.expandByPoint(ed);
	}
	computeBoundingSphere() {
		const e = this.geometry;
		this.boundingSphere === null && (this.boundingSphere = new un()), this.boundingSphere.makeEmpty();
		const t = e.getAttribute('position');
		for (let n = 0; n < t.count; n++) this.getVertexPosition(n, ed), this.boundingSphere.expandByPoint(ed);
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.bindMode = e.bindMode),
			this.bindMatrix.copy(e.bindMatrix),
			this.bindMatrixInverse.copy(e.bindMatrixInverse),
			(this.skeleton = e.skeleton),
			e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
			e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
			this
		);
	}
	raycast(e, t) {
		const n = this.material,
			s = this.matrixWorld;
		n !== void 0 &&
			(this.boundingSphere === null && this.computeBoundingSphere(),
			um.copy(this.boundingSphere),
			um.applyMatrix4(s),
			e.ray.intersectsSphere(um) !== !1 &&
				(kx.copy(s).invert(),
				dm.copy(e.ray).applyMatrix4(kx),
				!(this.boundingBox !== null && dm.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, dm)));
	}
	getVertexPosition(e, t) {
		return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
	}
	bind(e, t) {
		(this.skeleton = e),
			t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (t = this.matrixWorld)),
			this.bindMatrix.copy(t),
			this.bindMatrixInverse.copy(t).invert();
	}
	pose() {
		this.skeleton.pose();
	}
	normalizeSkinWeights() {
		const e = new Pt(),
			t = this.geometry.attributes.skinWeight;
		for (let n = 0, s = t.count; n < s; n++) {
			e.fromBufferAttribute(t, n);
			const r = 1 / e.manhattanLength();
			r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
		}
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e),
			this.bindMode === Cg
				? this.bindMatrixInverse.copy(this.matrixWorld).invert()
				: this.bindMode === UM
				? this.bindMatrixInverse.copy(this.bindMatrix).invert()
				: console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
	}
	applyBoneTransform(e, t) {
		const n = this.skeleton,
			s = this.geometry;
		Nx.fromBufferAttribute(s.attributes.skinIndex, e),
			Fx.fromBufferAttribute(s.attributes.skinWeight, e),
			Ux.copy(t).applyMatrix4(this.bindMatrix),
			t.set(0, 0, 0);
		for (let r = 0; r < 4; r++) {
			const o = Fx.getComponent(r);
			if (o !== 0) {
				const a = Nx.getComponent(r);
				Bx.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(hN.copy(Ux).applyMatrix4(Bx), o);
			}
		}
		return t.applyMatrix4(this.bindMatrixInverse);
	}
}
class jp extends ft {
	constructor() {
		super(), (this.isBone = !0), (this.type = 'Bone');
	}
}
class ho extends zt {
	constructor(e = null, t = 1, n = 1, s, r, o, a, l, c = It, h = It, u, d) {
		super(null, o, a, l, c, h, s, r, u, d),
			(this.isDataTexture = !0),
			(this.image = { data: e, width: t, height: n }),
			(this.generateMipmaps = !1),
			(this.flipY = !1),
			(this.unpackAlignment = 1);
	}
}
const zx = new He(),
	uN = new He();
class iu {
	constructor(e = [], t = []) {
		(this.uuid = Bi()),
			(this.bones = e.slice(0)),
			(this.boneInverses = t),
			(this.boneMatrices = null),
			(this.boneTexture = null),
			this.init();
	}
	init() {
		const e = this.bones,
			t = this.boneInverses;
		if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0)) this.calculateInverses();
		else if (e.length !== t.length) {
			console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'), (this.boneInverses = []);
			for (let n = 0, s = this.bones.length; n < s; n++) this.boneInverses.push(new He());
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const n = new He();
			this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
		}
	}
	pose() {
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const n = this.bones[e];
			n && n.matrixWorld.copy(this.boneInverses[e]).invert();
		}
		for (let e = 0, t = this.bones.length; e < t; e++) {
			const n = this.bones[e];
			n &&
				(n.parent && n.parent.isBone
					? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld))
					: n.matrix.copy(n.matrixWorld),
				n.matrix.decompose(n.position, n.quaternion, n.scale));
		}
	}
	update() {
		const e = this.bones,
			t = this.boneInverses,
			n = this.boneMatrices,
			s = this.boneTexture;
		for (let r = 0, o = e.length; r < o; r++) {
			const a = e[r] ? e[r].matrixWorld : uN;
			zx.multiplyMatrices(a, t[r]), zx.toArray(n, r * 16);
		}
		s !== null && (s.needsUpdate = !0);
	}
	clone() {
		return new iu(this.bones, this.boneInverses);
	}
	computeBoneTexture() {
		let e = Math.sqrt(this.bones.length * 4);
		(e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
		const t = new Float32Array(e * e * 4);
		t.set(this.boneMatrices);
		const n = new ho(t, e, e, mi, On);
		return (n.needsUpdate = !0), (this.boneMatrices = t), (this.boneTexture = n), this;
	}
	getBoneByName(e) {
		for (let t = 0, n = this.bones.length; t < n; t++) {
			const s = this.bones[t];
			if (s.name === e) return s;
		}
	}
	dispose() {
		this.boneTexture !== null && (this.boneTexture.dispose(), (this.boneTexture = null));
	}
	fromJSON(e, t) {
		this.uuid = e.uuid;
		for (let n = 0, s = e.bones.length; n < s; n++) {
			const r = e.bones[n];
			let o = t[r];
			o === void 0 && (console.warn('THREE.Skeleton: No bone found with UUID:', r), (o = new jp())),
				this.bones.push(o),
				this.boneInverses.push(new He().fromArray(e.boneInverses[n]));
		}
		return this.init(), this;
	}
	toJSON() {
		const e = { metadata: { version: 4.6, type: 'Skeleton', generator: 'Skeleton.toJSON' }, bones: [], boneInverses: [] };
		e.uuid = this.uuid;
		const t = this.bones,
			n = this.boneInverses;
		for (let s = 0, r = t.length; s < r; s++) {
			const o = t[s];
			e.bones.push(o.uuid);
			const a = n[s];
			e.boneInverses.push(a.toArray());
		}
		return e;
	}
}
class Ca extends $e {
	constructor(e, t, n, s = 1) {
		super(e, t, n), (this.isInstancedBufferAttribute = !0), (this.meshPerAttribute = s);
	}
	copy(e) {
		return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.meshPerAttribute = this.meshPerAttribute), (e.isInstancedBufferAttribute = !0), e;
	}
}
const ml = new He(),
	Vx = new He(),
	td = [],
	Hx = new An(),
	dN = new He(),
	Tc = new bt(),
	Ac = new un();
class D_ extends bt {
	constructor(e, t, n) {
		super(e, t),
			(this.isInstancedMesh = !0),
			(this.instanceMatrix = new Ca(new Float32Array(n * 16), 16)),
			(this.instanceColor = null),
			(this.morphTexture = null),
			(this.count = n),
			(this.boundingBox = null),
			(this.boundingSphere = null);
		for (let s = 0; s < n; s++) this.setMatrixAt(s, dN);
	}
	computeBoundingBox() {
		const e = this.geometry,
			t = this.count;
		this.boundingBox === null && (this.boundingBox = new An()),
			e.boundingBox === null && e.computeBoundingBox(),
			this.boundingBox.makeEmpty();
		for (let n = 0; n < t; n++) this.getMatrixAt(n, ml), Hx.copy(e.boundingBox).applyMatrix4(ml), this.boundingBox.union(Hx);
	}
	computeBoundingSphere() {
		const e = this.geometry,
			t = this.count;
		this.boundingSphere === null && (this.boundingSphere = new un()),
			e.boundingSphere === null && e.computeBoundingSphere(),
			this.boundingSphere.makeEmpty();
		for (let n = 0; n < t; n++) this.getMatrixAt(n, ml), Ac.copy(e.boundingSphere).applyMatrix4(ml), this.boundingSphere.union(Ac);
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			this.instanceMatrix.copy(e.instanceMatrix),
			e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
			e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
			(this.count = e.count),
			e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
			e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
			this
		);
	}
	getColorAt(e, t) {
		t.fromArray(this.instanceColor.array, e * 3);
	}
	getMatrixAt(e, t) {
		t.fromArray(this.instanceMatrix.array, e * 16);
	}
	getMorphAt(e, t) {
		const n = t.morphTargetInfluences,
			s = this.morphTexture.source.data.data,
			r = n.length + 1,
			o = e * r + 1;
		for (let a = 0; a < n.length; a++) n[a] = s[o + a];
	}
	raycast(e, t) {
		const n = this.matrixWorld,
			s = this.count;
		if (
			((Tc.geometry = this.geometry),
			(Tc.material = this.material),
			Tc.material !== void 0 &&
				(this.boundingSphere === null && this.computeBoundingSphere(),
				Ac.copy(this.boundingSphere),
				Ac.applyMatrix4(n),
				e.ray.intersectsSphere(Ac) !== !1))
		)
			for (let r = 0; r < s; r++) {
				this.getMatrixAt(r, ml), Vx.multiplyMatrices(n, ml), (Tc.matrixWorld = Vx), Tc.raycast(e, td);
				for (let o = 0, a = td.length; o < a; o++) {
					const l = td[o];
					(l.instanceId = r), (l.object = this), t.push(l);
				}
				td.length = 0;
			}
	}
	setColorAt(e, t) {
		this.instanceColor === null && (this.instanceColor = new Ca(new Float32Array(this.instanceMatrix.count * 3), 3)),
			t.toArray(this.instanceColor.array, e * 3);
	}
	setMatrixAt(e, t) {
		t.toArray(this.instanceMatrix.array, e * 16);
	}
	setMorphAt(e, t) {
		const n = t.morphTargetInfluences,
			s = n.length + 1;
		this.morphTexture === null && (this.morphTexture = new ho(new Float32Array(s * this.count), s, this.count, Bp, On));
		const r = this.morphTexture.source.data.data;
		let o = 0;
		for (let c = 0; c < n.length; c++) o += n[c];
		const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
			l = s * e;
		(r[l] = a), r.set(n, l + 1);
	}
	updateMorphTargets() {}
	dispose() {
		return (
			this.dispatchEvent({ type: 'dispose' }),
			this.morphTexture !== null && (this.morphTexture.dispose(), (this.morphTexture = null)),
			this
		);
	}
}
function pN(i, e) {
	return i.z - e.z;
}
function fN(i, e) {
	return e.z - i.z;
}
class mN {
	constructor() {
		(this.index = 0), (this.pool = []), (this.list = []);
	}
	push(e, t) {
		const n = this.pool,
			s = this.list;
		this.index >= n.length && n.push({ start: -1, count: -1, z: -1 });
		const r = n[this.index];
		s.push(r), this.index++, (r.start = e.start), (r.count = e.count), (r.z = t);
	}
	reset() {
		(this.list.length = 0), (this.index = 0);
	}
}
const gl = 'batchId',
	Fr = new He(),
	Gx = new He(),
	gN = new He(),
	Wx = new He(),
	pm = new Qh(),
	nd = new An(),
	Ho = new un(),
	Cc = new I(),
	fm = new mN(),
	Xn = new bt(),
	id = [];
function vN(i, e, t = 0) {
	const n = e.itemSize;
	if (i.isInterleavedBufferAttribute || i.array.constructor !== e.array.constructor) {
		const s = i.count;
		for (let r = 0; r < s; r++) for (let o = 0; o < n; o++) e.setComponent(r + t, o, i.getComponent(r, o));
	} else e.array.set(i.array, t * n);
	e.needsUpdate = !0;
}
class EE extends bt {
	get maxGeometryCount() {
		return this._maxGeometryCount;
	}
	constructor(e, t, n = t * 2, s) {
		super(new Ze(), s),
			(this.isBatchedMesh = !0),
			(this.perObjectFrustumCulled = !0),
			(this.sortObjects = !0),
			(this.boundingBox = null),
			(this.boundingSphere = null),
			(this.customSort = null),
			(this._drawRanges = []),
			(this._reservedRanges = []),
			(this._visibility = []),
			(this._active = []),
			(this._bounds = []),
			(this._maxGeometryCount = e),
			(this._maxVertexCount = t),
			(this._maxIndexCount = n),
			(this._geometryInitialized = !1),
			(this._geometryCount = 0),
			(this._multiDrawCounts = new Int32Array(e)),
			(this._multiDrawStarts = new Int32Array(e)),
			(this._multiDrawCount = 0),
			(this._multiDrawInstances = null),
			(this._visibilityChanged = !0),
			(this._matricesTexture = null),
			this._initMatricesTexture();
	}
	_initMatricesTexture() {
		let e = Math.sqrt(this._maxGeometryCount * 4);
		(e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
		const t = new Float32Array(e * e * 4),
			n = new ho(t, e, e, mi, On);
		this._matricesTexture = n;
	}
	_initializeGeometry(e) {
		const t = this.geometry,
			n = this._maxVertexCount,
			s = this._maxGeometryCount,
			r = this._maxIndexCount;
		if (this._geometryInitialized === !1) {
			for (const a in e.attributes) {
				const l = e.getAttribute(a),
					{ array: c, itemSize: h, normalized: u } = l,
					d = new c.constructor(n * h),
					p = new $e(d, h, u);
				t.setAttribute(a, p);
			}
			if (e.getIndex() !== null) {
				const a = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
				t.setIndex(new $e(a, 1));
			}
			const o = s > 65536 ? new Uint32Array(n) : new Uint16Array(n);
			t.setAttribute(gl, new $e(o, 1)), (this._geometryInitialized = !0);
		}
	}
	_validateGeometry(e) {
		if (e.getAttribute(gl)) throw new Error('BatchedMesh: Geometry cannot use attribute "'.concat(gl, '"'));
		const t = this.geometry;
		if (!!e.getIndex() != !!t.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
		for (const n in t.attributes) {
			if (n === gl) continue;
			if (!e.hasAttribute(n))
				throw new Error('BatchedMesh: Added geometry missing "'.concat(n, '". All geometries must have consistent attributes.'));
			const s = e.getAttribute(n),
				r = t.getAttribute(n);
			if (s.itemSize !== r.itemSize || s.normalized !== r.normalized)
				throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.');
		}
	}
	setCustomSort(e) {
		return (this.customSort = e), this;
	}
	computeBoundingBox() {
		this.boundingBox === null && (this.boundingBox = new An());
		const e = this._geometryCount,
			t = this.boundingBox,
			n = this._active;
		t.makeEmpty();
		for (let s = 0; s < e; s++) n[s] !== !1 && (this.getMatrixAt(s, Fr), this.getBoundingBoxAt(s, nd).applyMatrix4(Fr), t.union(nd));
	}
	computeBoundingSphere() {
		this.boundingSphere === null && (this.boundingSphere = new un());
		const e = this._geometryCount,
			t = this.boundingSphere,
			n = this._active;
		t.makeEmpty();
		for (let s = 0; s < e; s++) n[s] !== !1 && (this.getMatrixAt(s, Fr), this.getBoundingSphereAt(s, Ho).applyMatrix4(Fr), t.union(Ho));
	}
	addGeometry(e, t = -1, n = -1) {
		if ((this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount))
			throw new Error('BatchedMesh: Maximum geometry count reached.');
		const s = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
		let r = null;
		const o = this._reservedRanges,
			a = this._drawRanges,
			l = this._bounds;
		this._geometryCount !== 0 && (r = o[o.length - 1]),
			t === -1 ? (s.vertexCount = e.getAttribute('position').count) : (s.vertexCount = t),
			r === null ? (s.vertexStart = 0) : (s.vertexStart = r.vertexStart + r.vertexCount);
		const c = e.getIndex(),
			h = c !== null;
		if (
			(h &&
				(n === -1 ? (s.indexCount = c.count) : (s.indexCount = n),
				r === null ? (s.indexStart = 0) : (s.indexStart = r.indexStart + r.indexCount)),
			(s.indexStart !== -1 && s.indexStart + s.indexCount > this._maxIndexCount) ||
				s.vertexStart + s.vertexCount > this._maxVertexCount)
		)
			throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.');
		const u = this._visibility,
			d = this._active,
			p = this._matricesTexture,
			g = this._matricesTexture.image.data;
		u.push(!0), d.push(!0);
		const v = this._geometryCount;
		this._geometryCount++,
			gN.toArray(g, v * 16),
			(p.needsUpdate = !0),
			o.push(s),
			a.push({ start: h ? s.indexStart : s.vertexStart, count: -1 }),
			l.push({ boxInitialized: !1, box: new An(), sphereInitialized: !1, sphere: new un() });
		const m = this.geometry.getAttribute(gl);
		for (let f = 0; f < s.vertexCount; f++) m.setX(s.vertexStart + f, v);
		return (m.needsUpdate = !0), this.setGeometryAt(v, e), v;
	}
	setGeometryAt(e, t) {
		if (e >= this._geometryCount) throw new Error('BatchedMesh: Maximum geometry count reached.');
		this._validateGeometry(t);
		const n = this.geometry,
			s = n.getIndex() !== null,
			r = n.getIndex(),
			o = t.getIndex(),
			a = this._reservedRanges[e];
		if ((s && o.count > a.indexCount) || t.attributes.position.count > a.vertexCount)
			throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.');
		const l = a.vertexStart,
			c = a.vertexCount;
		for (const p in n.attributes) {
			if (p === gl) continue;
			const g = t.getAttribute(p),
				v = n.getAttribute(p);
			vN(g, v, l);
			const m = g.itemSize;
			for (let f = g.count, y = c; f < y; f++) {
				const _ = l + f;
				for (let x = 0; x < m; x++) v.setComponent(_, x, 0);
			}
			(v.needsUpdate = !0), v.addUpdateRange(l * m, c * m);
		}
		if (s) {
			const p = a.indexStart;
			for (let g = 0; g < o.count; g++) r.setX(p + g, l + o.getX(g));
			for (let g = o.count, v = a.indexCount; g < v; g++) r.setX(p + g, l);
			(r.needsUpdate = !0), r.addUpdateRange(p, a.indexCount);
		}
		const h = this._bounds[e];
		t.boundingBox !== null ? (h.box.copy(t.boundingBox), (h.boxInitialized = !0)) : (h.boxInitialized = !1),
			t.boundingSphere !== null ? (h.sphere.copy(t.boundingSphere), (h.sphereInitialized = !0)) : (h.sphereInitialized = !1);
		const u = this._drawRanges[e],
			d = t.getAttribute('position');
		return (u.count = s ? o.count : d.count), (this._visibilityChanged = !0), e;
	}
	deleteGeometry(e) {
		const t = this._active;
		return e >= t.length || t[e] === !1 ? this : ((t[e] = !1), (this._visibilityChanged = !0), this);
	}
	getInstanceCountAt(e) {
		return this._multiDrawInstances === null ? null : this._multiDrawInstances[e];
	}
	setInstanceCountAt(e, t) {
		return (
			this._multiDrawInstances === null && (this._multiDrawInstances = new Int32Array(this._maxGeometryCount).fill(1)),
			(this._multiDrawInstances[e] = t),
			e
		);
	}
	getBoundingBoxAt(e, t) {
		if (this._active[e] === !1) return null;
		const s = this._bounds[e],
			r = s.box,
			o = this.geometry;
		if (s.boxInitialized === !1) {
			r.makeEmpty();
			const a = o.index,
				l = o.attributes.position,
				c = this._drawRanges[e];
			for (let h = c.start, u = c.start + c.count; h < u; h++) {
				let d = h;
				a && (d = a.getX(d)), r.expandByPoint(Cc.fromBufferAttribute(l, d));
			}
			s.boxInitialized = !0;
		}
		return t.copy(r), t;
	}
	getBoundingSphereAt(e, t) {
		if (this._active[e] === !1) return null;
		const s = this._bounds[e],
			r = s.sphere,
			o = this.geometry;
		if (s.sphereInitialized === !1) {
			r.makeEmpty(), this.getBoundingBoxAt(e, nd), nd.getCenter(r.center);
			const a = o.index,
				l = o.attributes.position,
				c = this._drawRanges[e];
			let h = 0;
			for (let u = c.start, d = c.start + c.count; u < d; u++) {
				let p = u;
				a && (p = a.getX(p)), Cc.fromBufferAttribute(l, p), (h = Math.max(h, r.center.distanceToSquared(Cc)));
			}
			(r.radius = Math.sqrt(h)), (s.sphereInitialized = !0);
		}
		return t.copy(r), t;
	}
	setMatrixAt(e, t) {
		const n = this._active,
			s = this._matricesTexture,
			r = this._matricesTexture.image.data,
			o = this._geometryCount;
		return e >= o || n[e] === !1 ? this : (t.toArray(r, e * 16), (s.needsUpdate = !0), this);
	}
	getMatrixAt(e, t) {
		const n = this._active,
			s = this._matricesTexture.image.data,
			r = this._geometryCount;
		return e >= r || n[e] === !1 ? null : t.fromArray(s, e * 16);
	}
	setVisibleAt(e, t) {
		const n = this._visibility,
			s = this._active,
			r = this._geometryCount;
		return e >= r || s[e] === !1 || n[e] === t ? this : ((n[e] = t), (this._visibilityChanged = !0), this);
	}
	getVisibleAt(e) {
		const t = this._visibility,
			n = this._active,
			s = this._geometryCount;
		return e >= s || n[e] === !1 ? !1 : t[e];
	}
	raycast(e, t) {
		const n = this._visibility,
			s = this._active,
			r = this._drawRanges,
			o = this._geometryCount,
			a = this.matrixWorld,
			l = this.geometry;
		(Xn.material = this.material),
			(Xn.geometry.index = l.index),
			(Xn.geometry.attributes = l.attributes),
			Xn.geometry.boundingBox === null && (Xn.geometry.boundingBox = new An()),
			Xn.geometry.boundingSphere === null && (Xn.geometry.boundingSphere = new un());
		for (let c = 0; c < o; c++) {
			if (!n[c] || !s[c]) continue;
			const h = r[c];
			Xn.geometry.setDrawRange(h.start, h.count),
				this.getMatrixAt(c, Xn.matrixWorld).premultiply(a),
				this.getBoundingBoxAt(c, Xn.geometry.boundingBox),
				this.getBoundingSphereAt(c, Xn.geometry.boundingSphere),
				Xn.raycast(e, id);
			for (let u = 0, d = id.length; u < d; u++) {
				const p = id[u];
				(p.object = this), (p.batchId = c), t.push(p);
			}
			id.length = 0;
		}
		(Xn.material = null), (Xn.geometry.index = null), (Xn.geometry.attributes = {}), Xn.geometry.setDrawRange(0, 1 / 0);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.geometry = e.geometry.clone()),
			(this.perObjectFrustumCulled = e.perObjectFrustumCulled),
			(this.sortObjects = e.sortObjects),
			(this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null),
			(this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null),
			(this._drawRanges = e._drawRanges.map((t) => ({ ...t }))),
			(this._reservedRanges = e._reservedRanges.map((t) => ({ ...t }))),
			(this._visibility = e._visibility.slice()),
			(this._active = e._active.slice()),
			(this._bounds = e._bounds.map((t) => ({
				boxInitialized: t.boxInitialized,
				box: t.box.clone(),
				sphereInitialized: t.sphereInitialized,
				sphere: t.sphere.clone(),
			}))),
			(this._maxGeometryCount = e._maxGeometryCount),
			(this._maxVertexCount = e._maxVertexCount),
			(this._maxIndexCount = e._maxIndexCount),
			(this._geometryInitialized = e._geometryInitialized),
			(this._geometryCount = e._geometryCount),
			(this._multiDrawCounts = e._multiDrawCounts.slice()),
			(this._multiDrawStarts = e._multiDrawStarts.slice()),
			(this._matricesTexture = e._matricesTexture.clone()),
			(this._matricesTexture.image.data = this._matricesTexture.image.slice()),
			this
		);
	}
	dispose() {
		return this.geometry.dispose(), this._matricesTexture.dispose(), (this._matricesTexture = null), this;
	}
	onBeforeRender(e, t, n, s, r) {
		if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
		const o = s.getIndex(),
			a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
			l = this._active,
			c = this._visibility,
			h = this._multiDrawStarts,
			u = this._multiDrawCounts,
			d = this._drawRanges,
			p = this.perObjectFrustumCulled;
		p &&
			(Wx.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld),
			pm.setFromProjectionMatrix(Wx, e.coordinateSystem));
		let g = 0;
		if (this.sortObjects) {
			Gx.copy(this.matrixWorld).invert(), Cc.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Gx);
			for (let f = 0, y = c.length; f < y; f++)
				if (c[f] && l[f]) {
					this.getMatrixAt(f, Fr), this.getBoundingSphereAt(f, Ho).applyMatrix4(Fr);
					let _ = !1;
					if ((p && (_ = !pm.intersectsSphere(Ho)), !_)) {
						const x = Cc.distanceTo(Ho.center);
						fm.push(d[f], x);
					}
				}
			const v = fm.list,
				m = this.customSort;
			m === null ? v.sort(r.transparent ? fN : pN) : m.call(this, v, n);
			for (let f = 0, y = v.length; f < y; f++) {
				const _ = v[f];
				(h[g] = _.start * a), (u[g] = _.count), g++;
			}
			fm.reset();
		} else
			for (let v = 0, m = c.length; v < m; v++)
				if (c[v] && l[v]) {
					let f = !1;
					if (
						(p && (this.getMatrixAt(v, Fr), this.getBoundingSphereAt(v, Ho).applyMatrix4(Fr), (f = !pm.intersectsSphere(Ho))),
						!f)
					) {
						const y = d[v];
						(h[g] = y.start * a), (u[g] = y.count), g++;
					}
				}
		(this._multiDrawCount = g), (this._visibilityChanged = !1);
	}
	onBeforeShadow(e, t, n, s, r, o) {
		this.onBeforeRender(e, null, s, r, o);
	}
}
class Jn extends vn {
	constructor(e) {
		super(),
			(this.isLineBasicMaterial = !0),
			(this.type = 'LineBasicMaterial'),
			(this.color = new Ee(16777215)),
			(this.map = null),
			(this.linewidth = 1),
			(this.linecap = 'round'),
			(this.linejoin = 'round'),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.linewidth = e.linewidth),
			(this.linecap = e.linecap),
			(this.linejoin = e.linejoin),
			(this.fog = e.fog),
			this
		);
	}
}
const np = new I(),
	ip = new I(),
	Xx = new He(),
	Rc = new ka(),
	sd = new un(),
	mm = new I(),
	qx = new I();
let xr = class extends ft {
	constructor(e = new Ze(), t = new Jn()) {
		super(), (this.isLine = !0), (this.type = 'Line'), (this.geometry = e), (this.material = t), this.updateMorphTargets();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
			(this.geometry = e.geometry),
			this
		);
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.index === null) {
			const t = e.attributes.position,
				n = [0];
			for (let s = 1, r = t.count; s < r; s++)
				np.fromBufferAttribute(t, s - 1), ip.fromBufferAttribute(t, s), (n[s] = n[s - 1]), (n[s] += np.distanceTo(ip));
			e.setAttribute('lineDistance', new ze(n, 1));
		} else console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
		return this;
	}
	raycast(e, t) {
		const n = this.geometry,
			s = this.matrixWorld,
			r = e.params.Line.threshold,
			o = n.drawRange;
		if (
			(n.boundingSphere === null && n.computeBoundingSphere(),
			sd.copy(n.boundingSphere),
			sd.applyMatrix4(s),
			(sd.radius += r),
			e.ray.intersectsSphere(sd) === !1)
		)
			return;
		Xx.copy(s).invert(), Rc.copy(e.ray).applyMatrix4(Xx);
		const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			l = a * a,
			c = this.isLineSegments ? 2 : 1,
			h = n.index,
			d = n.attributes.position;
		if (h !== null) {
			const p = Math.max(0, o.start),
				g = Math.min(h.count, o.start + o.count);
			for (let v = p, m = g - 1; v < m; v += c) {
				const f = h.getX(v),
					y = h.getX(v + 1),
					_ = rd(this, e, Rc, l, f, y);
				_ && t.push(_);
			}
			if (this.isLineLoop) {
				const v = h.getX(g - 1),
					m = h.getX(p),
					f = rd(this, e, Rc, l, v, m);
				f && t.push(f);
			}
		} else {
			const p = Math.max(0, o.start),
				g = Math.min(d.count, o.start + o.count);
			for (let v = p, m = g - 1; v < m; v += c) {
				const f = rd(this, e, Rc, l, v, v + 1);
				f && t.push(f);
			}
			if (this.isLineLoop) {
				const v = rd(this, e, Rc, l, g - 1, p);
				v && t.push(v);
			}
		}
	}
	updateMorphTargets() {
		const t = this.geometry.morphAttributes,
			n = Object.keys(t);
		if (n.length > 0) {
			const s = t[n[0]];
			if (s !== void 0) {
				(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
				for (let r = 0, o = s.length; r < o; r++) {
					const a = s[r].name || String(r);
					this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = r);
				}
			}
		}
	}
};
function rd(i, e, t, n, s, r) {
	const o = i.geometry.attributes.position;
	if ((np.fromBufferAttribute(o, s), ip.fromBufferAttribute(o, r), t.distanceSqToSegment(np, ip, mm, qx) > n)) return;
	mm.applyMatrix4(i.matrixWorld);
	const l = e.ray.origin.distanceTo(mm);
	if (!(l < e.near || l > e.far))
		return { distance: l, point: qx.clone().applyMatrix4(i.matrixWorld), index: s, face: null, faceIndex: null, object: i };
}
const Yx = new I(),
	jx = new I();
class as extends xr {
	constructor(e, t) {
		super(e, t), (this.isLineSegments = !0), (this.type = 'LineSegments');
	}
	computeLineDistances() {
		const e = this.geometry;
		if (e.index === null) {
			const t = e.attributes.position,
				n = [];
			for (let s = 0, r = t.count; s < r; s += 2)
				Yx.fromBufferAttribute(t, s),
					jx.fromBufferAttribute(t, s + 1),
					(n[s] = s === 0 ? 0 : n[s - 1]),
					(n[s + 1] = n[s] + Yx.distanceTo(jx));
			e.setAttribute('lineDistance', new ze(n, 1));
		} else console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
		return this;
	}
}
class O_ extends xr {
	constructor(e, t) {
		super(e, t), (this.isLineLoop = !0), (this.type = 'LineLoop');
	}
}
class Kp extends vn {
	constructor(e) {
		super(),
			(this.isPointsMaterial = !0),
			(this.type = 'PointsMaterial'),
			(this.color = new Ee(16777215)),
			(this.map = null),
			(this.alphaMap = null),
			(this.size = 1),
			(this.sizeAttenuation = !0),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.alphaMap = e.alphaMap),
			(this.size = e.size),
			(this.sizeAttenuation = e.sizeAttenuation),
			(this.fog = e.fog),
			this
		);
	}
}
const Kx = new He(),
	sv = new ka(),
	od = new un(),
	ad = new I();
class U_ extends ft {
	constructor(e = new Ze(), t = new Kp()) {
		super(), (this.isPoints = !0), (this.type = 'Points'), (this.geometry = e), (this.material = t), this.updateMorphTargets();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.material = Array.isArray(e.material) ? e.material.slice() : e.material),
			(this.geometry = e.geometry),
			this
		);
	}
	raycast(e, t) {
		const n = this.geometry,
			s = this.matrixWorld,
			r = e.params.Points.threshold,
			o = n.drawRange;
		if (
			(n.boundingSphere === null && n.computeBoundingSphere(),
			od.copy(n.boundingSphere),
			od.applyMatrix4(s),
			(od.radius += r),
			e.ray.intersectsSphere(od) === !1)
		)
			return;
		Kx.copy(s).invert(), sv.copy(e.ray).applyMatrix4(Kx);
		const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			l = a * a,
			c = n.index,
			u = n.attributes.position;
		if (c !== null) {
			const d = Math.max(0, o.start),
				p = Math.min(c.count, o.start + o.count);
			for (let g = d, v = p; g < v; g++) {
				const m = c.getX(g);
				ad.fromBufferAttribute(u, m), $x(ad, m, l, s, e, t, this);
			}
		} else {
			const d = Math.max(0, o.start),
				p = Math.min(u.count, o.start + o.count);
			for (let g = d, v = p; g < v; g++) ad.fromBufferAttribute(u, g), $x(ad, g, l, s, e, t, this);
		}
	}
	updateMorphTargets() {
		const t = this.geometry.morphAttributes,
			n = Object.keys(t);
		if (n.length > 0) {
			const s = t[n[0]];
			if (s !== void 0) {
				(this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
				for (let r = 0, o = s.length; r < o; r++) {
					const a = s[r].name || String(r);
					this.morphTargetInfluences.push(0), (this.morphTargetDictionary[a] = r);
				}
			}
		}
	}
}
function $x(i, e, t, n, s, r, o) {
	const a = sv.distanceSqToPoint(i);
	if (a < t) {
		const l = new I();
		sv.closestPointToPoint(i, l), l.applyMatrix4(n);
		const c = s.ray.origin.distanceTo(l);
		if (c < s.near || c > s.far) return;
		r.push({ distance: c, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: o });
	}
}
class TE extends zt {
	constructor(e, t, n, s, r, o, a, l, c) {
		super(e, t, n, s, r, o, a, l, c),
			(this.isVideoTexture = !0),
			(this.minFilter = o !== void 0 ? o : Tt),
			(this.magFilter = r !== void 0 ? r : Tt),
			(this.generateMipmaps = !1);
		const h = this;
		function u() {
			(h.needsUpdate = !0), e.requestVideoFrameCallback(u);
		}
		'requestVideoFrameCallback' in e && e.requestVideoFrameCallback(u);
	}
	clone() {
		return new this.constructor(this.image).copy(this);
	}
	update() {
		const e = this.image;
		'requestVideoFrameCallback' in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
	}
}
class _N extends zt {
	constructor(e, t) {
		super({ width: e, height: t }),
			(this.isFramebufferTexture = !0),
			(this.magFilter = It),
			(this.minFilter = It),
			(this.generateMipmaps = !1),
			(this.needsUpdate = !0);
	}
}
class $p extends zt {
	constructor(e, t, n, s, r, o, a, l, c, h, u, d) {
		super(null, o, a, l, c, h, s, r, u, d),
			(this.isCompressedTexture = !0),
			(this.image = { width: t, height: n }),
			(this.mipmaps = e),
			(this.flipY = !1),
			(this.generateMipmaps = !1);
	}
}
class yN extends $p {
	constructor(e, t, n, s, r, o) {
		super(e, t, n, r, o), (this.isCompressedArrayTexture = !0), (this.image.depth = s), (this.wrapR = Oi);
	}
}
class xN extends $p {
	constructor(e, t, n) {
		super(void 0, e[0].width, e[0].height, t, n, _r), (this.isCompressedCubeTexture = !0), (this.isCubeTexture = !0), (this.image = e);
	}
}
class N_ extends zt {
	constructor(e, t, n, s, r, o, a, l, c) {
		super(e, t, n, s, r, o, a, l, c), (this.isCanvasTexture = !0), (this.needsUpdate = !0);
	}
}
class Ts {
	constructor() {
		(this.type = 'Curve'), (this.arcLengthDivisions = 200);
	}
	getPoint() {
		return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
	}
	getPointAt(e, t) {
		const n = this.getUtoTmapping(e);
		return this.getPoint(n, t);
	}
	getPoints(e = 5) {
		const t = [];
		for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
		return t;
	}
	getSpacedPoints(e = 5) {
		const t = [];
		for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
		return t;
	}
	getLength() {
		const e = this.getLengths();
		return e[e.length - 1];
	}
	getLengths(e = this.arcLengthDivisions) {
		if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
		this.needsUpdate = !1;
		const t = [];
		let n,
			s = this.getPoint(0),
			r = 0;
		t.push(0);
		for (let o = 1; o <= e; o++) (n = this.getPoint(o / e)), (r += n.distanceTo(s)), t.push(r), (s = n);
		return (this.cacheArcLengths = t), t;
	}
	updateArcLengths() {
		(this.needsUpdate = !0), this.getLengths();
	}
	getUtoTmapping(e, t) {
		const n = this.getLengths();
		let s = 0;
		const r = n.length;
		let o;
		t ? (o = t) : (o = e * n[r - 1]);
		let a = 0,
			l = r - 1,
			c;
		for (; a <= l; )
			if (((s = Math.floor(a + (l - a) / 2)), (c = n[s] - o), c < 0)) a = s + 1;
			else if (c > 0) l = s - 1;
			else {
				l = s;
				break;
			}
		if (((s = l), n[s] === o)) return s / (r - 1);
		const h = n[s],
			d = n[s + 1] - h,
			p = (o - h) / d;
		return (s + p) / (r - 1);
	}
	getTangent(e, t) {
		let s = e - 1e-4,
			r = e + 1e-4;
		s < 0 && (s = 0), r > 1 && (r = 1);
		const o = this.getPoint(s),
			a = this.getPoint(r),
			l = t || (o.isVector2 ? new ce() : new I());
		return l.copy(a).sub(o).normalize(), l;
	}
	getTangentAt(e, t) {
		const n = this.getUtoTmapping(e);
		return this.getTangent(n, t);
	}
	computeFrenetFrames(e, t) {
		const n = new I(),
			s = [],
			r = [],
			o = [],
			a = new I(),
			l = new He();
		for (let p = 0; p <= e; p++) {
			const g = p / e;
			s[p] = this.getTangentAt(g, new I());
		}
		(r[0] = new I()), (o[0] = new I());
		let c = Number.MAX_VALUE;
		const h = Math.abs(s[0].x),
			u = Math.abs(s[0].y),
			d = Math.abs(s[0].z);
		h <= c && ((c = h), n.set(1, 0, 0)),
			u <= c && ((c = u), n.set(0, 1, 0)),
			d <= c && n.set(0, 0, 1),
			a.crossVectors(s[0], n).normalize(),
			r[0].crossVectors(s[0], a),
			o[0].crossVectors(s[0], r[0]);
		for (let p = 1; p <= e; p++) {
			if (((r[p] = r[p - 1].clone()), (o[p] = o[p - 1].clone()), a.crossVectors(s[p - 1], s[p]), a.length() > Number.EPSILON)) {
				a.normalize();
				const g = Math.acos(ln(s[p - 1].dot(s[p]), -1, 1));
				r[p].applyMatrix4(l.makeRotationAxis(a, g));
			}
			o[p].crossVectors(s[p], r[p]);
		}
		if (t === !0) {
			let p = Math.acos(ln(r[0].dot(r[e]), -1, 1));
			(p /= e), s[0].dot(a.crossVectors(r[0], r[e])) > 0 && (p = -p);
			for (let g = 1; g <= e; g++) r[g].applyMatrix4(l.makeRotationAxis(s[g], p * g)), o[g].crossVectors(s[g], r[g]);
		}
		return { tangents: s, normals: r, binormals: o };
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return (this.arcLengthDivisions = e.arcLengthDivisions), this;
	}
	toJSON() {
		const e = { metadata: { version: 4.6, type: 'Curve', generator: 'Curve.toJSON' } };
		return (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e;
	}
	fromJSON(e) {
		return (this.arcLengthDivisions = e.arcLengthDivisions), this;
	}
}
class Zp extends Ts {
	constructor(e = 0, t = 0, n = 1, s = 1, r = 0, o = Math.PI * 2, a = !1, l = 0) {
		super(),
			(this.isEllipseCurve = !0),
			(this.type = 'EllipseCurve'),
			(this.aX = e),
			(this.aY = t),
			(this.xRadius = n),
			(this.yRadius = s),
			(this.aStartAngle = r),
			(this.aEndAngle = o),
			(this.aClockwise = a),
			(this.aRotation = l);
	}
	getPoint(e, t = new ce()) {
		const n = t,
			s = Math.PI * 2;
		let r = this.aEndAngle - this.aStartAngle;
		const o = Math.abs(r) < Number.EPSILON;
		for (; r < 0; ) r += s;
		for (; r > s; ) r -= s;
		r < Number.EPSILON && (o ? (r = 0) : (r = s)), this.aClockwise === !0 && !o && (r === s ? (r = -s) : (r = r - s));
		const a = this.aStartAngle + e * r;
		let l = this.aX + this.xRadius * Math.cos(a),
			c = this.aY + this.yRadius * Math.sin(a);
		if (this.aRotation !== 0) {
			const h = Math.cos(this.aRotation),
				u = Math.sin(this.aRotation),
				d = l - this.aX,
				p = c - this.aY;
			(l = d * h - p * u + this.aX), (c = d * u + p * h + this.aY);
		}
		return n.set(l, c);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.aX = e.aX),
			(this.aY = e.aY),
			(this.xRadius = e.xRadius),
			(this.yRadius = e.yRadius),
			(this.aStartAngle = e.aStartAngle),
			(this.aEndAngle = e.aEndAngle),
			(this.aClockwise = e.aClockwise),
			(this.aRotation = e.aRotation),
			this
		);
	}
	toJSON() {
		const e = super.toJSON();
		return (
			(e.aX = this.aX),
			(e.aY = this.aY),
			(e.xRadius = this.xRadius),
			(e.yRadius = this.yRadius),
			(e.aStartAngle = this.aStartAngle),
			(e.aEndAngle = this.aEndAngle),
			(e.aClockwise = this.aClockwise),
			(e.aRotation = this.aRotation),
			e
		);
	}
	fromJSON(e) {
		return (
			super.fromJSON(e),
			(this.aX = e.aX),
			(this.aY = e.aY),
			(this.xRadius = e.xRadius),
			(this.yRadius = e.yRadius),
			(this.aStartAngle = e.aStartAngle),
			(this.aEndAngle = e.aEndAngle),
			(this.aClockwise = e.aClockwise),
			(this.aRotation = e.aRotation),
			this
		);
	}
}
class AE extends Zp {
	constructor(e, t, n, s, r, o) {
		super(e, t, n, n, s, r, o), (this.isArcCurve = !0), (this.type = 'ArcCurve');
	}
}
function F_() {
	let i = 0,
		e = 0,
		t = 0,
		n = 0;
	function s(r, o, a, l) {
		(i = r), (e = a), (t = -3 * r + 3 * o - 2 * a - l), (n = 2 * r - 2 * o + a + l);
	}
	return {
		initCatmullRom: function (r, o, a, l, c) {
			s(o, a, c * (a - r), c * (l - o));
		},
		initNonuniformCatmullRom: function (r, o, a, l, c, h, u) {
			let d = (o - r) / c - (a - r) / (c + h) + (a - o) / h,
				p = (a - o) / h - (l - o) / (h + u) + (l - a) / u;
			(d *= h), (p *= h), s(o, a, d, p);
		},
		calc: function (r) {
			const o = r * r,
				a = o * r;
			return i + e * r + t * o + n * a;
		},
	};
}
const ld = new I(),
	gm = new F_(),
	vm = new F_(),
	_m = new F_();
class CE extends Ts {
	constructor(e = [], t = !1, n = 'centripetal', s = 0.5) {
		super(),
			(this.isCatmullRomCurve3 = !0),
			(this.type = 'CatmullRomCurve3'),
			(this.points = e),
			(this.closed = t),
			(this.curveType = n),
			(this.tension = s);
	}
	getPoint(e, t = new I()) {
		const n = t,
			s = this.points,
			r = s.length,
			o = (r - (this.closed ? 0 : 1)) * e;
		let a = Math.floor(o),
			l = o - a;
		this.closed ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r) : l === 0 && a === r - 1 && ((a = r - 2), (l = 1));
		let c, h;
		this.closed || a > 0 ? (c = s[(a - 1) % r]) : (ld.subVectors(s[0], s[1]).add(s[0]), (c = ld));
		const u = s[a % r],
			d = s[(a + 1) % r];
		if (
			(this.closed || a + 2 < r ? (h = s[(a + 2) % r]) : (ld.subVectors(s[r - 1], s[r - 2]).add(s[r - 1]), (h = ld)),
			this.curveType === 'centripetal' || this.curveType === 'chordal')
		) {
			const p = this.curveType === 'chordal' ? 0.5 : 0.25;
			let g = Math.pow(c.distanceToSquared(u), p),
				v = Math.pow(u.distanceToSquared(d), p),
				m = Math.pow(d.distanceToSquared(h), p);
			v < 1e-4 && (v = 1),
				g < 1e-4 && (g = v),
				m < 1e-4 && (m = v),
				gm.initNonuniformCatmullRom(c.x, u.x, d.x, h.x, g, v, m),
				vm.initNonuniformCatmullRom(c.y, u.y, d.y, h.y, g, v, m),
				_m.initNonuniformCatmullRom(c.z, u.z, d.z, h.z, g, v, m);
		} else
			this.curveType === 'catmullrom' &&
				(gm.initCatmullRom(c.x, u.x, d.x, h.x, this.tension),
				vm.initCatmullRom(c.y, u.y, d.y, h.y, this.tension),
				_m.initCatmullRom(c.z, u.z, d.z, h.z, this.tension));
		return n.set(gm.calc(l), vm.calc(l), _m.calc(l)), n;
	}
	copy(e) {
		super.copy(e), (this.points = []);
		for (let t = 0, n = e.points.length; t < n; t++) {
			const s = e.points[t];
			this.points.push(s.clone());
		}
		return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
	}
	toJSON() {
		const e = super.toJSON();
		e.points = [];
		for (let t = 0, n = this.points.length; t < n; t++) {
			const s = this.points[t];
			e.points.push(s.toArray());
		}
		return (e.closed = this.closed), (e.curveType = this.curveType), (e.tension = this.tension), e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.points = []);
		for (let t = 0, n = e.points.length; t < n; t++) {
			const s = e.points[t];
			this.points.push(new I().fromArray(s));
		}
		return (this.closed = e.closed), (this.curveType = e.curveType), (this.tension = e.tension), this;
	}
}
function Zx(i, e, t, n, s) {
	const r = (n - e) * 0.5,
		o = (s - t) * 0.5,
		a = i * i,
		l = i * a;
	return (2 * t - 2 * n + r + o) * l + (-3 * t + 3 * n - 2 * r - o) * a + r * i + t;
}
function bN(i, e) {
	const t = 1 - i;
	return t * t * e;
}
function wN(i, e) {
	return 2 * (1 - i) * i * e;
}
function SN(i, e) {
	return i * i * e;
}
function ih(i, e, t, n) {
	return bN(i, e) + wN(i, t) + SN(i, n);
}
function MN(i, e) {
	const t = 1 - i;
	return t * t * t * e;
}
function EN(i, e) {
	const t = 1 - i;
	return 3 * t * t * i * e;
}
function TN(i, e) {
	return 3 * (1 - i) * i * i * e;
}
function AN(i, e) {
	return i * i * i * e;
}
function sh(i, e, t, n, s) {
	return MN(i, e) + EN(i, t) + TN(i, n) + AN(i, s);
}
class B_ extends Ts {
	constructor(e = new ce(), t = new ce(), n = new ce(), s = new ce()) {
		super(),
			(this.isCubicBezierCurve = !0),
			(this.type = 'CubicBezierCurve'),
			(this.v0 = e),
			(this.v1 = t),
			(this.v2 = n),
			(this.v3 = s);
	}
	getPoint(e, t = new ce()) {
		const n = t,
			s = this.v0,
			r = this.v1,
			o = this.v2,
			a = this.v3;
		return n.set(sh(e, s.x, r.x, o.x, a.x), sh(e, s.y, r.y, o.y, a.y)), n;
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), (e.v3 = this.v3.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
	}
}
class RE extends Ts {
	constructor(e = new I(), t = new I(), n = new I(), s = new I()) {
		super(),
			(this.isCubicBezierCurve3 = !0),
			(this.type = 'CubicBezierCurve3'),
			(this.v0 = e),
			(this.v1 = t),
			(this.v2 = n),
			(this.v3 = s);
	}
	getPoint(e, t = new I()) {
		const n = t,
			s = this.v0,
			r = this.v1,
			o = this.v2,
			a = this.v3;
		return n.set(sh(e, s.x, r.x, o.x, a.x), sh(e, s.y, r.y, o.y, a.y), sh(e, s.z, r.z, o.z, a.z)), n;
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), (e.v3 = this.v3.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
	}
}
class k_ extends Ts {
	constructor(e = new ce(), t = new ce()) {
		super(), (this.isLineCurve = !0), (this.type = 'LineCurve'), (this.v1 = e), (this.v2 = t);
	}
	getPoint(e, t = new ce()) {
		const n = t;
		return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
	}
	getPointAt(e, t) {
		return this.getPoint(e, t);
	}
	getTangent(e, t = new ce()) {
		return t.subVectors(this.v2, this.v1).normalize();
	}
	getTangentAt(e, t) {
		return this.getTangent(e, t);
	}
	copy(e) {
		return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
	}
}
class PE extends Ts {
	constructor(e = new I(), t = new I()) {
		super(), (this.isLineCurve3 = !0), (this.type = 'LineCurve3'), (this.v1 = e), (this.v2 = t);
	}
	getPoint(e, t = new I()) {
		const n = t;
		return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
	}
	getPointAt(e, t) {
		return this.getPoint(e, t);
	}
	getTangent(e, t = new I()) {
		return t.subVectors(this.v2, this.v1).normalize();
	}
	getTangentAt(e, t) {
		return this.getTangent(e, t);
	}
	copy(e) {
		return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
	}
}
class z_ extends Ts {
	constructor(e = new ce(), t = new ce(), n = new ce()) {
		super(), (this.isQuadraticBezierCurve = !0), (this.type = 'QuadraticBezierCurve'), (this.v0 = e), (this.v1 = t), (this.v2 = n);
	}
	getPoint(e, t = new ce()) {
		const n = t,
			s = this.v0,
			r = this.v1,
			o = this.v2;
		return n.set(ih(e, s.x, r.x, o.x), ih(e, s.y, r.y, o.y)), n;
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
	}
}
class Jp extends Ts {
	constructor(e = new I(), t = new I(), n = new I()) {
		super(), (this.isQuadraticBezierCurve3 = !0), (this.type = 'QuadraticBezierCurve3'), (this.v0 = e), (this.v1 = t), (this.v2 = n);
	}
	getPoint(e, t = new I()) {
		const n = t,
			s = this.v0,
			r = this.v1,
			o = this.v2;
		return n.set(ih(e, s.x, r.x, o.x), ih(e, s.y, r.y, o.y), ih(e, s.z, r.z, o.z)), n;
	}
	copy(e) {
		return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.v0 = this.v0.toArray()), (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
	}
}
class V_ extends Ts {
	constructor(e = []) {
		super(), (this.isSplineCurve = !0), (this.type = 'SplineCurve'), (this.points = e);
	}
	getPoint(e, t = new ce()) {
		const n = t,
			s = this.points,
			r = (s.length - 1) * e,
			o = Math.floor(r),
			a = r - o,
			l = s[o === 0 ? o : o - 1],
			c = s[o],
			h = s[o > s.length - 2 ? s.length - 1 : o + 1],
			u = s[o > s.length - 3 ? s.length - 1 : o + 2];
		return n.set(Zx(a, l.x, c.x, h.x, u.x), Zx(a, l.y, c.y, h.y, u.y)), n;
	}
	copy(e) {
		super.copy(e), (this.points = []);
		for (let t = 0, n = e.points.length; t < n; t++) {
			const s = e.points[t];
			this.points.push(s.clone());
		}
		return this;
	}
	toJSON() {
		const e = super.toJSON();
		e.points = [];
		for (let t = 0, n = this.points.length; t < n; t++) {
			const s = this.points[t];
			e.points.push(s.toArray());
		}
		return e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.points = []);
		for (let t = 0, n = e.points.length; t < n; t++) {
			const s = e.points[t];
			this.points.push(new ce().fromArray(s));
		}
		return this;
	}
}
var sp = Object.freeze({
	__proto__: null,
	ArcCurve: AE,
	CatmullRomCurve3: CE,
	CubicBezierCurve: B_,
	CubicBezierCurve3: RE,
	EllipseCurve: Zp,
	LineCurve: k_,
	LineCurve3: PE,
	QuadraticBezierCurve: z_,
	QuadraticBezierCurve3: Jp,
	SplineCurve: V_,
});
class LE extends Ts {
	constructor() {
		super(), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
	}
	add(e) {
		this.curves.push(e);
	}
	closePath() {
		const e = this.curves[0].getPoint(0),
			t = this.curves[this.curves.length - 1].getPoint(1);
		if (!e.equals(t)) {
			const n = e.isVector2 === !0 ? 'LineCurve' : 'LineCurve3';
			this.curves.push(new sp[n](t, e));
		}
		return this;
	}
	getPoint(e, t) {
		const n = e * this.getLength(),
			s = this.getCurveLengths();
		let r = 0;
		for (; r < s.length; ) {
			if (s[r] >= n) {
				const o = s[r] - n,
					a = this.curves[r],
					l = a.getLength(),
					c = l === 0 ? 0 : 1 - o / l;
				return a.getPointAt(c, t);
			}
			r++;
		}
		return null;
	}
	getLength() {
		const e = this.getCurveLengths();
		return e[e.length - 1];
	}
	updateArcLengths() {
		(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
	}
	getCurveLengths() {
		if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
		const e = [];
		let t = 0;
		for (let n = 0, s = this.curves.length; n < s; n++) (t += this.curves[n].getLength()), e.push(t);
		return (this.cacheLengths = e), e;
	}
	getSpacedPoints(e = 40) {
		const t = [];
		for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
		return this.autoClose && t.push(t[0]), t;
	}
	getPoints(e = 12) {
		const t = [];
		let n;
		for (let s = 0, r = this.curves; s < r.length; s++) {
			const o = r[s],
				a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
				l = o.getPoints(a);
			for (let c = 0; c < l.length; c++) {
				const h = l[c];
				(n && n.equals(h)) || (t.push(h), (n = h));
			}
		}
		return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
	}
	copy(e) {
		super.copy(e), (this.curves = []);
		for (let t = 0, n = e.curves.length; t < n; t++) {
			const s = e.curves[t];
			this.curves.push(s.clone());
		}
		return (this.autoClose = e.autoClose), this;
	}
	toJSON() {
		const e = super.toJSON();
		(e.autoClose = this.autoClose), (e.curves = []);
		for (let t = 0, n = this.curves.length; t < n; t++) {
			const s = this.curves[t];
			e.curves.push(s.toJSON());
		}
		return e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
		for (let t = 0, n = e.curves.length; t < n; t++) {
			const s = e.curves[t];
			this.curves.push(new sp[s.type]().fromJSON(s));
		}
		return this;
	}
}
class Rh extends LE {
	constructor(e) {
		super(), (this.type = 'Path'), (this.currentPoint = new ce()), e && this.setFromPoints(e);
	}
	setFromPoints(e) {
		this.moveTo(e[0].x, e[0].y);
		for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
		return this;
	}
	moveTo(e, t) {
		return this.currentPoint.set(e, t), this;
	}
	lineTo(e, t) {
		const n = new k_(this.currentPoint.clone(), new ce(e, t));
		return this.curves.push(n), this.currentPoint.set(e, t), this;
	}
	quadraticCurveTo(e, t, n, s) {
		const r = new z_(this.currentPoint.clone(), new ce(e, t), new ce(n, s));
		return this.curves.push(r), this.currentPoint.set(n, s), this;
	}
	bezierCurveTo(e, t, n, s, r, o) {
		const a = new B_(this.currentPoint.clone(), new ce(e, t), new ce(n, s), new ce(r, o));
		return this.curves.push(a), this.currentPoint.set(r, o), this;
	}
	splineThru(e) {
		const t = [this.currentPoint.clone()].concat(e),
			n = new V_(t);
		return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
	}
	arc(e, t, n, s, r, o) {
		const a = this.currentPoint.x,
			l = this.currentPoint.y;
		return this.absarc(e + a, t + l, n, s, r, o), this;
	}
	absarc(e, t, n, s, r, o) {
		return this.absellipse(e, t, n, n, s, r, o), this;
	}
	ellipse(e, t, n, s, r, o, a, l) {
		const c = this.currentPoint.x,
			h = this.currentPoint.y;
		return this.absellipse(e + c, t + h, n, s, r, o, a, l), this;
	}
	absellipse(e, t, n, s, r, o, a, l) {
		const c = new Zp(e, t, n, s, r, o, a, l);
		if (this.curves.length > 0) {
			const u = c.getPoint(0);
			u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
		}
		this.curves.push(c);
		const h = c.getPoint(1);
		return this.currentPoint.copy(h), this;
	}
	copy(e) {
		return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.currentPoint = this.currentPoint.toArray()), e;
	}
	fromJSON(e) {
		return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
	}
}
class su extends Ze {
	constructor(e = [new ce(0, -0.5), new ce(0.5, 0), new ce(0, 0.5)], t = 12, n = 0, s = Math.PI * 2) {
		super(),
			(this.type = 'LatheGeometry'),
			(this.parameters = { points: e, segments: t, phiStart: n, phiLength: s }),
			(t = Math.floor(t)),
			(s = ln(s, 0, Math.PI * 2));
		const r = [],
			o = [],
			a = [],
			l = [],
			c = [],
			h = 1 / t,
			u = new I(),
			d = new ce(),
			p = new I(),
			g = new I(),
			v = new I();
		let m = 0,
			f = 0;
		for (let y = 0; y <= e.length - 1; y++)
			switch (y) {
				case 0:
					(m = e[y + 1].x - e[y].x),
						(f = e[y + 1].y - e[y].y),
						(p.x = f * 1),
						(p.y = -m),
						(p.z = f * 0),
						v.copy(p),
						p.normalize(),
						l.push(p.x, p.y, p.z);
					break;
				case e.length - 1:
					l.push(v.x, v.y, v.z);
					break;
				default:
					(m = e[y + 1].x - e[y].x),
						(f = e[y + 1].y - e[y].y),
						(p.x = f * 1),
						(p.y = -m),
						(p.z = f * 0),
						g.copy(p),
						(p.x += v.x),
						(p.y += v.y),
						(p.z += v.z),
						p.normalize(),
						l.push(p.x, p.y, p.z),
						v.copy(g);
			}
		for (let y = 0; y <= t; y++) {
			const _ = n + y * h * s,
				x = Math.sin(_),
				E = Math.cos(_);
			for (let w = 0; w <= e.length - 1; w++) {
				(u.x = e[w].x * x),
					(u.y = e[w].y),
					(u.z = e[w].x * E),
					o.push(u.x, u.y, u.z),
					(d.x = y / t),
					(d.y = w / (e.length - 1)),
					a.push(d.x, d.y);
				const C = l[3 * w + 0] * x,
					P = l[3 * w + 1],
					S = l[3 * w + 0] * E;
				c.push(C, P, S);
			}
		}
		for (let y = 0; y < t; y++)
			for (let _ = 0; _ < e.length - 1; _++) {
				const x = _ + y * e.length,
					E = x,
					w = x + e.length,
					C = x + e.length + 1,
					P = x + 1;
				r.push(E, w, P), r.push(C, P, w);
			}
		this.setIndex(r),
			this.setAttribute('position', new ze(o, 3)),
			this.setAttribute('uv', new ze(a, 2)),
			this.setAttribute('normal', new ze(c, 3));
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new su(e.points, e.segments, e.phiStart, e.phiLength);
	}
}
class Qp extends su {
	constructor(e = 1, t = 1, n = 4, s = 8) {
		const r = new Rh();
		r.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
			r.absarc(0, t / 2, e, 0, Math.PI * 0.5),
			super(r.getPoints(n), s),
			(this.type = 'CapsuleGeometry'),
			(this.parameters = { radius: e, length: t, capSegments: n, radialSegments: s });
	}
	static fromJSON(e) {
		return new Qp(e.radius, e.length, e.capSegments, e.radialSegments);
	}
}
class ef extends Ze {
	constructor(e = 1, t = 32, n = 0, s = Math.PI * 2) {
		super(),
			(this.type = 'CircleGeometry'),
			(this.parameters = { radius: e, segments: t, thetaStart: n, thetaLength: s }),
			(t = Math.max(3, t));
		const r = [],
			o = [],
			a = [],
			l = [],
			c = new I(),
			h = new ce();
		o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
		for (let u = 0, d = 3; u <= t; u++, d += 3) {
			const p = n + (u / t) * s;
			(c.x = e * Math.cos(p)),
				(c.y = e * Math.sin(p)),
				o.push(c.x, c.y, c.z),
				a.push(0, 0, 1),
				(h.x = (o[d] / e + 1) / 2),
				(h.y = (o[d + 1] / e + 1) / 2),
				l.push(h.x, h.y);
		}
		for (let u = 1; u <= t; u++) r.push(u, u + 1, 0);
		this.setIndex(r),
			this.setAttribute('position', new ze(o, 3)),
			this.setAttribute('normal', new ze(a, 3)),
			this.setAttribute('uv', new ze(l, 2));
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new ef(e.radius, e.segments, e.thetaStart, e.thetaLength);
	}
}
class Va extends Ze {
	constructor(e = 1, t = 1, n = 1, s = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
		super(),
			(this.type = 'CylinderGeometry'),
			(this.parameters = {
				radiusTop: e,
				radiusBottom: t,
				height: n,
				radialSegments: s,
				heightSegments: r,
				openEnded: o,
				thetaStart: a,
				thetaLength: l,
			});
		const c = this;
		(s = Math.floor(s)), (r = Math.floor(r));
		const h = [],
			u = [],
			d = [],
			p = [];
		let g = 0;
		const v = [],
			m = n / 2;
		let f = 0;
		y(),
			o === !1 && (e > 0 && _(!0), t > 0 && _(!1)),
			this.setIndex(h),
			this.setAttribute('position', new ze(u, 3)),
			this.setAttribute('normal', new ze(d, 3)),
			this.setAttribute('uv', new ze(p, 2));
		function y() {
			const x = new I(),
				E = new I();
			let w = 0;
			const C = (t - e) / n;
			for (let P = 0; P <= r; P++) {
				const S = [],
					M = P / r,
					k = M * (t - e) + e;
				for (let q = 0; q <= s; q++) {
					const B = q / s,
						W = B * l + a,
						Q = Math.sin(W),
						$ = Math.cos(W);
					(E.x = k * Q),
						(E.y = -M * n + m),
						(E.z = k * $),
						u.push(E.x, E.y, E.z),
						x.set(Q, C, $).normalize(),
						d.push(x.x, x.y, x.z),
						p.push(B, 1 - M),
						S.push(g++);
				}
				v.push(S);
			}
			for (let P = 0; P < s; P++)
				for (let S = 0; S < r; S++) {
					const M = v[S][P],
						k = v[S + 1][P],
						q = v[S + 1][P + 1],
						B = v[S][P + 1];
					h.push(M, k, B), h.push(k, q, B), (w += 6);
				}
			c.addGroup(f, w, 0), (f += w);
		}
		function _(x) {
			const E = g,
				w = new ce(),
				C = new I();
			let P = 0;
			const S = x === !0 ? e : t,
				M = x === !0 ? 1 : -1;
			for (let q = 1; q <= s; q++) u.push(0, m * M, 0), d.push(0, M, 0), p.push(0.5, 0.5), g++;
			const k = g;
			for (let q = 0; q <= s; q++) {
				const W = (q / s) * l + a,
					Q = Math.cos(W),
					$ = Math.sin(W);
				(C.x = S * $),
					(C.y = m * M),
					(C.z = S * Q),
					u.push(C.x, C.y, C.z),
					d.push(0, M, 0),
					(w.x = Q * 0.5 + 0.5),
					(w.y = $ * 0.5 * M + 0.5),
					p.push(w.x, w.y),
					g++;
			}
			for (let q = 0; q < s; q++) {
				const B = E + q,
					W = k + q;
				x === !0 ? h.push(W, W + 1, B) : h.push(W + 1, W, B), (P += 3);
			}
			c.addGroup(f, P, x === !0 ? 1 : 2), (f += P);
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new Va(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
	}
}
class tf extends Va {
	constructor(e = 1, t = 1, n = 32, s = 1, r = !1, o = 0, a = Math.PI * 2) {
		super(0, e, t, n, s, r, o, a),
			(this.type = 'ConeGeometry'),
			(this.parameters = { radius: e, height: t, radialSegments: n, heightSegments: s, openEnded: r, thetaStart: o, thetaLength: a });
	}
	static fromJSON(e) {
		return new tf(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
	}
}
class Po extends Ze {
	constructor(e = [], t = [], n = 1, s = 0) {
		super(), (this.type = 'PolyhedronGeometry'), (this.parameters = { vertices: e, indices: t, radius: n, detail: s });
		const r = [],
			o = [];
		a(s),
			c(n),
			h(),
			this.setAttribute('position', new ze(r, 3)),
			this.setAttribute('normal', new ze(r.slice(), 3)),
			this.setAttribute('uv', new ze(o, 2)),
			s === 0 ? this.computeVertexNormals() : this.normalizeNormals();
		function a(y) {
			const _ = new I(),
				x = new I(),
				E = new I();
			for (let w = 0; w < t.length; w += 3) p(t[w + 0], _), p(t[w + 1], x), p(t[w + 2], E), l(_, x, E, y);
		}
		function l(y, _, x, E) {
			const w = E + 1,
				C = [];
			for (let P = 0; P <= w; P++) {
				C[P] = [];
				const S = y.clone().lerp(x, P / w),
					M = _.clone().lerp(x, P / w),
					k = w - P;
				for (let q = 0; q <= k; q++) q === 0 && P === w ? (C[P][q] = S) : (C[P][q] = S.clone().lerp(M, q / k));
			}
			for (let P = 0; P < w; P++)
				for (let S = 0; S < 2 * (w - P) - 1; S++) {
					const M = Math.floor(S / 2);
					S % 2 === 0 ? (d(C[P][M + 1]), d(C[P + 1][M]), d(C[P][M])) : (d(C[P][M + 1]), d(C[P + 1][M + 1]), d(C[P + 1][M]));
				}
		}
		function c(y) {
			const _ = new I();
			for (let x = 0; x < r.length; x += 3)
				(_.x = r[x + 0]),
					(_.y = r[x + 1]),
					(_.z = r[x + 2]),
					_.normalize().multiplyScalar(y),
					(r[x + 0] = _.x),
					(r[x + 1] = _.y),
					(r[x + 2] = _.z);
		}
		function h() {
			const y = new I();
			for (let _ = 0; _ < r.length; _ += 3) {
				(y.x = r[_ + 0]), (y.y = r[_ + 1]), (y.z = r[_ + 2]);
				const x = m(y) / 2 / Math.PI + 0.5,
					E = f(y) / Math.PI + 0.5;
				o.push(x, 1 - E);
			}
			g(), u();
		}
		function u() {
			for (let y = 0; y < o.length; y += 6) {
				const _ = o[y + 0],
					x = o[y + 2],
					E = o[y + 4],
					w = Math.max(_, x, E),
					C = Math.min(_, x, E);
				w > 0.9 && C < 0.1 && (_ < 0.2 && (o[y + 0] += 1), x < 0.2 && (o[y + 2] += 1), E < 0.2 && (o[y + 4] += 1));
			}
		}
		function d(y) {
			r.push(y.x, y.y, y.z);
		}
		function p(y, _) {
			const x = y * 3;
			(_.x = e[x + 0]), (_.y = e[x + 1]), (_.z = e[x + 2]);
		}
		function g() {
			const y = new I(),
				_ = new I(),
				x = new I(),
				E = new I(),
				w = new ce(),
				C = new ce(),
				P = new ce();
			for (let S = 0, M = 0; S < r.length; S += 9, M += 6) {
				y.set(r[S + 0], r[S + 1], r[S + 2]),
					_.set(r[S + 3], r[S + 4], r[S + 5]),
					x.set(r[S + 6], r[S + 7], r[S + 8]),
					w.set(o[M + 0], o[M + 1]),
					C.set(o[M + 2], o[M + 3]),
					P.set(o[M + 4], o[M + 5]),
					E.copy(y).add(_).add(x).divideScalar(3);
				const k = m(E);
				v(w, M + 0, y, k), v(C, M + 2, _, k), v(P, M + 4, x, k);
			}
		}
		function v(y, _, x, E) {
			E < 0 && y.x === 1 && (o[_] = y.x - 1), x.x === 0 && x.z === 0 && (o[_] = E / 2 / Math.PI + 0.5);
		}
		function m(y) {
			return Math.atan2(y.z, -y.x);
		}
		function f(y) {
			return Math.atan2(-y.y, Math.sqrt(y.x * y.x + y.z * y.z));
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new Po(e.vertices, e.indices, e.radius, e.details);
	}
}
class nf extends Po {
	constructor(e = 1, t = 0) {
		const n = (1 + Math.sqrt(5)) / 2,
			s = 1 / n,
			r = [
				-1,
				-1,
				-1,
				-1,
				-1,
				1,
				-1,
				1,
				-1,
				-1,
				1,
				1,
				1,
				-1,
				-1,
				1,
				-1,
				1,
				1,
				1,
				-1,
				1,
				1,
				1,
				0,
				-s,
				-n,
				0,
				-s,
				n,
				0,
				s,
				-n,
				0,
				s,
				n,
				-s,
				-n,
				0,
				-s,
				n,
				0,
				s,
				-n,
				0,
				s,
				n,
				0,
				-n,
				0,
				-s,
				n,
				0,
				-s,
				-n,
				0,
				s,
				n,
				0,
				s,
			],
			o = [
				3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10,
				0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3,
				4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
			];
		super(r, o, e, t), (this.type = 'DodecahedronGeometry'), (this.parameters = { radius: e, detail: t });
	}
	static fromJSON(e) {
		return new nf(e.radius, e.detail);
	}
}
const cd = new I(),
	hd = new I(),
	ym = new I(),
	ud = new Li();
class IE extends Ze {
	constructor(e = null, t = 1) {
		if ((super(), (this.type = 'EdgesGeometry'), (this.parameters = { geometry: e, thresholdAngle: t }), e !== null)) {
			const s = Math.pow(10, 4),
				r = Math.cos(va * t),
				o = e.getIndex(),
				a = e.getAttribute('position'),
				l = o ? o.count : a.count,
				c = [0, 0, 0],
				h = ['a', 'b', 'c'],
				u = new Array(3),
				d = {},
				p = [];
			for (let g = 0; g < l; g += 3) {
				o ? ((c[0] = o.getX(g)), (c[1] = o.getX(g + 1)), (c[2] = o.getX(g + 2))) : ((c[0] = g), (c[1] = g + 1), (c[2] = g + 2));
				const { a: v, b: m, c: f } = ud;
				if (
					(v.fromBufferAttribute(a, c[0]),
					m.fromBufferAttribute(a, c[1]),
					f.fromBufferAttribute(a, c[2]),
					ud.getNormal(ym),
					(u[0] = ''
						.concat(Math.round(v.x * s), ',')
						.concat(Math.round(v.y * s), ',')
						.concat(Math.round(v.z * s))),
					(u[1] = ''
						.concat(Math.round(m.x * s), ',')
						.concat(Math.round(m.y * s), ',')
						.concat(Math.round(m.z * s))),
					(u[2] = ''
						.concat(Math.round(f.x * s), ',')
						.concat(Math.round(f.y * s), ',')
						.concat(Math.round(f.z * s))),
					!(u[0] === u[1] || u[1] === u[2] || u[2] === u[0]))
				)
					for (let y = 0; y < 3; y++) {
						const _ = (y + 1) % 3,
							x = u[y],
							E = u[_],
							w = ud[h[y]],
							C = ud[h[_]],
							P = ''.concat(x, '_').concat(E),
							S = ''.concat(E, '_').concat(x);
						S in d && d[S]
							? (ym.dot(d[S].normal) <= r && (p.push(w.x, w.y, w.z), p.push(C.x, C.y, C.z)), (d[S] = null))
							: P in d || (d[P] = { index0: c[y], index1: c[_], normal: ym.clone() });
					}
			}
			for (const g in d)
				if (d[g]) {
					const { index0: v, index1: m } = d[g];
					cd.fromBufferAttribute(a, v), hd.fromBufferAttribute(a, m), p.push(cd.x, cd.y, cd.z), p.push(hd.x, hd.y, hd.z);
				}
			this.setAttribute('position', new ze(p, 3));
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
}
class _a extends Rh {
	constructor(e) {
		super(e), (this.uuid = Bi()), (this.type = 'Shape'), (this.holes = []);
	}
	getPointsHoles(e) {
		const t = [];
		for (let n = 0, s = this.holes.length; n < s; n++) t[n] = this.holes[n].getPoints(e);
		return t;
	}
	extractPoints(e) {
		return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
	}
	copy(e) {
		super.copy(e), (this.holes = []);
		for (let t = 0, n = e.holes.length; t < n; t++) {
			const s = e.holes[t];
			this.holes.push(s.clone());
		}
		return this;
	}
	toJSON() {
		const e = super.toJSON();
		(e.uuid = this.uuid), (e.holes = []);
		for (let t = 0, n = this.holes.length; t < n; t++) {
			const s = this.holes[t];
			e.holes.push(s.toJSON());
		}
		return e;
	}
	fromJSON(e) {
		super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
		for (let t = 0, n = e.holes.length; t < n; t++) {
			const s = e.holes[t];
			this.holes.push(new Rh().fromJSON(s));
		}
		return this;
	}
}
const CN = {
	triangulate: function (i, e, t = 2) {
		const n = e && e.length,
			s = n ? e[0] * t : i.length;
		let r = DE(i, 0, s, t, !0);
		const o = [];
		if (!r || r.next === r.prev) return o;
		let a, l, c, h, u, d, p;
		if ((n && (r = DN(i, e, r, t)), i.length > 80 * t)) {
			(a = c = i[0]), (l = h = i[1]);
			for (let g = t; g < s; g += t)
				(u = i[g]), (d = i[g + 1]), u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
			(p = Math.max(c - a, h - l)), (p = p !== 0 ? 32767 / p : 0);
		}
		return Ph(r, o, t, a, l, p, 0), o;
	},
};
function DE(i, e, t, n, s) {
	let r, o;
	if (s === WN(i, e, t, n) > 0) for (r = e; r < t; r += n) o = Jx(r, i[r], i[r + 1], o);
	else for (r = t - n; r >= e; r -= n) o = Jx(r, i[r], i[r + 1], o);
	return o && sf(o, o.next) && (Ih(o), (o = o.next)), o;
}
function Ra(i, e) {
	if (!i) return i;
	e || (e = i);
	let t = i,
		n;
	do
		if (((n = !1), !t.steiner && (sf(t, t.next) || nn(t.prev, t, t.next) === 0))) {
			if ((Ih(t), (t = e = t.prev), t === t.next)) break;
			n = !0;
		} else t = t.next;
	while (n || t !== e);
	return e;
}
function Ph(i, e, t, n, s, r, o) {
	if (!i) return;
	!o && r && BN(i, n, s, r);
	let a = i,
		l,
		c;
	for (; i.prev !== i.next; ) {
		if (((l = i.prev), (c = i.next), r ? PN(i, n, s, r) : RN(i))) {
			e.push((l.i / t) | 0), e.push((i.i / t) | 0), e.push((c.i / t) | 0), Ih(i), (i = c.next), (a = c.next);
			continue;
		}
		if (((i = c), i === a)) {
			o
				? o === 1
					? ((i = LN(Ra(i), e, t)), Ph(i, e, t, n, s, r, 2))
					: o === 2 && IN(i, e, t, n, s, r)
				: Ph(Ra(i), e, t, n, s, r, 1);
			break;
		}
	}
}
function RN(i) {
	const e = i.prev,
		t = i,
		n = i.next;
	if (nn(e, t, n) >= 0) return !1;
	const s = e.x,
		r = t.x,
		o = n.x,
		a = e.y,
		l = t.y,
		c = n.y,
		h = s < r ? (s < o ? s : o) : r < o ? r : o,
		u = a < l ? (a < c ? a : c) : l < c ? l : c,
		d = s > r ? (s > o ? s : o) : r > o ? r : o,
		p = a > l ? (a > c ? a : c) : l > c ? l : c;
	let g = n.next;
	for (; g !== e; ) {
		if (g.x >= h && g.x <= d && g.y >= u && g.y <= p && Pl(s, a, r, l, o, c, g.x, g.y) && nn(g.prev, g, g.next) >= 0) return !1;
		g = g.next;
	}
	return !0;
}
function PN(i, e, t, n) {
	const s = i.prev,
		r = i,
		o = i.next;
	if (nn(s, r, o) >= 0) return !1;
	const a = s.x,
		l = r.x,
		c = o.x,
		h = s.y,
		u = r.y,
		d = o.y,
		p = a < l ? (a < c ? a : c) : l < c ? l : c,
		g = h < u ? (h < d ? h : d) : u < d ? u : d,
		v = a > l ? (a > c ? a : c) : l > c ? l : c,
		m = h > u ? (h > d ? h : d) : u > d ? u : d,
		f = rv(p, g, e, t, n),
		y = rv(v, m, e, t, n);
	let _ = i.prevZ,
		x = i.nextZ;
	for (; _ && _.z >= f && x && x.z <= y; ) {
		if (
			(_.x >= p &&
				_.x <= v &&
				_.y >= g &&
				_.y <= m &&
				_ !== s &&
				_ !== o &&
				Pl(a, h, l, u, c, d, _.x, _.y) &&
				nn(_.prev, _, _.next) >= 0) ||
			((_ = _.prevZ),
			x.x >= p &&
				x.x <= v &&
				x.y >= g &&
				x.y <= m &&
				x !== s &&
				x !== o &&
				Pl(a, h, l, u, c, d, x.x, x.y) &&
				nn(x.prev, x, x.next) >= 0)
		)
			return !1;
		x = x.nextZ;
	}
	for (; _ && _.z >= f; ) {
		if (
			_.x >= p &&
			_.x <= v &&
			_.y >= g &&
			_.y <= m &&
			_ !== s &&
			_ !== o &&
			Pl(a, h, l, u, c, d, _.x, _.y) &&
			nn(_.prev, _, _.next) >= 0
		)
			return !1;
		_ = _.prevZ;
	}
	for (; x && x.z <= y; ) {
		if (
			x.x >= p &&
			x.x <= v &&
			x.y >= g &&
			x.y <= m &&
			x !== s &&
			x !== o &&
			Pl(a, h, l, u, c, d, x.x, x.y) &&
			nn(x.prev, x, x.next) >= 0
		)
			return !1;
		x = x.nextZ;
	}
	return !0;
}
function LN(i, e, t) {
	let n = i;
	do {
		const s = n.prev,
			r = n.next.next;
		!sf(s, r) &&
			OE(s, n, n.next, r) &&
			Lh(s, r) &&
			Lh(r, s) &&
			(e.push((s.i / t) | 0), e.push((n.i / t) | 0), e.push((r.i / t) | 0), Ih(n), Ih(n.next), (n = i = r)),
			(n = n.next);
	} while (n !== i);
	return Ra(n);
}
function IN(i, e, t, n, s, r) {
	let o = i;
	do {
		let a = o.next.next;
		for (; a !== o.prev; ) {
			if (o.i !== a.i && VN(o, a)) {
				let l = UE(o, a);
				(o = Ra(o, o.next)), (l = Ra(l, l.next)), Ph(o, e, t, n, s, r, 0), Ph(l, e, t, n, s, r, 0);
				return;
			}
			a = a.next;
		}
		o = o.next;
	} while (o !== i);
}
function DN(i, e, t, n) {
	const s = [];
	let r, o, a, l, c;
	for (r = 0, o = e.length; r < o; r++)
		(a = e[r] * n),
			(l = r < o - 1 ? e[r + 1] * n : i.length),
			(c = DE(i, a, l, n, !1)),
			c === c.next && (c.steiner = !0),
			s.push(zN(c));
	for (s.sort(ON), r = 0; r < s.length; r++) t = UN(s[r], t);
	return t;
}
function ON(i, e) {
	return i.x - e.x;
}
function UN(i, e) {
	const t = NN(i, e);
	if (!t) return e;
	const n = UE(t, i);
	return Ra(n, n.next), Ra(t, t.next);
}
function NN(i, e) {
	let t = e,
		n = -1 / 0,
		s;
	const r = i.x,
		o = i.y;
	do {
		if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
			const d = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
			if (d <= r && d > n && ((n = d), (s = t.x < t.next.x ? t : t.next), d === r)) return s;
		}
		t = t.next;
	} while (t !== e);
	if (!s) return null;
	const a = s,
		l = s.x,
		c = s.y;
	let h = 1 / 0,
		u;
	t = s;
	do
		r >= t.x &&
			t.x >= l &&
			r !== t.x &&
			Pl(o < c ? r : n, o, l, c, o < c ? n : r, o, t.x, t.y) &&
			((u = Math.abs(o - t.y) / (r - t.x)),
			Lh(t, i) && (u < h || (u === h && (t.x > s.x || (t.x === s.x && FN(s, t))))) && ((s = t), (h = u))),
			(t = t.next);
	while (t !== a);
	return s;
}
function FN(i, e) {
	return nn(i.prev, i, e.prev) < 0 && nn(e.next, i, i.next) < 0;
}
function BN(i, e, t, n) {
	let s = i;
	do s.z === 0 && (s.z = rv(s.x, s.y, e, t, n)), (s.prevZ = s.prev), (s.nextZ = s.next), (s = s.next);
	while (s !== i);
	(s.prevZ.nextZ = null), (s.prevZ = null), kN(s);
}
function kN(i) {
	let e,
		t,
		n,
		s,
		r,
		o,
		a,
		l,
		c = 1;
	do {
		for (t = i, i = null, r = null, o = 0; t; ) {
			for (o++, n = t, a = 0, e = 0; e < c && (a++, (n = n.nextZ), !!n); e++);
			for (l = c; a > 0 || (l > 0 && n); )
				a !== 0 && (l === 0 || !n || t.z <= n.z) ? ((s = t), (t = t.nextZ), a--) : ((s = n), (n = n.nextZ), l--),
					r ? (r.nextZ = s) : (i = s),
					(s.prevZ = r),
					(r = s);
			t = n;
		}
		(r.nextZ = null), (c *= 2);
	} while (o > 1);
	return i;
}
function rv(i, e, t, n, s) {
	return (
		(i = ((i - t) * s) | 0),
		(e = ((e - n) * s) | 0),
		(i = (i | (i << 8)) & 16711935),
		(i = (i | (i << 4)) & 252645135),
		(i = (i | (i << 2)) & 858993459),
		(i = (i | (i << 1)) & 1431655765),
		(e = (e | (e << 8)) & 16711935),
		(e = (e | (e << 4)) & 252645135),
		(e = (e | (e << 2)) & 858993459),
		(e = (e | (e << 1)) & 1431655765),
		i | (e << 1)
	);
}
function zN(i) {
	let e = i,
		t = i;
	do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
	while (e !== i);
	return t;
}
function Pl(i, e, t, n, s, r, o, a) {
	return (s - o) * (e - a) >= (i - o) * (r - a) && (i - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (s - o) * (n - a);
}
function VN(i, e) {
	return (
		i.next.i !== e.i &&
		i.prev.i !== e.i &&
		!HN(i, e) &&
		((Lh(i, e) && Lh(e, i) && GN(i, e) && (nn(i.prev, i, e.prev) || nn(i, e.prev, e))) ||
			(sf(i, e) && nn(i.prev, i, i.next) > 0 && nn(e.prev, e, e.next) > 0))
	);
}
function nn(i, e, t) {
	return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function sf(i, e) {
	return i.x === e.x && i.y === e.y;
}
function OE(i, e, t, n) {
	const s = pd(nn(i, e, t)),
		r = pd(nn(i, e, n)),
		o = pd(nn(t, n, i)),
		a = pd(nn(t, n, e));
	return !!(
		(s !== r && o !== a) ||
		(s === 0 && dd(i, t, e)) ||
		(r === 0 && dd(i, n, e)) ||
		(o === 0 && dd(t, i, n)) ||
		(a === 0 && dd(t, e, n))
	);
}
function dd(i, e, t) {
	return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function pd(i) {
	return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function HN(i, e) {
	let t = i;
	do {
		if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && OE(t, t.next, i, e)) return !0;
		t = t.next;
	} while (t !== i);
	return !1;
}
function Lh(i, e) {
	return nn(i.prev, i, i.next) < 0 ? nn(i, e, i.next) >= 0 && nn(i, i.prev, e) >= 0 : nn(i, e, i.prev) < 0 || nn(i, i.next, e) < 0;
}
function GN(i, e) {
	let t = i,
		n = !1;
	const s = (i.x + e.x) / 2,
		r = (i.y + e.y) / 2;
	do t.y > r != t.next.y > r && t.next.y !== t.y && s < ((t.next.x - t.x) * (r - t.y)) / (t.next.y - t.y) + t.x && (n = !n), (t = t.next);
	while (t !== i);
	return n;
}
function UE(i, e) {
	const t = new ov(i.i, i.x, i.y),
		n = new ov(e.i, e.x, e.y),
		s = i.next,
		r = e.prev;
	return (i.next = e), (e.prev = i), (t.next = s), (s.prev = t), (n.next = t), (t.prev = n), (r.next = n), (n.prev = r), n;
}
function Jx(i, e, t, n) {
	const s = new ov(i, e, t);
	return n ? ((s.next = n.next), (s.prev = n), (n.next.prev = s), (n.next = s)) : ((s.prev = s), (s.next = s)), s;
}
function Ih(i) {
	(i.next.prev = i.prev), (i.prev.next = i.next), i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function ov(i, e, t) {
	(this.i = i),
		(this.x = e),
		(this.y = t),
		(this.prev = null),
		(this.next = null),
		(this.z = 0),
		(this.prevZ = null),
		(this.nextZ = null),
		(this.steiner = !1);
}
function WN(i, e, t, n) {
	let s = 0;
	for (let r = e, o = t - n; r < t; r += n) (s += (i[o] - i[r]) * (i[r + 1] + i[o + 1])), (o = r);
	return s;
}
class qs {
	static area(e) {
		const t = e.length;
		let n = 0;
		for (let s = t - 1, r = 0; r < t; s = r++) n += e[s].x * e[r].y - e[r].x * e[s].y;
		return n * 0.5;
	}
	static isClockWise(e) {
		return qs.area(e) < 0;
	}
	static triangulateShape(e, t) {
		const n = [],
			s = [],
			r = [];
		Qx(e), eb(n, e);
		let o = e.length;
		t.forEach(Qx);
		for (let l = 0; l < t.length; l++) s.push(o), (o += t[l].length), eb(n, t[l]);
		const a = CN.triangulate(n, s);
		for (let l = 0; l < a.length; l += 3) r.push(a.slice(l, l + 3));
		return r;
	}
}
function Qx(i) {
	const e = i.length;
	e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function eb(i, e) {
	for (let t = 0; t < e.length; t++) i.push(e[t].x), i.push(e[t].y);
}
class rf extends Ze {
	constructor(e = new _a([new ce(0.5, 0.5), new ce(-0.5, 0.5), new ce(-0.5, -0.5), new ce(0.5, -0.5)]), t = {}) {
		super(), (this.type = 'ExtrudeGeometry'), (this.parameters = { shapes: e, options: t }), (e = Array.isArray(e) ? e : [e]);
		const n = this,
			s = [],
			r = [];
		for (let a = 0, l = e.length; a < l; a++) {
			const c = e[a];
			o(c);
		}
		this.setAttribute('position', new ze(s, 3)), this.setAttribute('uv', new ze(r, 2)), this.computeVertexNormals();
		function o(a) {
			const l = [],
				c = t.curveSegments !== void 0 ? t.curveSegments : 12,
				h = t.steps !== void 0 ? t.steps : 1,
				u = t.depth !== void 0 ? t.depth : 1;
			let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
				p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
				g = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1,
				v = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
				m = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
			const f = t.extrudePath,
				y = t.UVGenerator !== void 0 ? t.UVGenerator : XN;
			let _,
				x = !1,
				E,
				w,
				C,
				P;
			f &&
				((_ = f.getSpacedPoints(h)),
				(x = !0),
				(d = !1),
				(E = f.computeFrenetFrames(h, !1)),
				(w = new I()),
				(C = new I()),
				(P = new I())),
				d || ((m = 0), (p = 0), (g = 0), (v = 0));
			const S = a.extractPoints(c);
			let M = S.shape;
			const k = S.holes;
			if (!qs.isClockWise(M)) {
				M = M.reverse();
				for (let oe = 0, L = k.length; oe < L; oe++) {
					const D = k[oe];
					qs.isClockWise(D) && (k[oe] = D.reverse());
				}
			}
			const B = qs.triangulateShape(M, k),
				W = M;
			for (let oe = 0, L = k.length; oe < L; oe++) {
				const D = k[oe];
				M = M.concat(D);
			}
			function Q(oe, L, D) {
				return L || console.error('THREE.ExtrudeGeometry: vec does not exist'), oe.clone().addScaledVector(L, D);
			}
			const $ = M.length,
				le = B.length;
			function Z(oe, L, D) {
				let z, Y, K;
				const re = oe.x - L.x,
					O = oe.y - L.y,
					T = D.x - oe.x,
					V = D.y - oe.y,
					G = re * re + O * O,
					ee = re * V - O * T;
				if (Math.abs(ee) > Number.EPSILON) {
					const ne = Math.sqrt(G),
						_e = Math.sqrt(T * T + V * V),
						me = L.x - O / ne,
						ye = L.y + re / ne,
						De = D.x - V / _e,
						ve = D.y + T / _e,
						Le = ((De - me) * V - (ve - ye) * T) / (re * V - O * T);
					(z = me + re * Le - oe.x), (Y = ye + O * Le - oe.y);
					const Ye = z * z + Y * Y;
					if (Ye <= 2) return new ce(z, Y);
					K = Math.sqrt(Ye / 2);
				} else {
					let ne = !1;
					re > Number.EPSILON
						? T > Number.EPSILON && (ne = !0)
						: re < -Number.EPSILON
						? T < -Number.EPSILON && (ne = !0)
						: Math.sign(O) === Math.sign(V) && (ne = !0),
						ne ? ((z = -O), (Y = re), (K = Math.sqrt(G))) : ((z = re), (Y = O), (K = Math.sqrt(G / 2)));
				}
				return new ce(z / K, Y / K);
			}
			const xe = [];
			for (let oe = 0, L = W.length, D = L - 1, z = oe + 1; oe < L; oe++, D++, z++)
				D === L && (D = 0), z === L && (z = 0), (xe[oe] = Z(W[oe], W[D], W[z]));
			const ue = [];
			let Te,
				Ae = xe.concat();
			for (let oe = 0, L = k.length; oe < L; oe++) {
				const D = k[oe];
				Te = [];
				for (let z = 0, Y = D.length, K = Y - 1, re = z + 1; z < Y; z++, K++, re++)
					K === Y && (K = 0), re === Y && (re = 0), (Te[z] = Z(D[z], D[K], D[re]));
				ue.push(Te), (Ae = Ae.concat(Te));
			}
			for (let oe = 0; oe < m; oe++) {
				const L = oe / m,
					D = p * Math.cos((L * Math.PI) / 2),
					z = g * Math.sin((L * Math.PI) / 2) + v;
				for (let Y = 0, K = W.length; Y < K; Y++) {
					const re = Q(W[Y], xe[Y], z);
					X(re.x, re.y, -D);
				}
				for (let Y = 0, K = k.length; Y < K; Y++) {
					const re = k[Y];
					Te = ue[Y];
					for (let O = 0, T = re.length; O < T; O++) {
						const V = Q(re[O], Te[O], z);
						X(V.x, V.y, -D);
					}
				}
			}
			const We = g + v;
			for (let oe = 0; oe < $; oe++) {
				const L = d ? Q(M[oe], Ae[oe], We) : M[oe];
				x
					? (C.copy(E.normals[0]).multiplyScalar(L.x),
					  w.copy(E.binormals[0]).multiplyScalar(L.y),
					  P.copy(_[0]).add(C).add(w),
					  X(P.x, P.y, P.z))
					: X(L.x, L.y, 0);
			}
			for (let oe = 1; oe <= h; oe++)
				for (let L = 0; L < $; L++) {
					const D = d ? Q(M[L], Ae[L], We) : M[L];
					x
						? (C.copy(E.normals[oe]).multiplyScalar(D.x),
						  w.copy(E.binormals[oe]).multiplyScalar(D.y),
						  P.copy(_[oe]).add(C).add(w),
						  X(P.x, P.y, P.z))
						: X(D.x, D.y, (u / h) * oe);
				}
			for (let oe = m - 1; oe >= 0; oe--) {
				const L = oe / m,
					D = p * Math.cos((L * Math.PI) / 2),
					z = g * Math.sin((L * Math.PI) / 2) + v;
				for (let Y = 0, K = W.length; Y < K; Y++) {
					const re = Q(W[Y], xe[Y], z);
					X(re.x, re.y, u + D);
				}
				for (let Y = 0, K = k.length; Y < K; Y++) {
					const re = k[Y];
					Te = ue[Y];
					for (let O = 0, T = re.length; O < T; O++) {
						const V = Q(re[O], Te[O], z);
						x ? X(V.x, V.y + _[h - 1].y, _[h - 1].x + D) : X(V.x, V.y, u + D);
					}
				}
			}
			se(), Se();
			function se() {
				const oe = s.length / 3;
				if (d) {
					let L = 0,
						D = $ * L;
					for (let z = 0; z < le; z++) {
						const Y = B[z];
						ge(Y[2] + D, Y[1] + D, Y[0] + D);
					}
					(L = h + m * 2), (D = $ * L);
					for (let z = 0; z < le; z++) {
						const Y = B[z];
						ge(Y[0] + D, Y[1] + D, Y[2] + D);
					}
				} else {
					for (let L = 0; L < le; L++) {
						const D = B[L];
						ge(D[2], D[1], D[0]);
					}
					for (let L = 0; L < le; L++) {
						const D = B[L];
						ge(D[0] + $ * h, D[1] + $ * h, D[2] + $ * h);
					}
				}
				n.addGroup(oe, s.length / 3 - oe, 0);
			}
			function Se() {
				const oe = s.length / 3;
				let L = 0;
				we(W, L), (L += W.length);
				for (let D = 0, z = k.length; D < z; D++) {
					const Y = k[D];
					we(Y, L), (L += Y.length);
				}
				n.addGroup(oe, s.length / 3 - oe, 1);
			}
			function we(oe, L) {
				let D = oe.length;
				for (; --D >= 0; ) {
					const z = D;
					let Y = D - 1;
					Y < 0 && (Y = oe.length - 1);
					for (let K = 0, re = h + m * 2; K < re; K++) {
						const O = $ * K,
							T = $ * (K + 1),
							V = L + z + O,
							G = L + Y + O,
							ee = L + Y + T,
							ne = L + z + T;
						be(V, G, ee, ne);
					}
				}
			}
			function X(oe, L, D) {
				l.push(oe), l.push(L), l.push(D);
			}
			function ge(oe, L, D) {
				H(oe), H(L), H(D);
				const z = s.length / 3,
					Y = y.generateTopUV(n, s, z - 3, z - 2, z - 1);
				Ne(Y[0]), Ne(Y[1]), Ne(Y[2]);
			}
			function be(oe, L, D, z) {
				H(oe), H(L), H(z), H(L), H(D), H(z);
				const Y = s.length / 3,
					K = y.generateSideWallUV(n, s, Y - 6, Y - 3, Y - 2, Y - 1);
				Ne(K[0]), Ne(K[1]), Ne(K[3]), Ne(K[1]), Ne(K[2]), Ne(K[3]);
			}
			function H(oe) {
				s.push(l[oe * 3 + 0]), s.push(l[oe * 3 + 1]), s.push(l[oe * 3 + 2]);
			}
			function Ne(oe) {
				r.push(oe.x), r.push(oe.y);
			}
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	toJSON() {
		const e = super.toJSON(),
			t = this.parameters.shapes,
			n = this.parameters.options;
		return qN(t, n, e);
	}
	static fromJSON(e, t) {
		const n = [];
		for (let r = 0, o = e.shapes.length; r < o; r++) {
			const a = t[e.shapes[r]];
			n.push(a);
		}
		const s = e.options.extrudePath;
		return s !== void 0 && (e.options.extrudePath = new sp[s.type]().fromJSON(s)), new rf(n, e.options);
	}
}
const XN = {
	generateTopUV: function (i, e, t, n, s) {
		const r = e[t * 3],
			o = e[t * 3 + 1],
			a = e[n * 3],
			l = e[n * 3 + 1],
			c = e[s * 3],
			h = e[s * 3 + 1];
		return [new ce(r, o), new ce(a, l), new ce(c, h)];
	},
	generateSideWallUV: function (i, e, t, n, s, r) {
		const o = e[t * 3],
			a = e[t * 3 + 1],
			l = e[t * 3 + 2],
			c = e[n * 3],
			h = e[n * 3 + 1],
			u = e[n * 3 + 2],
			d = e[s * 3],
			p = e[s * 3 + 1],
			g = e[s * 3 + 2],
			v = e[r * 3],
			m = e[r * 3 + 1],
			f = e[r * 3 + 2];
		return Math.abs(a - h) < Math.abs(o - c)
			? [new ce(o, 1 - l), new ce(c, 1 - u), new ce(d, 1 - g), new ce(v, 1 - f)]
			: [new ce(a, 1 - l), new ce(h, 1 - u), new ce(p, 1 - g), new ce(m, 1 - f)];
	},
};
function qN(i, e, t) {
	if (((t.shapes = []), Array.isArray(i)))
		for (let n = 0, s = i.length; n < s; n++) {
			const r = i[n];
			t.shapes.push(r.uuid);
		}
	else t.shapes.push(i.uuid);
	return (t.options = Object.assign({}, e)), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class of extends Po {
	constructor(e = 1, t = 0) {
		const n = (1 + Math.sqrt(5)) / 2,
			s = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
			r = [
				0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6,
				3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
			];
		super(s, r, e, t), (this.type = 'IcosahedronGeometry'), (this.parameters = { radius: e, detail: t });
	}
	static fromJSON(e) {
		return new of(e.radius, e.detail);
	}
}
class ru extends Po {
	constructor(e = 1, t = 0) {
		const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
			s = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
		super(n, s, e, t), (this.type = 'OctahedronGeometry'), (this.parameters = { radius: e, detail: t });
	}
	static fromJSON(e) {
		return new ru(e.radius, e.detail);
	}
}
class af extends Ze {
	constructor(e = 0.5, t = 1, n = 32, s = 1, r = 0, o = Math.PI * 2) {
		super(),
			(this.type = 'RingGeometry'),
			(this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: n, phiSegments: s, thetaStart: r, thetaLength: o }),
			(n = Math.max(3, n)),
			(s = Math.max(1, s));
		const a = [],
			l = [],
			c = [],
			h = [];
		let u = e;
		const d = (t - e) / s,
			p = new I(),
			g = new ce();
		for (let v = 0; v <= s; v++) {
			for (let m = 0; m <= n; m++) {
				const f = r + (m / n) * o;
				(p.x = u * Math.cos(f)),
					(p.y = u * Math.sin(f)),
					l.push(p.x, p.y, p.z),
					c.push(0, 0, 1),
					(g.x = (p.x / t + 1) / 2),
					(g.y = (p.y / t + 1) / 2),
					h.push(g.x, g.y);
			}
			u += d;
		}
		for (let v = 0; v < s; v++) {
			const m = v * (n + 1);
			for (let f = 0; f < n; f++) {
				const y = f + m,
					_ = y,
					x = y + n + 1,
					E = y + n + 2,
					w = y + 1;
				a.push(_, x, w), a.push(x, E, w);
			}
		}
		this.setIndex(a),
			this.setAttribute('position', new ze(l, 3)),
			this.setAttribute('normal', new ze(c, 3)),
			this.setAttribute('uv', new ze(h, 2));
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new af(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
	}
}
class lf extends Ze {
	constructor(e = new _a([new ce(0, 0.5), new ce(-0.5, -0.5), new ce(0.5, -0.5)]), t = 12) {
		super(), (this.type = 'ShapeGeometry'), (this.parameters = { shapes: e, curveSegments: t });
		const n = [],
			s = [],
			r = [],
			o = [];
		let a = 0,
			l = 0;
		if (Array.isArray(e) === !1) c(e);
		else for (let h = 0; h < e.length; h++) c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
		this.setIndex(n),
			this.setAttribute('position', new ze(s, 3)),
			this.setAttribute('normal', new ze(r, 3)),
			this.setAttribute('uv', new ze(o, 2));
		function c(h) {
			const u = s.length / 3,
				d = h.extractPoints(t);
			let p = d.shape;
			const g = d.holes;
			qs.isClockWise(p) === !1 && (p = p.reverse());
			for (let m = 0, f = g.length; m < f; m++) {
				const y = g[m];
				qs.isClockWise(y) === !0 && (g[m] = y.reverse());
			}
			const v = qs.triangulateShape(p, g);
			for (let m = 0, f = g.length; m < f; m++) {
				const y = g[m];
				p = p.concat(y);
			}
			for (let m = 0, f = p.length; m < f; m++) {
				const y = p[m];
				s.push(y.x, y.y, 0), r.push(0, 0, 1), o.push(y.x, y.y);
			}
			for (let m = 0, f = v.length; m < f; m++) {
				const y = v[m],
					_ = y[0] + u,
					x = y[1] + u,
					E = y[2] + u;
				n.push(_, x, E), (l += 3);
			}
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	toJSON() {
		const e = super.toJSON(),
			t = this.parameters.shapes;
		return YN(t, e);
	}
	static fromJSON(e, t) {
		const n = [];
		for (let s = 0, r = e.shapes.length; s < r; s++) {
			const o = t[e.shapes[s]];
			n.push(o);
		}
		return new lf(n, e.curveSegments);
	}
}
function YN(i, e) {
	if (((e.shapes = []), Array.isArray(i)))
		for (let t = 0, n = i.length; t < n; t++) {
			const s = i[t];
			e.shapes.push(s.uuid);
		}
	else e.shapes.push(i.uuid);
	return e;
}
class hc extends Ze {
	constructor(e = 1, t = 32, n = 16, s = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
		super(),
			(this.type = 'SphereGeometry'),
			(this.parameters = {
				radius: e,
				widthSegments: t,
				heightSegments: n,
				phiStart: s,
				phiLength: r,
				thetaStart: o,
				thetaLength: a,
			}),
			(t = Math.max(3, Math.floor(t))),
			(n = Math.max(2, Math.floor(n)));
		const l = Math.min(o + a, Math.PI);
		let c = 0;
		const h = [],
			u = new I(),
			d = new I(),
			p = [],
			g = [],
			v = [],
			m = [];
		for (let f = 0; f <= n; f++) {
			const y = [],
				_ = f / n;
			let x = 0;
			f === 0 && o === 0 ? (x = 0.5 / t) : f === n && l === Math.PI && (x = -0.5 / t);
			for (let E = 0; E <= t; E++) {
				const w = E / t;
				(u.x = -e * Math.cos(s + w * r) * Math.sin(o + _ * a)),
					(u.y = e * Math.cos(o + _ * a)),
					(u.z = e * Math.sin(s + w * r) * Math.sin(o + _ * a)),
					g.push(u.x, u.y, u.z),
					d.copy(u).normalize(),
					v.push(d.x, d.y, d.z),
					m.push(w + x, 1 - _),
					y.push(c++);
			}
			h.push(y);
		}
		for (let f = 0; f < n; f++)
			for (let y = 0; y < t; y++) {
				const _ = h[f][y + 1],
					x = h[f][y],
					E = h[f + 1][y],
					w = h[f + 1][y + 1];
				(f !== 0 || o > 0) && p.push(_, x, w), (f !== n - 1 || l < Math.PI) && p.push(x, E, w);
			}
		this.setIndex(p),
			this.setAttribute('position', new ze(g, 3)),
			this.setAttribute('normal', new ze(v, 3)),
			this.setAttribute('uv', new ze(m, 2));
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new hc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
	}
}
class cf extends Po {
	constructor(e = 1, t = 0) {
		const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
			s = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
		super(n, s, e, t), (this.type = 'TetrahedronGeometry'), (this.parameters = { radius: e, detail: t });
	}
	static fromJSON(e) {
		return new cf(e.radius, e.detail);
	}
}
class hf extends Ze {
	constructor(e = 1, t = 0.4, n = 12, s = 48, r = Math.PI * 2) {
		super(),
			(this.type = 'TorusGeometry'),
			(this.parameters = { radius: e, tube: t, radialSegments: n, tubularSegments: s, arc: r }),
			(n = Math.floor(n)),
			(s = Math.floor(s));
		const o = [],
			a = [],
			l = [],
			c = [],
			h = new I(),
			u = new I(),
			d = new I();
		for (let p = 0; p <= n; p++)
			for (let g = 0; g <= s; g++) {
				const v = (g / s) * r,
					m = (p / n) * Math.PI * 2;
				(u.x = (e + t * Math.cos(m)) * Math.cos(v)),
					(u.y = (e + t * Math.cos(m)) * Math.sin(v)),
					(u.z = t * Math.sin(m)),
					a.push(u.x, u.y, u.z),
					(h.x = e * Math.cos(v)),
					(h.y = e * Math.sin(v)),
					d.subVectors(u, h).normalize(),
					l.push(d.x, d.y, d.z),
					c.push(g / s),
					c.push(p / n);
			}
		for (let p = 1; p <= n; p++)
			for (let g = 1; g <= s; g++) {
				const v = (s + 1) * p + g - 1,
					m = (s + 1) * (p - 1) + g - 1,
					f = (s + 1) * (p - 1) + g,
					y = (s + 1) * p + g;
				o.push(v, m, y), o.push(m, f, y);
			}
		this.setIndex(o),
			this.setAttribute('position', new ze(a, 3)),
			this.setAttribute('normal', new ze(l, 3)),
			this.setAttribute('uv', new ze(c, 2));
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new hf(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
	}
}
class uf extends Ze {
	constructor(e = 1, t = 0.4, n = 64, s = 8, r = 2, o = 3) {
		super(),
			(this.type = 'TorusKnotGeometry'),
			(this.parameters = { radius: e, tube: t, tubularSegments: n, radialSegments: s, p: r, q: o }),
			(n = Math.floor(n)),
			(s = Math.floor(s));
		const a = [],
			l = [],
			c = [],
			h = [],
			u = new I(),
			d = new I(),
			p = new I(),
			g = new I(),
			v = new I(),
			m = new I(),
			f = new I();
		for (let _ = 0; _ <= n; ++_) {
			const x = (_ / n) * r * Math.PI * 2;
			y(x, r, o, e, p),
				y(x + 0.01, r, o, e, g),
				m.subVectors(g, p),
				f.addVectors(g, p),
				v.crossVectors(m, f),
				f.crossVectors(v, m),
				v.normalize(),
				f.normalize();
			for (let E = 0; E <= s; ++E) {
				const w = (E / s) * Math.PI * 2,
					C = -t * Math.cos(w),
					P = t * Math.sin(w);
				(u.x = p.x + (C * f.x + P * v.x)),
					(u.y = p.y + (C * f.y + P * v.y)),
					(u.z = p.z + (C * f.z + P * v.z)),
					l.push(u.x, u.y, u.z),
					d.subVectors(u, p).normalize(),
					c.push(d.x, d.y, d.z),
					h.push(_ / n),
					h.push(E / s);
			}
		}
		for (let _ = 1; _ <= n; _++)
			for (let x = 1; x <= s; x++) {
				const E = (s + 1) * (_ - 1) + (x - 1),
					w = (s + 1) * _ + (x - 1),
					C = (s + 1) * _ + x,
					P = (s + 1) * (_ - 1) + x;
				a.push(E, w, P), a.push(w, C, P);
			}
		this.setIndex(a),
			this.setAttribute('position', new ze(l, 3)),
			this.setAttribute('normal', new ze(c, 3)),
			this.setAttribute('uv', new ze(h, 2));
		function y(_, x, E, w, C) {
			const P = Math.cos(_),
				S = Math.sin(_),
				M = (E / x) * _,
				k = Math.cos(M);
			(C.x = w * (2 + k) * 0.5 * P), (C.y = w * (2 + k) * S * 0.5), (C.z = w * Math.sin(M) * 0.5);
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	static fromJSON(e) {
		return new uf(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
	}
}
class df extends Ze {
	constructor(e = new Jp(new I(-1, -1, 0), new I(-1, 1, 0), new I(1, 1, 0)), t = 64, n = 1, s = 8, r = !1) {
		super(), (this.type = 'TubeGeometry'), (this.parameters = { path: e, tubularSegments: t, radius: n, radialSegments: s, closed: r });
		const o = e.computeFrenetFrames(t, r);
		(this.tangents = o.tangents), (this.normals = o.normals), (this.binormals = o.binormals);
		const a = new I(),
			l = new I(),
			c = new ce();
		let h = new I();
		const u = [],
			d = [],
			p = [],
			g = [];
		v(),
			this.setIndex(g),
			this.setAttribute('position', new ze(u, 3)),
			this.setAttribute('normal', new ze(d, 3)),
			this.setAttribute('uv', new ze(p, 2));
		function v() {
			for (let _ = 0; _ < t; _++) m(_);
			m(r === !1 ? t : 0), y(), f();
		}
		function m(_) {
			h = e.getPointAt(_ / t, h);
			const x = o.normals[_],
				E = o.binormals[_];
			for (let w = 0; w <= s; w++) {
				const C = (w / s) * Math.PI * 2,
					P = Math.sin(C),
					S = -Math.cos(C);
				(l.x = S * x.x + P * E.x),
					(l.y = S * x.y + P * E.y),
					(l.z = S * x.z + P * E.z),
					l.normalize(),
					d.push(l.x, l.y, l.z),
					(a.x = h.x + n * l.x),
					(a.y = h.y + n * l.y),
					(a.z = h.z + n * l.z),
					u.push(a.x, a.y, a.z);
			}
		}
		function f() {
			for (let _ = 1; _ <= t; _++)
				for (let x = 1; x <= s; x++) {
					const E = (s + 1) * (_ - 1) + (x - 1),
						w = (s + 1) * _ + (x - 1),
						C = (s + 1) * _ + x,
						P = (s + 1) * (_ - 1) + x;
					g.push(E, w, P), g.push(w, C, P);
				}
		}
		function y() {
			for (let _ = 0; _ <= t; _++) for (let x = 0; x <= s; x++) (c.x = _ / t), (c.y = x / s), p.push(c.x, c.y);
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.path = this.parameters.path.toJSON()), e;
	}
	static fromJSON(e) {
		return new df(new sp[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
	}
}
class NE extends Ze {
	constructor(e = null) {
		if ((super(), (this.type = 'WireframeGeometry'), (this.parameters = { geometry: e }), e !== null)) {
			const t = [],
				n = new Set(),
				s = new I(),
				r = new I();
			if (e.index !== null) {
				const o = e.attributes.position,
					a = e.index;
				let l = e.groups;
				l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
				for (let c = 0, h = l.length; c < h; ++c) {
					const u = l[c],
						d = u.start,
						p = u.count;
					for (let g = d, v = d + p; g < v; g += 3)
						for (let m = 0; m < 3; m++) {
							const f = a.getX(g + m),
								y = a.getX(g + ((m + 1) % 3));
							s.fromBufferAttribute(o, f),
								r.fromBufferAttribute(o, y),
								tb(s, r, n) === !0 && (t.push(s.x, s.y, s.z), t.push(r.x, r.y, r.z));
						}
				}
			} else {
				const o = e.attributes.position;
				for (let a = 0, l = o.count / 3; a < l; a++)
					for (let c = 0; c < 3; c++) {
						const h = 3 * a + c,
							u = 3 * a + ((c + 1) % 3);
						s.fromBufferAttribute(o, h),
							r.fromBufferAttribute(o, u),
							tb(s, r, n) === !0 && (t.push(s.x, s.y, s.z), t.push(r.x, r.y, r.z));
					}
			}
			this.setAttribute('position', new ze(t, 3));
		}
	}
	copy(e) {
		return super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this;
	}
}
function tb(i, e, t) {
	const n = ''.concat(i.x, ',').concat(i.y, ',').concat(i.z, '-').concat(e.x, ',').concat(e.y, ',').concat(e.z),
		s = ''.concat(e.x, ',').concat(e.y, ',').concat(e.z, '-').concat(i.x, ',').concat(i.y, ',').concat(i.z);
	return t.has(n) === !0 || t.has(s) === !0 ? !1 : (t.add(n), t.add(s), !0);
}
var nb = Object.freeze({
	__proto__: null,
	BoxGeometry: za,
	CapsuleGeometry: Qp,
	CircleGeometry: ef,
	ConeGeometry: tf,
	CylinderGeometry: Va,
	DodecahedronGeometry: nf,
	EdgesGeometry: IE,
	ExtrudeGeometry: rf,
	IcosahedronGeometry: of,
	LatheGeometry: su,
	OctahedronGeometry: ru,
	PlaneGeometry: js,
	PolyhedronGeometry: Po,
	RingGeometry: af,
	ShapeGeometry: lf,
	SphereGeometry: hc,
	TetrahedronGeometry: cf,
	TorusGeometry: hf,
	TorusKnotGeometry: uf,
	TubeGeometry: df,
	WireframeGeometry: NE,
});
class FE extends vn {
	constructor(e) {
		super(),
			(this.isShadowMaterial = !0),
			(this.type = 'ShadowMaterial'),
			(this.color = new Ee(0)),
			(this.transparent = !0),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
	}
}
class BE extends xn {
	constructor(e) {
		super(e), (this.isRawShaderMaterial = !0), (this.type = 'RawShaderMaterial');
	}
}
class Ha extends vn {
	constructor(e) {
		super(),
			(this.isMeshStandardMaterial = !0),
			(this.defines = { STANDARD: '' }),
			(this.type = 'MeshStandardMaterial'),
			(this.color = new Ee(16777215)),
			(this.roughness = 1),
			(this.metalness = 0),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ee(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = Ro),
			(this.normalScale = new ce(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.roughnessMap = null),
			(this.metalnessMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.envMapRotation = new zi()),
			(this.envMapIntensity = 1),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.flatShading = !1),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.defines = { STANDARD: '' }),
			this.color.copy(e.color),
			(this.roughness = e.roughness),
			(this.metalness = e.metalness),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.roughnessMap = e.roughnessMap),
			(this.metalnessMap = e.metalnessMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			this.envMapRotation.copy(e.envMapRotation),
			(this.envMapIntensity = e.envMapIntensity),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.flatShading = e.flatShading),
			(this.fog = e.fog),
			this
		);
	}
}
class ls extends Ha {
	constructor(e) {
		super(),
			(this.isMeshPhysicalMaterial = !0),
			(this.defines = { STANDARD: '', PHYSICAL: '' }),
			(this.type = 'MeshPhysicalMaterial'),
			(this.anisotropyRotation = 0),
			(this.anisotropyMap = null),
			(this.clearcoatMap = null),
			(this.clearcoatRoughness = 0),
			(this.clearcoatRoughnessMap = null),
			(this.clearcoatNormalScale = new ce(1, 1)),
			(this.clearcoatNormalMap = null),
			(this.ior = 1.5),
			Object.defineProperty(this, 'reflectivity', {
				get: function () {
					return ln((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
				},
				set: function (t) {
					this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
				},
			}),
			(this.iridescenceMap = null),
			(this.iridescenceIOR = 1.3),
			(this.iridescenceThicknessRange = [100, 400]),
			(this.iridescenceThicknessMap = null),
			(this.sheenColor = new Ee(0)),
			(this.sheenColorMap = null),
			(this.sheenRoughness = 1),
			(this.sheenRoughnessMap = null),
			(this.transmissionMap = null),
			(this.thickness = 0),
			(this.thicknessMap = null),
			(this.attenuationDistance = 1 / 0),
			(this.attenuationColor = new Ee(1, 1, 1)),
			(this.specularIntensity = 1),
			(this.specularIntensityMap = null),
			(this.specularColor = new Ee(1, 1, 1)),
			(this.specularColorMap = null),
			(this._anisotropy = 0),
			(this._clearcoat = 0),
			(this._dispersion = 0),
			(this._iridescence = 0),
			(this._sheen = 0),
			(this._transmission = 0),
			this.setValues(e);
	}
	get anisotropy() {
		return this._anisotropy;
	}
	set anisotropy(e) {
		this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
	}
	get clearcoat() {
		return this._clearcoat;
	}
	set clearcoat(e) {
		this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
	}
	get iridescence() {
		return this._iridescence;
	}
	set iridescence(e) {
		this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
	}
	get dispersion() {
		return this._dispersion;
	}
	set dispersion(e) {
		this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
	}
	get sheen() {
		return this._sheen;
	}
	set sheen(e) {
		this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
	}
	get transmission() {
		return this._transmission;
	}
	set transmission(e) {
		this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.defines = { STANDARD: '', PHYSICAL: '' }),
			(this.anisotropy = e.anisotropy),
			(this.anisotropyRotation = e.anisotropyRotation),
			(this.anisotropyMap = e.anisotropyMap),
			(this.clearcoat = e.clearcoat),
			(this.clearcoatMap = e.clearcoatMap),
			(this.clearcoatRoughness = e.clearcoatRoughness),
			(this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
			(this.clearcoatNormalMap = e.clearcoatNormalMap),
			this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
			(this.dispersion = e.dispersion),
			(this.ior = e.ior),
			(this.iridescence = e.iridescence),
			(this.iridescenceMap = e.iridescenceMap),
			(this.iridescenceIOR = e.iridescenceIOR),
			(this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
			(this.iridescenceThicknessMap = e.iridescenceThicknessMap),
			(this.sheen = e.sheen),
			this.sheenColor.copy(e.sheenColor),
			(this.sheenColorMap = e.sheenColorMap),
			(this.sheenRoughness = e.sheenRoughness),
			(this.sheenRoughnessMap = e.sheenRoughnessMap),
			(this.transmission = e.transmission),
			(this.transmissionMap = e.transmissionMap),
			(this.thickness = e.thickness),
			(this.thicknessMap = e.thicknessMap),
			(this.attenuationDistance = e.attenuationDistance),
			this.attenuationColor.copy(e.attenuationColor),
			(this.specularIntensity = e.specularIntensity),
			(this.specularIntensityMap = e.specularIntensityMap),
			this.specularColor.copy(e.specularColor),
			(this.specularColorMap = e.specularColorMap),
			this
		);
	}
}
class kE extends vn {
	constructor(e) {
		super(),
			(this.isMeshPhongMaterial = !0),
			(this.type = 'MeshPhongMaterial'),
			(this.color = new Ee(16777215)),
			(this.specular = new Ee(1118481)),
			(this.shininess = 30),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ee(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = Ro),
			(this.normalScale = new ce(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.specularMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.envMapRotation = new zi()),
			(this.combine = Kh),
			(this.reflectivity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.flatShading = !1),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			this.specular.copy(e.specular),
			(this.shininess = e.shininess),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.specularMap = e.specularMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			this.envMapRotation.copy(e.envMapRotation),
			(this.combine = e.combine),
			(this.reflectivity = e.reflectivity),
			(this.refractionRatio = e.refractionRatio),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.flatShading = e.flatShading),
			(this.fog = e.fog),
			this
		);
	}
}
class zE extends vn {
	constructor(e) {
		super(),
			(this.isMeshToonMaterial = !0),
			(this.defines = { TOON: '' }),
			(this.type = 'MeshToonMaterial'),
			(this.color = new Ee(16777215)),
			(this.map = null),
			(this.gradientMap = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ee(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = Ro),
			(this.normalScale = new ce(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.alphaMap = null),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.gradientMap = e.gradientMap),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.alphaMap = e.alphaMap),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.fog = e.fog),
			this
		);
	}
}
class VE extends vn {
	constructor(e) {
		super(),
			(this.isMeshNormalMaterial = !0),
			(this.type = 'MeshNormalMaterial'),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = Ro),
			(this.normalScale = new ce(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.flatShading = !1),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.flatShading = e.flatShading),
			this
		);
	}
}
class HE extends vn {
	constructor(e) {
		super(),
			(this.isMeshLambertMaterial = !0),
			(this.type = 'MeshLambertMaterial'),
			(this.color = new Ee(16777215)),
			(this.map = null),
			(this.lightMap = null),
			(this.lightMapIntensity = 1),
			(this.aoMap = null),
			(this.aoMapIntensity = 1),
			(this.emissive = new Ee(0)),
			(this.emissiveIntensity = 1),
			(this.emissiveMap = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = Ro),
			(this.normalScale = new ce(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.specularMap = null),
			(this.alphaMap = null),
			(this.envMap = null),
			(this.envMapRotation = new zi()),
			(this.combine = Kh),
			(this.reflectivity = 1),
			(this.refractionRatio = 0.98),
			(this.wireframe = !1),
			(this.wireframeLinewidth = 1),
			(this.wireframeLinecap = 'round'),
			(this.wireframeLinejoin = 'round'),
			(this.flatShading = !1),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			this.color.copy(e.color),
			(this.map = e.map),
			(this.lightMap = e.lightMap),
			(this.lightMapIntensity = e.lightMapIntensity),
			(this.aoMap = e.aoMap),
			(this.aoMapIntensity = e.aoMapIntensity),
			this.emissive.copy(e.emissive),
			(this.emissiveMap = e.emissiveMap),
			(this.emissiveIntensity = e.emissiveIntensity),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.specularMap = e.specularMap),
			(this.alphaMap = e.alphaMap),
			(this.envMap = e.envMap),
			this.envMapRotation.copy(e.envMapRotation),
			(this.combine = e.combine),
			(this.reflectivity = e.reflectivity),
			(this.refractionRatio = e.refractionRatio),
			(this.wireframe = e.wireframe),
			(this.wireframeLinewidth = e.wireframeLinewidth),
			(this.wireframeLinecap = e.wireframeLinecap),
			(this.wireframeLinejoin = e.wireframeLinejoin),
			(this.flatShading = e.flatShading),
			(this.fog = e.fog),
			this
		);
	}
}
class GE extends vn {
	constructor(e) {
		super(),
			(this.isMeshMatcapMaterial = !0),
			(this.defines = { MATCAP: '' }),
			(this.type = 'MeshMatcapMaterial'),
			(this.color = new Ee(16777215)),
			(this.matcap = null),
			(this.map = null),
			(this.bumpMap = null),
			(this.bumpScale = 1),
			(this.normalMap = null),
			(this.normalMapType = Ro),
			(this.normalScale = new ce(1, 1)),
			(this.displacementMap = null),
			(this.displacementScale = 1),
			(this.displacementBias = 0),
			(this.alphaMap = null),
			(this.flatShading = !1),
			(this.fog = !0),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.defines = { MATCAP: '' }),
			this.color.copy(e.color),
			(this.matcap = e.matcap),
			(this.map = e.map),
			(this.bumpMap = e.bumpMap),
			(this.bumpScale = e.bumpScale),
			(this.normalMap = e.normalMap),
			(this.normalMapType = e.normalMapType),
			this.normalScale.copy(e.normalScale),
			(this.displacementMap = e.displacementMap),
			(this.displacementScale = e.displacementScale),
			(this.displacementBias = e.displacementBias),
			(this.alphaMap = e.alphaMap),
			(this.flatShading = e.flatShading),
			(this.fog = e.fog),
			this
		);
	}
}
class WE extends Jn {
	constructor(e) {
		super(),
			(this.isLineDashedMaterial = !0),
			(this.type = 'LineDashedMaterial'),
			(this.scale = 1),
			(this.dashSize = 3),
			(this.gapSize = 1),
			this.setValues(e);
	}
	copy(e) {
		return super.copy(e), (this.scale = e.scale), (this.dashSize = e.dashSize), (this.gapSize = e.gapSize), this;
	}
}
function ua(i, e, t) {
	return !i || (!t && i.constructor === e) ? i : typeof e.BYTES_PER_ELEMENT == 'number' ? new e(i) : Array.prototype.slice.call(i);
}
function XE(i) {
	return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function qE(i) {
	function e(s, r) {
		return i[s] - i[r];
	}
	const t = i.length,
		n = new Array(t);
	for (let s = 0; s !== t; ++s) n[s] = s;
	return n.sort(e), n;
}
function av(i, e, t) {
	const n = i.length,
		s = new i.constructor(n);
	for (let r = 0, o = 0; o !== n; ++r) {
		const a = t[r] * e;
		for (let l = 0; l !== e; ++l) s[o++] = i[a + l];
	}
	return s;
}
function H_(i, e, t, n) {
	let s = 1,
		r = i[0];
	for (; r !== void 0 && r[n] === void 0; ) r = i[s++];
	if (r === void 0) return;
	let o = r[n];
	if (o !== void 0)
		if (Array.isArray(o))
			do (o = r[n]), o !== void 0 && (e.push(r.time), t.push.apply(t, o)), (r = i[s++]);
			while (r !== void 0);
		else if (o.toArray !== void 0)
			do (o = r[n]), o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), (r = i[s++]);
			while (r !== void 0);
		else
			do (o = r[n]), o !== void 0 && (e.push(r.time), t.push(o)), (r = i[s++]);
			while (r !== void 0);
}
function jN(i, e, t, n, s = 30) {
	const r = i.clone();
	r.name = e;
	const o = [];
	for (let l = 0; l < r.tracks.length; ++l) {
		const c = r.tracks[l],
			h = c.getValueSize(),
			u = [],
			d = [];
		for (let p = 0; p < c.times.length; ++p) {
			const g = c.times[p] * s;
			if (!(g < t || g >= n)) {
				u.push(c.times[p]);
				for (let v = 0; v < h; ++v) d.push(c.values[p * h + v]);
			}
		}
		u.length !== 0 && ((c.times = ua(u, c.times.constructor)), (c.values = ua(d, c.values.constructor)), o.push(c));
	}
	r.tracks = o;
	let a = 1 / 0;
	for (let l = 0; l < r.tracks.length; ++l) a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
	for (let l = 0; l < r.tracks.length; ++l) r.tracks[l].shift(-1 * a);
	return r.resetDuration(), r;
}
function KN(i, e = 0, t = i, n = 30) {
	n <= 0 && (n = 30);
	const s = t.tracks.length,
		r = e / n;
	for (let o = 0; o < s; ++o) {
		const a = t.tracks[o],
			l = a.ValueTypeName;
		if (l === 'bool' || l === 'string') continue;
		const c = i.tracks.find(function (f) {
			return f.name === a.name && f.ValueTypeName === l;
		});
		if (c === void 0) continue;
		let h = 0;
		const u = a.getValueSize();
		a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = u / 3);
		let d = 0;
		const p = c.getValueSize();
		c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = p / 3);
		const g = a.times.length - 1;
		let v;
		if (r <= a.times[0]) {
			const f = h,
				y = u - h;
			v = a.values.slice(f, y);
		} else if (r >= a.times[g]) {
			const f = g * u + h,
				y = f + u - h;
			v = a.values.slice(f, y);
		} else {
			const f = a.createInterpolant(),
				y = h,
				_ = u - h;
			f.evaluate(r), (v = f.resultBuffer.slice(y, _));
		}
		l === 'quaternion' && new kn().fromArray(v).normalize().conjugate().toArray(v);
		const m = c.times.length;
		for (let f = 0; f < m; ++f) {
			const y = f * p + d;
			if (l === 'quaternion') kn.multiplyQuaternionsFlat(c.values, y, v, 0, c.values, y);
			else {
				const _ = p - d * 2;
				for (let x = 0; x < _; ++x) c.values[y + x] -= v[x];
			}
		}
	}
	return (i.blendMode = w_), i;
}
const $N = {
	convertArray: ua,
	isTypedArray: XE,
	getKeyframeOrder: qE,
	sortedArray: av,
	flattenJSON: H_,
	subclip: jN,
	makeClipAdditive: KN,
};
class uc {
	constructor(e, t, n, s) {
		(this.parameterPositions = e),
			(this._cachedIndex = 0),
			(this.resultBuffer = s !== void 0 ? s : new t.constructor(n)),
			(this.sampleValues = t),
			(this.valueSize = n),
			(this.settings = null),
			(this.DefaultSettings_ = {});
	}
	evaluate(e) {
		const t = this.parameterPositions;
		let n = this._cachedIndex,
			s = t[n],
			r = t[n - 1];
		e: {
			t: {
				let o;
				n: {
					i: if (!(e < s)) {
						for (let a = n + 2; ; ) {
							if (s === void 0) {
								if (e < r) break i;
								return (n = t.length), (this._cachedIndex = n), this.copySampleValue_(n - 1);
							}
							if (n === a) break;
							if (((r = s), (s = t[++n]), e < s)) break t;
						}
						o = t.length;
						break n;
					}
					if (!(e >= r)) {
						const a = t[1];
						e < a && ((n = 2), (r = a));
						for (let l = n - 2; ; ) {
							if (r === void 0) return (this._cachedIndex = 0), this.copySampleValue_(0);
							if (n === l) break;
							if (((s = r), (r = t[--n - 1]), e >= r)) break t;
						}
						(o = n), (n = 0);
						break n;
					}
					break e;
				}
				for (; n < o; ) {
					const a = (n + o) >>> 1;
					e < t[a] ? (o = a) : (n = a + 1);
				}
				if (((s = t[n]), (r = t[n - 1]), r === void 0)) return (this._cachedIndex = 0), this.copySampleValue_(0);
				if (s === void 0) return (n = t.length), (this._cachedIndex = n), this.copySampleValue_(n - 1);
			}
			(this._cachedIndex = n), this.intervalChanged_(n, r, s);
		}
		return this.interpolate_(n, r, e, s);
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_;
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			n = this.sampleValues,
			s = this.valueSize,
			r = e * s;
		for (let o = 0; o !== s; ++o) t[o] = n[r + o];
		return t;
	}
	interpolate_() {
		throw new Error('call to abstract method');
	}
	intervalChanged_() {}
}
class YE extends uc {
	constructor(e, t, n, s) {
		super(e, t, n, s),
			(this._weightPrev = -0),
			(this._offsetPrev = -0),
			(this._weightNext = -0),
			(this._offsetNext = -0),
			(this.DefaultSettings_ = { endingStart: aa, endingEnd: aa });
	}
	intervalChanged_(e, t, n) {
		const s = this.parameterPositions;
		let r = e - 2,
			o = e + 1,
			a = s[r],
			l = s[o];
		if (a === void 0)
			switch (this.getSettings_().endingStart) {
				case la:
					(r = e), (a = 2 * t - n);
					break;
				case xh:
					(r = s.length - 2), (a = t + s[r] - s[r + 1]);
					break;
				default:
					(r = e), (a = n);
			}
		if (l === void 0)
			switch (this.getSettings_().endingEnd) {
				case la:
					(o = e), (l = 2 * n - t);
					break;
				case xh:
					(o = 1), (l = n + s[1] - s[0]);
					break;
				default:
					(o = e - 1), (l = t);
			}
		const c = (n - t) * 0.5,
			h = this.valueSize;
		(this._weightPrev = c / (t - a)), (this._weightNext = c / (l - n)), (this._offsetPrev = r * h), (this._offsetNext = o * h);
	}
	interpolate_(e, t, n, s) {
		const r = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = e * a,
			c = l - a,
			h = this._offsetPrev,
			u = this._offsetNext,
			d = this._weightPrev,
			p = this._weightNext,
			g = (n - t) / (s - t),
			v = g * g,
			m = v * g,
			f = -d * m + 2 * d * v - d * g,
			y = (1 + d) * m + (-1.5 - 2 * d) * v + (-0.5 + d) * g + 1,
			_ = (-1 - p) * m + (1.5 + p) * v + 0.5 * g,
			x = p * m - p * v;
		for (let E = 0; E !== a; ++E) r[E] = f * o[h + E] + y * o[c + E] + _ * o[l + E] + x * o[u + E];
		return r;
	}
}
class G_ extends uc {
	constructor(e, t, n, s) {
		super(e, t, n, s);
	}
	interpolate_(e, t, n, s) {
		const r = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = e * a,
			c = l - a,
			h = (n - t) / (s - t),
			u = 1 - h;
		for (let d = 0; d !== a; ++d) r[d] = o[c + d] * u + o[l + d] * h;
		return r;
	}
}
class jE extends uc {
	constructor(e, t, n, s) {
		super(e, t, n, s);
	}
	interpolate_(e) {
		return this.copySampleValue_(e - 1);
	}
}
class As {
	constructor(e, t, n, s) {
		if (e === void 0) throw new Error('THREE.KeyframeTrack: track name is undefined');
		if (t === void 0 || t.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + e);
		(this.name = e),
			(this.times = ua(t, this.TimeBufferType)),
			(this.values = ua(n, this.ValueBufferType)),
			this.setInterpolation(s || this.DefaultInterpolation);
	}
	static toJSON(e) {
		const t = e.constructor;
		let n;
		if (t.toJSON !== this.toJSON) n = t.toJSON(e);
		else {
			n = { name: e.name, times: ua(e.times, Array), values: ua(e.values, Array) };
			const s = e.getInterpolation();
			s !== e.DefaultInterpolation && (n.interpolation = s);
		}
		return (n.type = e.ValueTypeName), n;
	}
	InterpolantFactoryMethodDiscrete(e) {
		return new jE(this.times, this.values, this.getValueSize(), e);
	}
	InterpolantFactoryMethodLinear(e) {
		return new G_(this.times, this.values, this.getValueSize(), e);
	}
	InterpolantFactoryMethodSmooth(e) {
		return new YE(this.times, this.values, this.getValueSize(), e);
	}
	setInterpolation(e) {
		let t;
		switch (e) {
			case $l:
				t = this.InterpolantFactoryMethodDiscrete;
				break;
			case Aa:
				t = this.InterpolantFactoryMethodLinear;
				break;
			case zd:
				t = this.InterpolantFactoryMethodSmooth;
				break;
		}
		if (t === void 0) {
			const n = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
			if (this.createInterpolant === void 0)
				if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
				else throw new Error(n);
			return console.warn('THREE.KeyframeTrack:', n), this;
		}
		return (this.createInterpolant = t), this;
	}
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return $l;
			case this.InterpolantFactoryMethodLinear:
				return Aa;
			case this.InterpolantFactoryMethodSmooth:
				return zd;
		}
	}
	getValueSize() {
		return this.values.length / this.times.length;
	}
	shift(e) {
		if (e !== 0) {
			const t = this.times;
			for (let n = 0, s = t.length; n !== s; ++n) t[n] += e;
		}
		return this;
	}
	scale(e) {
		if (e !== 1) {
			const t = this.times;
			for (let n = 0, s = t.length; n !== s; ++n) t[n] *= e;
		}
		return this;
	}
	trim(e, t) {
		const n = this.times,
			s = n.length;
		let r = 0,
			o = s - 1;
		for (; r !== s && n[r] < e; ) ++r;
		for (; o !== -1 && n[o] > t; ) --o;
		if ((++o, r !== 0 || o !== s)) {
			r >= o && ((o = Math.max(o, 1)), (r = o - 1));
			const a = this.getValueSize();
			(this.times = n.slice(r, o)), (this.values = this.values.slice(r * a, o * a));
		}
		return this;
	}
	validate() {
		let e = !0;
		const t = this.getValueSize();
		t - Math.floor(t) !== 0 && (console.error('THREE.KeyframeTrack: Invalid value size in track.', this), (e = !1));
		const n = this.times,
			s = this.values,
			r = n.length;
		r === 0 && (console.error('THREE.KeyframeTrack: Track is empty.', this), (e = !1));
		let o = null;
		for (let a = 0; a !== r; a++) {
			const l = n[a];
			if (typeof l == 'number' && isNaN(l)) {
				console.error('THREE.KeyframeTrack: Time is not a valid number.', this, a, l), (e = !1);
				break;
			}
			if (o !== null && o > l) {
				console.error('THREE.KeyframeTrack: Out of order keys.', this, a, l, o), (e = !1);
				break;
			}
			o = l;
		}
		if (s !== void 0 && XE(s))
			for (let a = 0, l = s.length; a !== l; ++a) {
				const c = s[a];
				if (isNaN(c)) {
					console.error('THREE.KeyframeTrack: Value is not a valid number.', this, a, c), (e = !1);
					break;
				}
			}
		return e;
	}
	optimize() {
		const e = this.times.slice(),
			t = this.values.slice(),
			n = this.getValueSize(),
			s = this.getInterpolation() === zd,
			r = e.length - 1;
		let o = 1;
		for (let a = 1; a < r; ++a) {
			let l = !1;
			const c = e[a],
				h = e[a + 1];
			if (c !== h && (a !== 1 || c !== e[0]))
				if (s) l = !0;
				else {
					const u = a * n,
						d = u - n,
						p = u + n;
					for (let g = 0; g !== n; ++g) {
						const v = t[u + g];
						if (v !== t[d + g] || v !== t[p + g]) {
							l = !0;
							break;
						}
					}
				}
			if (l) {
				if (a !== o) {
					e[o] = e[a];
					const u = a * n,
						d = o * n;
					for (let p = 0; p !== n; ++p) t[d + p] = t[u + p];
				}
				++o;
			}
		}
		if (r > 0) {
			e[o] = e[r];
			for (let a = r * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
			++o;
		}
		return (
			o !== e.length ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * n))) : ((this.times = e), (this.values = t)), this
		);
	}
	clone() {
		const e = this.times.slice(),
			t = this.values.slice(),
			n = this.constructor,
			s = new n(this.name, e, t);
		return (s.createInterpolant = this.createInterpolant), s;
	}
}
As.prototype.TimeBufferType = Float32Array;
As.prototype.ValueBufferType = Float32Array;
As.prototype.DefaultInterpolation = Aa;
class Ga extends As {}
Ga.prototype.ValueTypeName = 'bool';
Ga.prototype.ValueBufferType = Array;
Ga.prototype.DefaultInterpolation = $l;
Ga.prototype.InterpolantFactoryMethodLinear = void 0;
Ga.prototype.InterpolantFactoryMethodSmooth = void 0;
class W_ extends As {}
W_.prototype.ValueTypeName = 'color';
class Pa extends As {}
Pa.prototype.ValueTypeName = 'number';
class KE extends uc {
	constructor(e, t, n, s) {
		super(e, t, n, s);
	}
	interpolate_(e, t, n, s) {
		const r = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = (n - t) / (s - t);
		let c = e * a;
		for (let h = c + a; c !== h; c += 4) kn.slerpFlat(r, 0, o, c - a, o, c, l);
		return r;
	}
}
class bo extends As {
	InterpolantFactoryMethodLinear(e) {
		return new KE(this.times, this.values, this.getValueSize(), e);
	}
}
bo.prototype.ValueTypeName = 'quaternion';
bo.prototype.DefaultInterpolation = Aa;
bo.prototype.InterpolantFactoryMethodSmooth = void 0;
class Wa extends As {}
Wa.prototype.ValueTypeName = 'string';
Wa.prototype.ValueBufferType = Array;
Wa.prototype.DefaultInterpolation = $l;
Wa.prototype.InterpolantFactoryMethodLinear = void 0;
Wa.prototype.InterpolantFactoryMethodSmooth = void 0;
class La extends As {}
La.prototype.ValueTypeName = 'vector';
class Ql {
	constructor(e = '', t = -1, n = [], s = kp) {
		(this.name = e),
			(this.tracks = n),
			(this.duration = t),
			(this.blendMode = s),
			(this.uuid = Bi()),
			this.duration < 0 && this.resetDuration();
	}
	static parse(e) {
		const t = [],
			n = e.tracks,
			s = 1 / (e.fps || 1);
		for (let o = 0, a = n.length; o !== a; ++o) t.push(JN(n[o]).scale(s));
		const r = new this(e.name, e.duration, t, e.blendMode);
		return (r.uuid = e.uuid), r;
	}
	static toJSON(e) {
		const t = [],
			n = e.tracks,
			s = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
		for (let r = 0, o = n.length; r !== o; ++r) t.push(As.toJSON(n[r]));
		return s;
	}
	static CreateFromMorphTargetSequence(e, t, n, s) {
		const r = t.length,
			o = [];
		for (let a = 0; a < r; a++) {
			let l = [],
				c = [];
			l.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0);
			const h = qE(l);
			(l = av(l, 1, h)),
				(c = av(c, 1, h)),
				!s && l[0] === 0 && (l.push(r), c.push(c[0])),
				o.push(new Pa('.morphTargetInfluences[' + t[a].name + ']', l, c).scale(1 / n));
		}
		return new this(e, -1, o);
	}
	static findByName(e, t) {
		let n = e;
		if (!Array.isArray(e)) {
			const s = e;
			n = (s.geometry && s.geometry.animations) || s.animations;
		}
		for (let s = 0; s < n.length; s++) if (n[s].name === t) return n[s];
		return null;
	}
	static CreateClipsFromMorphTargetSequences(e, t, n) {
		const s = {},
			r = /^([\w-]*?)([\d]+)$/;
		for (let a = 0, l = e.length; a < l; a++) {
			const c = e[a],
				h = c.name.match(r);
			if (h && h.length > 1) {
				const u = h[1];
				let d = s[u];
				d || (s[u] = d = []), d.push(c);
			}
		}
		const o = [];
		for (const a in s) o.push(this.CreateFromMorphTargetSequence(a, s[a], t, n));
		return o;
	}
	static parseAnimation(e, t) {
		if (!e) return console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null;
		const n = function (u, d, p, g, v) {
				if (p.length !== 0) {
					const m = [],
						f = [];
					H_(p, m, f, g), m.length !== 0 && v.push(new u(d, m, f));
				}
			},
			s = [],
			r = e.name || 'default',
			o = e.fps || 30,
			a = e.blendMode;
		let l = e.length || -1;
		const c = e.hierarchy || [];
		for (let u = 0; u < c.length; u++) {
			const d = c[u].keys;
			if (!(!d || d.length === 0))
				if (d[0].morphTargets) {
					const p = {};
					let g;
					for (g = 0; g < d.length; g++)
						if (d[g].morphTargets) for (let v = 0; v < d[g].morphTargets.length; v++) p[d[g].morphTargets[v]] = -1;
					for (const v in p) {
						const m = [],
							f = [];
						for (let y = 0; y !== d[g].morphTargets.length; ++y) {
							const _ = d[g];
							m.push(_.time), f.push(_.morphTarget === v ? 1 : 0);
						}
						s.push(new Pa('.morphTargetInfluence[' + v + ']', m, f));
					}
					l = p.length * o;
				} else {
					const p = '.bones[' + t[u].name + ']';
					n(La, p + '.position', d, 'pos', s), n(bo, p + '.quaternion', d, 'rot', s), n(La, p + '.scale', d, 'scl', s);
				}
		}
		return s.length === 0 ? null : new this(r, l, s, a);
	}
	resetDuration() {
		const e = this.tracks;
		let t = 0;
		for (let n = 0, s = e.length; n !== s; ++n) {
			const r = this.tracks[n];
			t = Math.max(t, r.times[r.times.length - 1]);
		}
		return (this.duration = t), this;
	}
	trim() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
		return this;
	}
	validate() {
		let e = !0;
		for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
		return e;
	}
	optimize() {
		for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
		return this;
	}
	clone() {
		const e = [];
		for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
		return new this.constructor(this.name, this.duration, e, this.blendMode);
	}
	toJSON() {
		return this.constructor.toJSON(this);
	}
}
function ZN(i) {
	switch (i.toLowerCase()) {
		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':
			return Pa;
		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':
			return La;
		case 'color':
			return W_;
		case 'quaternion':
			return bo;
		case 'bool':
		case 'boolean':
			return Ga;
		case 'string':
			return Wa;
	}
	throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + i);
}
function JN(i) {
	if (i.type === void 0) throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
	const e = ZN(i.type);
	if (i.times === void 0) {
		const t = [],
			n = [];
		H_(i.keys, t, n, 'value'), (i.times = t), (i.values = n);
	}
	return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
const Hs = {
	enabled: !1,
	files: {},
	add: function (i, e) {
		this.enabled !== !1 && (this.files[i] = e);
	},
	get: function (i) {
		if (this.enabled !== !1) return this.files[i];
	},
	remove: function (i) {
		delete this.files[i];
	},
	clear: function () {
		this.files = {};
	},
};
class pf {
	constructor(e, t, n) {
		const s = this;
		let r = !1,
			o = 0,
			a = 0,
			l;
		const c = [];
		(this.onStart = void 0),
			(this.onLoad = e),
			(this.onProgress = t),
			(this.onError = n),
			(this.itemStart = function (h) {
				a++, r === !1 && s.onStart !== void 0 && s.onStart(h, o, a), (r = !0);
			}),
			(this.itemEnd = function (h) {
				o++, s.onProgress !== void 0 && s.onProgress(h, o, a), o === a && ((r = !1), s.onLoad !== void 0 && s.onLoad());
			}),
			(this.itemError = function (h) {
				s.onError !== void 0 && s.onError(h);
			}),
			(this.resolveURL = function (h) {
				return l ? l(h) : h;
			}),
			(this.setURLModifier = function (h) {
				return (l = h), this;
			}),
			(this.addHandler = function (h, u) {
				return c.push(h, u), this;
			}),
			(this.removeHandler = function (h) {
				const u = c.indexOf(h);
				return u !== -1 && c.splice(u, 2), this;
			}),
			(this.getHandler = function (h) {
				for (let u = 0, d = c.length; u < d; u += 2) {
					const p = c[u],
						g = c[u + 1];
					if ((p.global && (p.lastIndex = 0), p.test(h))) return g;
				}
				return null;
			});
	}
}
const $E = new pf();
class Qn {
	constructor(e) {
		(this.manager = e !== void 0 ? e : $E),
			(this.crossOrigin = 'anonymous'),
			(this.withCredentials = !1),
			(this.path = ''),
			(this.resourcePath = ''),
			(this.requestHeader = {});
	}
	load() {}
	loadAsync(e, t) {
		const n = this;
		return new Promise(function (s, r) {
			n.load(e, s, t, r);
		});
	}
	parse() {}
	setCrossOrigin(e) {
		return (this.crossOrigin = e), this;
	}
	setWithCredentials(e) {
		return (this.withCredentials = e), this;
	}
	setPath(e) {
		return (this.path = e), this;
	}
	setResourcePath(e) {
		return (this.resourcePath = e), this;
	}
	setRequestHeader(e) {
		return (this.requestHeader = e), this;
	}
}
Qn.DEFAULT_MATERIAL_NAME = '__DEFAULT';
const rr = {};
class QN extends Error {
	constructor(e, t) {
		super(e), (this.response = t);
	}
}
class Si extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		e === void 0 && (e = ''), this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
		const r = Hs.get(e);
		if (r !== void 0)
			return (
				this.manager.itemStart(e),
				setTimeout(() => {
					t && t(r), this.manager.itemEnd(e);
				}, 0),
				r
			);
		if (rr[e] !== void 0) {
			rr[e].push({ onLoad: t, onProgress: n, onError: s });
			return;
		}
		(rr[e] = []), rr[e].push({ onLoad: t, onProgress: n, onError: s });
		const o = new Request(e, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? 'include' : 'same-origin',
			}),
			a = this.mimeType,
			l = this.responseType;
		fetch(o)
			.then((c) => {
				if (c.status === 200 || c.status === 0) {
					if (
						(c.status === 0 && console.warn('THREE.FileLoader: HTTP Status 0 received.'),
						typeof ReadableStream > 'u' || c.body === void 0 || c.body.getReader === void 0)
					)
						return c;
					const h = rr[e],
						u = c.body.getReader(),
						d = c.headers.get('X-File-Size') || c.headers.get('Content-Length'),
						p = d ? parseInt(d) : 0,
						g = p !== 0;
					let v = 0;
					const m = new ReadableStream({
						start(f) {
							y();
							function y() {
								u.read().then(({ done: _, value: x }) => {
									if (_) f.close();
									else {
										v += x.byteLength;
										const E = new ProgressEvent('progress', { lengthComputable: g, loaded: v, total: p });
										for (let w = 0, C = h.length; w < C; w++) {
											const P = h[w];
											P.onProgress && P.onProgress(E);
										}
										f.enqueue(x), y();
									}
								});
							}
						},
					});
					return new Response(m);
				} else throw new QN('fetch for "'.concat(c.url, '" responded with ').concat(c.status, ': ').concat(c.statusText), c);
			})
			.then((c) => {
				switch (l) {
					case 'arraybuffer':
						return c.arrayBuffer();
					case 'blob':
						return c.blob();
					case 'document':
						return c.text().then((h) => new DOMParser().parseFromString(h, a));
					case 'json':
						return c.json();
					default:
						if (a === void 0) return c.text();
						{
							const u = /charset="?([^;"\s]*)"?/i.exec(a),
								d = u && u[1] ? u[1].toLowerCase() : void 0,
								p = new TextDecoder(d);
							return c.arrayBuffer().then((g) => p.decode(g));
						}
				}
			})
			.then((c) => {
				Hs.add(e, c);
				const h = rr[e];
				delete rr[e];
				for (let u = 0, d = h.length; u < d; u++) {
					const p = h[u];
					p.onLoad && p.onLoad(c);
				}
			})
			.catch((c) => {
				const h = rr[e];
				if (h === void 0) throw (this.manager.itemError(e), c);
				delete rr[e];
				for (let u = 0, d = h.length; u < d; u++) {
					const p = h[u];
					p.onError && p.onError(c);
				}
				this.manager.itemError(e);
			})
			.finally(() => {
				this.manager.itemEnd(e);
			}),
			this.manager.itemStart(e);
	}
	setResponseType(e) {
		return (this.responseType = e), this;
	}
	setMimeType(e) {
		return (this.mimeType = e), this;
	}
}
class e3 extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = this,
			o = new Si(this.manager);
		o.setPath(this.path),
			o.setRequestHeader(this.requestHeader),
			o.setWithCredentials(this.withCredentials),
			o.load(
				e,
				function (a) {
					try {
						t(r.parse(JSON.parse(a)));
					} catch (l) {
						s ? s(l) : console.error(l), r.manager.itemError(e);
					}
				},
				n,
				s
			);
	}
	parse(e) {
		const t = [];
		for (let n = 0; n < e.length; n++) {
			const s = Ql.parse(e[n]);
			t.push(s);
		}
		return t;
	}
}
class t3 extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = this,
			o = [],
			a = new $p(),
			l = new Si(this.manager);
		l.setPath(this.path),
			l.setResponseType('arraybuffer'),
			l.setRequestHeader(this.requestHeader),
			l.setWithCredentials(r.withCredentials);
		let c = 0;
		function h(u) {
			l.load(
				e[u],
				function (d) {
					const p = r.parse(d, !0);
					(o[u] = { width: p.width, height: p.height, format: p.format, mipmaps: p.mipmaps }),
						(c += 1),
						c === 6 &&
							(p.mipmapCount === 1 && (a.minFilter = Tt),
							(a.image = o),
							(a.format = p.format),
							(a.needsUpdate = !0),
							t && t(a));
				},
				n,
				s
			);
		}
		if (Array.isArray(e)) for (let u = 0, d = e.length; u < d; ++u) h(u);
		else
			l.load(
				e,
				function (u) {
					const d = r.parse(u, !0);
					if (d.isCubemap) {
						const p = d.mipmaps.length / d.mipmapCount;
						for (let g = 0; g < p; g++) {
							o[g] = { mipmaps: [] };
							for (let v = 0; v < d.mipmapCount; v++)
								o[g].mipmaps.push(d.mipmaps[g * d.mipmapCount + v]),
									(o[g].format = d.format),
									(o[g].width = d.width),
									(o[g].height = d.height);
						}
						a.image = o;
					} else (a.image.width = d.width), (a.image.height = d.height), (a.mipmaps = d.mipmaps);
					d.mipmapCount === 1 && (a.minFilter = Tt), (a.format = d.format), (a.needsUpdate = !0), t && t(a);
				},
				n,
				s
			);
		return a;
	}
}
class Dh extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
		const r = this,
			o = Hs.get(e);
		if (o !== void 0)
			return (
				r.manager.itemStart(e),
				setTimeout(function () {
					t && t(o), r.manager.itemEnd(e);
				}, 0),
				o
			);
		const a = Th('img');
		function l() {
			h(), Hs.add(e, this), t && t(this), r.manager.itemEnd(e);
		}
		function c(u) {
			h(), s && s(u), r.manager.itemError(e), r.manager.itemEnd(e);
		}
		function h() {
			a.removeEventListener('load', l, !1), a.removeEventListener('error', c, !1);
		}
		return (
			a.addEventListener('load', l, !1),
			a.addEventListener('error', c, !1),
			e.slice(0, 5) !== 'data:' && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
			r.manager.itemStart(e),
			(a.src = e),
			a
		);
	}
}
class n3 extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = new Jh();
		r.colorSpace = ot;
		const o = new Dh(this.manager);
		o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
		let a = 0;
		function l(c) {
			o.load(
				e[c],
				function (h) {
					(r.images[c] = h), a++, a === 6 && ((r.needsUpdate = !0), t && t(r));
				},
				void 0,
				s
			);
		}
		for (let c = 0; c < e.length; ++c) l(c);
		return r;
	}
}
class X_ extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = this,
			o = new ho(),
			a = new Si(this.manager);
		return (
			a.setResponseType('arraybuffer'),
			a.setRequestHeader(this.requestHeader),
			a.setPath(this.path),
			a.setWithCredentials(r.withCredentials),
			a.load(
				e,
				function (l) {
					let c;
					try {
						c = r.parse(l);
					} catch (h) {
						if (s !== void 0) s(h);
						else {
							console.error(h);
							return;
						}
					}
					c.image !== void 0
						? (o.image = c.image)
						: c.data !== void 0 && ((o.image.width = c.width), (o.image.height = c.height), (o.image.data = c.data)),
						(o.wrapS = c.wrapS !== void 0 ? c.wrapS : Oi),
						(o.wrapT = c.wrapT !== void 0 ? c.wrapT : Oi),
						(o.magFilter = c.magFilter !== void 0 ? c.magFilter : Tt),
						(o.minFilter = c.minFilter !== void 0 ? c.minFilter : Tt),
						(o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
						c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
						c.flipY !== void 0 && (o.flipY = c.flipY),
						c.format !== void 0 && (o.format = c.format),
						c.type !== void 0 && (o.type = c.type),
						c.mipmaps !== void 0 && ((o.mipmaps = c.mipmaps), (o.minFilter = ts)),
						c.mipmapCount === 1 && (o.minFilter = Tt),
						c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
						(o.needsUpdate = !0),
						t && t(o, c);
				},
				n,
				s
			),
			o
		);
	}
}
class ff extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = new zt(),
			o = new Dh(this.manager);
		return (
			o.setCrossOrigin(this.crossOrigin),
			o.setPath(this.path),
			o.load(
				e,
				function (a) {
					(r.image = a), (r.needsUpdate = !0), t !== void 0 && t(r);
				},
				n,
				s
			),
			r
		);
	}
}
class Lo extends ft {
	constructor(e, t = 1) {
		super(), (this.isLight = !0), (this.type = 'Light'), (this.color = new Ee(e)), (this.intensity = t);
	}
	dispose() {}
	copy(e, t) {
		return super.copy(e, t), this.color.copy(e.color), (this.intensity = e.intensity), this;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (
			(t.object.color = this.color.getHex()),
			(t.object.intensity = this.intensity),
			this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
			this.distance !== void 0 && (t.object.distance = this.distance),
			this.angle !== void 0 && (t.object.angle = this.angle),
			this.decay !== void 0 && (t.object.decay = this.decay),
			this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
			this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
			t
		);
	}
}
class q_ extends Lo {
	constructor(e, t, n) {
		super(e, n),
			(this.isHemisphereLight = !0),
			(this.type = 'HemisphereLight'),
			this.position.copy(ft.DEFAULT_UP),
			this.updateMatrix(),
			(this.groundColor = new Ee(t));
	}
	copy(e, t) {
		return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
	}
}
const xm = new He(),
	ib = new I(),
	sb = new I();
class Y_ {
	constructor(e) {
		(this.camera = e),
			(this.bias = 0),
			(this.normalBias = 0),
			(this.radius = 1),
			(this.blurSamples = 8),
			(this.mapSize = new ce(512, 512)),
			(this.map = null),
			(this.mapPass = null),
			(this.matrix = new He()),
			(this.autoUpdate = !0),
			(this.needsUpdate = !1),
			(this._frustum = new Qh()),
			(this._frameExtents = new ce(1, 1)),
			(this._viewportCount = 1),
			(this._viewports = [new Pt(0, 0, 1, 1)]);
	}
	getViewportCount() {
		return this._viewportCount;
	}
	getFrustum() {
		return this._frustum;
	}
	updateMatrices(e) {
		const t = this.camera,
			n = this.matrix;
		ib.setFromMatrixPosition(e.matrixWorld),
			t.position.copy(ib),
			sb.setFromMatrixPosition(e.target.matrixWorld),
			t.lookAt(sb),
			t.updateMatrixWorld(),
			xm.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
			this._frustum.setFromProjectionMatrix(xm),
			n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
			n.multiply(xm);
	}
	getViewport(e) {
		return this._viewports[e];
	}
	getFrameExtents() {
		return this._frameExtents;
	}
	dispose() {
		this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
	}
	copy(e) {
		return (this.camera = e.camera.clone()), (this.bias = e.bias), (this.radius = e.radius), this.mapSize.copy(e.mapSize), this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	toJSON() {
		const e = {};
		return (
			this.bias !== 0 && (e.bias = this.bias),
			this.normalBias !== 0 && (e.normalBias = this.normalBias),
			this.radius !== 1 && (e.radius = this.radius),
			(this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
			(e.camera = this.camera.toJSON(!1).object),
			delete e.camera.matrix,
			e
		);
	}
}
class i3 extends Y_ {
	constructor() {
		super(new fn(50, 1, 0.5, 500)), (this.isSpotLightShadow = !0), (this.focus = 1);
	}
	updateMatrices(e) {
		const t = this.camera,
			n = Zl * 2 * e.angle * this.focus,
			s = this.mapSize.width / this.mapSize.height,
			r = e.distance || t.far;
		(n !== t.fov || s !== t.aspect || r !== t.far) && ((t.fov = n), (t.aspect = s), (t.far = r), t.updateProjectionMatrix()),
			super.updateMatrices(e);
	}
	copy(e) {
		return super.copy(e), (this.focus = e.focus), this;
	}
}
class mf extends Lo {
	constructor(e, t, n = 0, s = Math.PI / 3, r = 0, o = 2) {
		super(e, t),
			(this.isSpotLight = !0),
			(this.type = 'SpotLight'),
			this.position.copy(ft.DEFAULT_UP),
			this.updateMatrix(),
			(this.target = new ft()),
			(this.distance = n),
			(this.angle = s),
			(this.penumbra = r),
			(this.decay = o),
			(this.map = null),
			(this.shadow = new i3());
	}
	get power() {
		return this.intensity * Math.PI;
	}
	set power(e) {
		this.intensity = e / Math.PI;
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(e, t) {
		return (
			super.copy(e, t),
			(this.distance = e.distance),
			(this.angle = e.angle),
			(this.penumbra = e.penumbra),
			(this.decay = e.decay),
			(this.target = e.target.clone()),
			(this.shadow = e.shadow.clone()),
			this
		);
	}
}
const rb = new He(),
	Pc = new I(),
	bm = new I();
class s3 extends Y_ {
	constructor() {
		super(new fn(90, 1, 0.5, 500)),
			(this.isPointLightShadow = !0),
			(this._frameExtents = new ce(4, 2)),
			(this._viewportCount = 6),
			(this._viewports = [
				new Pt(2, 1, 1, 1),
				new Pt(0, 1, 1, 1),
				new Pt(3, 1, 1, 1),
				new Pt(1, 1, 1, 1),
				new Pt(3, 0, 1, 1),
				new Pt(1, 0, 1, 1),
			]),
			(this._cubeDirections = [new I(1, 0, 0), new I(-1, 0, 0), new I(0, 0, 1), new I(0, 0, -1), new I(0, 1, 0), new I(0, -1, 0)]),
			(this._cubeUps = [new I(0, 1, 0), new I(0, 1, 0), new I(0, 1, 0), new I(0, 1, 0), new I(0, 0, 1), new I(0, 0, -1)]);
	}
	updateMatrices(e, t = 0) {
		const n = this.camera,
			s = this.matrix,
			r = e.distance || n.far;
		r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
			Pc.setFromMatrixPosition(e.matrixWorld),
			n.position.copy(Pc),
			bm.copy(n.position),
			bm.add(this._cubeDirections[t]),
			n.up.copy(this._cubeUps[t]),
			n.lookAt(bm),
			n.updateMatrixWorld(),
			s.makeTranslation(-Pc.x, -Pc.y, -Pc.z),
			rb.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
			this._frustum.setFromProjectionMatrix(rb);
	}
}
class j_ extends Lo {
	constructor(e, t, n = 0, s = 2) {
		super(e, t), (this.isPointLight = !0), (this.type = 'PointLight'), (this.distance = n), (this.decay = s), (this.shadow = new s3());
	}
	get power() {
		return this.intensity * 4 * Math.PI;
	}
	set power(e) {
		this.intensity = e / (4 * Math.PI);
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(e, t) {
		return super.copy(e, t), (this.distance = e.distance), (this.decay = e.decay), (this.shadow = e.shadow.clone()), this;
	}
}
class r3 extends Y_ {
	constructor() {
		super(new eu(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
	}
}
class gf extends Lo {
	constructor(e, t) {
		super(e, t),
			(this.isDirectionalLight = !0),
			(this.type = 'DirectionalLight'),
			this.position.copy(ft.DEFAULT_UP),
			this.updateMatrix(),
			(this.target = new ft()),
			(this.shadow = new r3());
	}
	dispose() {
		this.shadow.dispose();
	}
	copy(e) {
		return super.copy(e), (this.target = e.target.clone()), (this.shadow = e.shadow.clone()), this;
	}
}
class K_ extends Lo {
	constructor(e, t) {
		super(e, t), (this.isAmbientLight = !0), (this.type = 'AmbientLight');
	}
}
class ZE extends Lo {
	constructor(e, t, n = 10, s = 10) {
		super(e, t), (this.isRectAreaLight = !0), (this.type = 'RectAreaLight'), (this.width = n), (this.height = s);
	}
	get power() {
		return this.intensity * this.width * this.height * Math.PI;
	}
	set power(e) {
		this.intensity = e / (this.width * this.height * Math.PI);
	}
	copy(e) {
		return super.copy(e), (this.width = e.width), (this.height = e.height), this;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (t.object.width = this.width), (t.object.height = this.height), t;
	}
}
class JE {
	constructor() {
		(this.isSphericalHarmonics3 = !0), (this.coefficients = []);
		for (let e = 0; e < 9; e++) this.coefficients.push(new I());
	}
	set(e) {
		for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
		return this;
	}
	zero() {
		for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
		return this;
	}
	getAt(e, t) {
		const n = e.x,
			s = e.y,
			r = e.z,
			o = this.coefficients;
		return (
			t.copy(o[0]).multiplyScalar(0.282095),
			t.addScaledVector(o[1], 0.488603 * s),
			t.addScaledVector(o[2], 0.488603 * r),
			t.addScaledVector(o[3], 0.488603 * n),
			t.addScaledVector(o[4], 1.092548 * (n * s)),
			t.addScaledVector(o[5], 1.092548 * (s * r)),
			t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)),
			t.addScaledVector(o[7], 1.092548 * (n * r)),
			t.addScaledVector(o[8], 0.546274 * (n * n - s * s)),
			t
		);
	}
	getIrradianceAt(e, t) {
		const n = e.x,
			s = e.y,
			r = e.z,
			o = this.coefficients;
		return (
			t.copy(o[0]).multiplyScalar(0.886227),
			t.addScaledVector(o[1], 2 * 0.511664 * s),
			t.addScaledVector(o[2], 2 * 0.511664 * r),
			t.addScaledVector(o[3], 2 * 0.511664 * n),
			t.addScaledVector(o[4], 2 * 0.429043 * n * s),
			t.addScaledVector(o[5], 2 * 0.429043 * s * r),
			t.addScaledVector(o[6], 0.743125 * r * r - 0.247708),
			t.addScaledVector(o[7], 2 * 0.429043 * n * r),
			t.addScaledVector(o[8], 0.429043 * (n * n - s * s)),
			t
		);
	}
	add(e) {
		for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
		return this;
	}
	addScaledSH(e, t) {
		for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
		return this;
	}
	scale(e) {
		for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
		return this;
	}
	lerp(e, t) {
		for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
		return this;
	}
	equals(e) {
		for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
		return !0;
	}
	copy(e) {
		return this.set(e.coefficients);
	}
	clone() {
		return new this.constructor().copy(this);
	}
	fromArray(e, t = 0) {
		const n = this.coefficients;
		for (let s = 0; s < 9; s++) n[s].fromArray(e, t + s * 3);
		return this;
	}
	toArray(e = [], t = 0) {
		const n = this.coefficients;
		for (let s = 0; s < 9; s++) n[s].toArray(e, t + s * 3);
		return e;
	}
	static getBasisAt(e, t) {
		const n = e.x,
			s = e.y,
			r = e.z;
		(t[0] = 0.282095),
			(t[1] = 0.488603 * s),
			(t[2] = 0.488603 * r),
			(t[3] = 0.488603 * n),
			(t[4] = 1.092548 * n * s),
			(t[5] = 1.092548 * s * r),
			(t[6] = 0.315392 * (3 * r * r - 1)),
			(t[7] = 1.092548 * n * r),
			(t[8] = 0.546274 * (n * n - s * s));
	}
}
class QE extends Lo {
	constructor(e = new JE(), t = 1) {
		super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
	}
	copy(e) {
		return super.copy(e), this.sh.copy(e.sh), this;
	}
	fromJSON(e) {
		return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (t.object.sh = this.sh.toArray()), t;
	}
}
class vf extends Qn {
	constructor(e) {
		super(e), (this.textures = {});
	}
	load(e, t, n, s) {
		const r = this,
			o = new Si(r.manager);
		o.setPath(r.path),
			o.setRequestHeader(r.requestHeader),
			o.setWithCredentials(r.withCredentials),
			o.load(
				e,
				function (a) {
					try {
						t(r.parse(JSON.parse(a)));
					} catch (l) {
						s ? s(l) : console.error(l), r.manager.itemError(e);
					}
				},
				n,
				s
			);
	}
	parse(e) {
		const t = this.textures;
		function n(r) {
			return t[r] === void 0 && console.warn('THREE.MaterialLoader: Undefined texture', r), t[r];
		}
		const s = vf.createMaterialFromType(e.type);
		if (
			(e.uuid !== void 0 && (s.uuid = e.uuid),
			e.name !== void 0 && (s.name = e.name),
			e.color !== void 0 && s.color !== void 0 && s.color.setHex(e.color),
			e.roughness !== void 0 && (s.roughness = e.roughness),
			e.metalness !== void 0 && (s.metalness = e.metalness),
			e.sheen !== void 0 && (s.sheen = e.sheen),
			e.sheenColor !== void 0 && (s.sheenColor = new Ee().setHex(e.sheenColor)),
			e.sheenRoughness !== void 0 && (s.sheenRoughness = e.sheenRoughness),
			e.emissive !== void 0 && s.emissive !== void 0 && s.emissive.setHex(e.emissive),
			e.specular !== void 0 && s.specular !== void 0 && s.specular.setHex(e.specular),
			e.specularIntensity !== void 0 && (s.specularIntensity = e.specularIntensity),
			e.specularColor !== void 0 && s.specularColor !== void 0 && s.specularColor.setHex(e.specularColor),
			e.shininess !== void 0 && (s.shininess = e.shininess),
			e.clearcoat !== void 0 && (s.clearcoat = e.clearcoat),
			e.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = e.clearcoatRoughness),
			e.dispersion !== void 0 && (s.dispersion = e.dispersion),
			e.iridescence !== void 0 && (s.iridescence = e.iridescence),
			e.iridescenceIOR !== void 0 && (s.iridescenceIOR = e.iridescenceIOR),
			e.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = e.iridescenceThicknessRange),
			e.transmission !== void 0 && (s.transmission = e.transmission),
			e.thickness !== void 0 && (s.thickness = e.thickness),
			e.attenuationDistance !== void 0 && (s.attenuationDistance = e.attenuationDistance),
			e.attenuationColor !== void 0 && s.attenuationColor !== void 0 && s.attenuationColor.setHex(e.attenuationColor),
			e.anisotropy !== void 0 && (s.anisotropy = e.anisotropy),
			e.anisotropyRotation !== void 0 && (s.anisotropyRotation = e.anisotropyRotation),
			e.fog !== void 0 && (s.fog = e.fog),
			e.flatShading !== void 0 && (s.flatShading = e.flatShading),
			e.blending !== void 0 && (s.blending = e.blending),
			e.combine !== void 0 && (s.combine = e.combine),
			e.side !== void 0 && (s.side = e.side),
			e.shadowSide !== void 0 && (s.shadowSide = e.shadowSide),
			e.opacity !== void 0 && (s.opacity = e.opacity),
			e.transparent !== void 0 && (s.transparent = e.transparent),
			e.alphaTest !== void 0 && (s.alphaTest = e.alphaTest),
			e.alphaHash !== void 0 && (s.alphaHash = e.alphaHash),
			e.depthFunc !== void 0 && (s.depthFunc = e.depthFunc),
			e.depthTest !== void 0 && (s.depthTest = e.depthTest),
			e.depthWrite !== void 0 && (s.depthWrite = e.depthWrite),
			e.colorWrite !== void 0 && (s.colorWrite = e.colorWrite),
			e.blendSrc !== void 0 && (s.blendSrc = e.blendSrc),
			e.blendDst !== void 0 && (s.blendDst = e.blendDst),
			e.blendEquation !== void 0 && (s.blendEquation = e.blendEquation),
			e.blendSrcAlpha !== void 0 && (s.blendSrcAlpha = e.blendSrcAlpha),
			e.blendDstAlpha !== void 0 && (s.blendDstAlpha = e.blendDstAlpha),
			e.blendEquationAlpha !== void 0 && (s.blendEquationAlpha = e.blendEquationAlpha),
			e.blendColor !== void 0 && s.blendColor !== void 0 && s.blendColor.setHex(e.blendColor),
			e.blendAlpha !== void 0 && (s.blendAlpha = e.blendAlpha),
			e.stencilWriteMask !== void 0 && (s.stencilWriteMask = e.stencilWriteMask),
			e.stencilFunc !== void 0 && (s.stencilFunc = e.stencilFunc),
			e.stencilRef !== void 0 && (s.stencilRef = e.stencilRef),
			e.stencilFuncMask !== void 0 && (s.stencilFuncMask = e.stencilFuncMask),
			e.stencilFail !== void 0 && (s.stencilFail = e.stencilFail),
			e.stencilZFail !== void 0 && (s.stencilZFail = e.stencilZFail),
			e.stencilZPass !== void 0 && (s.stencilZPass = e.stencilZPass),
			e.stencilWrite !== void 0 && (s.stencilWrite = e.stencilWrite),
			e.wireframe !== void 0 && (s.wireframe = e.wireframe),
			e.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = e.wireframeLinewidth),
			e.wireframeLinecap !== void 0 && (s.wireframeLinecap = e.wireframeLinecap),
			e.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = e.wireframeLinejoin),
			e.rotation !== void 0 && (s.rotation = e.rotation),
			e.linewidth !== void 0 && (s.linewidth = e.linewidth),
			e.dashSize !== void 0 && (s.dashSize = e.dashSize),
			e.gapSize !== void 0 && (s.gapSize = e.gapSize),
			e.scale !== void 0 && (s.scale = e.scale),
			e.polygonOffset !== void 0 && (s.polygonOffset = e.polygonOffset),
			e.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = e.polygonOffsetFactor),
			e.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = e.polygonOffsetUnits),
			e.dithering !== void 0 && (s.dithering = e.dithering),
			e.alphaToCoverage !== void 0 && (s.alphaToCoverage = e.alphaToCoverage),
			e.premultipliedAlpha !== void 0 && (s.premultipliedAlpha = e.premultipliedAlpha),
			e.forceSinglePass !== void 0 && (s.forceSinglePass = e.forceSinglePass),
			e.visible !== void 0 && (s.visible = e.visible),
			e.toneMapped !== void 0 && (s.toneMapped = e.toneMapped),
			e.userData !== void 0 && (s.userData = e.userData),
			e.vertexColors !== void 0 &&
				(typeof e.vertexColors == 'number' ? (s.vertexColors = e.vertexColors > 0) : (s.vertexColors = e.vertexColors)),
			e.uniforms !== void 0)
		)
			for (const r in e.uniforms) {
				const o = e.uniforms[r];
				switch (((s.uniforms[r] = {}), o.type)) {
					case 't':
						s.uniforms[r].value = n(o.value);
						break;
					case 'c':
						s.uniforms[r].value = new Ee().setHex(o.value);
						break;
					case 'v2':
						s.uniforms[r].value = new ce().fromArray(o.value);
						break;
					case 'v3':
						s.uniforms[r].value = new I().fromArray(o.value);
						break;
					case 'v4':
						s.uniforms[r].value = new Pt().fromArray(o.value);
						break;
					case 'm3':
						s.uniforms[r].value = new et().fromArray(o.value);
						break;
					case 'm4':
						s.uniforms[r].value = new He().fromArray(o.value);
						break;
					default:
						s.uniforms[r].value = o.value;
				}
			}
		if (
			(e.defines !== void 0 && (s.defines = e.defines),
			e.vertexShader !== void 0 && (s.vertexShader = e.vertexShader),
			e.fragmentShader !== void 0 && (s.fragmentShader = e.fragmentShader),
			e.glslVersion !== void 0 && (s.glslVersion = e.glslVersion),
			e.extensions !== void 0)
		)
			for (const r in e.extensions) s.extensions[r] = e.extensions[r];
		if (
			(e.lights !== void 0 && (s.lights = e.lights),
			e.clipping !== void 0 && (s.clipping = e.clipping),
			e.size !== void 0 && (s.size = e.size),
			e.sizeAttenuation !== void 0 && (s.sizeAttenuation = e.sizeAttenuation),
			e.map !== void 0 && (s.map = n(e.map)),
			e.matcap !== void 0 && (s.matcap = n(e.matcap)),
			e.alphaMap !== void 0 && (s.alphaMap = n(e.alphaMap)),
			e.bumpMap !== void 0 && (s.bumpMap = n(e.bumpMap)),
			e.bumpScale !== void 0 && (s.bumpScale = e.bumpScale),
			e.normalMap !== void 0 && (s.normalMap = n(e.normalMap)),
			e.normalMapType !== void 0 && (s.normalMapType = e.normalMapType),
			e.normalScale !== void 0)
		) {
			let r = e.normalScale;
			Array.isArray(r) === !1 && (r = [r, r]), (s.normalScale = new ce().fromArray(r));
		}
		return (
			e.displacementMap !== void 0 && (s.displacementMap = n(e.displacementMap)),
			e.displacementScale !== void 0 && (s.displacementScale = e.displacementScale),
			e.displacementBias !== void 0 && (s.displacementBias = e.displacementBias),
			e.roughnessMap !== void 0 && (s.roughnessMap = n(e.roughnessMap)),
			e.metalnessMap !== void 0 && (s.metalnessMap = n(e.metalnessMap)),
			e.emissiveMap !== void 0 && (s.emissiveMap = n(e.emissiveMap)),
			e.emissiveIntensity !== void 0 && (s.emissiveIntensity = e.emissiveIntensity),
			e.specularMap !== void 0 && (s.specularMap = n(e.specularMap)),
			e.specularIntensityMap !== void 0 && (s.specularIntensityMap = n(e.specularIntensityMap)),
			e.specularColorMap !== void 0 && (s.specularColorMap = n(e.specularColorMap)),
			e.envMap !== void 0 && (s.envMap = n(e.envMap)),
			e.envMapRotation !== void 0 && s.envMapRotation.fromArray(e.envMapRotation),
			e.envMapIntensity !== void 0 && (s.envMapIntensity = e.envMapIntensity),
			e.reflectivity !== void 0 && (s.reflectivity = e.reflectivity),
			e.refractionRatio !== void 0 && (s.refractionRatio = e.refractionRatio),
			e.lightMap !== void 0 && (s.lightMap = n(e.lightMap)),
			e.lightMapIntensity !== void 0 && (s.lightMapIntensity = e.lightMapIntensity),
			e.aoMap !== void 0 && (s.aoMap = n(e.aoMap)),
			e.aoMapIntensity !== void 0 && (s.aoMapIntensity = e.aoMapIntensity),
			e.gradientMap !== void 0 && (s.gradientMap = n(e.gradientMap)),
			e.clearcoatMap !== void 0 && (s.clearcoatMap = n(e.clearcoatMap)),
			e.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
			e.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = n(e.clearcoatNormalMap)),
			e.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new ce().fromArray(e.clearcoatNormalScale)),
			e.iridescenceMap !== void 0 && (s.iridescenceMap = n(e.iridescenceMap)),
			e.iridescenceThicknessMap !== void 0 && (s.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
			e.transmissionMap !== void 0 && (s.transmissionMap = n(e.transmissionMap)),
			e.thicknessMap !== void 0 && (s.thicknessMap = n(e.thicknessMap)),
			e.anisotropyMap !== void 0 && (s.anisotropyMap = n(e.anisotropyMap)),
			e.sheenColorMap !== void 0 && (s.sheenColorMap = n(e.sheenColorMap)),
			e.sheenRoughnessMap !== void 0 && (s.sheenRoughnessMap = n(e.sheenRoughnessMap)),
			s
		);
	}
	setTextures(e) {
		return (this.textures = e), this;
	}
	static createMaterialFromType(e) {
		const t = {
			ShadowMaterial: FE,
			SpriteMaterial: L_,
			RawShaderMaterial: BE,
			ShaderMaterial: xn,
			PointsMaterial: Kp,
			MeshPhysicalMaterial: ls,
			MeshStandardMaterial: Ha,
			MeshPhongMaterial: kE,
			MeshToonMaterial: zE,
			MeshNormalMaterial: VE,
			MeshLambertMaterial: HE,
			MeshDepthMaterial: qp,
			MeshDistanceMaterial: P_,
			MeshBasicMaterial: En,
			MeshMatcapMaterial: GE,
			LineDashedMaterial: WE,
			LineBasicMaterial: Jn,
			Material: vn,
		};
		return new t[e]();
	}
}
class uo {
	static decodeText(e) {
		if (typeof TextDecoder < 'u') return new TextDecoder().decode(e);
		let t = '';
		for (let n = 0, s = e.length; n < s; n++) t += String.fromCharCode(e[n]);
		try {
			return decodeURIComponent(escape(t));
		} catch (n) {
			return t;
		}
	}
	static extractUrlBase(e) {
		const t = e.lastIndexOf('/');
		return t === -1 ? './' : e.slice(0, t + 1);
	}
	static resolveURL(e, t) {
		return typeof e != 'string' || e === ''
			? ''
			: (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, '$1')),
			  /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
	}
}
class eT extends Ze {
	constructor() {
		super(), (this.isInstancedBufferGeometry = !0), (this.type = 'InstancedBufferGeometry'), (this.instanceCount = 1 / 0);
	}
	copy(e) {
		return super.copy(e), (this.instanceCount = e.instanceCount), this;
	}
	toJSON() {
		const e = super.toJSON();
		return (e.instanceCount = this.instanceCount), (e.isInstancedBufferGeometry = !0), e;
	}
}
class tT extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = this,
			o = new Si(r.manager);
		o.setPath(r.path),
			o.setRequestHeader(r.requestHeader),
			o.setWithCredentials(r.withCredentials),
			o.load(
				e,
				function (a) {
					try {
						t(r.parse(JSON.parse(a)));
					} catch (l) {
						s ? s(l) : console.error(l), r.manager.itemError(e);
					}
				},
				n,
				s
			);
	}
	parse(e) {
		const t = {},
			n = {};
		function s(p, g) {
			if (t[g] !== void 0) return t[g];
			const m = p.interleavedBuffers[g],
				f = r(p, m.buffer),
				y = Cl(m.type, f),
				_ = new nu(y, m.stride);
			return (_.uuid = m.uuid), (t[g] = _), _;
		}
		function r(p, g) {
			if (n[g] !== void 0) return n[g];
			const m = p.arrayBuffers[g],
				f = new Uint32Array(m).buffer;
			return (n[g] = f), f;
		}
		const o = e.isInstancedBufferGeometry ? new eT() : new Ze(),
			a = e.data.index;
		if (a !== void 0) {
			const p = Cl(a.type, a.array);
			o.setIndex(new $e(p, 1));
		}
		const l = e.data.attributes;
		for (const p in l) {
			const g = l[p];
			let v;
			if (g.isInterleavedBufferAttribute) {
				const m = s(e.data, g.data);
				v = new xo(m, g.itemSize, g.offset, g.normalized);
			} else {
				const m = Cl(g.type, g.array),
					f = g.isInstancedBufferAttribute ? Ca : $e;
				v = new f(m, g.itemSize, g.normalized);
			}
			g.name !== void 0 && (v.name = g.name), g.usage !== void 0 && v.setUsage(g.usage), o.setAttribute(p, v);
		}
		const c = e.data.morphAttributes;
		if (c)
			for (const p in c) {
				const g = c[p],
					v = [];
				for (let m = 0, f = g.length; m < f; m++) {
					const y = g[m];
					let _;
					if (y.isInterleavedBufferAttribute) {
						const x = s(e.data, y.data);
						_ = new xo(x, y.itemSize, y.offset, y.normalized);
					} else {
						const x = Cl(y.type, y.array);
						_ = new $e(x, y.itemSize, y.normalized);
					}
					y.name !== void 0 && (_.name = y.name), v.push(_);
				}
				o.morphAttributes[p] = v;
			}
		e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
		const u = e.data.groups || e.data.drawcalls || e.data.offsets;
		if (u !== void 0)
			for (let p = 0, g = u.length; p !== g; ++p) {
				const v = u[p];
				o.addGroup(v.start, v.count, v.materialIndex);
			}
		const d = e.data.boundingSphere;
		if (d !== void 0) {
			const p = new I();
			d.center !== void 0 && p.fromArray(d.center), (o.boundingSphere = new un(p, d.radius));
		}
		return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
	}
}
class o3 extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = this,
			o = this.path === '' ? uo.extractUrlBase(e) : this.path;
		this.resourcePath = this.resourcePath || o;
		const a = new Si(this.manager);
		a.setPath(this.path),
			a.setRequestHeader(this.requestHeader),
			a.setWithCredentials(this.withCredentials),
			a.load(
				e,
				function (l) {
					let c = null;
					try {
						c = JSON.parse(l);
					} catch (u) {
						s !== void 0 && s(u), console.error("THREE:ObjectLoader: Can't parse " + e + '.', u.message);
						return;
					}
					const h = c.metadata;
					if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === 'geometry') {
						s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + e)),
							console.error("THREE.ObjectLoader: Can't load " + e);
						return;
					}
					r.parse(c, t);
				},
				n,
				s
			);
	}
	async loadAsync(e, t) {
		const n = this,
			s = this.path === '' ? uo.extractUrlBase(e) : this.path;
		this.resourcePath = this.resourcePath || s;
		const r = new Si(this.manager);
		r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
		const o = await r.loadAsync(e, t),
			a = JSON.parse(o),
			l = a.metadata;
		if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === 'geometry')
			throw new Error("THREE.ObjectLoader: Can't load " + e);
		return await n.parseAsync(a);
	}
	parse(e, t) {
		const n = this.parseAnimations(e.animations),
			s = this.parseShapes(e.shapes),
			r = this.parseGeometries(e.geometries, s),
			o = this.parseImages(e.images, function () {
				t !== void 0 && t(c);
			}),
			a = this.parseTextures(e.textures, o),
			l = this.parseMaterials(e.materials, a),
			c = this.parseObject(e.object, r, l, a, n),
			h = this.parseSkeletons(e.skeletons, c);
		if ((this.bindSkeletons(c, h), t !== void 0)) {
			let u = !1;
			for (const d in o)
				if (o[d].data instanceof HTMLImageElement) {
					u = !0;
					break;
				}
			u === !1 && t(c);
		}
		return c;
	}
	async parseAsync(e) {
		const t = this.parseAnimations(e.animations),
			n = this.parseShapes(e.shapes),
			s = this.parseGeometries(e.geometries, n),
			r = await this.parseImagesAsync(e.images),
			o = this.parseTextures(e.textures, r),
			a = this.parseMaterials(e.materials, o),
			l = this.parseObject(e.object, s, a, o, t),
			c = this.parseSkeletons(e.skeletons, l);
		return this.bindSkeletons(l, c), l;
	}
	parseShapes(e) {
		const t = {};
		if (e !== void 0)
			for (let n = 0, s = e.length; n < s; n++) {
				const r = new _a().fromJSON(e[n]);
				t[r.uuid] = r;
			}
		return t;
	}
	parseSkeletons(e, t) {
		const n = {},
			s = {};
		if (
			(t.traverse(function (r) {
				r.isBone && (s[r.uuid] = r);
			}),
			e !== void 0)
		)
			for (let r = 0, o = e.length; r < o; r++) {
				const a = new iu().fromJSON(e[r], s);
				n[a.uuid] = a;
			}
		return n;
	}
	parseGeometries(e, t) {
		const n = {};
		if (e !== void 0) {
			const s = new tT();
			for (let r = 0, o = e.length; r < o; r++) {
				let a;
				const l = e[r];
				switch (l.type) {
					case 'BufferGeometry':
					case 'InstancedBufferGeometry':
						a = s.parse(l);
						break;
					default:
						l.type in nb
							? (a = nb[l.type].fromJSON(l, t))
							: console.warn('THREE.ObjectLoader: Unsupported geometry type "'.concat(l.type, '"'));
				}
				(a.uuid = l.uuid),
					l.name !== void 0 && (a.name = l.name),
					l.userData !== void 0 && (a.userData = l.userData),
					(n[l.uuid] = a);
			}
		}
		return n;
	}
	parseMaterials(e, t) {
		const n = {},
			s = {};
		if (e !== void 0) {
			const r = new vf();
			r.setTextures(t);
			for (let o = 0, a = e.length; o < a; o++) {
				const l = e[o];
				n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)), (s[l.uuid] = n[l.uuid]);
			}
		}
		return s;
	}
	parseAnimations(e) {
		const t = {};
		if (e !== void 0)
			for (let n = 0; n < e.length; n++) {
				const s = e[n],
					r = Ql.parse(s);
				t[r.uuid] = r;
			}
		return t;
	}
	parseImages(e, t) {
		const n = this,
			s = {};
		let r;
		function o(l) {
			return (
				n.manager.itemStart(l),
				r.load(
					l,
					function () {
						n.manager.itemEnd(l);
					},
					void 0,
					function () {
						n.manager.itemError(l), n.manager.itemEnd(l);
					}
				)
			);
		}
		function a(l) {
			if (typeof l == 'string') {
				const c = l,
					h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
				return o(h);
			} else return l.data ? { data: Cl(l.type, l.data), width: l.width, height: l.height } : null;
		}
		if (e !== void 0 && e.length > 0) {
			const l = new pf(t);
			(r = new Dh(l)), r.setCrossOrigin(this.crossOrigin);
			for (let c = 0, h = e.length; c < h; c++) {
				const u = e[c],
					d = u.url;
				if (Array.isArray(d)) {
					const p = [];
					for (let g = 0, v = d.length; g < v; g++) {
						const m = d[g],
							f = a(m);
						f !== null && (f instanceof HTMLImageElement ? p.push(f) : p.push(new ho(f.data, f.width, f.height)));
					}
					s[u.uuid] = new ca(p);
				} else {
					const p = a(u.url);
					s[u.uuid] = new ca(p);
				}
			}
		}
		return s;
	}
	async parseImagesAsync(e) {
		const t = this,
			n = {};
		let s;
		async function r(o) {
			if (typeof o == 'string') {
				const a = o,
					l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
				return await s.loadAsync(l);
			} else return o.data ? { data: Cl(o.type, o.data), width: o.width, height: o.height } : null;
		}
		if (e !== void 0 && e.length > 0) {
			(s = new Dh(this.manager)), s.setCrossOrigin(this.crossOrigin);
			for (let o = 0, a = e.length; o < a; o++) {
				const l = e[o],
					c = l.url;
				if (Array.isArray(c)) {
					const h = [];
					for (let u = 0, d = c.length; u < d; u++) {
						const p = c[u],
							g = await r(p);
						g !== null && (g instanceof HTMLImageElement ? h.push(g) : h.push(new ho(g.data, g.width, g.height)));
					}
					n[l.uuid] = new ca(h);
				} else {
					const h = await r(l.url);
					n[l.uuid] = new ca(h);
				}
			}
		}
		return n;
	}
	parseTextures(e, t) {
		function n(r, o) {
			return typeof r == 'number'
				? r
				: (console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', r), o[r]);
		}
		const s = {};
		if (e !== void 0)
			for (let r = 0, o = e.length; r < o; r++) {
				const a = e[r];
				a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
					t[a.image] === void 0 && console.warn('THREE.ObjectLoader: Undefined image', a.image);
				const l = t[a.image],
					c = l.data;
				let h;
				Array.isArray(c)
					? ((h = new Jh()), c.length === 6 && (h.needsUpdate = !0))
					: (c && c.data ? (h = new ho()) : (h = new zt()), c && (h.needsUpdate = !0)),
					(h.source = l),
					(h.uuid = a.uuid),
					a.name !== void 0 && (h.name = a.name),
					a.mapping !== void 0 && (h.mapping = n(a.mapping, a3)),
					a.channel !== void 0 && (h.channel = a.channel),
					a.offset !== void 0 && h.offset.fromArray(a.offset),
					a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
					a.center !== void 0 && h.center.fromArray(a.center),
					a.rotation !== void 0 && (h.rotation = a.rotation),
					a.wrap !== void 0 && ((h.wrapS = n(a.wrap[0], ob)), (h.wrapT = n(a.wrap[1], ob))),
					a.format !== void 0 && (h.format = a.format),
					a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
					a.type !== void 0 && (h.type = a.type),
					a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace),
					a.minFilter !== void 0 && (h.minFilter = n(a.minFilter, ab)),
					a.magFilter !== void 0 && (h.magFilter = n(a.magFilter, ab)),
					a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
					a.flipY !== void 0 && (h.flipY = a.flipY),
					a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps),
					a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha),
					a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment),
					a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction),
					a.userData !== void 0 && (h.userData = a.userData),
					(s[a.uuid] = h);
			}
		return s;
	}
	parseObject(e, t, n, s, r) {
		let o;
		function a(d) {
			return t[d] === void 0 && console.warn('THREE.ObjectLoader: Undefined geometry', d), t[d];
		}
		function l(d) {
			if (d !== void 0) {
				if (Array.isArray(d)) {
					const p = [];
					for (let g = 0, v = d.length; g < v; g++) {
						const m = d[g];
						n[m] === void 0 && console.warn('THREE.ObjectLoader: Undefined material', m), p.push(n[m]);
					}
					return p;
				}
				return n[d] === void 0 && console.warn('THREE.ObjectLoader: Undefined material', d), n[d];
			}
		}
		function c(d) {
			return s[d] === void 0 && console.warn('THREE.ObjectLoader: Undefined texture', d), s[d];
		}
		let h, u;
		switch (e.type) {
			case 'Scene':
				(o = new Ch()),
					e.background !== void 0 &&
						(Number.isInteger(e.background) ? (o.background = new Ee(e.background)) : (o.background = c(e.background))),
					e.environment !== void 0 && (o.environment = c(e.environment)),
					e.fog !== void 0 &&
						(e.fog.type === 'Fog'
							? (o.fog = new Yp(e.fog.color, e.fog.near, e.fog.far))
							: e.fog.type === 'FogExp2' && (o.fog = new tu(e.fog.color, e.fog.density)),
						e.fog.name !== '' && (o.fog.name = e.fog.name)),
					e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness),
					e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity),
					e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation),
					e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity),
					e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
				break;
			case 'PerspectiveCamera':
				(o = new fn(e.fov, e.aspect, e.near, e.far)),
					e.focus !== void 0 && (o.focus = e.focus),
					e.zoom !== void 0 && (o.zoom = e.zoom),
					e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
					e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
					e.view !== void 0 && (o.view = Object.assign({}, e.view));
				break;
			case 'OrthographicCamera':
				(o = new eu(e.left, e.right, e.top, e.bottom, e.near, e.far)),
					e.zoom !== void 0 && (o.zoom = e.zoom),
					e.view !== void 0 && (o.view = Object.assign({}, e.view));
				break;
			case 'AmbientLight':
				o = new K_(e.color, e.intensity);
				break;
			case 'DirectionalLight':
				o = new gf(e.color, e.intensity);
				break;
			case 'PointLight':
				o = new j_(e.color, e.intensity, e.distance, e.decay);
				break;
			case 'RectAreaLight':
				o = new ZE(e.color, e.intensity, e.width, e.height);
				break;
			case 'SpotLight':
				o = new mf(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
				break;
			case 'HemisphereLight':
				o = new q_(e.color, e.groundColor, e.intensity);
				break;
			case 'LightProbe':
				o = new QE().fromJSON(e);
				break;
			case 'SkinnedMesh':
				(h = a(e.geometry)),
					(u = l(e.material)),
					(o = new I_(h, u)),
					e.bindMode !== void 0 && (o.bindMode = e.bindMode),
					e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
					e.skeleton !== void 0 && (o.skeleton = e.skeleton);
				break;
			case 'Mesh':
				(h = a(e.geometry)), (u = l(e.material)), (o = new bt(h, u));
				break;
			case 'InstancedMesh':
				(h = a(e.geometry)), (u = l(e.material));
				const d = e.count,
					p = e.instanceMatrix,
					g = e.instanceColor;
				(o = new D_(h, u, d)),
					(o.instanceMatrix = new Ca(new Float32Array(p.array), 16)),
					g !== void 0 && (o.instanceColor = new Ca(new Float32Array(g.array), g.itemSize));
				break;
			case 'BatchedMesh':
				(h = a(e.geometry)),
					(u = l(e.material)),
					(o = new EE(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, u)),
					(o.geometry = h),
					(o.perObjectFrustumCulled = e.perObjectFrustumCulled),
					(o.sortObjects = e.sortObjects),
					(o._drawRanges = e.drawRanges),
					(o._reservedRanges = e.reservedRanges),
					(o._visibility = e.visibility),
					(o._active = e.active),
					(o._bounds = e.bounds.map((v) => {
						const m = new An();
						m.min.fromArray(v.boxMin), m.max.fromArray(v.boxMax);
						const f = new un();
						return (
							(f.radius = v.sphereRadius),
							f.center.fromArray(v.sphereCenter),
							{ boxInitialized: v.boxInitialized, box: m, sphereInitialized: v.sphereInitialized, sphere: f }
						);
					})),
					(o._maxGeometryCount = e.maxGeometryCount),
					(o._maxVertexCount = e.maxVertexCount),
					(o._maxIndexCount = e.maxIndexCount),
					(o._geometryInitialized = e.geometryInitialized),
					(o._geometryCount = e.geometryCount),
					(o._matricesTexture = c(e.matricesTexture.uuid));
				break;
			case 'LOD':
				o = new ME();
				break;
			case 'Line':
				o = new xr(a(e.geometry), l(e.material));
				break;
			case 'LineLoop':
				o = new O_(a(e.geometry), l(e.material));
				break;
			case 'LineSegments':
				o = new as(a(e.geometry), l(e.material));
				break;
			case 'PointCloud':
			case 'Points':
				o = new U_(a(e.geometry), l(e.material));
				break;
			case 'Sprite':
				o = new SE(l(e.material));
				break;
			case 'Group':
				o = new Ui();
				break;
			case 'Bone':
				o = new jp();
				break;
			default:
				o = new ft();
		}
		if (
			((o.uuid = e.uuid),
			e.name !== void 0 && (o.name = e.name),
			e.matrix !== void 0
				? (o.matrix.fromArray(e.matrix),
				  e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate),
				  o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale))
				: (e.position !== void 0 && o.position.fromArray(e.position),
				  e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
				  e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
				  e.scale !== void 0 && o.scale.fromArray(e.scale)),
			e.up !== void 0 && o.up.fromArray(e.up),
			e.castShadow !== void 0 && (o.castShadow = e.castShadow),
			e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
			e.shadow &&
				(e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
				e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias),
				e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
				e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize),
				e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))),
			e.visible !== void 0 && (o.visible = e.visible),
			e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
			e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
			e.userData !== void 0 && (o.userData = e.userData),
			e.layers !== void 0 && (o.layers.mask = e.layers),
			e.children !== void 0)
		) {
			const d = e.children;
			for (let p = 0; p < d.length; p++) o.add(this.parseObject(d[p], t, n, s, r));
		}
		if (e.animations !== void 0) {
			const d = e.animations;
			for (let p = 0; p < d.length; p++) {
				const g = d[p];
				o.animations.push(r[g]);
			}
		}
		if (e.type === 'LOD') {
			e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
			const d = e.levels;
			for (let p = 0; p < d.length; p++) {
				const g = d[p],
					v = o.getObjectByProperty('uuid', g.object);
				v !== void 0 && o.addLevel(v, g.distance, g.hysteresis);
			}
		}
		return o;
	}
	bindSkeletons(e, t) {
		Object.keys(t).length !== 0 &&
			e.traverse(function (n) {
				if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
					const s = t[n.skeleton];
					s === void 0 ? console.warn('THREE.ObjectLoader: No skeleton found with UUID:', n.skeleton) : n.bind(s, n.bindMatrix);
				}
			});
	}
}
const a3 = {
		UVMapping: Np,
		CubeReflectionMapping: _r,
		CubeRefractionMapping: _o,
		EquirectangularReflectionMapping: _h,
		EquirectangularRefractionMapping: yh,
		CubeUVReflectionMapping: lc,
	},
	ob = { RepeatWrapping: rs, ClampToEdgeWrapping: Oi, MirroredRepeatWrapping: Kl },
	ab = {
		NearestFilter: It,
		NearestMipmapNearestFilter: Fp,
		NearestMipmapLinearFilter: oa,
		LinearFilter: Tt,
		LinearMipmapNearestFilter: Nl,
		LinearMipmapLinearFilter: ts,
	};
class nT extends Qn {
	constructor(e) {
		super(e),
			(this.isImageBitmapLoader = !0),
			typeof createImageBitmap > 'u' && console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
			typeof fetch > 'u' && console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
			(this.options = { premultiplyAlpha: 'none' });
	}
	setOptions(e) {
		return (this.options = e), this;
	}
	load(e, t, n, s) {
		e === void 0 && (e = ''), this.path !== void 0 && (e = this.path + e), (e = this.manager.resolveURL(e));
		const r = this,
			o = Hs.get(e);
		if (o !== void 0) {
			if ((r.manager.itemStart(e), o.then)) {
				o.then((c) => {
					t && t(c), r.manager.itemEnd(e);
				}).catch((c) => {
					s && s(c);
				});
				return;
			}
			return (
				setTimeout(function () {
					t && t(o), r.manager.itemEnd(e);
				}, 0),
				o
			);
		}
		const a = {};
		(a.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'), (a.headers = this.requestHeader);
		const l = fetch(e, a)
			.then(function (c) {
				return c.blob();
			})
			.then(function (c) {
				return createImageBitmap(c, Object.assign(r.options, { colorSpaceConversion: 'none' }));
			})
			.then(function (c) {
				return Hs.add(e, c), t && t(c), r.manager.itemEnd(e), c;
			})
			.catch(function (c) {
				s && s(c), Hs.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
			});
		Hs.add(e, l), r.manager.itemStart(e);
	}
}
let fd;
class $_ {
	static getContext() {
		return fd === void 0 && (fd = new (window.AudioContext || window.webkitAudioContext)()), fd;
	}
	static setContext(e) {
		fd = e;
	}
}
class l3 extends Qn {
	constructor(e) {
		super(e);
	}
	load(e, t, n, s) {
		const r = this,
			o = new Si(this.manager);
		o.setResponseType('arraybuffer'),
			o.setPath(this.path),
			o.setRequestHeader(this.requestHeader),
			o.setWithCredentials(this.withCredentials),
			o.load(
				e,
				function (l) {
					try {
						const c = l.slice(0);
						$_.getContext()
							.decodeAudioData(c, function (u) {
								t(u);
							})
							.catch(a);
					} catch (c) {
						a(c);
					}
				},
				n,
				s
			);
		function a(l) {
			s ? s(l) : console.error(l), r.manager.itemError(e);
		}
	}
}
const lb = new He(),
	cb = new He(),
	Go = new He();
class c3 {
	constructor() {
		(this.type = 'StereoCamera'),
			(this.aspect = 1),
			(this.eyeSep = 0.064),
			(this.cameraL = new fn()),
			this.cameraL.layers.enable(1),
			(this.cameraL.matrixAutoUpdate = !1),
			(this.cameraR = new fn()),
			this.cameraR.layers.enable(2),
			(this.cameraR.matrixAutoUpdate = !1),
			(this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null });
	}
	update(e) {
		const t = this._cache;
		if (
			t.focus !== e.focus ||
			t.fov !== e.fov ||
			t.aspect !== e.aspect * this.aspect ||
			t.near !== e.near ||
			t.far !== e.far ||
			t.zoom !== e.zoom ||
			t.eyeSep !== this.eyeSep
		) {
			(t.focus = e.focus),
				(t.fov = e.fov),
				(t.aspect = e.aspect * this.aspect),
				(t.near = e.near),
				(t.far = e.far),
				(t.zoom = e.zoom),
				(t.eyeSep = this.eyeSep),
				Go.copy(e.projectionMatrix);
			const s = t.eyeSep / 2,
				r = (s * t.near) / t.focus,
				o = (t.near * Math.tan(va * t.fov * 0.5)) / t.zoom;
			let a, l;
			(cb.elements[12] = -s),
				(lb.elements[12] = s),
				(a = -o * t.aspect + r),
				(l = o * t.aspect + r),
				(Go.elements[0] = (2 * t.near) / (l - a)),
				(Go.elements[8] = (l + a) / (l - a)),
				this.cameraL.projectionMatrix.copy(Go),
				(a = -o * t.aspect - r),
				(l = o * t.aspect - r),
				(Go.elements[0] = (2 * t.near) / (l - a)),
				(Go.elements[8] = (l + a) / (l - a)),
				this.cameraR.projectionMatrix.copy(Go);
		}
		this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(cb), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(lb);
	}
}
class Z_ {
	constructor(e = !0) {
		(this.autoStart = e), (this.startTime = 0), (this.oldTime = 0), (this.elapsedTime = 0), (this.running = !1);
	}
	start() {
		(this.startTime = hb()), (this.oldTime = this.startTime), (this.elapsedTime = 0), (this.running = !0);
	}
	stop() {
		this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
	}
	getElapsedTime() {
		return this.getDelta(), this.elapsedTime;
	}
	getDelta() {
		let e = 0;
		if (this.autoStart && !this.running) return this.start(), 0;
		if (this.running) {
			const t = hb();
			(e = (t - this.oldTime) / 1e3), (this.oldTime = t), (this.elapsedTime += e);
		}
		return e;
	}
}
function hb() {
	return (typeof performance > 'u' ? Date : performance).now();
}
const Wo = new I(),
	ub = new kn(),
	h3 = new I(),
	Xo = new I();
class u3 extends ft {
	constructor() {
		super(),
			(this.type = 'AudioListener'),
			(this.context = $_.getContext()),
			(this.gain = this.context.createGain()),
			this.gain.connect(this.context.destination),
			(this.filter = null),
			(this.timeDelta = 0),
			(this._clock = new Z_());
	}
	getInput() {
		return this.gain;
	}
	removeFilter() {
		return (
			this.filter !== null &&
				(this.gain.disconnect(this.filter),
				this.filter.disconnect(this.context.destination),
				this.gain.connect(this.context.destination),
				(this.filter = null)),
			this
		);
	}
	getFilter() {
		return this.filter;
	}
	setFilter(e) {
		return (
			this.filter !== null
				? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination))
				: this.gain.disconnect(this.context.destination),
			(this.filter = e),
			this.gain.connect(this.filter),
			this.filter.connect(this.context.destination),
			this
		);
	}
	getMasterVolume() {
		return this.gain.gain.value;
	}
	setMasterVolume(e) {
		return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
	}
	updateMatrixWorld(e) {
		super.updateMatrixWorld(e);
		const t = this.context.listener,
			n = this.up;
		if (
			((this.timeDelta = this._clock.getDelta()),
			this.matrixWorld.decompose(Wo, ub, h3),
			Xo.set(0, 0, -1).applyQuaternion(ub),
			t.positionX)
		) {
			const s = this.context.currentTime + this.timeDelta;
			t.positionX.linearRampToValueAtTime(Wo.x, s),
				t.positionY.linearRampToValueAtTime(Wo.y, s),
				t.positionZ.linearRampToValueAtTime(Wo.z, s),
				t.forwardX.linearRampToValueAtTime(Xo.x, s),
				t.forwardY.linearRampToValueAtTime(Xo.y, s),
				t.forwardZ.linearRampToValueAtTime(Xo.z, s),
				t.upX.linearRampToValueAtTime(n.x, s),
				t.upY.linearRampToValueAtTime(n.y, s),
				t.upZ.linearRampToValueAtTime(n.z, s);
		} else t.setPosition(Wo.x, Wo.y, Wo.z), t.setOrientation(Xo.x, Xo.y, Xo.z, n.x, n.y, n.z);
	}
}
class iT extends ft {
	constructor(e) {
		super(),
			(this.type = 'Audio'),
			(this.listener = e),
			(this.context = e.context),
			(this.gain = this.context.createGain()),
			this.gain.connect(e.getInput()),
			(this.autoplay = !1),
			(this.buffer = null),
			(this.detune = 0),
			(this.loop = !1),
			(this.loopStart = 0),
			(this.loopEnd = 0),
			(this.offset = 0),
			(this.duration = void 0),
			(this.playbackRate = 1),
			(this.isPlaying = !1),
			(this.hasPlaybackControl = !0),
			(this.source = null),
			(this.sourceType = 'empty'),
			(this._startedAt = 0),
			(this._progress = 0),
			(this._connected = !1),
			(this.filters = []);
	}
	getOutput() {
		return this.gain;
	}
	setNodeSource(e) {
		return (this.hasPlaybackControl = !1), (this.sourceType = 'audioNode'), (this.source = e), this.connect(), this;
	}
	setMediaElementSource(e) {
		return (
			(this.hasPlaybackControl = !1),
			(this.sourceType = 'mediaNode'),
			(this.source = this.context.createMediaElementSource(e)),
			this.connect(),
			this
		);
	}
	setMediaStreamSource(e) {
		return (
			(this.hasPlaybackControl = !1),
			(this.sourceType = 'mediaStreamNode'),
			(this.source = this.context.createMediaStreamSource(e)),
			this.connect(),
			this
		);
	}
	setBuffer(e) {
		return (this.buffer = e), (this.sourceType = 'buffer'), this.autoplay && this.play(), this;
	}
	play(e = 0) {
		if (this.isPlaying === !0) {
			console.warn('THREE.Audio: Audio is already playing.');
			return;
		}
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		this._startedAt = this.context.currentTime + e;
		const t = this.context.createBufferSource();
		return (
			(t.buffer = this.buffer),
			(t.loop = this.loop),
			(t.loopStart = this.loopStart),
			(t.loopEnd = this.loopEnd),
			(t.onended = this.onEnded.bind(this)),
			t.start(this._startedAt, this._progress + this.offset, this.duration),
			(this.isPlaying = !0),
			(this.source = t),
			this.setDetune(this.detune),
			this.setPlaybackRate(this.playbackRate),
			this.connect()
		);
	}
	pause() {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			this.isPlaying === !0 &&
				((this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate),
				this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
				this.source.stop(),
				(this.source.onended = null),
				(this.isPlaying = !1)),
			this
		);
	}
	stop() {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			(this._progress = 0), this.source !== null && (this.source.stop(), (this.source.onended = null)), (this.isPlaying = !1), this
		);
	}
	connect() {
		if (this.filters.length > 0) {
			this.source.connect(this.filters[0]);
			for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
			this.filters[this.filters.length - 1].connect(this.getOutput());
		} else this.source.connect(this.getOutput());
		return (this._connected = !0), this;
	}
	disconnect() {
		if (this._connected !== !1) {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);
				for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else this.source.disconnect(this.getOutput());
			return (this._connected = !1), this;
		}
	}
	getFilters() {
		return this.filters;
	}
	setFilters(e) {
		return (
			e || (e = []),
			this._connected === !0 ? (this.disconnect(), (this.filters = e.slice()), this.connect()) : (this.filters = e.slice()),
			this
		);
	}
	setDetune(e) {
		return (
			(this.detune = e),
			this.isPlaying === !0 &&
				this.source.detune !== void 0 &&
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01),
			this
		);
	}
	getDetune() {
		return this.detune;
	}
	getFilter() {
		return this.getFilters()[0];
	}
	setFilter(e) {
		return this.setFilters(e ? [e] : []);
	}
	setPlaybackRate(e) {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (
			(this.playbackRate = e),
			this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01),
			this
		);
	}
	getPlaybackRate() {
		return this.playbackRate;
	}
	onEnded() {
		this.isPlaying = !1;
	}
	getLoop() {
		return this.hasPlaybackControl === !1 ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1) : this.loop;
	}
	setLoop(e) {
		if (this.hasPlaybackControl === !1) {
			console.warn('THREE.Audio: this Audio has no playback control.');
			return;
		}
		return (this.loop = e), this.isPlaying === !0 && (this.source.loop = this.loop), this;
	}
	setLoopStart(e) {
		return (this.loopStart = e), this;
	}
	setLoopEnd(e) {
		return (this.loopEnd = e), this;
	}
	getVolume() {
		return this.gain.gain.value;
	}
	setVolume(e) {
		return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
	}
}
const qo = new I(),
	db = new kn(),
	d3 = new I(),
	Yo = new I();
class p3 extends iT {
	constructor(e) {
		super(e), (this.panner = this.context.createPanner()), (this.panner.panningModel = 'HRTF'), this.panner.connect(this.gain);
	}
	connect() {
		super.connect(), this.panner.connect(this.gain);
	}
	disconnect() {
		super.disconnect(), this.panner.disconnect(this.gain);
	}
	getOutput() {
		return this.panner;
	}
	getRefDistance() {
		return this.panner.refDistance;
	}
	setRefDistance(e) {
		return (this.panner.refDistance = e), this;
	}
	getRolloffFactor() {
		return this.panner.rolloffFactor;
	}
	setRolloffFactor(e) {
		return (this.panner.rolloffFactor = e), this;
	}
	getDistanceModel() {
		return this.panner.distanceModel;
	}
	setDistanceModel(e) {
		return (this.panner.distanceModel = e), this;
	}
	getMaxDistance() {
		return this.panner.maxDistance;
	}
	setMaxDistance(e) {
		return (this.panner.maxDistance = e), this;
	}
	setDirectionalCone(e, t, n) {
		return (this.panner.coneInnerAngle = e), (this.panner.coneOuterAngle = t), (this.panner.coneOuterGain = n), this;
	}
	updateMatrixWorld(e) {
		if ((super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)) return;
		this.matrixWorld.decompose(qo, db, d3), Yo.set(0, 0, 1).applyQuaternion(db);
		const t = this.panner;
		if (t.positionX) {
			const n = this.context.currentTime + this.listener.timeDelta;
			t.positionX.linearRampToValueAtTime(qo.x, n),
				t.positionY.linearRampToValueAtTime(qo.y, n),
				t.positionZ.linearRampToValueAtTime(qo.z, n),
				t.orientationX.linearRampToValueAtTime(Yo.x, n),
				t.orientationY.linearRampToValueAtTime(Yo.y, n),
				t.orientationZ.linearRampToValueAtTime(Yo.z, n);
		} else t.setPosition(qo.x, qo.y, qo.z), t.setOrientation(Yo.x, Yo.y, Yo.z);
	}
}
class f3 {
	constructor(e, t = 2048) {
		(this.analyser = e.context.createAnalyser()),
			(this.analyser.fftSize = t),
			(this.data = new Uint8Array(this.analyser.frequencyBinCount)),
			e.getOutput().connect(this.analyser);
	}
	getFrequencyData() {
		return this.analyser.getByteFrequencyData(this.data), this.data;
	}
	getAverageFrequency() {
		let e = 0;
		const t = this.getFrequencyData();
		for (let n = 0; n < t.length; n++) e += t[n];
		return e / t.length;
	}
}
class sT {
	constructor(e, t, n) {
		(this.binding = e), (this.valueSize = n);
		let s, r, o;
		switch (t) {
			case 'quaternion':
				(s = this._slerp),
					(r = this._slerpAdditive),
					(o = this._setAdditiveIdentityQuaternion),
					(this.buffer = new Float64Array(n * 6)),
					(this._workIndex = 5);
				break;
			case 'string':
			case 'bool':
				(s = this._select), (r = this._select), (o = this._setAdditiveIdentityOther), (this.buffer = new Array(n * 5));
				break;
			default:
				(s = this._lerp), (r = this._lerpAdditive), (o = this._setAdditiveIdentityNumeric), (this.buffer = new Float64Array(n * 5));
		}
		(this._mixBufferRegion = s),
			(this._mixBufferRegionAdditive = r),
			(this._setIdentity = o),
			(this._origIndex = 3),
			(this._addIndex = 4),
			(this.cumulativeWeight = 0),
			(this.cumulativeWeightAdditive = 0),
			(this.useCount = 0),
			(this.referenceCount = 0);
	}
	accumulate(e, t) {
		const n = this.buffer,
			s = this.valueSize,
			r = e * s + s;
		let o = this.cumulativeWeight;
		if (o === 0) {
			for (let a = 0; a !== s; ++a) n[r + a] = n[a];
			o = t;
		} else {
			o += t;
			const a = t / o;
			this._mixBufferRegion(n, r, 0, a, s);
		}
		this.cumulativeWeight = o;
	}
	accumulateAdditive(e) {
		const t = this.buffer,
			n = this.valueSize,
			s = n * this._addIndex;
		this.cumulativeWeightAdditive === 0 && this._setIdentity(),
			this._mixBufferRegionAdditive(t, s, 0, e, n),
			(this.cumulativeWeightAdditive += e);
	}
	apply(e) {
		const t = this.valueSize,
			n = this.buffer,
			s = e * t + t,
			r = this.cumulativeWeight,
			o = this.cumulativeWeightAdditive,
			a = this.binding;
		if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), r < 1)) {
			const l = t * this._origIndex;
			this._mixBufferRegion(n, s, l, 1 - r, t);
		}
		o > 0 && this._mixBufferRegionAdditive(n, s, this._addIndex * t, 1, t);
		for (let l = t, c = t + t; l !== c; ++l)
			if (n[l] !== n[l + t]) {
				a.setValue(n, s);
				break;
			}
	}
	saveOriginalState() {
		const e = this.binding,
			t = this.buffer,
			n = this.valueSize,
			s = n * this._origIndex;
		e.getValue(t, s);
		for (let r = n, o = s; r !== o; ++r) t[r] = t[s + (r % n)];
		this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
	}
	restoreOriginalState() {
		const e = this.valueSize * 3;
		this.binding.setValue(this.buffer, e);
	}
	_setAdditiveIdentityNumeric() {
		const e = this._addIndex * this.valueSize,
			t = e + this.valueSize;
		for (let n = e; n < t; n++) this.buffer[n] = 0;
	}
	_setAdditiveIdentityQuaternion() {
		this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1);
	}
	_setAdditiveIdentityOther() {
		const e = this._origIndex * this.valueSize,
			t = this._addIndex * this.valueSize;
		for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n];
	}
	_select(e, t, n, s, r) {
		if (s >= 0.5) for (let o = 0; o !== r; ++o) e[t + o] = e[n + o];
	}
	_slerp(e, t, n, s) {
		kn.slerpFlat(e, t, e, t, e, n, s);
	}
	_slerpAdditive(e, t, n, s, r) {
		const o = this._workIndex * r;
		kn.multiplyQuaternionsFlat(e, o, e, t, e, n), kn.slerpFlat(e, t, e, t, e, o, s);
	}
	_lerp(e, t, n, s, r) {
		const o = 1 - s;
		for (let a = 0; a !== r; ++a) {
			const l = t + a;
			e[l] = e[l] * o + e[n + a] * s;
		}
	}
	_lerpAdditive(e, t, n, s, r) {
		for (let o = 0; o !== r; ++o) {
			const a = t + o;
			e[a] = e[a] + e[n + o] * s;
		}
	}
}
const J_ = '\\[\\]\\.:\\/',
	m3 = new RegExp('[' + J_ + ']', 'g'),
	Q_ = '[^' + J_ + ']',
	g3 = '[^' + J_.replace('\\.', '') + ']',
	v3 = /((?:WC+[\/:])*)/.source.replace('WC', Q_),
	_3 = /(WCOD+)?/.source.replace('WCOD', g3),
	y3 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', Q_),
	x3 = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', Q_),
	b3 = new RegExp('^' + v3 + _3 + y3 + x3 + '$'),
	w3 = ['material', 'materials', 'bones', 'map'];
class S3 {
	constructor(e, t, n) {
		const s = n || _t.parseTrackName(t);
		(this._targetGroup = e), (this._bindings = e.subscribe_(t, s));
	}
	getValue(e, t) {
		this.bind();
		const n = this._targetGroup.nCachedObjects_,
			s = this._bindings[n];
		s !== void 0 && s.getValue(e, t);
	}
	setValue(e, t) {
		const n = this._bindings;
		for (let s = this._targetGroup.nCachedObjects_, r = n.length; s !== r; ++s) n[s].setValue(e, t);
	}
	bind() {
		const e = this._bindings;
		for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind();
	}
	unbind() {
		const e = this._bindings;
		for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind();
	}
}
class _t {
	constructor(e, t, n) {
		(this.path = t),
			(this.parsedPath = n || _t.parseTrackName(t)),
			(this.node = _t.findNode(e, this.parsedPath.nodeName)),
			(this.rootNode = e),
			(this.getValue = this._getValue_unbound),
			(this.setValue = this._setValue_unbound);
	}
	static create(e, t, n) {
		return e && e.isAnimationObjectGroup ? new _t.Composite(e, t, n) : new _t(e, t, n);
	}
	static sanitizeNodeName(e) {
		return e.replace(/\s/g, '_').replace(m3, '');
	}
	static parseTrackName(e) {
		const t = b3.exec(e);
		if (t === null) throw new Error('PropertyBinding: Cannot parse trackName: ' + e);
		const n = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] },
			s = n.nodeName && n.nodeName.lastIndexOf('.');
		if (s !== void 0 && s !== -1) {
			const r = n.nodeName.substring(s + 1);
			w3.indexOf(r) !== -1 && ((n.nodeName = n.nodeName.substring(0, s)), (n.objectName = r));
		}
		if (n.propertyName === null || n.propertyName.length === 0)
			throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + e);
		return n;
	}
	static findNode(e, t) {
		if (t === void 0 || t === '' || t === '.' || t === -1 || t === e.name || t === e.uuid) return e;
		if (e.skeleton) {
			const n = e.skeleton.getBoneByName(t);
			if (n !== void 0) return n;
		}
		if (e.children) {
			const n = function (r) {
					for (let o = 0; o < r.length; o++) {
						const a = r[o];
						if (a.name === t || a.uuid === t) return a;
						const l = n(a.children);
						if (l) return l;
					}
					return null;
				},
				s = n(e.children);
			if (s) return s;
		}
		return null;
	}
	_getValue_unavailable() {}
	_setValue_unavailable() {}
	_getValue_direct(e, t) {
		e[t] = this.targetObject[this.propertyName];
	}
	_getValue_array(e, t) {
		const n = this.resolvedProperty;
		for (let s = 0, r = n.length; s !== r; ++s) e[t++] = n[s];
	}
	_getValue_arrayElement(e, t) {
		e[t] = this.resolvedProperty[this.propertyIndex];
	}
	_getValue_toArray(e, t) {
		this.resolvedProperty.toArray(e, t);
	}
	_setValue_direct(e, t) {
		this.targetObject[this.propertyName] = e[t];
	}
	_setValue_direct_setNeedsUpdate(e, t) {
		(this.targetObject[this.propertyName] = e[t]), (this.targetObject.needsUpdate = !0);
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
		(this.targetObject[this.propertyName] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
	}
	_setValue_array(e, t) {
		const n = this.resolvedProperty;
		for (let s = 0, r = n.length; s !== r; ++s) n[s] = e[t++];
	}
	_setValue_array_setNeedsUpdate(e, t) {
		const n = this.resolvedProperty;
		for (let s = 0, r = n.length; s !== r; ++s) n[s] = e[t++];
		this.targetObject.needsUpdate = !0;
	}
	_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
		const n = this.resolvedProperty;
		for (let s = 0, r = n.length; s !== r; ++s) n[s] = e[t++];
		this.targetObject.matrixWorldNeedsUpdate = !0;
	}
	_setValue_arrayElement(e, t) {
		this.resolvedProperty[this.propertyIndex] = e[t];
	}
	_setValue_arrayElement_setNeedsUpdate(e, t) {
		(this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.needsUpdate = !0);
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
		(this.resolvedProperty[this.propertyIndex] = e[t]), (this.targetObject.matrixWorldNeedsUpdate = !0);
	}
	_setValue_fromArray(e, t) {
		this.resolvedProperty.fromArray(e, t);
	}
	_setValue_fromArray_setNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
		this.resolvedProperty.fromArray(e, t), (this.targetObject.matrixWorldNeedsUpdate = !0);
	}
	_getValue_unbound(e, t) {
		this.bind(), this.getValue(e, t);
	}
	_setValue_unbound(e, t) {
		this.bind(), this.setValue(e, t);
	}
	bind() {
		let e = this.node;
		const t = this.parsedPath,
			n = t.objectName,
			s = t.propertyName;
		let r = t.propertyIndex;
		if (
			(e || ((e = _t.findNode(this.rootNode, t.nodeName)), (this.node = e)),
			(this.getValue = this._getValue_unavailable),
			(this.setValue = this._setValue_unavailable),
			!e)
		) {
			console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
			return;
		}
		if (n) {
			let c = t.objectIndex;
			switch (n) {
				case 'materials':
					if (!e.material) {
						console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
						return;
					}
					if (!e.material.materials) {
						console.error(
							'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
							this
						);
						return;
					}
					e = e.material.materials;
					break;
				case 'bones':
					if (!e.skeleton) {
						console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
						return;
					}
					e = e.skeleton.bones;
					for (let h = 0; h < e.length; h++)
						if (e[h].name === c) {
							c = h;
							break;
						}
					break;
				case 'map':
					if ('map' in e) {
						e = e.map;
						break;
					}
					if (!e.material) {
						console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
						return;
					}
					if (!e.material.map) {
						console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
						return;
					}
					e = e.material.map;
					break;
				default:
					if (e[n] === void 0) {
						console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
						return;
					}
					e = e[n];
			}
			if (c !== void 0) {
				if (e[c] === void 0) {
					console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, e);
					return;
				}
				e = e[c];
			}
		}
		const o = e[s];
		if (o === void 0) {
			const c = t.nodeName;
			console.error('THREE.PropertyBinding: Trying to update property for track: ' + c + '.' + s + " but it wasn't found.", e);
			return;
		}
		let a = this.Versioning.None;
		(this.targetObject = e),
			e.needsUpdate !== void 0
				? (a = this.Versioning.NeedsUpdate)
				: e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
		let l = this.BindingType.Direct;
		if (r !== void 0) {
			if (s === 'morphTargetInfluences') {
				if (!e.geometry) {
					console.error(
						'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
						this
					);
					return;
				}
				if (!e.geometry.morphAttributes) {
					console.error(
						'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
						this
					);
					return;
				}
				e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
			}
			(l = this.BindingType.ArrayElement), (this.resolvedProperty = o), (this.propertyIndex = r);
		} else
			o.fromArray !== void 0 && o.toArray !== void 0
				? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
				: Array.isArray(o)
				? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
				: (this.propertyName = s);
		(this.getValue = this.GetterByBindingType[l]), (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
	}
	unbind() {
		(this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
	}
}
_t.Composite = S3;
_t.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
_t.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
_t.prototype.GetterByBindingType = [
	_t.prototype._getValue_direct,
	_t.prototype._getValue_array,
	_t.prototype._getValue_arrayElement,
	_t.prototype._getValue_toArray,
];
_t.prototype.SetterByBindingTypeAndVersioning = [
	[_t.prototype._setValue_direct, _t.prototype._setValue_direct_setNeedsUpdate, _t.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
	[_t.prototype._setValue_array, _t.prototype._setValue_array_setNeedsUpdate, _t.prototype._setValue_array_setMatrixWorldNeedsUpdate],
	[
		_t.prototype._setValue_arrayElement,
		_t.prototype._setValue_arrayElement_setNeedsUpdate,
		_t.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
	],
	[
		_t.prototype._setValue_fromArray,
		_t.prototype._setValue_fromArray_setNeedsUpdate,
		_t.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
	],
];
class M3 {
	constructor() {
		(this.isAnimationObjectGroup = !0),
			(this.uuid = Bi()),
			(this._objects = Array.prototype.slice.call(arguments)),
			(this.nCachedObjects_ = 0);
		const e = {};
		this._indicesByUUID = e;
		for (let n = 0, s = arguments.length; n !== s; ++n) e[arguments[n].uuid] = n;
		(this._paths = []), (this._parsedPaths = []), (this._bindings = []), (this._bindingsIndicesByPath = {});
		const t = this;
		this.stats = {
			objects: {
				get total() {
					return t._objects.length;
				},
				get inUse() {
					return this.total - t.nCachedObjects_;
				},
			},
			get bindingsPerObject() {
				return t._bindings.length;
			},
		};
	}
	add() {
		const e = this._objects,
			t = this._indicesByUUID,
			n = this._paths,
			s = this._parsedPaths,
			r = this._bindings,
			o = r.length;
		let a,
			l = e.length,
			c = this.nCachedObjects_;
		for (let h = 0, u = arguments.length; h !== u; ++h) {
			const d = arguments[h],
				p = d.uuid;
			let g = t[p];
			if (g === void 0) {
				(g = l++), (t[p] = g), e.push(d);
				for (let v = 0, m = o; v !== m; ++v) r[v].push(new _t(d, n[v], s[v]));
			} else if (g < c) {
				a = e[g];
				const v = --c,
					m = e[v];
				(t[m.uuid] = g), (e[g] = m), (t[p] = v), (e[v] = d);
				for (let f = 0, y = o; f !== y; ++f) {
					const _ = r[f],
						x = _[v];
					let E = _[g];
					(_[g] = x), E === void 0 && (E = new _t(d, n[f], s[f])), (_[v] = E);
				}
			} else
				e[g] !== a &&
					console.error(
						'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
					);
		}
		this.nCachedObjects_ = c;
	}
	remove() {
		const e = this._objects,
			t = this._indicesByUUID,
			n = this._bindings,
			s = n.length;
		let r = this.nCachedObjects_;
		for (let o = 0, a = arguments.length; o !== a; ++o) {
			const l = arguments[o],
				c = l.uuid,
				h = t[c];
			if (h !== void 0 && h >= r) {
				const u = r++,
					d = e[u];
				(t[d.uuid] = h), (e[h] = d), (t[c] = u), (e[u] = l);
				for (let p = 0, g = s; p !== g; ++p) {
					const v = n[p],
						m = v[u],
						f = v[h];
					(v[h] = m), (v[u] = f);
				}
			}
		}
		this.nCachedObjects_ = r;
	}
	uncache() {
		const e = this._objects,
			t = this._indicesByUUID,
			n = this._bindings,
			s = n.length;
		let r = this.nCachedObjects_,
			o = e.length;
		for (let a = 0, l = arguments.length; a !== l; ++a) {
			const c = arguments[a],
				h = c.uuid,
				u = t[h];
			if (u !== void 0)
				if ((delete t[h], u < r)) {
					const d = --r,
						p = e[d],
						g = --o,
						v = e[g];
					(t[p.uuid] = u), (e[u] = p), (t[v.uuid] = d), (e[d] = v), e.pop();
					for (let m = 0, f = s; m !== f; ++m) {
						const y = n[m],
							_ = y[d],
							x = y[g];
						(y[u] = _), (y[d] = x), y.pop();
					}
				} else {
					const d = --o,
						p = e[d];
					d > 0 && (t[p.uuid] = u), (e[u] = p), e.pop();
					for (let g = 0, v = s; g !== v; ++g) {
						const m = n[g];
						(m[u] = m[d]), m.pop();
					}
				}
		}
		this.nCachedObjects_ = r;
	}
	subscribe_(e, t) {
		const n = this._bindingsIndicesByPath;
		let s = n[e];
		const r = this._bindings;
		if (s !== void 0) return r[s];
		const o = this._paths,
			a = this._parsedPaths,
			l = this._objects,
			c = l.length,
			h = this.nCachedObjects_,
			u = new Array(c);
		(s = r.length), (n[e] = s), o.push(e), a.push(t), r.push(u);
		for (let d = h, p = l.length; d !== p; ++d) {
			const g = l[d];
			u[d] = new _t(g, e, t);
		}
		return u;
	}
	unsubscribe_(e) {
		const t = this._bindingsIndicesByPath,
			n = t[e];
		if (n !== void 0) {
			const s = this._paths,
				r = this._parsedPaths,
				o = this._bindings,
				a = o.length - 1,
				l = o[a],
				c = e[a];
			(t[c] = n), (o[n] = l), o.pop(), (r[n] = r[a]), r.pop(), (s[n] = s[a]), s.pop();
		}
	}
}
class rT {
	constructor(e, t, n = null, s = t.blendMode) {
		(this._mixer = e), (this._clip = t), (this._localRoot = n), (this.blendMode = s);
		const r = t.tracks,
			o = r.length,
			a = new Array(o),
			l = { endingStart: aa, endingEnd: aa };
		for (let c = 0; c !== o; ++c) {
			const h = r[c].createInterpolant(null);
			(a[c] = h), (h.settings = l);
		}
		(this._interpolantSettings = l),
			(this._interpolants = a),
			(this._propertyBindings = new Array(o)),
			(this._cacheIndex = null),
			(this._byClipCacheIndex = null),
			(this._timeScaleInterpolant = null),
			(this._weightInterpolant = null),
			(this.loop = qM),
			(this._loopCount = -1),
			(this._startTime = null),
			(this.time = 0),
			(this.timeScale = 1),
			(this._effectiveTimeScale = 1),
			(this.weight = 1),
			(this._effectiveWeight = 1),
			(this.repetitions = 1 / 0),
			(this.paused = !1),
			(this.enabled = !0),
			(this.clampWhenFinished = !1),
			(this.zeroSlopeAtStart = !0),
			(this.zeroSlopeAtEnd = !0);
	}
	play() {
		return this._mixer._activateAction(this), this;
	}
	stop() {
		return this._mixer._deactivateAction(this), this.reset();
	}
	reset() {
		return (
			(this.paused = !1),
			(this.enabled = !0),
			(this.time = 0),
			(this._loopCount = -1),
			(this._startTime = null),
			this.stopFading().stopWarping()
		);
	}
	isRunning() {
		return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
	}
	isScheduled() {
		return this._mixer._isActiveAction(this);
	}
	startAt(e) {
		return (this._startTime = e), this;
	}
	setLoop(e, t) {
		return (this.loop = e), (this.repetitions = t), this;
	}
	setEffectiveWeight(e) {
		return (this.weight = e), (this._effectiveWeight = this.enabled ? e : 0), this.stopFading();
	}
	getEffectiveWeight() {
		return this._effectiveWeight;
	}
	fadeIn(e) {
		return this._scheduleFading(e, 0, 1);
	}
	fadeOut(e) {
		return this._scheduleFading(e, 1, 0);
	}
	crossFadeFrom(e, t, n) {
		if ((e.fadeOut(t), this.fadeIn(t), n)) {
			const s = this._clip.duration,
				r = e._clip.duration,
				o = r / s,
				a = s / r;
			e.warp(1, o, t), this.warp(a, 1, t);
		}
		return this;
	}
	crossFadeTo(e, t, n) {
		return e.crossFadeFrom(this, t, n);
	}
	stopFading() {
		const e = this._weightInterpolant;
		return e !== null && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(e)), this;
	}
	setEffectiveTimeScale(e) {
		return (this.timeScale = e), (this._effectiveTimeScale = this.paused ? 0 : e), this.stopWarping();
	}
	getEffectiveTimeScale() {
		return this._effectiveTimeScale;
	}
	setDuration(e) {
		return (this.timeScale = this._clip.duration / e), this.stopWarping();
	}
	syncWith(e) {
		return (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping();
	}
	halt(e) {
		return this.warp(this._effectiveTimeScale, 0, e);
	}
	warp(e, t, n) {
		const s = this._mixer,
			r = s.time,
			o = this.timeScale;
		let a = this._timeScaleInterpolant;
		a === null && ((a = s._lendControlInterpolant()), (this._timeScaleInterpolant = a));
		const l = a.parameterPositions,
			c = a.sampleValues;
		return (l[0] = r), (l[1] = r + n), (c[0] = e / o), (c[1] = t / o), this;
	}
	stopWarping() {
		const e = this._timeScaleInterpolant;
		return e !== null && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(e)), this;
	}
	getMixer() {
		return this._mixer;
	}
	getClip() {
		return this._clip;
	}
	getRoot() {
		return this._localRoot || this._mixer._root;
	}
	_update(e, t, n, s) {
		if (!this.enabled) {
			this._updateWeight(e);
			return;
		}
		const r = this._startTime;
		if (r !== null) {
			const l = (e - r) * n;
			l < 0 || n === 0 ? (t = 0) : ((this._startTime = null), (t = n * l));
		}
		t *= this._updateTimeScale(e);
		const o = this._updateTime(t),
			a = this._updateWeight(e);
		if (a > 0) {
			const l = this._interpolants,
				c = this._propertyBindings;
			switch (this.blendMode) {
				case w_:
					for (let h = 0, u = l.length; h !== u; ++h) l[h].evaluate(o), c[h].accumulateAdditive(a);
					break;
				case kp:
				default:
					for (let h = 0, u = l.length; h !== u; ++h) l[h].evaluate(o), c[h].accumulate(s, a);
			}
		}
	}
	_updateWeight(e) {
		let t = 0;
		if (this.enabled) {
			t = this.weight;
			const n = this._weightInterpolant;
			if (n !== null) {
				const s = n.evaluate(e)[0];
				(t *= s), e > n.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1));
			}
		}
		return (this._effectiveWeight = t), t;
	}
	_updateTimeScale(e) {
		let t = 0;
		if (!this.paused) {
			t = this.timeScale;
			const n = this._timeScaleInterpolant;
			if (n !== null) {
				const s = n.evaluate(e)[0];
				(t *= s), e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? (this.paused = !0) : (this.timeScale = t));
			}
		}
		return (this._effectiveTimeScale = t), t;
	}
	_updateTime(e) {
		const t = this._clip.duration,
			n = this.loop;
		let s = this.time + e,
			r = this._loopCount;
		const o = n === YM;
		if (e === 0) return r === -1 ? s : o && (r & 1) === 1 ? t - s : s;
		if (n === XM) {
			r === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
			e: {
				if (s >= t) s = t;
				else if (s < 0) s = 0;
				else {
					this.time = s;
					break e;
				}
				this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
					(this.time = s),
					this._mixer.dispatchEvent({ type: 'finished', action: this, direction: e < 0 ? -1 : 1 });
			}
		} else {
			if (
				(r === -1 &&
					(e >= 0 ? ((r = 0), this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)),
				s >= t || s < 0)
			) {
				const a = Math.floor(s / t);
				(s -= t * a), (r += Math.abs(a));
				const l = this.repetitions - r;
				if (l <= 0)
					this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
						(s = e > 0 ? t : 0),
						(this.time = s),
						this._mixer.dispatchEvent({ type: 'finished', action: this, direction: e > 0 ? 1 : -1 });
				else {
					if (l === 1) {
						const c = e < 0;
						this._setEndings(c, !c, o);
					} else this._setEndings(!1, !1, o);
					(this._loopCount = r), (this.time = s), this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: a });
				}
			} else this.time = s;
			if (o && (r & 1) === 1) return t - s;
		}
		return s;
	}
	_setEndings(e, t, n) {
		const s = this._interpolantSettings;
		n
			? ((s.endingStart = la), (s.endingEnd = la))
			: (e ? (s.endingStart = this.zeroSlopeAtStart ? la : aa) : (s.endingStart = xh),
			  t ? (s.endingEnd = this.zeroSlopeAtEnd ? la : aa) : (s.endingEnd = xh));
	}
	_scheduleFading(e, t, n) {
		const s = this._mixer,
			r = s.time;
		let o = this._weightInterpolant;
		o === null && ((o = s._lendControlInterpolant()), (this._weightInterpolant = o));
		const a = o.parameterPositions,
			l = o.sampleValues;
		return (a[0] = r), (l[0] = t), (a[1] = r + e), (l[1] = n), this;
	}
}
const E3 = new Float32Array(1);
class T3 extends Hi {
	constructor(e) {
		super(), (this._root = e), this._initMemoryManager(), (this._accuIndex = 0), (this.time = 0), (this.timeScale = 1);
	}
	_bindAction(e, t) {
		const n = e._localRoot || this._root,
			s = e._clip.tracks,
			r = s.length,
			o = e._propertyBindings,
			a = e._interpolants,
			l = n.uuid,
			c = this._bindingsByRootAndName;
		let h = c[l];
		h === void 0 && ((h = {}), (c[l] = h));
		for (let u = 0; u !== r; ++u) {
			const d = s[u],
				p = d.name;
			let g = h[p];
			if (g !== void 0) ++g.referenceCount, (o[u] = g);
			else {
				if (((g = o[u]), g !== void 0)) {
					g._cacheIndex === null && (++g.referenceCount, this._addInactiveBinding(g, l, p));
					continue;
				}
				const v = t && t._propertyBindings[u].binding.parsedPath;
				(g = new sT(_t.create(n, p, v), d.ValueTypeName, d.getValueSize())),
					++g.referenceCount,
					this._addInactiveBinding(g, l, p),
					(o[u] = g);
			}
			a[u].resultBuffer = g.buffer;
		}
	}
	_activateAction(e) {
		if (!this._isActiveAction(e)) {
			if (e._cacheIndex === null) {
				const n = (e._localRoot || this._root).uuid,
					s = e._clip.uuid,
					r = this._actionsByClip[s];
				this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, s, n);
			}
			const t = e._propertyBindings;
			for (let n = 0, s = t.length; n !== s; ++n) {
				const r = t[n];
				r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
			}
			this._lendAction(e);
		}
	}
	_deactivateAction(e) {
		if (this._isActiveAction(e)) {
			const t = e._propertyBindings;
			for (let n = 0, s = t.length; n !== s; ++n) {
				const r = t[n];
				--r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
			}
			this._takeBackAction(e);
		}
	}
	_initMemoryManager() {
		(this._actions = []),
			(this._nActiveActions = 0),
			(this._actionsByClip = {}),
			(this._bindings = []),
			(this._nActiveBindings = 0),
			(this._bindingsByRootAndName = {}),
			(this._controlInterpolants = []),
			(this._nActiveControlInterpolants = 0);
		const e = this;
		this.stats = {
			actions: {
				get total() {
					return e._actions.length;
				},
				get inUse() {
					return e._nActiveActions;
				},
			},
			bindings: {
				get total() {
					return e._bindings.length;
				},
				get inUse() {
					return e._nActiveBindings;
				},
			},
			controlInterpolants: {
				get total() {
					return e._controlInterpolants.length;
				},
				get inUse() {
					return e._nActiveControlInterpolants;
				},
			},
		};
	}
	_isActiveAction(e) {
		const t = e._cacheIndex;
		return t !== null && t < this._nActiveActions;
	}
	_addInactiveAction(e, t, n) {
		const s = this._actions,
			r = this._actionsByClip;
		let o = r[t];
		if (o === void 0) (o = { knownActions: [e], actionByRoot: {} }), (e._byClipCacheIndex = 0), (r[t] = o);
		else {
			const a = o.knownActions;
			(e._byClipCacheIndex = a.length), a.push(e);
		}
		(e._cacheIndex = s.length), s.push(e), (o.actionByRoot[n] = e);
	}
	_removeInactiveAction(e) {
		const t = this._actions,
			n = t[t.length - 1],
			s = e._cacheIndex;
		(n._cacheIndex = s), (t[s] = n), t.pop(), (e._cacheIndex = null);
		const r = e._clip.uuid,
			o = this._actionsByClip,
			a = o[r],
			l = a.knownActions,
			c = l[l.length - 1],
			h = e._byClipCacheIndex;
		(c._byClipCacheIndex = h), (l[h] = c), l.pop(), (e._byClipCacheIndex = null);
		const u = a.actionByRoot,
			d = (e._localRoot || this._root).uuid;
		delete u[d], l.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e);
	}
	_removeInactiveBindingsForAction(e) {
		const t = e._propertyBindings;
		for (let n = 0, s = t.length; n !== s; ++n) {
			const r = t[n];
			--r.referenceCount === 0 && this._removeInactiveBinding(r);
		}
	}
	_lendAction(e) {
		const t = this._actions,
			n = e._cacheIndex,
			s = this._nActiveActions++,
			r = t[s];
		(e._cacheIndex = s), (t[s] = e), (r._cacheIndex = n), (t[n] = r);
	}
	_takeBackAction(e) {
		const t = this._actions,
			n = e._cacheIndex,
			s = --this._nActiveActions,
			r = t[s];
		(e._cacheIndex = s), (t[s] = e), (r._cacheIndex = n), (t[n] = r);
	}
	_addInactiveBinding(e, t, n) {
		const s = this._bindingsByRootAndName,
			r = this._bindings;
		let o = s[t];
		o === void 0 && ((o = {}), (s[t] = o)), (o[n] = e), (e._cacheIndex = r.length), r.push(e);
	}
	_removeInactiveBinding(e) {
		const t = this._bindings,
			n = e.binding,
			s = n.rootNode.uuid,
			r = n.path,
			o = this._bindingsByRootAndName,
			a = o[s],
			l = t[t.length - 1],
			c = e._cacheIndex;
		(l._cacheIndex = c), (t[c] = l), t.pop(), delete a[r], Object.keys(a).length === 0 && delete o[s];
	}
	_lendBinding(e) {
		const t = this._bindings,
			n = e._cacheIndex,
			s = this._nActiveBindings++,
			r = t[s];
		(e._cacheIndex = s), (t[s] = e), (r._cacheIndex = n), (t[n] = r);
	}
	_takeBackBinding(e) {
		const t = this._bindings,
			n = e._cacheIndex,
			s = --this._nActiveBindings,
			r = t[s];
		(e._cacheIndex = s), (t[s] = e), (r._cacheIndex = n), (t[n] = r);
	}
	_lendControlInterpolant() {
		const e = this._controlInterpolants,
			t = this._nActiveControlInterpolants++;
		let n = e[t];
		return n === void 0 && ((n = new G_(new Float32Array(2), new Float32Array(2), 1, E3)), (n.__cacheIndex = t), (e[t] = n)), n;
	}
	_takeBackControlInterpolant(e) {
		const t = this._controlInterpolants,
			n = e.__cacheIndex,
			s = --this._nActiveControlInterpolants,
			r = t[s];
		(e.__cacheIndex = s), (t[s] = e), (r.__cacheIndex = n), (t[n] = r);
	}
	clipAction(e, t, n) {
		const s = t || this._root,
			r = s.uuid;
		let o = typeof e == 'string' ? Ql.findByName(s, e) : e;
		const a = o !== null ? o.uuid : e,
			l = this._actionsByClip[a];
		let c = null;
		if ((n === void 0 && (o !== null ? (n = o.blendMode) : (n = kp)), l !== void 0)) {
			const u = l.actionByRoot[r];
			if (u !== void 0 && u.blendMode === n) return u;
			(c = l.knownActions[0]), o === null && (o = c._clip);
		}
		if (o === null) return null;
		const h = new rT(this, o, t, n);
		return this._bindAction(h, c), this._addInactiveAction(h, a, r), h;
	}
	existingAction(e, t) {
		const n = t || this._root,
			s = n.uuid,
			r = typeof e == 'string' ? Ql.findByName(n, e) : e,
			o = r ? r.uuid : e,
			a = this._actionsByClip[o];
		return (a !== void 0 && a.actionByRoot[s]) || null;
	}
	stopAllAction() {
		const e = this._actions,
			t = this._nActiveActions;
		for (let n = t - 1; n >= 0; --n) e[n].stop();
		return this;
	}
	update(e) {
		e *= this.timeScale;
		const t = this._actions,
			n = this._nActiveActions,
			s = (this.time += e),
			r = Math.sign(e),
			o = (this._accuIndex ^= 1);
		for (let c = 0; c !== n; ++c) t[c]._update(s, e, r, o);
		const a = this._bindings,
			l = this._nActiveBindings;
		for (let c = 0; c !== l; ++c) a[c].apply(o);
		return this;
	}
	setTime(e) {
		this.time = 0;
		for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
		return this.update(e);
	}
	getRoot() {
		return this._root;
	}
	uncacheClip(e) {
		const t = this._actions,
			n = e.uuid,
			s = this._actionsByClip,
			r = s[n];
		if (r !== void 0) {
			const o = r.knownActions;
			for (let a = 0, l = o.length; a !== l; ++a) {
				const c = o[a];
				this._deactivateAction(c);
				const h = c._cacheIndex,
					u = t[t.length - 1];
				(c._cacheIndex = null),
					(c._byClipCacheIndex = null),
					(u._cacheIndex = h),
					(t[h] = u),
					t.pop(),
					this._removeInactiveBindingsForAction(c);
			}
			delete s[n];
		}
	}
	uncacheRoot(e) {
		const t = e.uuid,
			n = this._actionsByClip;
		for (const o in n) {
			const a = n[o].actionByRoot,
				l = a[t];
			l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
		}
		const s = this._bindingsByRootAndName,
			r = s[t];
		if (r !== void 0)
			for (const o in r) {
				const a = r[o];
				a.restoreOriginalState(), this._removeInactiveBinding(a);
			}
	}
	uncacheAction(e, t) {
		const n = this.existingAction(e, t);
		n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
	}
}
class yt {
	constructor(e) {
		this.value = e;
	}
	clone() {
		return new yt(this.value.clone === void 0 ? this.value : this.value.clone());
	}
}
let A3 = 0;
class C3 extends Hi {
	constructor() {
		super(),
			(this.isUniformsGroup = !0),
			Object.defineProperty(this, 'id', { value: A3++ }),
			(this.name = ''),
			(this.usage = Mh),
			(this.uniforms = []);
	}
	add(e) {
		return this.uniforms.push(e), this;
	}
	remove(e) {
		const t = this.uniforms.indexOf(e);
		return t !== -1 && this.uniforms.splice(t, 1), this;
	}
	setName(e) {
		return (this.name = e), this;
	}
	setUsage(e) {
		return (this.usage = e), this;
	}
	dispose() {
		return this.dispatchEvent({ type: 'dispose' }), this;
	}
	copy(e) {
		(this.name = e.name), (this.usage = e.usage);
		const t = e.uniforms;
		this.uniforms.length = 0;
		for (let n = 0, s = t.length; n < s; n++) {
			const r = Array.isArray(t[n]) ? t[n] : [t[n]];
			for (let o = 0; o < r.length; o++) this.uniforms.push(r[o].clone());
		}
		return this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
class R3 extends nu {
	constructor(e, t, n = 1) {
		super(e, t), (this.isInstancedInterleavedBuffer = !0), (this.meshPerAttribute = n);
	}
	copy(e) {
		return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
	}
	clone(e) {
		const t = super.clone(e);
		return (t.meshPerAttribute = this.meshPerAttribute), t;
	}
	toJSON(e) {
		const t = super.toJSON(e);
		return (t.isInstancedInterleavedBuffer = !0), (t.meshPerAttribute = this.meshPerAttribute), t;
	}
}
class P3 {
	constructor(e, t, n, s, r) {
		(this.isGLBufferAttribute = !0),
			(this.name = ''),
			(this.buffer = e),
			(this.type = t),
			(this.itemSize = n),
			(this.elementSize = s),
			(this.count = r),
			(this.version = 0);
	}
	set needsUpdate(e) {
		e === !0 && this.version++;
	}
	setBuffer(e) {
		return (this.buffer = e), this;
	}
	setType(e, t) {
		return (this.type = e), (this.elementSize = t), this;
	}
	setItemSize(e) {
		return (this.itemSize = e), this;
	}
	setCount(e) {
		return (this.count = e), this;
	}
}
const pb = new He();
class e0 {
	constructor(e, t, n = 0, s = 1 / 0) {
		(this.ray = new ka(e, t)),
			(this.near = n),
			(this.far = s),
			(this.camera = null),
			(this.layers = new Gp()),
			(this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} });
	}
	set(e, t) {
		this.ray.set(e, t);
	}
	setFromCamera(e, t) {
		t.isPerspectiveCamera
			? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
			  this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(),
			  (this.camera = t))
			: t.isOrthographicCamera
			? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
			  this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
			  (this.camera = t))
			: console.error('THREE.Raycaster: Unsupported camera type: ' + t.type);
	}
	setFromXRController(e) {
		return (
			pb.identity().extractRotation(e.matrixWorld),
			this.ray.origin.setFromMatrixPosition(e.matrixWorld),
			this.ray.direction.set(0, 0, -1).applyMatrix4(pb),
			this
		);
	}
	intersectObject(e, t = !0, n = []) {
		return lv(e, this, n, t), n.sort(fb), n;
	}
	intersectObjects(e, t = !0, n = []) {
		for (let s = 0, r = e.length; s < r; s++) lv(e[s], this, n, t);
		return n.sort(fb), n;
	}
}
function fb(i, e) {
	return i.distance - e.distance;
}
function lv(i, e, t, n) {
	if ((i.layers.test(e.layers) && i.raycast(e, t), n === !0)) {
		const s = i.children;
		for (let r = 0, o = s.length; r < o; r++) lv(s[r], e, t, !0);
	}
}
class L3 {
	constructor(e = 1, t = 0, n = 0) {
		return (this.radius = e), (this.phi = t), (this.theta = n), this;
	}
	set(e, t, n) {
		return (this.radius = e), (this.phi = t), (this.theta = n), this;
	}
	copy(e) {
		return (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this;
	}
	makeSafe() {
		return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this;
	}
	setFromVector3(e) {
		return this.setFromCartesianCoords(e.x, e.y, e.z);
	}
	setFromCartesianCoords(e, t, n) {
		return (
			(this.radius = Math.sqrt(e * e + t * t + n * n)),
			this.radius === 0
				? ((this.theta = 0), (this.phi = 0))
				: ((this.theta = Math.atan2(e, n)), (this.phi = Math.acos(ln(t / this.radius, -1, 1)))),
			this
		);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
class I3 {
	constructor(e = 1, t = 0, n = 0) {
		return (this.radius = e), (this.theta = t), (this.y = n), this;
	}
	set(e, t, n) {
		return (this.radius = e), (this.theta = t), (this.y = n), this;
	}
	copy(e) {
		return (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this;
	}
	setFromVector3(e) {
		return this.setFromCartesianCoords(e.x, e.y, e.z);
	}
	setFromCartesianCoords(e, t, n) {
		return (this.radius = Math.sqrt(e * e + n * n)), (this.theta = Math.atan2(e, n)), (this.y = t), this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const mb = new ce();
class D3 {
	constructor(e = new ce(1 / 0, 1 / 0), t = new ce(-1 / 0, -1 / 0)) {
		(this.isBox2 = !0), (this.min = e), (this.max = t);
	}
	set(e, t) {
		return this.min.copy(e), this.max.copy(t), this;
	}
	setFromPoints(e) {
		this.makeEmpty();
		for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
		return this;
	}
	setFromCenterAndSize(e, t) {
		const n = mb.copy(t).multiplyScalar(0.5);
		return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
	}
	clone() {
		return new this.constructor().copy(this);
	}
	copy(e) {
		return this.min.copy(e.min), this.max.copy(e.max), this;
	}
	makeEmpty() {
		return (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this;
	}
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y;
	}
	getCenter(e) {
		return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
	}
	getSize(e) {
		return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
	}
	expandByPoint(e) {
		return this.min.min(e), this.max.max(e), this;
	}
	expandByVector(e) {
		return this.min.sub(e), this.max.add(e), this;
	}
	expandByScalar(e) {
		return this.min.addScalar(-e), this.max.addScalar(e), this;
	}
	containsPoint(e) {
		return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
	}
	containsBox(e) {
		return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
	}
	getParameter(e, t) {
		return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
	}
	intersectsBox(e) {
		return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
	}
	clampPoint(e, t) {
		return t.copy(e).clamp(this.min, this.max);
	}
	distanceToPoint(e) {
		return this.clampPoint(e, mb).distanceTo(e);
	}
	intersect(e) {
		return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
	}
	union(e) {
		return this.min.min(e.min), this.max.max(e.max), this;
	}
	translate(e) {
		return this.min.add(e), this.max.add(e), this;
	}
	equals(e) {
		return e.min.equals(this.min) && e.max.equals(this.max);
	}
}
const gb = new I(),
	md = new I();
class O3 {
	constructor(e = new I(), t = new I()) {
		(this.start = e), (this.end = t);
	}
	set(e, t) {
		return this.start.copy(e), this.end.copy(t), this;
	}
	copy(e) {
		return this.start.copy(e.start), this.end.copy(e.end), this;
	}
	getCenter(e) {
		return e.addVectors(this.start, this.end).multiplyScalar(0.5);
	}
	delta(e) {
		return e.subVectors(this.end, this.start);
	}
	distanceSq() {
		return this.start.distanceToSquared(this.end);
	}
	distance() {
		return this.start.distanceTo(this.end);
	}
	at(e, t) {
		return this.delta(t).multiplyScalar(e).add(this.start);
	}
	closestPointToPointParameter(e, t) {
		gb.subVectors(e, this.start), md.subVectors(this.end, this.start);
		const n = md.dot(md);
		let r = md.dot(gb) / n;
		return t && (r = ln(r, 0, 1)), r;
	}
	closestPointToPoint(e, t, n) {
		const s = this.closestPointToPointParameter(e, t);
		return this.delta(n).multiplyScalar(s).add(this.start);
	}
	applyMatrix4(e) {
		return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
	}
	equals(e) {
		return e.start.equals(this.start) && e.end.equals(this.end);
	}
	clone() {
		return new this.constructor().copy(this);
	}
}
const vb = new I();
class oT extends ft {
	constructor(e, t) {
		super(), (this.light = e), (this.matrixAutoUpdate = !1), (this.color = t), (this.type = 'SpotLightHelper');
		const n = new Ze(),
			s = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
		for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
			const c = (o / l) * Math.PI * 2,
				h = (a / l) * Math.PI * 2;
			s.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1);
		}
		n.setAttribute('position', new ze(s, 3));
		const r = new Jn({ fog: !1, toneMapped: !1 });
		(this.cone = new as(n, r)), this.add(this.cone), this.update();
	}
	dispose() {
		this.cone.geometry.dispose(), this.cone.material.dispose();
	}
	update() {
		this.light.updateWorldMatrix(!0, !1),
			this.light.target.updateWorldMatrix(!0, !1),
			this.parent
				? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld))
				: this.matrix.copy(this.light.matrixWorld),
			this.matrixWorld.copy(this.light.matrixWorld);
		const e = this.light.distance ? this.light.distance : 1e3,
			t = e * Math.tan(this.light.angle);
		this.cone.scale.set(t, t, e),
			vb.setFromMatrixPosition(this.light.target.matrixWorld),
			this.cone.lookAt(vb),
			this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
	}
}
const Br = new I(),
	gd = new He(),
	wm = new He();
class U3 extends as {
	constructor(e) {
		const t = aT(e),
			n = new Ze(),
			s = [],
			r = [],
			o = new Ee(0, 0, 1),
			a = new Ee(0, 1, 0);
		for (let c = 0; c < t.length; c++) {
			const h = t[c];
			h.parent && h.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b));
		}
		n.setAttribute('position', new ze(s, 3)), n.setAttribute('color', new ze(r, 3));
		const l = new Jn({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
		super(n, l),
			(this.isSkeletonHelper = !0),
			(this.type = 'SkeletonHelper'),
			(this.root = e),
			(this.bones = t),
			(this.matrix = e.matrixWorld),
			(this.matrixAutoUpdate = !1);
	}
	updateMatrixWorld(e) {
		const t = this.bones,
			n = this.geometry,
			s = n.getAttribute('position');
		wm.copy(this.root.matrixWorld).invert();
		for (let r = 0, o = 0; r < t.length; r++) {
			const a = t[r];
			a.parent &&
				a.parent.isBone &&
				(gd.multiplyMatrices(wm, a.matrixWorld),
				Br.setFromMatrixPosition(gd),
				s.setXYZ(o, Br.x, Br.y, Br.z),
				gd.multiplyMatrices(wm, a.parent.matrixWorld),
				Br.setFromMatrixPosition(gd),
				s.setXYZ(o + 1, Br.x, Br.y, Br.z),
				(o += 2));
		}
		(n.getAttribute('position').needsUpdate = !0), super.updateMatrixWorld(e);
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
function aT(i) {
	const e = [];
	i.isBone === !0 && e.push(i);
	for (let t = 0; t < i.children.length; t++) e.push.apply(e, aT(i.children[t]));
	return e;
}
class N3 extends bt {
	constructor(e, t, n) {
		const s = new hc(t, 4, 2),
			r = new En({ wireframe: !0, fog: !1, toneMapped: !1 });
		super(s, r),
			(this.light = e),
			(this.color = n),
			(this.type = 'PointLightHelper'),
			(this.matrix = this.light.matrixWorld),
			(this.matrixAutoUpdate = !1),
			this.update();
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
	update() {
		this.light.updateWorldMatrix(!0, !1),
			this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
	}
}
const F3 = new I(),
	_b = new Ee(),
	yb = new Ee();
class lT extends ft {
	constructor(e, t, n) {
		super(),
			(this.light = e),
			(this.matrix = e.matrixWorld),
			(this.matrixAutoUpdate = !1),
			(this.color = n),
			(this.type = 'HemisphereLightHelper');
		const s = new ru(t);
		s.rotateY(Math.PI * 0.5),
			(this.material = new En({ wireframe: !0, fog: !1, toneMapped: !1 })),
			this.color === void 0 && (this.material.vertexColors = !0);
		const r = s.getAttribute('position'),
			o = new Float32Array(r.count * 3);
		s.setAttribute('color', new $e(o, 3)), this.add(new bt(s, this.material)), this.update();
	}
	dispose() {
		this.children[0].geometry.dispose(), this.children[0].material.dispose();
	}
	update() {
		const e = this.children[0];
		if (this.color !== void 0) this.material.color.set(this.color);
		else {
			const t = e.geometry.getAttribute('color');
			_b.copy(this.light.color), yb.copy(this.light.groundColor);
			for (let n = 0, s = t.count; n < s; n++) {
				const r = n < s / 2 ? _b : yb;
				t.setXYZ(n, r.r, r.g, r.b);
			}
			t.needsUpdate = !0;
		}
		this.light.updateWorldMatrix(!0, !1), e.lookAt(F3.setFromMatrixPosition(this.light.matrixWorld).negate());
	}
}
class B3 extends as {
	constructor(e = 10, t = 10, n = 4473924, s = 8947848) {
		(n = new Ee(n)), (s = new Ee(s));
		const r = t / 2,
			o = e / t,
			a = e / 2,
			l = [],
			c = [];
		for (let d = 0, p = 0, g = -a; d <= t; d++, g += o) {
			l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
			const v = d === r ? n : s;
			v.toArray(c, p), (p += 3), v.toArray(c, p), (p += 3), v.toArray(c, p), (p += 3), v.toArray(c, p), (p += 3);
		}
		const h = new Ze();
		h.setAttribute('position', new ze(l, 3)), h.setAttribute('color', new ze(c, 3));
		const u = new Jn({ vertexColors: !0, toneMapped: !1 });
		super(h, u), (this.type = 'GridHelper');
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
class k3 extends as {
	constructor(e = 10, t = 16, n = 8, s = 64, r = 4473924, o = 8947848) {
		(r = new Ee(r)), (o = new Ee(o));
		const a = [],
			l = [];
		if (t > 1)
			for (let u = 0; u < t; u++) {
				const d = (u / t) * (Math.PI * 2),
					p = Math.sin(d) * e,
					g = Math.cos(d) * e;
				a.push(0, 0, 0), a.push(p, 0, g);
				const v = u & 1 ? r : o;
				l.push(v.r, v.g, v.b), l.push(v.r, v.g, v.b);
			}
		for (let u = 0; u < n; u++) {
			const d = u & 1 ? r : o,
				p = e - (e / n) * u;
			for (let g = 0; g < s; g++) {
				let v = (g / s) * (Math.PI * 2),
					m = Math.sin(v) * p,
					f = Math.cos(v) * p;
				a.push(m, 0, f),
					l.push(d.r, d.g, d.b),
					(v = ((g + 1) / s) * (Math.PI * 2)),
					(m = Math.sin(v) * p),
					(f = Math.cos(v) * p),
					a.push(m, 0, f),
					l.push(d.r, d.g, d.b);
			}
		}
		const c = new Ze();
		c.setAttribute('position', new ze(a, 3)), c.setAttribute('color', new ze(l, 3));
		const h = new Jn({ vertexColors: !0, toneMapped: !1 });
		super(c, h), (this.type = 'PolarGridHelper');
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
const xb = new I(),
	vd = new I(),
	bb = new I();
class cT extends ft {
	constructor(e, t, n) {
		super(),
			(this.light = e),
			(this.matrix = e.matrixWorld),
			(this.matrixAutoUpdate = !1),
			(this.color = n),
			(this.type = 'DirectionalLightHelper'),
			t === void 0 && (t = 1);
		let s = new Ze();
		s.setAttribute('position', new ze([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
		const r = new Jn({ fog: !1, toneMapped: !1 });
		(this.lightPlane = new xr(s, r)),
			this.add(this.lightPlane),
			(s = new Ze()),
			s.setAttribute('position', new ze([0, 0, 0, 0, 0, 1], 3)),
			(this.targetLine = new xr(s, r)),
			this.add(this.targetLine),
			this.update();
	}
	dispose() {
		this.lightPlane.geometry.dispose(),
			this.lightPlane.material.dispose(),
			this.targetLine.geometry.dispose(),
			this.targetLine.material.dispose();
	}
	update() {
		this.light.updateWorldMatrix(!0, !1),
			this.light.target.updateWorldMatrix(!0, !1),
			xb.setFromMatrixPosition(this.light.matrixWorld),
			vd.setFromMatrixPosition(this.light.target.matrixWorld),
			bb.subVectors(vd, xb),
			this.lightPlane.lookAt(vd),
			this.color !== void 0
				? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color))
				: (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)),
			this.targetLine.lookAt(vd),
			(this.targetLine.scale.z = bb.length());
	}
}
const _d = new I(),
	an = new Zh();
class z3 extends as {
	constructor(e) {
		const t = new Ze(),
			n = new Jn({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
			s = [],
			r = [],
			o = {};
		a('n1', 'n2'),
			a('n2', 'n4'),
			a('n4', 'n3'),
			a('n3', 'n1'),
			a('f1', 'f2'),
			a('f2', 'f4'),
			a('f4', 'f3'),
			a('f3', 'f1'),
			a('n1', 'f1'),
			a('n2', 'f2'),
			a('n3', 'f3'),
			a('n4', 'f4'),
			a('p', 'n1'),
			a('p', 'n2'),
			a('p', 'n3'),
			a('p', 'n4'),
			a('u1', 'u2'),
			a('u2', 'u3'),
			a('u3', 'u1'),
			a('c', 't'),
			a('p', 'c'),
			a('cn1', 'cn2'),
			a('cn3', 'cn4'),
			a('cf1', 'cf2'),
			a('cf3', 'cf4');
		function a(g, v) {
			l(g), l(v);
		}
		function l(g) {
			s.push(0, 0, 0), r.push(0, 0, 0), o[g] === void 0 && (o[g] = []), o[g].push(s.length / 3 - 1);
		}
		t.setAttribute('position', new ze(s, 3)),
			t.setAttribute('color', new ze(r, 3)),
			super(t, n),
			(this.type = 'CameraHelper'),
			(this.camera = e),
			this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
			(this.matrix = e.matrixWorld),
			(this.matrixAutoUpdate = !1),
			(this.pointMap = o),
			this.update();
		const c = new Ee(16755200),
			h = new Ee(16711680),
			u = new Ee(43775),
			d = new Ee(16777215),
			p = new Ee(3355443);
		this.setColors(c, h, u, d, p);
	}
	setColors(e, t, n, s, r) {
		const a = this.geometry.getAttribute('color');
		a.setXYZ(0, e.r, e.g, e.b),
			a.setXYZ(1, e.r, e.g, e.b),
			a.setXYZ(2, e.r, e.g, e.b),
			a.setXYZ(3, e.r, e.g, e.b),
			a.setXYZ(4, e.r, e.g, e.b),
			a.setXYZ(5, e.r, e.g, e.b),
			a.setXYZ(6, e.r, e.g, e.b),
			a.setXYZ(7, e.r, e.g, e.b),
			a.setXYZ(8, e.r, e.g, e.b),
			a.setXYZ(9, e.r, e.g, e.b),
			a.setXYZ(10, e.r, e.g, e.b),
			a.setXYZ(11, e.r, e.g, e.b),
			a.setXYZ(12, e.r, e.g, e.b),
			a.setXYZ(13, e.r, e.g, e.b),
			a.setXYZ(14, e.r, e.g, e.b),
			a.setXYZ(15, e.r, e.g, e.b),
			a.setXYZ(16, e.r, e.g, e.b),
			a.setXYZ(17, e.r, e.g, e.b),
			a.setXYZ(18, e.r, e.g, e.b),
			a.setXYZ(19, e.r, e.g, e.b),
			a.setXYZ(20, e.r, e.g, e.b),
			a.setXYZ(21, e.r, e.g, e.b),
			a.setXYZ(22, e.r, e.g, e.b),
			a.setXYZ(23, e.r, e.g, e.b),
			a.setXYZ(24, t.r, t.g, t.b),
			a.setXYZ(25, t.r, t.g, t.b),
			a.setXYZ(26, t.r, t.g, t.b),
			a.setXYZ(27, t.r, t.g, t.b),
			a.setXYZ(28, t.r, t.g, t.b),
			a.setXYZ(29, t.r, t.g, t.b),
			a.setXYZ(30, t.r, t.g, t.b),
			a.setXYZ(31, t.r, t.g, t.b),
			a.setXYZ(32, n.r, n.g, n.b),
			a.setXYZ(33, n.r, n.g, n.b),
			a.setXYZ(34, n.r, n.g, n.b),
			a.setXYZ(35, n.r, n.g, n.b),
			a.setXYZ(36, n.r, n.g, n.b),
			a.setXYZ(37, n.r, n.g, n.b),
			a.setXYZ(38, s.r, s.g, s.b),
			a.setXYZ(39, s.r, s.g, s.b),
			a.setXYZ(40, r.r, r.g, r.b),
			a.setXYZ(41, r.r, r.g, r.b),
			a.setXYZ(42, r.r, r.g, r.b),
			a.setXYZ(43, r.r, r.g, r.b),
			a.setXYZ(44, r.r, r.g, r.b),
			a.setXYZ(45, r.r, r.g, r.b),
			a.setXYZ(46, r.r, r.g, r.b),
			a.setXYZ(47, r.r, r.g, r.b),
			a.setXYZ(48, r.r, r.g, r.b),
			a.setXYZ(49, r.r, r.g, r.b),
			(a.needsUpdate = !0);
	}
	update() {
		const e = this.geometry,
			t = this.pointMap,
			n = 1,
			s = 1;
		an.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
			dn('c', t, e, an, 0, 0, -1),
			dn('t', t, e, an, 0, 0, 1),
			dn('n1', t, e, an, -n, -s, -1),
			dn('n2', t, e, an, n, -s, -1),
			dn('n3', t, e, an, -n, s, -1),
			dn('n4', t, e, an, n, s, -1),
			dn('f1', t, e, an, -n, -s, 1),
			dn('f2', t, e, an, n, -s, 1),
			dn('f3', t, e, an, -n, s, 1),
			dn('f4', t, e, an, n, s, 1),
			dn('u1', t, e, an, n * 0.7, s * 1.1, -1),
			dn('u2', t, e, an, -n * 0.7, s * 1.1, -1),
			dn('u3', t, e, an, 0, s * 2, -1),
			dn('cf1', t, e, an, -n, 0, 1),
			dn('cf2', t, e, an, n, 0, 1),
			dn('cf3', t, e, an, 0, -s, 1),
			dn('cf4', t, e, an, 0, s, 1),
			dn('cn1', t, e, an, -n, 0, -1),
			dn('cn2', t, e, an, n, 0, -1),
			dn('cn3', t, e, an, 0, -s, -1),
			dn('cn4', t, e, an, 0, s, -1),
			(e.getAttribute('position').needsUpdate = !0);
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
function dn(i, e, t, n, s, r, o) {
	_d.set(s, r, o).unproject(n);
	const a = e[i];
	if (a !== void 0) {
		const l = t.getAttribute('position');
		for (let c = 0, h = a.length; c < h; c++) l.setXYZ(a[c], _d.x, _d.y, _d.z);
	}
}
const yd = new An();
class V3 extends as {
	constructor(e, t = 16776960) {
		const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
			s = new Float32Array(8 * 3),
			r = new Ze();
		r.setIndex(new $e(n, 1)),
			r.setAttribute('position', new $e(s, 3)),
			super(r, new Jn({ color: t, toneMapped: !1 })),
			(this.object = e),
			(this.type = 'BoxHelper'),
			(this.matrixAutoUpdate = !1),
			this.update();
	}
	update(e) {
		if (
			(e !== void 0 && console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
			this.object !== void 0 && yd.setFromObject(this.object),
			yd.isEmpty())
		)
			return;
		const t = yd.min,
			n = yd.max,
			s = this.geometry.attributes.position,
			r = s.array;
		(r[0] = n.x),
			(r[1] = n.y),
			(r[2] = n.z),
			(r[3] = t.x),
			(r[4] = n.y),
			(r[5] = n.z),
			(r[6] = t.x),
			(r[7] = t.y),
			(r[8] = n.z),
			(r[9] = n.x),
			(r[10] = t.y),
			(r[11] = n.z),
			(r[12] = n.x),
			(r[13] = n.y),
			(r[14] = t.z),
			(r[15] = t.x),
			(r[16] = n.y),
			(r[17] = t.z),
			(r[18] = t.x),
			(r[19] = t.y),
			(r[20] = t.z),
			(r[21] = n.x),
			(r[22] = t.y),
			(r[23] = t.z),
			(s.needsUpdate = !0),
			this.geometry.computeBoundingSphere();
	}
	setFromObject(e) {
		return (this.object = e), this.update(), this;
	}
	copy(e, t) {
		return super.copy(e, t), (this.object = e.object), this;
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
class hT extends as {
	constructor(e, t = 16776960) {
		const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
			s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
			r = new Ze();
		r.setIndex(new $e(n, 1)),
			r.setAttribute('position', new ze(s, 3)),
			super(r, new Jn({ color: t, toneMapped: !1 })),
			(this.box = e),
			(this.type = 'Box3Helper'),
			this.geometry.computeBoundingSphere();
	}
	updateMatrixWorld(e) {
		const t = this.box;
		t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
class H3 extends xr {
	constructor(e, t = 1, n = 16776960) {
		const s = n,
			r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
			o = new Ze();
		o.setAttribute('position', new ze(r, 3)),
			o.computeBoundingSphere(),
			super(o, new Jn({ color: s, toneMapped: !1 })),
			(this.type = 'PlaneHelper'),
			(this.plane = e),
			(this.size = t);
		const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
			l = new Ze();
		l.setAttribute('position', new ze(a, 3)),
			l.computeBoundingSphere(),
			this.add(new bt(l, new En({ color: s, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
	}
	updateMatrixWorld(e) {
		this.position.set(0, 0, 0),
			this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
			this.lookAt(this.plane.normal),
			this.translateZ(-this.plane.constant),
			super.updateMatrixWorld(e);
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
	}
}
const wb = new I();
let xd, Sm;
class G3 extends ft {
	constructor(e = new I(0, 0, 1), t = new I(0, 0, 0), n = 1, s = 16776960, r = n * 0.2, o = r * 0.2) {
		super(),
			(this.type = 'ArrowHelper'),
			xd === void 0 &&
				((xd = new Ze()),
				xd.setAttribute('position', new ze([0, 0, 0, 0, 1, 0], 3)),
				(Sm = new Va(0, 0.5, 1, 5, 1)),
				Sm.translate(0, -0.5, 0)),
			this.position.copy(t),
			(this.line = new xr(xd, new Jn({ color: s, toneMapped: !1 }))),
			(this.line.matrixAutoUpdate = !1),
			this.add(this.line),
			(this.cone = new bt(Sm, new En({ color: s, toneMapped: !1 }))),
			(this.cone.matrixAutoUpdate = !1),
			this.add(this.cone),
			this.setDirection(e),
			this.setLength(n, r, o);
	}
	setDirection(e) {
		if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
		else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
		else {
			wb.set(e.z, 0, -e.x).normalize();
			const t = Math.acos(e.y);
			this.quaternion.setFromAxisAngle(wb, t);
		}
	}
	setLength(e, t = e * 0.2, n = t * 0.2) {
		this.line.scale.set(1, Math.max(1e-4, e - t), 1),
			this.line.updateMatrix(),
			this.cone.scale.set(n, t, n),
			(this.cone.position.y = e),
			this.cone.updateMatrix();
	}
	setColor(e) {
		this.line.material.color.set(e), this.cone.material.color.set(e);
	}
	copy(e) {
		return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
	}
	dispose() {
		this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
	}
}
class uT extends as {
	constructor(e = 1) {
		const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
			n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
			s = new Ze();
		s.setAttribute('position', new ze(t, 3)), s.setAttribute('color', new ze(n, 3));
		const r = new Jn({ vertexColors: !0, toneMapped: !1 });
		super(s, r), (this.type = 'AxesHelper');
	}
	setColors(e, t, n) {
		const s = new Ee(),
			r = this.geometry.attributes.color.array;
		return (
			s.set(e),
			s.toArray(r, 0),
			s.toArray(r, 3),
			s.set(t),
			s.toArray(r, 6),
			s.toArray(r, 9),
			s.set(n),
			s.toArray(r, 12),
			s.toArray(r, 15),
			(this.geometry.attributes.color.needsUpdate = !0),
			this
		);
	}
	dispose() {
		this.geometry.dispose(), this.material.dispose();
	}
}
class W3 {
	constructor() {
		(this.type = 'ShapePath'), (this.color = new Ee()), (this.subPaths = []), (this.currentPath = null);
	}
	moveTo(e, t) {
		return (this.currentPath = new Rh()), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
	}
	lineTo(e, t) {
		return this.currentPath.lineTo(e, t), this;
	}
	quadraticCurveTo(e, t, n, s) {
		return this.currentPath.quadraticCurveTo(e, t, n, s), this;
	}
	bezierCurveTo(e, t, n, s, r, o) {
		return this.currentPath.bezierCurveTo(e, t, n, s, r, o), this;
	}
	splineThru(e) {
		return this.currentPath.splineThru(e), this;
	}
	toShapes(e) {
		function t(f) {
			const y = [];
			for (let _ = 0, x = f.length; _ < x; _++) {
				const E = f[_],
					w = new _a();
				(w.curves = E.curves), y.push(w);
			}
			return y;
		}
		function n(f, y) {
			const _ = y.length;
			let x = !1;
			for (let E = _ - 1, w = 0; w < _; E = w++) {
				let C = y[E],
					P = y[w],
					S = P.x - C.x,
					M = P.y - C.y;
				if (Math.abs(M) > Number.EPSILON) {
					if ((M < 0 && ((C = y[w]), (S = -S), (P = y[E]), (M = -M)), f.y < C.y || f.y > P.y)) continue;
					if (f.y === C.y) {
						if (f.x === C.x) return !0;
					} else {
						const k = M * (f.x - C.x) - S * (f.y - C.y);
						if (k === 0) return !0;
						if (k < 0) continue;
						x = !x;
					}
				} else {
					if (f.y !== C.y) continue;
					if ((P.x <= f.x && f.x <= C.x) || (C.x <= f.x && f.x <= P.x)) return !0;
				}
			}
			return x;
		}
		const s = qs.isClockWise,
			r = this.subPaths;
		if (r.length === 0) return [];
		let o, a, l;
		const c = [];
		if (r.length === 1) return (a = r[0]), (l = new _a()), (l.curves = a.curves), c.push(l), c;
		let h = !s(r[0].getPoints());
		h = e ? !h : h;
		const u = [],
			d = [];
		let p = [],
			g = 0,
			v;
		(d[g] = void 0), (p[g] = []);
		for (let f = 0, y = r.length; f < y; f++)
			(a = r[f]),
				(v = a.getPoints()),
				(o = s(v)),
				(o = e ? !o : o),
				o
					? (!h && d[g] && g++, (d[g] = { s: new _a(), p: v }), (d[g].s.curves = a.curves), h && g++, (p[g] = []))
					: p[g].push({ h: a, p: v[0] });
		if (!d[0]) return t(r);
		if (d.length > 1) {
			let f = !1,
				y = 0;
			for (let _ = 0, x = d.length; _ < x; _++) u[_] = [];
			for (let _ = 0, x = d.length; _ < x; _++) {
				const E = p[_];
				for (let w = 0; w < E.length; w++) {
					const C = E[w];
					let P = !0;
					for (let S = 0; S < d.length; S++) n(C.p, d[S].p) && (_ !== S && y++, P ? ((P = !1), u[S].push(C)) : (f = !0));
					P && u[_].push(C);
				}
			}
			y > 0 && f === !1 && (p = u);
		}
		let m;
		for (let f = 0, y = d.length; f < y; f++) {
			(l = d[f].s), c.push(l), (m = p[f]);
			for (let _ = 0, x = m.length; _ < x; _++) l.holes.push(m[_].h);
		}
		return c;
	}
}
class X3 extends yn {
	constructor(e = 1, t = 1, n = 1, s = {}) {
		console.warn(
			'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'
		),
			super(e, t, { ...s, count: n }),
			(this.isWebGLMultipleRenderTargets = !0);
	}
	get texture() {
		return this.textures;
	}
}
typeof __THREE_DEVTOOLS__ < 'u' && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', { detail: { revision: Co } }));
typeof window < 'u' &&
	(window.__THREE__ ? console.warn('WARNING: Multiple instances of Three.js being imported.') : (window.__THREE__ = Co));
const q3 = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				ACESFilmicToneMapping: f_,
				AddEquation: Jr,
				AddOperation: LM,
				AdditiveAnimationBlendMode: w_,
				AdditiveBlending: bs,
				AgXToneMapping: DM,
				AlphaFormat: kM,
				AlwaysCompare: nE,
				AlwaysDepth: c_,
				AlwaysStencilFunc: tv,
				AmbientLight: K_,
				AnimationAction: rT,
				AnimationClip: Ql,
				AnimationLoader: e3,
				AnimationMixer: T3,
				AnimationObjectGroup: M3,
				AnimationUtils: $N,
				ArcCurve: AE,
				ArrayCamera: xE,
				ArrowHelper: G3,
				AttachedBindMode: Cg,
				Audio: iT,
				AudioAnalyser: f3,
				AudioContext: $_,
				AudioListener: u3,
				AudioLoader: l3,
				AxesHelper: uT,
				BackSide: gn,
				BasicDepthPacking: yr,
				BasicShadowMap: fL,
				BatchedMesh: EE,
				Bone: jp,
				BooleanKeyframeTrack: Ga,
				Box2: D3,
				Box3: An,
				Box3Helper: hT,
				BoxGeometry: za,
				BoxHelper: V3,
				BufferAttribute: $e,
				BufferGeometry: Ze,
				BufferGeometryLoader: tT,
				ByteType: NM,
				Cache: Hs,
				Camera: Zh,
				CameraHelper: z3,
				CanvasTexture: N_,
				CapsuleGeometry: Qp,
				CatmullRomCurve3: CE,
				CineonToneMapping: p_,
				CircleGeometry: ef,
				ClampToEdgeWrapping: Oi,
				Clock: Z_,
				Color: Ee,
				ColorKeyframeTrack: W_,
				ColorManagement: Ft,
				CompressedArrayTexture: yN,
				CompressedCubeTexture: xN,
				CompressedTexture: $p,
				CompressedTextureLoader: t3,
				ConeGeometry: tf,
				ConstantAlphaFactor: CM,
				ConstantColorFactor: TM,
				CubeCamera: uE,
				CubeReflectionMapping: _r,
				CubeRefractionMapping: _o,
				CubeTexture: Jh,
				CubeTextureLoader: n3,
				CubeUVReflectionMapping: lc,
				CubicBezierCurve: B_,
				CubicBezierCurve3: RE,
				CubicInterpolant: YE,
				CullFaceBack: Eg,
				CullFaceFront: hM,
				CullFaceFrontBack: pL,
				CullFaceNone: cM,
				Curve: Ts,
				CurvePath: LE,
				CustomBlending: dM,
				CustomToneMapping: IM,
				CylinderGeometry: Va,
				Cylindrical: I3,
				Data3DTexture: T_,
				DataArrayTexture: Hp,
				DataTexture: ho,
				DataTextureLoader: X_,
				DataUtils: ha,
				DecrementStencilOp: wL,
				DecrementWrapStencilOp: ML,
				DefaultLoadingManager: $E,
				DepthFormat: ga,
				DepthStencilFormat: Ta,
				DepthTexture: Wp,
				DetachedBindMode: UM,
				DirectionalLight: gf,
				DirectionalLightHelper: cT,
				DiscreteInterpolant: jE,
				DisplayP3ColorSpace: Vp,
				DodecahedronGeometry: nf,
				DoubleSide: mn,
				DstAlphaFactor: bM,
				DstColorFactor: SM,
				DynamicCopyUsage: kL,
				DynamicDrawUsage: DL,
				DynamicReadUsage: NL,
				EdgesGeometry: IE,
				EllipseCurve: Zp,
				EqualCompare: JM,
				EqualDepth: vh,
				EqualStencilFunc: CL,
				EquirectangularReflectionMapping: _h,
				EquirectangularRefractionMapping: yh,
				Euler: zi,
				EventDispatcher: Hi,
				ExtrudeGeometry: rf,
				FileLoader: Si,
				Float16BufferAttribute: MI,
				Float32BufferAttribute: ze,
				FloatType: On,
				Fog: Yp,
				FogExp2: tu,
				FramebufferTexture: _N,
				FrontSide: Ms,
				Frustum: Qh,
				GLBufferAttribute: P3,
				GLSL1: VL,
				GLSL3: nv,
				GreaterCompare: QM,
				GreaterDepth: u_,
				GreaterEqualCompare: tE,
				GreaterEqualDepth: h_,
				GreaterEqualStencilFunc: IL,
				GreaterStencilFunc: PL,
				GridHelper: B3,
				Group: Ui,
				HalfFloatType: fi,
				HemisphereLight: q_,
				HemisphereLightHelper: lT,
				IcosahedronGeometry: of,
				ImageBitmapLoader: nT,
				ImageLoader: Dh,
				ImageUtils: oE,
				IncrementStencilOp: bL,
				IncrementWrapStencilOp: SL,
				InstancedBufferAttribute: Ca,
				InstancedBufferGeometry: eT,
				InstancedInterleavedBuffer: R3,
				InstancedMesh: D_,
				Int16BufferAttribute: wI,
				Int32BufferAttribute: SI,
				Int8BufferAttribute: yI,
				IntType: g_,
				InterleavedBuffer: nu,
				InterleavedBufferAttribute: xo,
				Interpolant: uc,
				InterpolateDiscrete: $l,
				InterpolateLinear: Aa,
				InterpolateSmooth: zd,
				InvertStencilOp: EL,
				KeepStencilOp: ea,
				KeyframeTrack: As,
				LOD: ME,
				LatheGeometry: su,
				Layers: Gp,
				LessCompare: ZM,
				LessDepth: ep,
				LessEqualCompare: M_,
				LessEqualDepth: jl,
				LessEqualStencilFunc: RL,
				LessStencilFunc: AL,
				Light: Lo,
				LightProbe: QE,
				Line: xr,
				Line3: O3,
				LineBasicMaterial: Jn,
				LineCurve: k_,
				LineCurve3: PE,
				LineDashedMaterial: WE,
				LineLoop: O_,
				LineSegments: as,
				LinearDisplayP3ColorSpace: $h,
				LinearFilter: Tt,
				LinearInterpolant: G_,
				LinearMipMapLinearFilter: _L,
				LinearMipMapNearestFilter: vL,
				LinearMipmapLinearFilter: ts,
				LinearMipmapNearestFilter: Nl,
				LinearSRGBColorSpace: Es,
				LinearToneMapping: Up,
				LinearTransfer: bh,
				Loader: Qn,
				LoaderUtils: uo,
				LoadingManager: pf,
				LoopOnce: XM,
				LoopPingPong: YM,
				LoopRepeat: qM,
				LuminanceAlphaFormat: HM,
				LuminanceFormat: VM,
				MOUSE: uL,
				Material: vn,
				MaterialLoader: vf,
				MathUtils: Dn,
				Matrix3: et,
				Matrix4: He,
				MaxEquation: gM,
				Mesh: bt,
				MeshBasicMaterial: En,
				MeshDepthMaterial: qp,
				MeshDistanceMaterial: P_,
				MeshLambertMaterial: HE,
				MeshMatcapMaterial: GE,
				MeshNormalMaterial: VE,
				MeshPhongMaterial: kE,
				MeshPhysicalMaterial: ls,
				MeshStandardMaterial: Ha,
				MeshToonMaterial: zE,
				MinEquation: mM,
				MirroredRepeatWrapping: Kl,
				MixOperation: PM,
				MultiplyBlending: Ag,
				MultiplyOperation: Kh,
				NearestFilter: It,
				NearestMipMapLinearFilter: gL,
				NearestMipMapNearestFilter: mL,
				NearestMipmapLinearFilter: oa,
				NearestMipmapNearestFilter: Fp,
				NeutralToneMapping: OM,
				NeverCompare: $M,
				NeverDepth: l_,
				NeverStencilFunc: TL,
				NoBlending: jn,
				NoColorSpace: xs,
				NoToneMapping: Xs,
				NormalAnimationBlendMode: kp,
				NormalBlending: co,
				NotEqualCompare: eE,
				NotEqualDepth: Op,
				NotEqualStencilFunc: LL,
				NumberKeyframeTrack: Pa,
				Object3D: ft,
				ObjectLoader: o3,
				ObjectSpaceNormalMap: KM,
				OctahedronGeometry: ru,
				OneFactor: _M,
				OneMinusConstantAlphaFactor: RM,
				OneMinusConstantColorFactor: AM,
				OneMinusDstAlphaFactor: wM,
				OneMinusDstColorFactor: MM,
				OneMinusSrcAlphaFactor: Qd,
				OneMinusSrcColorFactor: xM,
				OrthographicCamera: eu,
				P3Primaries: Sh,
				PCFShadowMap: a_,
				PCFSoftShadowMap: uM,
				PMREMGenerator: Ah,
				Path: Rh,
				PerspectiveCamera: fn,
				Plane: Zr,
				PlaneGeometry: js,
				PlaneHelper: H3,
				PointLight: j_,
				PointLightHelper: N3,
				Points: U_,
				PointsMaterial: Kp,
				PolarGridHelper: k3,
				PolyhedronGeometry: Po,
				PositionalAudio: p3,
				PropertyBinding: _t,
				PropertyMixer: sT,
				QuadraticBezierCurve: z_,
				QuadraticBezierCurve3: Jp,
				Quaternion: kn,
				QuaternionKeyframeTrack: bo,
				QuaternionLinearInterpolant: KE,
				RED_GREEN_RGTC2_Format: Qg,
				RED_RGTC1_Format: WM,
				REVISION: Co,
				RGBADepthPacking: zp,
				RGBAFormat: mi,
				RGBAIntegerFormat: b_,
				RGBA_ASTC_10x10_Format: Yg,
				RGBA_ASTC_10x5_Format: Wg,
				RGBA_ASTC_10x6_Format: Xg,
				RGBA_ASTC_10x8_Format: qg,
				RGBA_ASTC_12x10_Format: jg,
				RGBA_ASTC_12x12_Format: Kg,
				RGBA_ASTC_4x4_Format: Ng,
				RGBA_ASTC_5x4_Format: Fg,
				RGBA_ASTC_5x5_Format: Bg,
				RGBA_ASTC_6x5_Format: kg,
				RGBA_ASTC_6x6_Format: zg,
				RGBA_ASTC_8x5_Format: Vg,
				RGBA_ASTC_8x6_Format: Hg,
				RGBA_ASTC_8x8_Format: Gg,
				RGBA_BPTC_Format: kd,
				RGBA_ETC2_EAC_Format: Ug,
				RGBA_PVRTC_2BPPV1_Format: Ig,
				RGBA_PVRTC_4BPPV1_Format: Lg,
				RGBA_S3TC_DXT1_Format: Nd,
				RGBA_S3TC_DXT3_Format: Fd,
				RGBA_S3TC_DXT5_Format: Bd,
				RGBFormat: zM,
				RGB_BPTC_SIGNED_Format: $g,
				RGB_BPTC_UNSIGNED_Format: Zg,
				RGB_ETC1_Format: Dg,
				RGB_ETC2_Format: Og,
				RGB_PVRTC_2BPPV1_Format: Pg,
				RGB_PVRTC_4BPPV1_Format: Rg,
				RGB_S3TC_DXT1_Format: Ud,
				RGFormat: GM,
				RGIntegerFormat: x_,
				RawShaderMaterial: BE,
				Ray: ka,
				Raycaster: e0,
				Rec709Primaries: wh,
				RectAreaLight: ZE,
				RedFormat: Bp,
				RedIntegerFormat: y_,
				ReinhardToneMapping: d_,
				RenderTarget: aE,
				RepeatWrapping: rs,
				ReplaceStencilOp: xL,
				ReverseSubtractEquation: fM,
				RingGeometry: af,
				SIGNED_RED_GREEN_RGTC2_Format: ev,
				SIGNED_RED_RGTC1_Format: Jg,
				SRGBColorSpace: ot,
				SRGBTransfer: Wt,
				Scene: Ch,
				ShaderChunk: rt,
				ShaderLib: _s,
				ShaderMaterial: xn,
				ShadowMaterial: FE,
				Shape: _a,
				ShapeGeometry: lf,
				ShapePath: W3,
				ShapeUtils: qs,
				ShortType: FM,
				Skeleton: iu,
				SkeletonHelper: U3,
				SkinnedMesh: I_,
				Source: ca,
				Sphere: un,
				SphereGeometry: hc,
				Spherical: L3,
				SphericalHarmonics3: JE,
				SplineCurve: V_,
				SpotLight: mf,
				SpotLightHelper: oT,
				Sprite: SE,
				SpriteMaterial: L_,
				SrcAlphaFactor: Jd,
				SrcAlphaSaturateFactor: EM,
				SrcColorFactor: yM,
				StaticCopyUsage: BL,
				StaticDrawUsage: Mh,
				StaticReadUsage: UL,
				StereoCamera: c3,
				StreamCopyUsage: zL,
				StreamDrawUsage: OL,
				StreamReadUsage: FL,
				StringKeyframeTrack: Wa,
				SubtractEquation: pM,
				SubtractiveBlending: Tg,
				TOUCH: dL,
				TangentSpaceNormalMap: Ro,
				TetrahedronGeometry: cf,
				Texture: zt,
				TextureLoader: ff,
				TorusGeometry: hf,
				TorusKnotGeometry: uf,
				Triangle: Li,
				TriangleFanDrawMode: tp,
				TriangleStripDrawMode: S_,
				TrianglesDrawMode: jM,
				TubeGeometry: df,
				UVMapping: Np,
				Uint16BufferAttribute: A_,
				Uint32BufferAttribute: C_,
				Uint8BufferAttribute: xI,
				Uint8ClampedBufferAttribute: bI,
				Uniform: yt,
				UniformsGroup: C3,
				UniformsLib: Pe,
				UniformsUtils: hE,
				UnsignedByteType: Vn,
				UnsignedInt248Type: Ba,
				UnsignedInt5999Type: BM,
				UnsignedIntType: yo,
				UnsignedShort4444Type: v_,
				UnsignedShort5551Type: __,
				UnsignedShortType: m_,
				VSMShadowMap: Us,
				Vector2: ce,
				Vector3: I,
				Vector4: Pt,
				VectorKeyframeTrack: La,
				VideoTexture: TE,
				WebGL3DRenderTarget: cI,
				WebGLArrayRenderTarget: lI,
				WebGLCoordinateSystem: Vs,
				WebGLCubeRenderTarget: dE,
				WebGLMultipleRenderTargets: X3,
				WebGLRenderTarget: yn,
				WebGLRenderer: bE,
				WebGLUtils: yE,
				WebGPUCoordinateSystem: Eh,
				WireframeGeometry: NE,
				WrapAroundEnding: xh,
				ZeroCurvatureEnding: aa,
				ZeroFactor: vM,
				ZeroSlopeEnding: la,
				ZeroStencilOp: yL,
				createCanvasElement: sE,
			},
			Symbol.toStringTag,
			{ value: 'Module' }
		)
	),
	Y3 = parseInt(Co.replace(/\D+/g, ''));
class j3 extends ft {
	constructor(e = document.createElement('div')) {
		super(),
			(this.isCSS2DObject = !0),
			(this.element = e),
			(this.element.style.position = 'absolute'),
			(this.element.style.userSelect = 'none'),
			this.element.setAttribute('draggable', !1),
			(this.center = new ce(0.5, 0.5)),
			this.addEventListener('removed', function () {
				this.traverse(function (t) {
					t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
				});
			});
	}
	copy(e, t) {
		return super.copy(e, t), (this.element = e.element.cloneNode(!0)), (this.center = e.center), this;
	}
}
const vl = new I(),
	Sb = new He(),
	Mb = new He(),
	Eb = new I(),
	Tb = new I();
class K3 {
	constructor(e = {}) {
		const t = this;
		let n, s, r, o;
		const a = { objects: new WeakMap() },
			l = e.element !== void 0 ? e.element : document.createElement('div');
		(l.style.overflow = 'hidden'),
			(this.domElement = l),
			(this.getSize = function () {
				return { width: n, height: s };
			}),
			(this.render = function (p, g) {
				p.matrixWorldAutoUpdate === !0 && p.updateMatrixWorld(),
					g.parent === null && g.matrixWorldAutoUpdate === !0 && g.updateMatrixWorld(),
					Sb.copy(g.matrixWorldInverse),
					Mb.multiplyMatrices(g.projectionMatrix, Sb),
					c(p, p, g),
					d(p);
			}),
			(this.setSize = function (p, g) {
				(n = p), (s = g), (r = n / 2), (o = s / 2), (l.style.width = p + 'px'), (l.style.height = g + 'px');
			});
		function c(p, g, v) {
			if (p.isCSS2DObject) {
				vl.setFromMatrixPosition(p.matrixWorld), vl.applyMatrix4(Mb);
				const m = p.visible === !0 && vl.z >= -1 && vl.z <= 1 && p.layers.test(v.layers) === !0;
				if (((p.element.style.display = m === !0 ? '' : 'none'), m === !0)) {
					p.onBeforeRender(t, g, v);
					const y = p.element;
					(y.style.transform =
						'translate(' +
						-100 * p.center.x +
						'%,' +
						-100 * p.center.y +
						'%)translate(' +
						(vl.x * r + r) +
						'px,' +
						(-vl.y * o + o) +
						'px)'),
						y.parentNode !== l && l.appendChild(y),
						p.onAfterRender(t, g, v);
				}
				const f = { distanceToCameraSquared: h(v, p) };
				a.objects.set(p, f);
			}
			for (let m = 0, f = p.children.length; m < f; m++) c(p.children[m], g, v);
		}
		function h(p, g) {
			return Eb.setFromMatrixPosition(p.matrixWorld), Tb.setFromMatrixPosition(g.matrixWorld), Eb.distanceToSquared(Tb);
		}
		function u(p) {
			const g = [];
			return (
				p.traverse(function (v) {
					v.isCSS2DObject && g.push(v);
				}),
				g
			);
		}
		function d(p) {
			const g = u(p).sort(function (m, f) {
					if (m.renderOrder !== f.renderOrder) return f.renderOrder - m.renderOrder;
					const y = a.objects.get(m).distanceToCameraSquared,
						_ = a.objects.get(f).distanceToCameraSquared;
					return y - _;
				}),
				v = g.length;
			for (let m = 0, f = g.length; m < f; m++) g[m].element.style.zIndex = v - m;
		}
	}
}
const Ab = new I(),
	$3 = new kn(),
	Cb = new I();
class dT extends ft {
	constructor(e = document.createElement('div')) {
		super(),
			(this.isCSS3DObject = !0),
			(this.element = e),
			(this.element.style.position = 'absolute'),
			(this.element.style.pointerEvents = 'auto'),
			(this.element.style.userSelect = 'none'),
			this.element.setAttribute('draggable', !1),
			this.addEventListener('removed', function () {
				this.traverse(function (t) {
					t.element instanceof Element && t.element.parentNode !== null && t.element.parentNode.removeChild(t.element);
				});
			});
	}
	copy(e, t) {
		return super.copy(e, t), (this.element = e.element.cloneNode(!0)), this;
	}
}
class Z3 extends dT {
	constructor(e) {
		super(e), (this.isCSS3DSprite = !0), (this.rotation2D = 0);
	}
	copy(e, t) {
		return super.copy(e, t), (this.rotation2D = e.rotation2D), this;
	}
}
const Ls = new He(),
	J3 = new He();
class Q3 {
	constructor(e = {}) {
		const t = this;
		let n, s, r, o;
		const a = { camera: { style: '' }, objects: new WeakMap() },
			l = e.element !== void 0 ? e.element : document.createElement('div');
		(l.style.overflow = 'hidden'), (this.domElement = l);
		const c = document.createElement('div');
		(c.style.transformOrigin = '0 0'), (c.style.pointerEvents = 'none'), l.appendChild(c);
		const h = document.createElement('div');
		(h.style.transformStyle = 'preserve-3d'),
			c.appendChild(h),
			(this.getSize = function () {
				return { width: n, height: s };
			}),
			(this.render = function (v, m) {
				const f = m.projectionMatrix.elements[5] * o;
				m.view && m.view.enabled
					? ((c.style.transform = 'translate( '
							.concat(-m.view.offsetX * (n / m.view.width), 'px, ')
							.concat(-m.view.offsetY * (s / m.view.height), 'px )')),
					  (c.style.transform += 'scale( '
							.concat(m.view.fullWidth / m.view.width, ', ')
							.concat(m.view.fullHeight / m.view.height, ' )')))
					: (c.style.transform = ''),
					v.matrixWorldAutoUpdate === !0 && v.updateMatrixWorld(),
					m.parent === null && m.matrixWorldAutoUpdate === !0 && m.updateMatrixWorld();
				let y, _;
				m.isOrthographicCamera && ((y = -(m.right + m.left) / 2), (_ = (m.top + m.bottom) / 2));
				const x = m.view && m.view.enabled ? m.view.height / m.view.fullHeight : 1,
					E = m.isOrthographicCamera
						? 'scale( '.concat(x, ' )scale(') + f + ')translate(' + u(y) + 'px,' + u(_) + 'px)' + d(m.matrixWorldInverse)
						: 'scale( '.concat(x, ' )translateZ(') + f + 'px)' + d(m.matrixWorldInverse),
					C = (m.isPerspectiveCamera ? 'perspective(' + f + 'px) ' : '') + E + 'translate(' + r + 'px,' + o + 'px)';
				a.camera.style !== C && ((h.style.transform = C), (a.camera.style = C)), g(v, v, m);
			}),
			(this.setSize = function (v, m) {
				(n = v),
					(s = m),
					(r = n / 2),
					(o = s / 2),
					(l.style.width = v + 'px'),
					(l.style.height = m + 'px'),
					(c.style.width = v + 'px'),
					(c.style.height = m + 'px'),
					(h.style.width = v + 'px'),
					(h.style.height = m + 'px');
			});
		function u(v) {
			return Math.abs(v) < 1e-10 ? 0 : v;
		}
		function d(v) {
			const m = v.elements;
			return (
				'matrix3d(' +
				u(m[0]) +
				',' +
				u(-m[1]) +
				',' +
				u(m[2]) +
				',' +
				u(m[3]) +
				',' +
				u(m[4]) +
				',' +
				u(-m[5]) +
				',' +
				u(m[6]) +
				',' +
				u(m[7]) +
				',' +
				u(m[8]) +
				',' +
				u(-m[9]) +
				',' +
				u(m[10]) +
				',' +
				u(m[11]) +
				',' +
				u(m[12]) +
				',' +
				u(-m[13]) +
				',' +
				u(m[14]) +
				',' +
				u(m[15]) +
				')'
			);
		}
		function p(v) {
			const m = v.elements;
			return (
				'translate(-50%,-50%)' +
				('matrix3d(' +
					u(m[0]) +
					',' +
					u(m[1]) +
					',' +
					u(m[2]) +
					',' +
					u(m[3]) +
					',' +
					u(-m[4]) +
					',' +
					u(-m[5]) +
					',' +
					u(-m[6]) +
					',' +
					u(-m[7]) +
					',' +
					u(m[8]) +
					',' +
					u(m[9]) +
					',' +
					u(m[10]) +
					',' +
					u(m[11]) +
					',' +
					u(m[12]) +
					',' +
					u(m[13]) +
					',' +
					u(m[14]) +
					',' +
					u(m[15]) +
					')')
			);
		}
		function g(v, m, f, y) {
			if (v.isCSS3DObject) {
				const _ = v.visible === !0 && v.layers.test(f.layers) === !0;
				if (((v.element.style.display = _ === !0 ? '' : 'none'), _ === !0)) {
					v.onBeforeRender(t, m, f);
					let x;
					v.isCSS3DSprite
						? (Ls.copy(f.matrixWorldInverse),
						  Ls.transpose(),
						  v.rotation2D !== 0 && Ls.multiply(J3.makeRotationZ(v.rotation2D)),
						  v.matrixWorld.decompose(Ab, $3, Cb),
						  Ls.setPosition(Ab),
						  Ls.scale(Cb),
						  (Ls.elements[3] = 0),
						  (Ls.elements[7] = 0),
						  (Ls.elements[11] = 0),
						  (Ls.elements[15] = 1),
						  (x = p(Ls)))
						: (x = p(v.matrixWorld));
					const E = v.element,
						w = a.objects.get(v);
					if (w === void 0 || w.style !== x) {
						E.style.transform = x;
						const C = { style: x };
						a.objects.set(v, C);
					}
					E.parentNode !== h && h.appendChild(E), v.onAfterRender(t, m, f);
				}
			}
			for (let _ = 0, x = v.children.length; _ < x; _++) g(v.children[_], m, f);
		}
	}
}
function Rb(i, e) {
	if (e === jM) return console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.'), i;
	if (e === tp || e === S_) {
		let t = i.getIndex();
		if (t === null) {
			const o = [],
				a = i.getAttribute('position');
			if (a !== void 0) {
				for (let l = 0; l < a.count; l++) o.push(l);
				i.setIndex(o), (t = i.getIndex());
			} else
				return (
					console.error(
						'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.'
					),
					i
				);
		}
		const n = t.count - 2,
			s = [];
		if (t)
			if (e === tp) for (let o = 1; o <= n; o++) s.push(t.getX(0)), s.push(t.getX(o)), s.push(t.getX(o + 1));
			else
				for (let o = 0; o < n; o++)
					o % 2 === 0
						? (s.push(t.getX(o)), s.push(t.getX(o + 1)), s.push(t.getX(o + 2)))
						: (s.push(t.getX(o + 2)), s.push(t.getX(o + 1)), s.push(t.getX(o)));
		s.length / 3 !== n &&
			console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
		const r = i.clone();
		return r.setIndex(s), r.clearGroups(), r;
	} else return console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', e), i;
}
var Ji = Uint8Array,
	eo = Uint16Array,
	cv = Uint32Array,
	pT = new Ji([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
	fT = new Ji([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
	eF = new Ji([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
	mT = function (i, e) {
		for (var t = new eo(31), n = 0; n < 31; ++n) t[n] = e += 1 << i[n - 1];
		for (var s = new cv(t[30]), n = 1; n < 30; ++n) for (var r = t[n]; r < t[n + 1]; ++r) s[r] = ((r - t[n]) << 5) | n;
		return [t, s];
	},
	gT = mT(pT, 2),
	vT = gT[0],
	tF = gT[1];
(vT[28] = 258), (tF[258] = 28);
var nF = mT(fT, 0),
	iF = nF[0],
	hv = new eo(32768);
for (var jt = 0; jt < 32768; ++jt) {
	var kr = ((jt & 43690) >>> 1) | ((jt & 21845) << 1);
	(kr = ((kr & 52428) >>> 2) | ((kr & 13107) << 2)),
		(kr = ((kr & 61680) >>> 4) | ((kr & 3855) << 4)),
		(hv[jt] = (((kr & 65280) >>> 8) | ((kr & 255) << 8)) >>> 1);
}
var rh = function (i, e, t) {
		for (var n = i.length, s = 0, r = new eo(e); s < n; ++s) ++r[i[s] - 1];
		var o = new eo(e);
		for (s = 0; s < e; ++s) o[s] = (o[s - 1] + r[s - 1]) << 1;
		var a;
		if (t) {
			a = new eo(1 << e);
			var l = 15 - e;
			for (s = 0; s < n; ++s)
				if (i[s])
					for (var c = (s << 4) | i[s], h = e - i[s], u = o[i[s] - 1]++ << h, d = u | ((1 << h) - 1); u <= d; ++u)
						a[hv[u] >>> l] = c;
		} else for (a = new eo(n), s = 0; s < n; ++s) i[s] && (a[s] = hv[o[i[s] - 1]++] >>> (15 - i[s]));
		return a;
	},
	ou = new Ji(288);
for (var jt = 0; jt < 144; ++jt) ou[jt] = 8;
for (var jt = 144; jt < 256; ++jt) ou[jt] = 9;
for (var jt = 256; jt < 280; ++jt) ou[jt] = 7;
for (var jt = 280; jt < 288; ++jt) ou[jt] = 8;
var _T = new Ji(32);
for (var jt = 0; jt < 32; ++jt) _T[jt] = 5;
var sF = rh(ou, 9, 1),
	rF = rh(_T, 5, 1),
	Mm = function (i) {
		for (var e = i[0], t = 1; t < i.length; ++t) i[t] > e && (e = i[t]);
		return e;
	},
	ps = function (i, e, t) {
		var n = (e / 8) | 0;
		return ((i[n] | (i[n + 1] << 8)) >> (e & 7)) & t;
	},
	Em = function (i, e) {
		var t = (e / 8) | 0;
		return (i[t] | (i[t + 1] << 8) | (i[t + 2] << 16)) >> (e & 7);
	},
	oF = function (i) {
		return ((i / 8) | 0) + (i & 7 && 1);
	},
	aF = function (i, e, t) {
		(t == null || t > i.length) && (t = i.length);
		var n = new (i instanceof eo ? eo : i instanceof cv ? cv : Ji)(t - e);
		return n.set(i.subarray(e, t)), n;
	},
	lF = function (i, e, t) {
		var n = i.length;
		if (!n || (t && !t.l && n < 5)) return e || new Ji(0);
		var s = !e || t,
			r = !t || t.i;
		t || (t = {}), e || (e = new Ji(n * 3));
		var o = function (we) {
				var X = e.length;
				if (we > X) {
					var ge = new Ji(Math.max(X * 2, we));
					ge.set(e), (e = ge);
				}
			},
			a = t.f || 0,
			l = t.p || 0,
			c = t.b || 0,
			h = t.l,
			u = t.d,
			d = t.m,
			p = t.n,
			g = n * 8;
		do {
			if (!h) {
				t.f = a = ps(i, l, 1);
				var v = ps(i, l + 1, 3);
				if (((l += 3), v))
					if (v == 1) (h = sF), (u = rF), (d = 9), (p = 5);
					else if (v == 2) {
						var _ = ps(i, l, 31) + 257,
							x = ps(i, l + 10, 15) + 4,
							E = _ + ps(i, l + 5, 31) + 1;
						l += 14;
						for (var w = new Ji(E), C = new Ji(19), P = 0; P < x; ++P) C[eF[P]] = ps(i, l + P * 3, 7);
						l += x * 3;
						for (var S = Mm(C), M = (1 << S) - 1, k = rh(C, S, 1), P = 0; P < E; ) {
							var q = k[ps(i, l, M)];
							l += q & 15;
							var m = q >>> 4;
							if (m < 16) w[P++] = m;
							else {
								var B = 0,
									W = 0;
								for (
									m == 16
										? ((W = 3 + ps(i, l, 3)), (l += 2), (B = w[P - 1]))
										: m == 17
										? ((W = 3 + ps(i, l, 7)), (l += 3))
										: m == 18 && ((W = 11 + ps(i, l, 127)), (l += 7));
									W--;

								)
									w[P++] = B;
							}
						}
						var Q = w.subarray(0, _),
							$ = w.subarray(_);
						(d = Mm(Q)), (p = Mm($)), (h = rh(Q, d, 1)), (u = rh($, p, 1));
					} else throw 'invalid block type';
				else {
					var m = oF(l) + 4,
						f = i[m - 4] | (i[m - 3] << 8),
						y = m + f;
					if (y > n) {
						if (r) throw 'unexpected EOF';
						break;
					}
					s && o(c + f), e.set(i.subarray(m, y), c), (t.b = c += f), (t.p = l = y * 8);
					continue;
				}
				if (l > g) {
					if (r) throw 'unexpected EOF';
					break;
				}
			}
			s && o(c + 131072);
			for (var le = (1 << d) - 1, Z = (1 << p) - 1, xe = l; ; xe = l) {
				var B = h[Em(i, l) & le],
					ue = B >>> 4;
				if (((l += B & 15), l > g)) {
					if (r) throw 'unexpected EOF';
					break;
				}
				if (!B) throw 'invalid length/literal';
				if (ue < 256) e[c++] = ue;
				else if (ue == 256) {
					(xe = l), (h = null);
					break;
				} else {
					var Te = ue - 254;
					if (ue > 264) {
						var P = ue - 257,
							Ae = pT[P];
						(Te = ps(i, l, (1 << Ae) - 1) + vT[P]), (l += Ae);
					}
					var We = u[Em(i, l) & Z],
						se = We >>> 4;
					if (!We) throw 'invalid distance';
					l += We & 15;
					var $ = iF[se];
					if (se > 3) {
						var Ae = fT[se];
						($ += Em(i, l) & ((1 << Ae) - 1)), (l += Ae);
					}
					if (l > g) {
						if (r) throw 'unexpected EOF';
						break;
					}
					s && o(c + 131072);
					for (var Se = c + Te; c < Se; c += 4)
						(e[c] = e[c - $]), (e[c + 1] = e[c + 1 - $]), (e[c + 2] = e[c + 2 - $]), (e[c + 3] = e[c + 3 - $]);
					c = Se;
				}
			}
			(t.l = h), (t.p = xe), (t.b = c), h && ((a = 1), (t.m = d), (t.d = u), (t.n = p));
		} while (!a);
		return c == e.length ? e : aF(e, 0, c);
	},
	cF = new Ji(0),
	hF = function (i) {
		if ((i[0] & 15) != 8 || i[0] >>> 4 > 7 || ((i[0] << 8) | i[1]) % 31) throw 'invalid zlib data';
		if (i[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
	};
function bd(i, e) {
	return lF((hF(i), i.subarray(2, -4)), e);
}
var uF = typeof TextDecoder < 'u' && new TextDecoder(),
	dF = 0;
try {
	uF.decode(cF, { stream: !0 }), (dF = 1);
} catch (i) {}
function rp(i) {
	if (typeof TextDecoder < 'u') return new TextDecoder().decode(i);
	let e = '';
	for (let t = 0, n = i.length; t < n; t++) e += String.fromCharCode(i[t]);
	try {
		return decodeURIComponent(escape(e));
	} catch (t) {
		return e;
	}
}
const da = 'srgb',
	gr = 'srgb-linear',
	Pb = 3001,
	pF = 3e3;
class fF extends Qn {
	constructor(e) {
		super(e),
			(this.dracoLoader = null),
			(this.ktx2Loader = null),
			(this.meshoptDecoder = null),
			(this.pluginCallbacks = []),
			this.register(function (t) {
				return new yF(t);
			}),
			this.register(function (t) {
				return new xF(t);
			}),
			this.register(function (t) {
				return new RF(t);
			}),
			this.register(function (t) {
				return new PF(t);
			}),
			this.register(function (t) {
				return new LF(t);
			}),
			this.register(function (t) {
				return new wF(t);
			}),
			this.register(function (t) {
				return new SF(t);
			}),
			this.register(function (t) {
				return new MF(t);
			}),
			this.register(function (t) {
				return new EF(t);
			}),
			this.register(function (t) {
				return new _F(t);
			}),
			this.register(function (t) {
				return new TF(t);
			}),
			this.register(function (t) {
				return new bF(t);
			}),
			this.register(function (t) {
				return new CF(t);
			}),
			this.register(function (t) {
				return new AF(t);
			}),
			this.register(function (t) {
				return new gF(t);
			}),
			this.register(function (t) {
				return new IF(t);
			}),
			this.register(function (t) {
				return new DF(t);
			});
	}
	load(e, t, n, s) {
		const r = this;
		let o;
		if (this.resourcePath !== '') o = this.resourcePath;
		else if (this.path !== '') {
			const c = uo.extractUrlBase(e);
			o = uo.resolveURL(c, this.path);
		} else o = uo.extractUrlBase(e);
		this.manager.itemStart(e);
		const a = function (c) {
				s ? s(c) : console.error(c), r.manager.itemError(e), r.manager.itemEnd(e);
			},
			l = new Si(this.manager);
		l.setPath(this.path),
			l.setResponseType('arraybuffer'),
			l.setRequestHeader(this.requestHeader),
			l.setWithCredentials(this.withCredentials),
			l.load(
				e,
				function (c) {
					try {
						r.parse(
							c,
							o,
							function (h) {
								t(h), r.manager.itemEnd(e);
							},
							a
						);
					} catch (h) {
						a(h);
					}
				},
				n,
				a
			);
	}
	setDRACOLoader(e) {
		return (this.dracoLoader = e), this;
	}
	setDDSLoader() {
		throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
	}
	setKTX2Loader(e) {
		return (this.ktx2Loader = e), this;
	}
	setMeshoptDecoder(e) {
		return (this.meshoptDecoder = e), this;
	}
	register(e) {
		return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
	}
	unregister(e) {
		return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
	}
	parse(e, t, n, s) {
		let r;
		const o = {},
			a = {};
		if (typeof e == 'string') r = JSON.parse(e);
		else if (e instanceof ArrayBuffer)
			if (rp(new Uint8Array(e.slice(0, 4))) === yT) {
				try {
					o[pt.KHR_BINARY_GLTF] = new OF(e);
				} catch (h) {
					s && s(h);
					return;
				}
				r = JSON.parse(o[pt.KHR_BINARY_GLTF].content);
			} else r = JSON.parse(rp(new Uint8Array(e)));
		else r = e;
		if (r.asset === void 0 || r.asset.version[0] < 2) {
			s && s(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
			return;
		}
		const l = new YF(r, {
			path: t || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder,
		});
		l.fileLoader.setRequestHeader(this.requestHeader);
		for (let c = 0; c < this.pluginCallbacks.length; c++) {
			const h = this.pluginCallbacks[c](l);
			h.name || console.error('THREE.GLTFLoader: Invalid plugin found: missing name'), (a[h.name] = h), (o[h.name] = !0);
		}
		if (r.extensionsUsed)
			for (let c = 0; c < r.extensionsUsed.length; ++c) {
				const h = r.extensionsUsed[c],
					u = r.extensionsRequired || [];
				switch (h) {
					case pt.KHR_MATERIALS_UNLIT:
						o[h] = new vF();
						break;
					case pt.KHR_DRACO_MESH_COMPRESSION:
						o[h] = new UF(r, this.dracoLoader);
						break;
					case pt.KHR_TEXTURE_TRANSFORM:
						o[h] = new NF();
						break;
					case pt.KHR_MESH_QUANTIZATION:
						o[h] = new FF();
						break;
					default:
						u.indexOf(h) >= 0 && a[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
				}
			}
		l.setExtensions(o), l.setPlugins(a), l.parse(n, s);
	}
	parseAsync(e, t) {
		const n = this;
		return new Promise(function (s, r) {
			n.parse(e, t, s, r);
		});
	}
}
function mF() {
	let i = {};
	return {
		get: function (e) {
			return i[e];
		},
		add: function (e, t) {
			i[e] = t;
		},
		remove: function (e) {
			delete i[e];
		},
		removeAll: function () {
			i = {};
		},
	};
}
const pt = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_MATERIALS_BUMP: 'EXT_materials_bump',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_TEXTURE_AVIF: 'EXT_texture_avif',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
	EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',
};
class gF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} });
	}
	_markDefs() {
		const e = this.parser,
			t = this.parser.json.nodes || [];
		for (let n = 0, s = t.length; n < s; n++) {
			const r = t[n];
			r.extensions &&
				r.extensions[this.name] &&
				r.extensions[this.name].light !== void 0 &&
				e._addNodeRef(this.cache, r.extensions[this.name].light);
		}
	}
	_loadLight(e) {
		const t = this.parser,
			n = 'light:' + e;
		let s = t.cache.get(n);
		if (s) return s;
		const r = t.json,
			l = (((r.extensions && r.extensions[this.name]) || {}).lights || [])[e];
		let c;
		const h = new Ee(16777215);
		l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], gr);
		const u = l.range !== void 0 ? l.range : 0;
		switch (l.type) {
			case 'directional':
				(c = new gf(h)), c.target.position.set(0, 0, -1), c.add(c.target);
				break;
			case 'point':
				(c = new j_(h)), (c.distance = u);
				break;
			case 'spot':
				(c = new mf(h)),
					(c.distance = u),
					(l.spot = l.spot || {}),
					(l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
					(l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4),
					(c.angle = l.spot.outerConeAngle),
					(c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
					c.target.position.set(0, 0, -1),
					c.add(c.target);
				break;
			default:
				throw new Error('THREE.GLTFLoader: Unexpected light type: ' + l.type);
		}
		return (
			c.position.set(0, 0, 0),
			(c.decay = 2),
			lr(c, l),
			l.intensity !== void 0 && (c.intensity = l.intensity),
			(c.name = t.createUniqueName(l.name || 'light_' + e)),
			(s = Promise.resolve(c)),
			t.cache.add(n, s),
			s
		);
	}
	getDependency(e, t) {
		if (e === 'light') return this._loadLight(t);
	}
	createNodeAttachment(e) {
		const t = this,
			n = this.parser,
			r = n.json.nodes[e],
			a = ((r.extensions && r.extensions[this.name]) || {}).light;
		return a === void 0
			? null
			: this._loadLight(a).then(function (l) {
					return n._getNodeRef(t.cache, a, l);
			  });
	}
}
class vF {
	constructor() {
		this.name = pt.KHR_MATERIALS_UNLIT;
	}
	getMaterialType() {
		return En;
	}
	extendParams(e, t, n) {
		const s = [];
		(e.color = new Ee(1, 1, 1)), (e.opacity = 1);
		const r = t.pbrMetallicRoughness;
		if (r) {
			if (Array.isArray(r.baseColorFactor)) {
				const o = r.baseColorFactor;
				e.color.setRGB(o[0], o[1], o[2], gr), (e.opacity = o[3]);
			}
			r.baseColorTexture !== void 0 && s.push(n.assignTexture(e, 'map', r.baseColorTexture, da));
		}
		return Promise.all(s);
	}
}
class _F {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_EMISSIVE_STRENGTH);
	}
	extendMaterialParams(e, t) {
		const s = this.parser.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = s.extensions[this.name].emissiveStrength;
		return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
	}
}
class yF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_CLEARCOAT);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		if (
			(o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
			o.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, 'clearcoatMap', o.clearcoatTexture)),
			o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
			o.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, 'clearcoatRoughnessMap', o.clearcoatRoughnessTexture)),
			o.clearcoatNormalTexture !== void 0 &&
				(r.push(n.assignTexture(t, 'clearcoatNormalMap', o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0))
		) {
			const a = o.clearcoatNormalTexture.scale;
			t.clearcoatNormalScale = new ce(a, a);
		}
		return Promise.all(r);
	}
}
class xF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_DISPERSION);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const s = this.parser.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = s.extensions[this.name];
		return (t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0), Promise.resolve();
	}
}
class bF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_IRIDESCENCE);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		return (
			o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
			o.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, 'iridescenceMap', o.iridescenceTexture)),
			o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
			t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
			o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
			o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
			o.iridescenceThicknessTexture !== void 0 &&
				r.push(n.assignTexture(t, 'iridescenceThicknessMap', o.iridescenceThicknessTexture)),
			Promise.all(r)
		);
	}
}
class wF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_SHEEN);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [];
		(t.sheenColor = new Ee(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
		const o = s.extensions[this.name];
		if (o.sheenColorFactor !== void 0) {
			const a = o.sheenColorFactor;
			t.sheenColor.setRGB(a[0], a[1], a[2], gr);
		}
		return (
			o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
			o.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, 'sheenColorMap', o.sheenColorTexture, da)),
			o.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, 'sheenRoughnessMap', o.sheenRoughnessTexture)),
			Promise.all(r)
		);
	}
}
class SF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_TRANSMISSION);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		return (
			o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
			o.transmissionTexture !== void 0 && r.push(n.assignTexture(t, 'transmissionMap', o.transmissionTexture)),
			Promise.all(r)
		);
	}
}
class MF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_VOLUME);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		(t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
			o.thicknessTexture !== void 0 && r.push(n.assignTexture(t, 'thicknessMap', o.thicknessTexture)),
			(t.attenuationDistance = o.attenuationDistance || 1 / 0);
		const a = o.attenuationColor || [1, 1, 1];
		return (t.attenuationColor = new Ee().setRGB(a[0], a[1], a[2], gr)), Promise.all(r);
	}
}
class EF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_IOR);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const s = this.parser.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = s.extensions[this.name];
		return (t.ior = r.ior !== void 0 ? r.ior : 1.5), Promise.resolve();
	}
}
class TF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_SPECULAR);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		(t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
			o.specularTexture !== void 0 && r.push(n.assignTexture(t, 'specularIntensityMap', o.specularTexture));
		const a = o.specularColorFactor || [1, 1, 1];
		return (
			(t.specularColor = new Ee().setRGB(a[0], a[1], a[2], gr)),
			o.specularColorTexture !== void 0 && r.push(n.assignTexture(t, 'specularColorMap', o.specularColorTexture, da)),
			Promise.all(r)
		);
	}
}
class AF {
	constructor(e) {
		(this.parser = e), (this.name = pt.EXT_MATERIALS_BUMP);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		return (
			(t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
			o.bumpTexture !== void 0 && r.push(n.assignTexture(t, 'bumpMap', o.bumpTexture)),
			Promise.all(r)
		);
	}
}
class CF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_MATERIALS_ANISOTROPY);
	}
	getMaterialType(e) {
		const n = this.parser.json.materials[e];
		return !n.extensions || !n.extensions[this.name] ? null : ls;
	}
	extendMaterialParams(e, t) {
		const n = this.parser,
			s = n.json.materials[e];
		if (!s.extensions || !s.extensions[this.name]) return Promise.resolve();
		const r = [],
			o = s.extensions[this.name];
		return (
			o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
			o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
			o.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, 'anisotropyMap', o.anisotropyTexture)),
			Promise.all(r)
		);
	}
}
class RF {
	constructor(e) {
		(this.parser = e), (this.name = pt.KHR_TEXTURE_BASISU);
	}
	loadTexture(e) {
		const t = this.parser,
			n = t.json,
			s = n.textures[e];
		if (!s.extensions || !s.extensions[this.name]) return null;
		const r = s.extensions[this.name],
			o = t.options.ktx2Loader;
		if (!o) {
			if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
				throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');
			return null;
		}
		return t.loadTextureImage(e, r.source, o);
	}
}
class PF {
	constructor(e) {
		(this.parser = e), (this.name = pt.EXT_TEXTURE_WEBP), (this.isSupported = null);
	}
	loadTexture(e) {
		const t = this.name,
			n = this.parser,
			s = n.json,
			r = s.textures[e];
		if (!r.extensions || !r.extensions[t]) return null;
		const o = r.extensions[t],
			a = s.images[o.source];
		let l = n.textureLoader;
		if (a.uri) {
			const c = n.options.manager.getHandler(a.uri);
			c !== null && (l = c);
		}
		return this.detectSupport().then(function (c) {
			if (c) return n.loadTextureImage(e, o.source, l);
			if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
				throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
			return n.loadTexture(e);
		});
	}
	detectSupport() {
		return (
			this.isSupported ||
				(this.isSupported = new Promise(function (e) {
					const t = new Image();
					(t.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'),
						(t.onload = t.onerror =
							function () {
								e(t.height === 1);
							});
				})),
			this.isSupported
		);
	}
}
class LF {
	constructor(e) {
		(this.parser = e), (this.name = pt.EXT_TEXTURE_AVIF), (this.isSupported = null);
	}
	loadTexture(e) {
		const t = this.name,
			n = this.parser,
			s = n.json,
			r = s.textures[e];
		if (!r.extensions || !r.extensions[t]) return null;
		const o = r.extensions[t],
			a = s.images[o.source];
		let l = n.textureLoader;
		if (a.uri) {
			const c = n.options.manager.getHandler(a.uri);
			c !== null && (l = c);
		}
		return this.detectSupport().then(function (c) {
			if (c) return n.loadTextureImage(e, o.source, l);
			if (s.extensionsRequired && s.extensionsRequired.indexOf(t) >= 0)
				throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.');
			return n.loadTexture(e);
		});
	}
	detectSupport() {
		return (
			this.isSupported ||
				(this.isSupported = new Promise(function (e) {
					const t = new Image();
					(t.src =
						'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='),
						(t.onload = t.onerror =
							function () {
								e(t.height === 1);
							});
				})),
			this.isSupported
		);
	}
}
class IF {
	constructor(e) {
		(this.name = pt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
	}
	loadBufferView(e) {
		const t = this.parser.json,
			n = t.bufferViews[e];
		if (n.extensions && n.extensions[this.name]) {
			const s = n.extensions[this.name],
				r = this.parser.getDependency('buffer', s.buffer),
				o = this.parser.options.meshoptDecoder;
			if (!o || !o.supported) {
				if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
					throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');
				return null;
			}
			return r.then(function (a) {
				const l = s.byteOffset || 0,
					c = s.byteLength || 0,
					h = s.count,
					u = s.byteStride,
					d = new Uint8Array(a, l, c);
				return o.decodeGltfBufferAsync
					? o.decodeGltfBufferAsync(h, u, d, s.mode, s.filter).then(function (p) {
							return p.buffer;
					  })
					: o.ready.then(function () {
							const p = new ArrayBuffer(h * u);
							return o.decodeGltfBuffer(new Uint8Array(p), h, u, d, s.mode, s.filter), p;
					  });
			});
		} else return null;
	}
}
class DF {
	constructor(e) {
		(this.name = pt.EXT_MESH_GPU_INSTANCING), (this.parser = e);
	}
	createNodeMesh(e) {
		const t = this.parser.json,
			n = t.nodes[e];
		if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
		const s = t.meshes[n.mesh];
		for (const c of s.primitives)
			if (c.mode !== Zi.TRIANGLES && c.mode !== Zi.TRIANGLE_STRIP && c.mode !== Zi.TRIANGLE_FAN && c.mode !== void 0) return null;
		const o = n.extensions[this.name].attributes,
			a = [],
			l = {};
		for (const c in o) a.push(this.parser.getDependency('accessor', o[c]).then((h) => ((l[c] = h), l[c])));
		return a.length < 1
			? null
			: (a.push(this.parser.createNodeMesh(e)),
			  Promise.all(a).then((c) => {
					const h = c.pop(),
						u = h.isGroup ? h.children : [h],
						d = c[0].count,
						p = [];
					for (const g of u) {
						const v = new He(),
							m = new I(),
							f = new kn(),
							y = new I(1, 1, 1),
							_ = new D_(g.geometry, g.material, d);
						for (let x = 0; x < d; x++)
							l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, x),
								l.ROTATION && f.fromBufferAttribute(l.ROTATION, x),
								l.SCALE && y.fromBufferAttribute(l.SCALE, x),
								_.setMatrixAt(x, v.compose(m, f, y));
						for (const x in l)
							if (x === '_COLOR_0') {
								const E = l[x];
								_.instanceColor = new Ca(E.array, E.itemSize, E.normalized);
							} else x !== 'TRANSLATION' && x !== 'ROTATION' && x !== 'SCALE' && g.geometry.setAttribute(x, l[x]);
						ft.prototype.copy.call(_, g), this.parser.assignFinalMaterial(_), p.push(_);
					}
					return h.isGroup ? (h.clear(), h.add(...p), h) : p[0];
			  }));
	}
}
const yT = 'glTF',
	Lc = 12,
	Lb = { JSON: 1313821514, BIN: 5130562 };
class OF {
	constructor(e) {
		(this.name = pt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
		const t = new DataView(e, 0, Lc);
		if (
			((this.header = { magic: rp(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }),
			this.header.magic !== yT)
		)
			throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
		if (this.header.version < 2) throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
		const n = this.header.length - Lc,
			s = new DataView(e, Lc);
		let r = 0;
		for (; r < n; ) {
			const o = s.getUint32(r, !0);
			r += 4;
			const a = s.getUint32(r, !0);
			if (((r += 4), a === Lb.JSON)) {
				const l = new Uint8Array(e, Lc + r, o);
				this.content = rp(l);
			} else if (a === Lb.BIN) {
				const l = Lc + r;
				this.body = e.slice(l, l + o);
			}
			r += o;
		}
		if (this.content === null) throw new Error('THREE.GLTFLoader: JSON content not found.');
	}
}
class UF {
	constructor(e, t) {
		if (!t) throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
		(this.name = pt.KHR_DRACO_MESH_COMPRESSION), (this.json = e), (this.dracoLoader = t), this.dracoLoader.preload();
	}
	decodePrimitive(e, t) {
		const n = this.json,
			s = this.dracoLoader,
			r = e.extensions[this.name].bufferView,
			o = e.extensions[this.name].attributes,
			a = {},
			l = {},
			c = {};
		for (const h in o) {
			const u = uv[h] || h.toLowerCase();
			a[u] = o[h];
		}
		for (const h in e.attributes) {
			const u = uv[h] || h.toLowerCase();
			if (o[h] !== void 0) {
				const d = n.accessors[e.attributes[h]],
					p = Bl[d.componentType];
				(c[u] = p.name), (l[u] = d.normalized === !0);
			}
		}
		return t.getDependency('bufferView', r).then(function (h) {
			return new Promise(function (u, d) {
				s.decodeDracoFile(
					h,
					function (p) {
						for (const g in p.attributes) {
							const v = p.attributes[g],
								m = l[g];
							m !== void 0 && (v.normalized = m);
						}
						u(p);
					},
					a,
					c,
					gr,
					d
				);
			});
		});
	}
}
class NF {
	constructor() {
		this.name = pt.KHR_TEXTURE_TRANSFORM;
	}
	extendTexture(e, t) {
		return (
			((t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
				((e = e.clone()),
				t.texCoord !== void 0 && (e.channel = t.texCoord),
				t.offset !== void 0 && e.offset.fromArray(t.offset),
				t.rotation !== void 0 && (e.rotation = t.rotation),
				t.scale !== void 0 && e.repeat.fromArray(t.scale),
				(e.needsUpdate = !0)),
			e
		);
	}
}
class FF {
	constructor() {
		this.name = pt.KHR_MESH_QUANTIZATION;
	}
}
class xT extends uc {
	constructor(e, t, n, s) {
		super(e, t, n, s);
	}
	copySampleValue_(e) {
		const t = this.resultBuffer,
			n = this.sampleValues,
			s = this.valueSize,
			r = e * s * 3 + s;
		for (let o = 0; o !== s; o++) t[o] = n[r + o];
		return t;
	}
	interpolate_(e, t, n, s) {
		const r = this.resultBuffer,
			o = this.sampleValues,
			a = this.valueSize,
			l = a * 2,
			c = a * 3,
			h = s - t,
			u = (n - t) / h,
			d = u * u,
			p = d * u,
			g = e * c,
			v = g - c,
			m = -2 * p + 3 * d,
			f = p - d,
			y = 1 - m,
			_ = f - d + u;
		for (let x = 0; x !== a; x++) {
			const E = o[v + x + a],
				w = o[v + x + l] * h,
				C = o[g + x + a],
				P = o[g + x] * h;
			r[x] = y * E + _ * w + m * C + f * P;
		}
		return r;
	}
}
const BF = new kn();
class kF extends xT {
	interpolate_(e, t, n, s) {
		const r = super.interpolate_(e, t, n, s);
		return BF.fromArray(r).normalize().toArray(r), r;
	}
}
const Zi = {
		FLOAT: 5126,
		FLOAT_MAT3: 35675,
		FLOAT_MAT4: 35676,
		FLOAT_VEC2: 35664,
		FLOAT_VEC3: 35665,
		FLOAT_VEC4: 35666,
		LINEAR: 9729,
		REPEAT: 10497,
		SAMPLER_2D: 35678,
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6,
		UNSIGNED_BYTE: 5121,
		UNSIGNED_SHORT: 5123,
	},
	Bl = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
	Ib = { 9728: It, 9729: Tt, 9984: Fp, 9985: Nl, 9986: oa, 9987: ts },
	Db = { 33071: Oi, 33648: Kl, 10497: rs },
	Tm = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
	uv = {
		POSITION: 'position',
		NORMAL: 'normal',
		TANGENT: 'tangent',
		...(Y3 >= 152
			? { TEXCOORD_0: 'uv', TEXCOORD_1: 'uv1', TEXCOORD_2: 'uv2', TEXCOORD_3: 'uv3' }
			: { TEXCOORD_0: 'uv', TEXCOORD_1: 'uv2' }),
		COLOR_0: 'color',
		WEIGHTS_0: 'skinWeight',
		JOINTS_0: 'skinIndex',
	},
	zr = { scale: 'scale', translation: 'position', rotation: 'quaternion', weights: 'morphTargetInfluences' },
	zF = { CUBICSPLINE: void 0, LINEAR: Aa, STEP: $l },
	Am = { OPAQUE: 'OPAQUE', MASK: 'MASK', BLEND: 'BLEND' };
function VF(i) {
	return (
		i.DefaultMaterial === void 0 &&
			(i.DefaultMaterial = new Ha({
				color: 16777215,
				emissive: 0,
				metalness: 1,
				roughness: 1,
				transparent: !1,
				depthTest: !0,
				side: Ms,
			})),
		i.DefaultMaterial
	);
}
function jo(i, e, t) {
	for (const n in t.extensions)
		i[n] === void 0 &&
			((e.userData.gltfExtensions = e.userData.gltfExtensions || {}), (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function lr(i, e) {
	e.extras !== void 0 &&
		(typeof e.extras == 'object'
			? Object.assign(i.userData, e.extras)
			: console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + e.extras));
}
function HF(i, e, t) {
	let n = !1,
		s = !1,
		r = !1;
	for (let c = 0, h = e.length; c < h; c++) {
		const u = e[c];
		if ((u.POSITION !== void 0 && (n = !0), u.NORMAL !== void 0 && (s = !0), u.COLOR_0 !== void 0 && (r = !0), n && s && r)) break;
	}
	if (!n && !s && !r) return Promise.resolve(i);
	const o = [],
		a = [],
		l = [];
	for (let c = 0, h = e.length; c < h; c++) {
		const u = e[c];
		if (n) {
			const d = u.POSITION !== void 0 ? t.getDependency('accessor', u.POSITION) : i.attributes.position;
			o.push(d);
		}
		if (s) {
			const d = u.NORMAL !== void 0 ? t.getDependency('accessor', u.NORMAL) : i.attributes.normal;
			a.push(d);
		}
		if (r) {
			const d = u.COLOR_0 !== void 0 ? t.getDependency('accessor', u.COLOR_0) : i.attributes.color;
			l.push(d);
		}
	}
	return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function (c) {
		const h = c[0],
			u = c[1],
			d = c[2];
		return (
			n && (i.morphAttributes.position = h),
			s && (i.morphAttributes.normal = u),
			r && (i.morphAttributes.color = d),
			(i.morphTargetsRelative = !0),
			i
		);
	});
}
function GF(i, e) {
	if ((i.updateMorphTargets(), e.weights !== void 0))
		for (let t = 0, n = e.weights.length; t < n; t++) i.morphTargetInfluences[t] = e.weights[t];
	if (e.extras && Array.isArray(e.extras.targetNames)) {
		const t = e.extras.targetNames;
		if (i.morphTargetInfluences.length === t.length) {
			i.morphTargetDictionary = {};
			for (let n = 0, s = t.length; n < s; n++) i.morphTargetDictionary[t[n]] = n;
		} else console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
	}
}
function WF(i) {
	let e;
	const t = i.extensions && i.extensions[pt.KHR_DRACO_MESH_COMPRESSION];
	if (
		(t
			? (e = 'draco:' + t.bufferView + ':' + t.indices + ':' + Cm(t.attributes))
			: (e = i.indices + ':' + Cm(i.attributes) + ':' + i.mode),
		i.targets !== void 0)
	)
		for (let n = 0, s = i.targets.length; n < s; n++) e += ':' + Cm(i.targets[n]);
	return e;
}
function Cm(i) {
	let e = '';
	const t = Object.keys(i).sort();
	for (let n = 0, s = t.length; n < s; n++) e += t[n] + ':' + i[t[n]] + ';';
	return e;
}
function dv(i) {
	switch (i) {
		case Int8Array:
			return 1 / 127;
		case Uint8Array:
			return 1 / 255;
		case Int16Array:
			return 1 / 32767;
		case Uint16Array:
			return 1 / 65535;
		default:
			throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');
	}
}
function XF(i) {
	return i.search(/\.jpe?g($|\?)/i) > 0 || i.search(/^data\:image\/jpeg/) === 0
		? 'image/jpeg'
		: i.search(/\.webp($|\?)/i) > 0 || i.search(/^data\:image\/webp/) === 0
		? 'image/webp'
		: 'image/png';
}
const qF = new He();
class YF {
	constructor(e = {}, t = {}) {
		(this.json = e),
			(this.extensions = {}),
			(this.plugins = {}),
			(this.options = t),
			(this.cache = new mF()),
			(this.associations = new Map()),
			(this.primitiveCache = {}),
			(this.nodeCache = {}),
			(this.meshCache = { refs: {}, uses: {} }),
			(this.cameraCache = { refs: {}, uses: {} }),
			(this.lightCache = { refs: {}, uses: {} }),
			(this.sourceCache = {}),
			(this.textureCache = {}),
			(this.nodeNamesUsed = {});
		let n = !1,
			s = !1,
			r = -1;
		typeof navigator < 'u' &&
			typeof navigator.userAgent < 'u' &&
			((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
			(s = navigator.userAgent.indexOf('Firefox') > -1),
			(r = s ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
			typeof createImageBitmap > 'u' || n || (s && r < 98)
				? (this.textureLoader = new ff(this.options.manager))
				: (this.textureLoader = new nT(this.options.manager)),
			this.textureLoader.setCrossOrigin(this.options.crossOrigin),
			this.textureLoader.setRequestHeader(this.options.requestHeader),
			(this.fileLoader = new Si(this.options.manager)),
			this.fileLoader.setResponseType('arraybuffer'),
			this.options.crossOrigin === 'use-credentials' && this.fileLoader.setWithCredentials(!0);
	}
	setExtensions(e) {
		this.extensions = e;
	}
	setPlugins(e) {
		this.plugins = e;
	}
	parse(e, t) {
		const n = this,
			s = this.json,
			r = this.extensions;
		this.cache.removeAll(),
			(this.nodeCache = {}),
			this._invokeAll(function (o) {
				return o._markDefs && o._markDefs();
			}),
			Promise.all(
				this._invokeAll(function (o) {
					return o.beforeRoot && o.beforeRoot();
				})
			)
				.then(function () {
					return Promise.all([n.getDependencies('scene'), n.getDependencies('animation'), n.getDependencies('camera')]);
				})
				.then(function (o) {
					const a = {
						scene: o[0][s.scene || 0],
						scenes: o[0],
						animations: o[1],
						cameras: o[2],
						asset: s.asset,
						parser: n,
						userData: {},
					};
					return (
						jo(r, a, s),
						lr(a, s),
						Promise.all(
							n._invokeAll(function (l) {
								return l.afterRoot && l.afterRoot(a);
							})
						).then(function () {
							for (const l of a.scenes) l.updateMatrixWorld();
							e(a);
						})
					);
				})
				.catch(t);
	}
	_markDefs() {
		const e = this.json.nodes || [],
			t = this.json.skins || [],
			n = this.json.meshes || [];
		for (let s = 0, r = t.length; s < r; s++) {
			const o = t[s].joints;
			for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
		}
		for (let s = 0, r = e.length; s < r; s++) {
			const o = e[s];
			o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
				o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
		}
	}
	_addNodeRef(e, t) {
		t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
	}
	_getNodeRef(e, t, n) {
		if (e.refs[t] <= 1) return n;
		const s = n.clone(),
			r = (o, a) => {
				const l = this.associations.get(o);
				l != null && this.associations.set(a, l);
				for (const [c, h] of o.children.entries()) r(h, a.children[c]);
			};
		return r(n, s), (s.name += '_instance_' + e.uses[t]++), s;
	}
	_invokeOne(e) {
		const t = Object.values(this.plugins);
		t.push(this);
		for (let n = 0; n < t.length; n++) {
			const s = e(t[n]);
			if (s) return s;
		}
		return null;
	}
	_invokeAll(e) {
		const t = Object.values(this.plugins);
		t.unshift(this);
		const n = [];
		for (let s = 0; s < t.length; s++) {
			const r = e(t[s]);
			r && n.push(r);
		}
		return n;
	}
	getDependency(e, t) {
		const n = e + ':' + t;
		let s = this.cache.get(n);
		if (!s) {
			switch (e) {
				case 'scene':
					s = this.loadScene(t);
					break;
				case 'node':
					s = this._invokeOne(function (r) {
						return r.loadNode && r.loadNode(t);
					});
					break;
				case 'mesh':
					s = this._invokeOne(function (r) {
						return r.loadMesh && r.loadMesh(t);
					});
					break;
				case 'accessor':
					s = this.loadAccessor(t);
					break;
				case 'bufferView':
					s = this._invokeOne(function (r) {
						return r.loadBufferView && r.loadBufferView(t);
					});
					break;
				case 'buffer':
					s = this.loadBuffer(t);
					break;
				case 'material':
					s = this._invokeOne(function (r) {
						return r.loadMaterial && r.loadMaterial(t);
					});
					break;
				case 'texture':
					s = this._invokeOne(function (r) {
						return r.loadTexture && r.loadTexture(t);
					});
					break;
				case 'skin':
					s = this.loadSkin(t);
					break;
				case 'animation':
					s = this._invokeOne(function (r) {
						return r.loadAnimation && r.loadAnimation(t);
					});
					break;
				case 'camera':
					s = this.loadCamera(t);
					break;
				default:
					if (
						((s = this._invokeOne(function (r) {
							return r != this && r.getDependency && r.getDependency(e, t);
						})),
						!s)
					)
						throw new Error('Unknown type: ' + e);
					break;
			}
			this.cache.add(n, s);
		}
		return s;
	}
	getDependencies(e) {
		let t = this.cache.get(e);
		if (!t) {
			const n = this,
				s = this.json[e + (e === 'mesh' ? 'es' : 's')] || [];
			(t = Promise.all(
				s.map(function (r, o) {
					return n.getDependency(e, o);
				})
			)),
				this.cache.add(e, t);
		}
		return t;
	}
	loadBuffer(e) {
		const t = this.json.buffers[e],
			n = this.fileLoader;
		if (t.type && t.type !== 'arraybuffer') throw new Error('THREE.GLTFLoader: ' + t.type + ' buffer type is not supported.');
		if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[pt.KHR_BINARY_GLTF].body);
		const s = this.options;
		return new Promise(function (r, o) {
			n.load(uo.resolveURL(t.uri, s.path), r, void 0, function () {
				o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
			});
		});
	}
	loadBufferView(e) {
		const t = this.json.bufferViews[e];
		return this.getDependency('buffer', t.buffer).then(function (n) {
			const s = t.byteLength || 0,
				r = t.byteOffset || 0;
			return n.slice(r, r + s);
		});
	}
	loadAccessor(e) {
		const t = this,
			n = this.json,
			s = this.json.accessors[e];
		if (s.bufferView === void 0 && s.sparse === void 0) {
			const o = Tm[s.type],
				a = Bl[s.componentType],
				l = s.normalized === !0,
				c = new a(s.count * o);
			return Promise.resolve(new $e(c, o, l));
		}
		const r = [];
		return (
			s.bufferView !== void 0 ? r.push(this.getDependency('bufferView', s.bufferView)) : r.push(null),
			s.sparse !== void 0 &&
				(r.push(this.getDependency('bufferView', s.sparse.indices.bufferView)),
				r.push(this.getDependency('bufferView', s.sparse.values.bufferView))),
			Promise.all(r).then(function (o) {
				const a = o[0],
					l = Tm[s.type],
					c = Bl[s.componentType],
					h = c.BYTES_PER_ELEMENT,
					u = h * l,
					d = s.byteOffset || 0,
					p = s.bufferView !== void 0 ? n.bufferViews[s.bufferView].byteStride : void 0,
					g = s.normalized === !0;
				let v, m;
				if (p && p !== u) {
					const f = Math.floor(d / p),
						y = 'InterleavedBuffer:' + s.bufferView + ':' + s.componentType + ':' + f + ':' + s.count;
					let _ = t.cache.get(y);
					_ || ((v = new c(a, f * p, (s.count * p) / h)), (_ = new nu(v, p / h)), t.cache.add(y, _)),
						(m = new xo(_, l, (d % p) / h, g));
				} else a === null ? (v = new c(s.count * l)) : (v = new c(a, d, s.count * l)), (m = new $e(v, l, g));
				if (s.sparse !== void 0) {
					const f = Tm.SCALAR,
						y = Bl[s.sparse.indices.componentType],
						_ = s.sparse.indices.byteOffset || 0,
						x = s.sparse.values.byteOffset || 0,
						E = new y(o[1], _, s.sparse.count * f),
						w = new c(o[2], x, s.sparse.count * l);
					a !== null && (m = new $e(m.array.slice(), m.itemSize, m.normalized));
					for (let C = 0, P = E.length; C < P; C++) {
						const S = E[C];
						if (
							(m.setX(S, w[C * l]),
							l >= 2 && m.setY(S, w[C * l + 1]),
							l >= 3 && m.setZ(S, w[C * l + 2]),
							l >= 4 && m.setW(S, w[C * l + 3]),
							l >= 5)
						)
							throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
					}
				}
				return m;
			})
		);
	}
	loadTexture(e) {
		const t = this.json,
			n = this.options,
			r = t.textures[e].source,
			o = t.images[r];
		let a = this.textureLoader;
		if (o.uri) {
			const l = n.manager.getHandler(o.uri);
			l !== null && (a = l);
		}
		return this.loadTextureImage(e, r, a);
	}
	loadTextureImage(e, t, n) {
		const s = this,
			r = this.json,
			o = r.textures[e],
			a = r.images[t],
			l = (a.uri || a.bufferView) + ':' + o.sampler;
		if (this.textureCache[l]) return this.textureCache[l];
		const c = this.loadImageSource(t, n)
			.then(function (h) {
				(h.flipY = !1),
					(h.name = o.name || a.name || ''),
					h.name === '' && typeof a.uri == 'string' && a.uri.startsWith('data:image/') === !1 && (h.name = a.uri);
				const d = (r.samplers || {})[o.sampler] || {};
				return (
					(h.magFilter = Ib[d.magFilter] || Tt),
					(h.minFilter = Ib[d.minFilter] || ts),
					(h.wrapS = Db[d.wrapS] || rs),
					(h.wrapT = Db[d.wrapT] || rs),
					s.associations.set(h, { textures: e }),
					h
				);
			})
			.catch(function () {
				return null;
			});
		return (this.textureCache[l] = c), c;
	}
	loadImageSource(e, t) {
		const n = this,
			s = this.json,
			r = this.options;
		if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((u) => u.clone());
		const o = s.images[e],
			a = self.URL || self.webkitURL;
		let l = o.uri || '',
			c = !1;
		if (o.bufferView !== void 0)
			l = n.getDependency('bufferView', o.bufferView).then(function (u) {
				c = !0;
				const d = new Blob([u], { type: o.mimeType });
				return (l = a.createObjectURL(d)), l;
			});
		else if (o.uri === void 0) throw new Error('THREE.GLTFLoader: Image ' + e + ' is missing URI and bufferView');
		const h = Promise.resolve(l)
			.then(function (u) {
				return new Promise(function (d, p) {
					let g = d;
					t.isImageBitmapLoader === !0 &&
						(g = function (v) {
							const m = new zt(v);
							(m.needsUpdate = !0), d(m);
						}),
						t.load(uo.resolveURL(u, r.path), g, void 0, p);
				});
			})
			.then(function (u) {
				return c === !0 && a.revokeObjectURL(l), lr(u, o), (u.userData.mimeType = o.mimeType || XF(o.uri)), u;
			})
			.catch(function (u) {
				throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), u);
			});
		return (this.sourceCache[e] = h), h;
	}
	assignTexture(e, t, n, s) {
		const r = this;
		return this.getDependency('texture', n.index).then(function (o) {
			if (!o) return null;
			if (
				(n.texCoord !== void 0 && n.texCoord > 0 && ((o = o.clone()), (o.channel = n.texCoord)),
				r.extensions[pt.KHR_TEXTURE_TRANSFORM])
			) {
				const a = n.extensions !== void 0 ? n.extensions[pt.KHR_TEXTURE_TRANSFORM] : void 0;
				if (a) {
					const l = r.associations.get(o);
					(o = r.extensions[pt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)), r.associations.set(o, l);
				}
			}
			return (
				s !== void 0 &&
					(typeof s == 'number' && (s = s === Pb ? da : gr),
					'colorSpace' in o ? (o.colorSpace = s) : (o.encoding = s === da ? Pb : pF)),
				(e[t] = o),
				o
			);
		});
	}
	assignFinalMaterial(e) {
		const t = e.geometry;
		let n = e.material;
		const s = t.attributes.tangent === void 0,
			r = t.attributes.color !== void 0,
			o = t.attributes.normal === void 0;
		if (e.isPoints) {
			const a = 'PointsMaterial:' + n.uuid;
			let l = this.cache.get(a);
			l ||
				((l = new Kp()),
				vn.prototype.copy.call(l, n),
				l.color.copy(n.color),
				(l.map = n.map),
				(l.sizeAttenuation = !1),
				this.cache.add(a, l)),
				(n = l);
		} else if (e.isLine) {
			const a = 'LineBasicMaterial:' + n.uuid;
			let l = this.cache.get(a);
			l || ((l = new Jn()), vn.prototype.copy.call(l, n), l.color.copy(n.color), (l.map = n.map), this.cache.add(a, l)), (n = l);
		}
		if (s || r || o) {
			let a = 'ClonedMaterial:' + n.uuid + ':';
			s && (a += 'derivative-tangents:'), r && (a += 'vertex-colors:'), o && (a += 'flat-shading:');
			let l = this.cache.get(a);
			l ||
				((l = n.clone()),
				r && (l.vertexColors = !0),
				o && (l.flatShading = !0),
				s && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
				this.cache.add(a, l),
				this.associations.set(l, this.associations.get(n))),
				(n = l);
		}
		e.material = n;
	}
	getMaterialType() {
		return Ha;
	}
	loadMaterial(e) {
		const t = this,
			n = this.json,
			s = this.extensions,
			r = n.materials[e];
		let o;
		const a = {},
			l = r.extensions || {},
			c = [];
		if (l[pt.KHR_MATERIALS_UNLIT]) {
			const u = s[pt.KHR_MATERIALS_UNLIT];
			(o = u.getMaterialType()), c.push(u.extendParams(a, r, t));
		} else {
			const u = r.pbrMetallicRoughness || {};
			if (((a.color = new Ee(1, 1, 1)), (a.opacity = 1), Array.isArray(u.baseColorFactor))) {
				const d = u.baseColorFactor;
				a.color.setRGB(d[0], d[1], d[2], gr), (a.opacity = d[3]);
			}
			u.baseColorTexture !== void 0 && c.push(t.assignTexture(a, 'map', u.baseColorTexture, da)),
				(a.metalness = u.metallicFactor !== void 0 ? u.metallicFactor : 1),
				(a.roughness = u.roughnessFactor !== void 0 ? u.roughnessFactor : 1),
				u.metallicRoughnessTexture !== void 0 &&
					(c.push(t.assignTexture(a, 'metalnessMap', u.metallicRoughnessTexture)),
					c.push(t.assignTexture(a, 'roughnessMap', u.metallicRoughnessTexture))),
				(o = this._invokeOne(function (d) {
					return d.getMaterialType && d.getMaterialType(e);
				})),
				c.push(
					Promise.all(
						this._invokeAll(function (d) {
							return d.extendMaterialParams && d.extendMaterialParams(e, a);
						})
					)
				);
		}
		r.doubleSided === !0 && (a.side = mn);
		const h = r.alphaMode || Am.OPAQUE;
		if (
			(h === Am.BLEND
				? ((a.transparent = !0), (a.depthWrite = !1))
				: ((a.transparent = !1), h === Am.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)),
			r.normalTexture !== void 0 &&
				o !== En &&
				(c.push(t.assignTexture(a, 'normalMap', r.normalTexture)),
				(a.normalScale = new ce(1, 1)),
				r.normalTexture.scale !== void 0))
		) {
			const u = r.normalTexture.scale;
			a.normalScale.set(u, u);
		}
		if (
			(r.occlusionTexture !== void 0 &&
				o !== En &&
				(c.push(t.assignTexture(a, 'aoMap', r.occlusionTexture)),
				r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)),
			r.emissiveFactor !== void 0 && o !== En)
		) {
			const u = r.emissiveFactor;
			a.emissive = new Ee().setRGB(u[0], u[1], u[2], gr);
		}
		return (
			r.emissiveTexture !== void 0 && o !== En && c.push(t.assignTexture(a, 'emissiveMap', r.emissiveTexture, da)),
			Promise.all(c).then(function () {
				const u = new o(a);
				return r.name && (u.name = r.name), lr(u, r), t.associations.set(u, { materials: e }), r.extensions && jo(s, u, r), u;
			})
		);
	}
	createUniqueName(e) {
		const t = _t.sanitizeNodeName(e || '');
		return t in this.nodeNamesUsed ? t + '_' + ++this.nodeNamesUsed[t] : ((this.nodeNamesUsed[t] = 0), t);
	}
	loadGeometries(e) {
		const t = this,
			n = this.extensions,
			s = this.primitiveCache;
		function r(a) {
			return n[pt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function (l) {
				return Ob(l, a, t);
			});
		}
		const o = [];
		for (let a = 0, l = e.length; a < l; a++) {
			const c = e[a],
				h = WF(c),
				u = s[h];
			if (u) o.push(u.promise);
			else {
				let d;
				c.extensions && c.extensions[pt.KHR_DRACO_MESH_COMPRESSION] ? (d = r(c)) : (d = Ob(new Ze(), c, t)),
					(s[h] = { primitive: c, promise: d }),
					o.push(d);
			}
		}
		return Promise.all(o);
	}
	loadMesh(e) {
		const t = this,
			n = this.json,
			s = this.extensions,
			r = n.meshes[e],
			o = r.primitives,
			a = [];
		for (let l = 0, c = o.length; l < c; l++) {
			const h = o[l].material === void 0 ? VF(this.cache) : this.getDependency('material', o[l].material);
			a.push(h);
		}
		return (
			a.push(t.loadGeometries(o)),
			Promise.all(a).then(function (l) {
				const c = l.slice(0, l.length - 1),
					h = l[l.length - 1],
					u = [];
				for (let p = 0, g = h.length; p < g; p++) {
					const v = h[p],
						m = o[p];
					let f;
					const y = c[p];
					if (m.mode === Zi.TRIANGLES || m.mode === Zi.TRIANGLE_STRIP || m.mode === Zi.TRIANGLE_FAN || m.mode === void 0)
						(f = r.isSkinnedMesh === !0 ? new I_(v, y) : new bt(v, y)),
							f.isSkinnedMesh === !0 && f.normalizeSkinWeights(),
							m.mode === Zi.TRIANGLE_STRIP
								? (f.geometry = Rb(f.geometry, S_))
								: m.mode === Zi.TRIANGLE_FAN && (f.geometry = Rb(f.geometry, tp));
					else if (m.mode === Zi.LINES) f = new as(v, y);
					else if (m.mode === Zi.LINE_STRIP) f = new xr(v, y);
					else if (m.mode === Zi.LINE_LOOP) f = new O_(v, y);
					else if (m.mode === Zi.POINTS) f = new U_(v, y);
					else throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + m.mode);
					Object.keys(f.geometry.morphAttributes).length > 0 && GF(f, r),
						(f.name = t.createUniqueName(r.name || 'mesh_' + e)),
						lr(f, r),
						m.extensions && jo(s, f, m),
						t.assignFinalMaterial(f),
						u.push(f);
				}
				for (let p = 0, g = u.length; p < g; p++) t.associations.set(u[p], { meshes: e, primitives: p });
				if (u.length === 1) return r.extensions && jo(s, u[0], r), u[0];
				const d = new Ui();
				r.extensions && jo(s, d, r), t.associations.set(d, { meshes: e });
				for (let p = 0, g = u.length; p < g; p++) d.add(u[p]);
				return d;
			})
		);
	}
	loadCamera(e) {
		let t;
		const n = this.json.cameras[e],
			s = n[n.type];
		if (!s) {
			console.warn('THREE.GLTFLoader: Missing camera parameters.');
			return;
		}
		return (
			n.type === 'perspective'
				? (t = new fn(Dn.radToDeg(s.yfov), s.aspectRatio || 1, s.znear || 1, s.zfar || 2e6))
				: n.type === 'orthographic' && (t = new eu(-s.xmag, s.xmag, s.ymag, -s.ymag, s.znear, s.zfar)),
			n.name && (t.name = this.createUniqueName(n.name)),
			lr(t, n),
			Promise.resolve(t)
		);
	}
	loadSkin(e) {
		const t = this.json.skins[e],
			n = [];
		for (let s = 0, r = t.joints.length; s < r; s++) n.push(this._loadNodeShallow(t.joints[s]));
		return (
			t.inverseBindMatrices !== void 0 ? n.push(this.getDependency('accessor', t.inverseBindMatrices)) : n.push(null),
			Promise.all(n).then(function (s) {
				const r = s.pop(),
					o = s,
					a = [],
					l = [];
				for (let c = 0, h = o.length; c < h; c++) {
					const u = o[c];
					if (u) {
						a.push(u);
						const d = new He();
						r !== null && d.fromArray(r.array, c * 16), l.push(d);
					} else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
				}
				return new iu(a, l);
			})
		);
	}
	loadAnimation(e) {
		const t = this.json,
			n = this,
			s = t.animations[e],
			r = s.name ? s.name : 'animation_' + e,
			o = [],
			a = [],
			l = [],
			c = [],
			h = [];
		for (let u = 0, d = s.channels.length; u < d; u++) {
			const p = s.channels[u],
				g = s.samplers[p.sampler],
				v = p.target,
				m = v.node,
				f = s.parameters !== void 0 ? s.parameters[g.input] : g.input,
				y = s.parameters !== void 0 ? s.parameters[g.output] : g.output;
			v.node !== void 0 &&
				(o.push(this.getDependency('node', m)),
				a.push(this.getDependency('accessor', f)),
				l.push(this.getDependency('accessor', y)),
				c.push(g),
				h.push(v));
		}
		return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(h)]).then(function (u) {
			const d = u[0],
				p = u[1],
				g = u[2],
				v = u[3],
				m = u[4],
				f = [];
			for (let y = 0, _ = d.length; y < _; y++) {
				const x = d[y],
					E = p[y],
					w = g[y],
					C = v[y],
					P = m[y];
				if (x === void 0) continue;
				x.updateMatrix && x.updateMatrix();
				const S = n._createAnimationTracks(x, E, w, C, P);
				if (S) for (let M = 0; M < S.length; M++) f.push(S[M]);
			}
			return new Ql(r, void 0, f);
		});
	}
	createNodeMesh(e) {
		const t = this.json,
			n = this,
			s = t.nodes[e];
		return s.mesh === void 0
			? null
			: n.getDependency('mesh', s.mesh).then(function (r) {
					const o = n._getNodeRef(n.meshCache, s.mesh, r);
					return (
						s.weights !== void 0 &&
							o.traverse(function (a) {
								if (a.isMesh) for (let l = 0, c = s.weights.length; l < c; l++) a.morphTargetInfluences[l] = s.weights[l];
							}),
						o
					);
			  });
	}
	loadNode(e) {
		const t = this.json,
			n = this,
			s = t.nodes[e],
			r = n._loadNodeShallow(e),
			o = [],
			a = s.children || [];
		for (let c = 0, h = a.length; c < h; c++) o.push(n.getDependency('node', a[c]));
		const l = s.skin === void 0 ? Promise.resolve(null) : n.getDependency('skin', s.skin);
		return Promise.all([r, Promise.all(o), l]).then(function (c) {
			const h = c[0],
				u = c[1],
				d = c[2];
			d !== null &&
				h.traverse(function (p) {
					p.isSkinnedMesh && p.bind(d, qF);
				});
			for (let p = 0, g = u.length; p < g; p++) h.add(u[p]);
			return h;
		});
	}
	_loadNodeShallow(e) {
		const t = this.json,
			n = this.extensions,
			s = this;
		if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
		const r = t.nodes[e],
			o = r.name ? s.createUniqueName(r.name) : '',
			a = [],
			l = s._invokeOne(function (c) {
				return c.createNodeMesh && c.createNodeMesh(e);
			});
		return (
			l && a.push(l),
			r.camera !== void 0 &&
				a.push(
					s.getDependency('camera', r.camera).then(function (c) {
						return s._getNodeRef(s.cameraCache, r.camera, c);
					})
				),
			s
				._invokeAll(function (c) {
					return c.createNodeAttachment && c.createNodeAttachment(e);
				})
				.forEach(function (c) {
					a.push(c);
				}),
			(this.nodeCache[e] = Promise.all(a).then(function (c) {
				let h;
				if (
					(r.isBone === !0 ? (h = new jp()) : c.length > 1 ? (h = new Ui()) : c.length === 1 ? (h = c[0]) : (h = new ft()),
					h !== c[0])
				)
					for (let u = 0, d = c.length; u < d; u++) h.add(c[u]);
				if ((r.name && ((h.userData.name = r.name), (h.name = o)), lr(h, r), r.extensions && jo(n, h, r), r.matrix !== void 0)) {
					const u = new He();
					u.fromArray(r.matrix), h.applyMatrix4(u);
				} else r.translation !== void 0 && h.position.fromArray(r.translation), r.rotation !== void 0 && h.quaternion.fromArray(r.rotation), r.scale !== void 0 && h.scale.fromArray(r.scale);
				return s.associations.has(h) || s.associations.set(h, {}), (s.associations.get(h).nodes = e), h;
			})),
			this.nodeCache[e]
		);
	}
	loadScene(e) {
		const t = this.extensions,
			n = this.json.scenes[e],
			s = this,
			r = new Ui();
		n.name && (r.name = s.createUniqueName(n.name)), lr(r, n), n.extensions && jo(t, r, n);
		const o = n.nodes || [],
			a = [];
		for (let l = 0, c = o.length; l < c; l++) a.push(s.getDependency('node', o[l]));
		return Promise.all(a).then(function (l) {
			for (let h = 0, u = l.length; h < u; h++) r.add(l[h]);
			const c = (h) => {
				const u = new Map();
				for (const [d, p] of s.associations) (d instanceof vn || d instanceof zt) && u.set(d, p);
				return (
					h.traverse((d) => {
						const p = s.associations.get(d);
						p != null && u.set(d, p);
					}),
					u
				);
			};
			return (s.associations = c(r)), r;
		});
	}
	_createAnimationTracks(e, t, n, s, r) {
		const o = [],
			a = e.name ? e.name : e.uuid,
			l = [];
		zr[r.path] === zr.weights
			? e.traverse(function (d) {
					d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
			  })
			: l.push(a);
		let c;
		switch (zr[r.path]) {
			case zr.weights:
				c = Pa;
				break;
			case zr.rotation:
				c = bo;
				break;
			case zr.position:
			case zr.scale:
				c = La;
				break;
			default:
				switch (n.itemSize) {
					case 1:
						c = Pa;
						break;
					case 2:
					case 3:
					default:
						c = La;
						break;
				}
				break;
		}
		const h = s.interpolation !== void 0 ? zF[s.interpolation] : Aa,
			u = this._getArrayFromAccessor(n);
		for (let d = 0, p = l.length; d < p; d++) {
			const g = new c(l[d] + '.' + zr[r.path], t.array, u, h);
			s.interpolation === 'CUBICSPLINE' && this._createCubicSplineTrackInterpolant(g), o.push(g);
		}
		return o;
	}
	_getArrayFromAccessor(e) {
		let t = e.array;
		if (e.normalized) {
			const n = dv(t.constructor),
				s = new Float32Array(t.length);
			for (let r = 0, o = t.length; r < o; r++) s[r] = t[r] * n;
			t = s;
		}
		return t;
	}
	_createCubicSplineTrackInterpolant(e) {
		(e.createInterpolant = function (n) {
			const s = this instanceof bo ? kF : xT;
			return new s(this.times, this.values, this.getValueSize() / 3, n);
		}),
			(e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
	}
}
function jF(i, e, t) {
	const n = e.attributes,
		s = new An();
	if (n.POSITION !== void 0) {
		const a = t.json.accessors[n.POSITION],
			l = a.min,
			c = a.max;
		if (l !== void 0 && c !== void 0) {
			if ((s.set(new I(l[0], l[1], l[2]), new I(c[0], c[1], c[2])), a.normalized)) {
				const h = dv(Bl[a.componentType]);
				s.min.multiplyScalar(h), s.max.multiplyScalar(h);
			}
		} else {
			console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
			return;
		}
	} else return;
	const r = e.targets;
	if (r !== void 0) {
		const a = new I(),
			l = new I();
		for (let c = 0, h = r.length; c < h; c++) {
			const u = r[c];
			if (u.POSITION !== void 0) {
				const d = t.json.accessors[u.POSITION],
					p = d.min,
					g = d.max;
				if (p !== void 0 && g !== void 0) {
					if (
						(l.setX(Math.max(Math.abs(p[0]), Math.abs(g[0]))),
						l.setY(Math.max(Math.abs(p[1]), Math.abs(g[1]))),
						l.setZ(Math.max(Math.abs(p[2]), Math.abs(g[2]))),
						d.normalized)
					) {
						const v = dv(Bl[d.componentType]);
						l.multiplyScalar(v);
					}
					a.max(l);
				} else console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
			}
		}
		s.expandByVector(a);
	}
	i.boundingBox = s;
	const o = new un();
	s.getCenter(o.center), (o.radius = s.min.distanceTo(s.max) / 2), (i.boundingSphere = o);
}
function Ob(i, e, t) {
	const n = e.attributes,
		s = [];
	function r(o, a) {
		return t.getDependency('accessor', o).then(function (l) {
			i.setAttribute(a, l);
		});
	}
	for (const o in n) {
		const a = uv[o] || o.toLowerCase();
		a in i.attributes || s.push(r(n[o], a));
	}
	if (e.indices !== void 0 && !i.index) {
		const o = t.getDependency('accessor', e.indices).then(function (a) {
			i.setIndex(a);
		});
		s.push(o);
	}
	return (
		lr(i, e),
		jF(i, e, t),
		Promise.all(s).then(function () {
			return e.targets !== void 0 ? HF(i, e.targets, t) : i;
		})
	);
}
class KF extends X_ {
	constructor(e) {
		super(e), (this.type = fi);
	}
	parse(e) {
		const o = function (P, S) {
				switch (P) {
					case 1:
						throw new Error('THREE.RGBELoader: Read Error: ' + (S || ''));
					case 2:
						throw new Error('THREE.RGBELoader: Write Error: ' + (S || ''));
					case 3:
						throw new Error('THREE.RGBELoader: Bad File Format: ' + (S || ''));
					default:
					case 4:
						throw new Error('THREE.RGBELoader: Memory Error: ' + (S || ''));
				}
			},
			h = '\n',
			u = function (P, S, M) {
				S = S || 1024;
				let q = P.pos,
					B = -1,
					W = 0,
					Q = '',
					$ = String.fromCharCode.apply(null, new Uint16Array(P.subarray(q, q + 128)));
				for (; 0 > (B = $.indexOf(h)) && W < S && q < P.byteLength; )
					(Q += $), (W += $.length), (q += 128), ($ += String.fromCharCode.apply(null, new Uint16Array(P.subarray(q, q + 128))));
				return -1 < B ? ((P.pos += W + B + 1), Q + $.slice(0, B)) : !1;
			},
			d = function (P) {
				const S = /^#\?(\S+)/,
					M = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					k = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					q = /^\s*FORMAT=(\S+)\s*$/,
					B = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
					W = { valid: 0, string: '', comments: '', programtype: 'RGBE', format: '', gamma: 1, exposure: 1, width: 0, height: 0 };
				let Q, $;
				for (
					(P.pos >= P.byteLength || !(Q = u(P))) && o(1, 'no header found'),
						($ = Q.match(S)) || o(3, 'bad initial token'),
						W.valid |= 1,
						W.programtype = $[1],
						W.string += Q + '\n';
					(Q = u(P)), Q !== !1;

				) {
					if (((W.string += Q + '\n'), Q.charAt(0) === '#')) {
						W.comments += Q + '\n';
						continue;
					}
					if (
						(($ = Q.match(M)) && (W.gamma = parseFloat($[1])),
						($ = Q.match(k)) && (W.exposure = parseFloat($[1])),
						($ = Q.match(q)) && ((W.valid |= 2), (W.format = $[1])),
						($ = Q.match(B)) && ((W.valid |= 4), (W.height = parseInt($[1], 10)), (W.width = parseInt($[2], 10))),
						W.valid & 2 && W.valid & 4)
					)
						break;
				}
				return W.valid & 2 || o(3, 'missing format specifier'), W.valid & 4 || o(3, 'missing image size specifier'), W;
			},
			p = function (P, S, M) {
				const k = S;
				if (k < 8 || k > 32767 || P[0] !== 2 || P[1] !== 2 || P[2] & 128) return new Uint8Array(P);
				k !== ((P[2] << 8) | P[3]) && o(3, 'wrong scanline width');
				const q = new Uint8Array(4 * S * M);
				q.length || o(4, 'unable to allocate buffer space');
				let B = 0,
					W = 0;
				const Q = 4 * k,
					$ = new Uint8Array(4),
					le = new Uint8Array(Q);
				let Z = M;
				for (; Z > 0 && W < P.byteLength; ) {
					W + 4 > P.byteLength && o(1),
						($[0] = P[W++]),
						($[1] = P[W++]),
						($[2] = P[W++]),
						($[3] = P[W++]),
						($[0] != 2 || $[1] != 2 || (($[2] << 8) | $[3]) != k) && o(3, 'bad rgbe scanline format');
					let xe = 0,
						ue;
					for (; xe < Q && W < P.byteLength; ) {
						ue = P[W++];
						const Ae = ue > 128;
						if ((Ae && (ue -= 128), (ue === 0 || xe + ue > Q) && o(3, 'bad scanline data'), Ae)) {
							const We = P[W++];
							for (let se = 0; se < ue; se++) le[xe++] = We;
						} else le.set(P.subarray(W, W + ue), xe), (xe += ue), (W += ue);
					}
					const Te = k;
					for (let Ae = 0; Ae < Te; Ae++) {
						let We = 0;
						(q[B] = le[Ae + We]),
							(We += k),
							(q[B + 1] = le[Ae + We]),
							(We += k),
							(q[B + 2] = le[Ae + We]),
							(We += k),
							(q[B + 3] = le[Ae + We]),
							(B += 4);
					}
					Z--;
				}
				return q;
			},
			g = function (P, S, M, k) {
				const q = P[S + 3],
					B = Math.pow(2, q - 128) / 255;
				(M[k + 0] = P[S + 0] * B), (M[k + 1] = P[S + 1] * B), (M[k + 2] = P[S + 2] * B), (M[k + 3] = 1);
			},
			v = function (P, S, M, k) {
				const q = P[S + 3],
					B = Math.pow(2, q - 128) / 255;
				(M[k + 0] = ha.toHalfFloat(Math.min(P[S + 0] * B, 65504))),
					(M[k + 1] = ha.toHalfFloat(Math.min(P[S + 1] * B, 65504))),
					(M[k + 2] = ha.toHalfFloat(Math.min(P[S + 2] * B, 65504))),
					(M[k + 3] = ha.toHalfFloat(1));
			},
			m = new Uint8Array(e);
		m.pos = 0;
		const f = d(m),
			y = f.width,
			_ = f.height,
			x = p(m.subarray(m.pos), y, _);
		let E, w, C;
		switch (this.type) {
			case On:
				C = x.length / 4;
				const P = new Float32Array(C * 4);
				for (let M = 0; M < C; M++) g(x, M * 4, P, M * 4);
				(E = P), (w = On);
				break;
			case fi:
				C = x.length / 4;
				const S = new Uint16Array(C * 4);
				for (let M = 0; M < C; M++) v(x, M * 4, S, M * 4);
				(E = S), (w = fi);
				break;
			default:
				throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type);
		}
		return { width: y, height: _, data: E, header: f.string, gamma: f.gamma, exposure: f.exposure, type: w };
	}
	setDataType(e) {
		return (this.type = e), this;
	}
	load(e, t, n, s) {
		function r(o, a) {
			switch (o.type) {
				case On:
				case fi:
					'colorSpace' in o ? (o.colorSpace = 'srgb-linear') : (o.encoding = 3e3),
						(o.minFilter = Tt),
						(o.magFilter = Tt),
						(o.generateMipmaps = !1),
						(o.flipY = !0);
					break;
			}
			t && t(o, a);
		}
		return super.load(e, r, n, s);
	}
}
const Ic = 'colorSpace' in new zt();
class $F extends X_ {
	constructor(e) {
		super(e), (this.type = fi);
	}
	parse(e) {
		const S = Math.pow(2.7182818, 2.2);
		function M(A, b) {
			for (var R = 0, U = 0; U < 65536; ++U) (U == 0 || A[U >> 3] & (1 << (U & 7))) && (b[R++] = U);
			for (var N = R - 1; R < 65536; ) b[R++] = 0;
			return N;
		}
		function k(A) {
			for (var b = 0; b < 16384; b++) (A[b] = {}), (A[b].len = 0), (A[b].lit = 0), (A[b].p = null);
		}
		const q = { l: 0, c: 0, lc: 0 };
		function B(A, b, R, U, N) {
			for (; R < A; ) (b = (b << 8) | it(U, N)), (R += 8);
			(R -= A), (q.l = (b >> R) & ((1 << A) - 1)), (q.c = b), (q.lc = R);
		}
		const W = new Array(59);
		function Q(A) {
			for (var b = 0; b <= 58; ++b) W[b] = 0;
			for (var b = 0; b < 65537; ++b) W[A[b]] += 1;
			for (var R = 0, b = 58; b > 0; --b) {
				var U = (R + W[b]) >> 1;
				(W[b] = R), (R = U);
			}
			for (var b = 0; b < 65537; ++b) {
				var N = A[b];
				N > 0 && (A[b] = N | (W[N]++ << 6));
			}
		}
		function $(A, b, R, U, N, F, te) {
			for (var ie = R, ae = 0, he = 0; N <= F; N++) {
				if (ie.value - R.value > U) return !1;
				B(6, ae, he, A, ie);
				var fe = q.l;
				if (((ae = q.c), (he = q.lc), (te[N] = fe), fe == 63)) {
					if (ie.value - R.value > U) throw 'Something wrong with hufUnpackEncTable';
					B(8, ae, he, A, ie);
					var pe = q.l + 6;
					if (((ae = q.c), (he = q.lc), N + pe > F + 1)) throw 'Something wrong with hufUnpackEncTable';
					for (; pe--; ) te[N++] = 0;
					N--;
				} else if (fe >= 59) {
					var pe = fe - 59 + 2;
					if (N + pe > F + 1) throw 'Something wrong with hufUnpackEncTable';
					for (; pe--; ) te[N++] = 0;
					N--;
				}
			}
			Q(te);
		}
		function le(A) {
			return A & 63;
		}
		function Z(A) {
			return A >> 6;
		}
		function xe(A, b, R, U) {
			for (; b <= R; b++) {
				var N = Z(A[b]),
					F = le(A[b]);
				if (N >> F) throw 'Invalid table entry';
				if (F > 14) {
					var te = U[N >> (F - 14)];
					if (te.len) throw 'Invalid table entry';
					if ((te.lit++, te.p)) {
						var ie = te.p;
						te.p = new Array(te.lit);
						for (var ae = 0; ae < te.lit - 1; ++ae) te.p[ae] = ie[ae];
					} else te.p = new Array(1);
					te.p[te.lit - 1] = b;
				} else if (F)
					for (var he = 0, ae = 1 << (14 - F); ae > 0; ae--) {
						var te = U[(N << (14 - F)) + he];
						if (te.len || te.p) throw 'Invalid table entry';
						(te.len = F), (te.lit = b), he++;
					}
			}
			return !0;
		}
		const ue = { c: 0, lc: 0 };
		function Te(A, b, R, U) {
			(A = (A << 8) | it(R, U)), (b += 8), (ue.c = A), (ue.lc = b);
		}
		const Ae = { c: 0, lc: 0 };
		function We(A, b, R, U, N, F, te, ie, ae, he) {
			if (A == b) {
				U < 8 && (Te(R, U, N, te), (R = ue.c), (U = ue.lc)), (U -= 8);
				var fe = R >> U,
					fe = new Uint8Array([fe])[0];
				if (ae.value + fe > he) return !1;
				for (var pe = ie[ae.value - 1]; fe-- > 0; ) ie[ae.value++] = pe;
			} else if (ae.value < he) ie[ae.value++] = A;
			else return !1;
			(Ae.c = R), (Ae.lc = U);
		}
		function se(A) {
			return A & 65535;
		}
		function Se(A) {
			var b = se(A);
			return b > 32767 ? b - 65536 : b;
		}
		const we = { a: 0, b: 0 };
		function X(A, b) {
			var R = Se(A),
				U = Se(b),
				N = U,
				F = R + (N & 1) + (N >> 1),
				te = F,
				ie = F - N;
			(we.a = te), (we.b = ie);
		}
		function ge(A, b) {
			var R = se(A),
				U = se(b),
				N = (R - (U >> 1)) & 65535,
				F = (U + N - 32768) & 65535;
			(we.a = F), (we.b = N);
		}
		function be(A, b, R, U, N, F, te) {
			for (var ie = te < 16384, ae = R > N ? N : R, he = 1, fe; he <= ae; ) he <<= 1;
			for (he >>= 1, fe = he, he >>= 1; he >= 1; ) {
				for (
					var pe = 0, ke = pe + F * (N - fe), Re = F * he, Oe = F * fe, qe = U * he, je = U * fe, Ge, Ue, Yt, at;
					pe <= ke;
					pe += Oe
				) {
					for (var vt = pe, Ti = pe + U * (R - fe); vt <= Ti; vt += je) {
						var Rt = vt + qe,
							on = vt + Re,
							Vt = on + qe;
						ie
							? (X(A[vt + b], A[on + b]),
							  (Ge = we.a),
							  (Yt = we.b),
							  X(A[Rt + b], A[Vt + b]),
							  (Ue = we.a),
							  (at = we.b),
							  X(Ge, Ue),
							  (A[vt + b] = we.a),
							  (A[Rt + b] = we.b),
							  X(Yt, at),
							  (A[on + b] = we.a),
							  (A[Vt + b] = we.b))
							: (ge(A[vt + b], A[on + b]),
							  (Ge = we.a),
							  (Yt = we.b),
							  ge(A[Rt + b], A[Vt + b]),
							  (Ue = we.a),
							  (at = we.b),
							  ge(Ge, Ue),
							  (A[vt + b] = we.a),
							  (A[Rt + b] = we.b),
							  ge(Yt, at),
							  (A[on + b] = we.a),
							  (A[Vt + b] = we.b));
					}
					if (R & he) {
						var on = vt + Re;
						ie ? X(A[vt + b], A[on + b]) : ge(A[vt + b], A[on + b]), (Ge = we.a), (A[on + b] = we.b), (A[vt + b] = Ge);
					}
				}
				if (N & he)
					for (var vt = pe, Ti = pe + U * (R - fe); vt <= Ti; vt += je) {
						var Rt = vt + qe;
						ie ? X(A[vt + b], A[Rt + b]) : ge(A[vt + b], A[Rt + b]), (Ge = we.a), (A[Rt + b] = we.b), (A[vt + b] = Ge);
					}
				(fe = he), (he >>= 1);
			}
			return pe;
		}
		function H(A, b, R, U, N, F, te, ie, ae, he) {
			for (var fe = 0, pe = 0, ke = ie, Re = Math.trunc(N.value + (F + 7) / 8); N.value < Re; )
				for (Te(fe, pe, R, N), fe = ue.c, pe = ue.lc; pe >= 14; ) {
					var Oe = (fe >> (pe - 14)) & 16383,
						qe = b[Oe];
					if (qe.len) (pe -= qe.len), We(qe.lit, te, fe, pe, R, U, N, ae, he, ke), (fe = Ae.c), (pe = Ae.lc);
					else {
						if (!qe.p) throw 'hufDecode issues';
						var je;
						for (je = 0; je < qe.lit; je++) {
							for (var Ge = le(A[qe.p[je]]); pe < Ge && N.value < Re; ) Te(fe, pe, R, N), (fe = ue.c), (pe = ue.lc);
							if (pe >= Ge && Z(A[qe.p[je]]) == ((fe >> (pe - Ge)) & ((1 << Ge) - 1))) {
								(pe -= Ge), We(qe.p[je], te, fe, pe, R, U, N, ae, he, ke), (fe = Ae.c), (pe = Ae.lc);
								break;
							}
						}
						if (je == qe.lit) throw 'hufDecode issues';
					}
				}
			var Ue = (8 - F) & 7;
			for (fe >>= Ue, pe -= Ue; pe > 0; ) {
				var qe = b[(fe << (14 - pe)) & 16383];
				if (qe.len) (pe -= qe.len), We(qe.lit, te, fe, pe, R, U, N, ae, he, ke), (fe = Ae.c), (pe = Ae.lc);
				else throw 'hufDecode issues';
			}
			return !0;
		}
		function Ne(A, b, R, U, N, F) {
			var te = { value: 0 },
				ie = R.value,
				ae = Ve(b, R),
				he = Ve(b, R);
			R.value += 4;
			var fe = Ve(b, R);
			if (((R.value += 4), ae < 0 || ae >= 65537 || he < 0 || he >= 65537)) throw 'Something wrong with HUF_ENCSIZE';
			var pe = new Array(65537),
				ke = new Array(16384);
			k(ke);
			var Re = U - (R.value - ie);
			if (($(A, b, R, Re, ae, he, pe), fe > 8 * (U - (R.value - ie)))) throw 'Something wrong with hufUncompress';
			xe(pe, ae, he, ke), H(pe, ke, A, b, R, fe, he, F, N, te);
		}
		function oe(A, b, R) {
			for (var U = 0; U < R; ++U) b[U] = A[b[U]];
		}
		function L(A) {
			for (var b = 1; b < A.length; b++) {
				var R = A[b - 1] + A[b] - 128;
				A[b] = R;
			}
		}
		function D(A, b) {
			for (var R = 0, U = Math.floor((A.length + 1) / 2), N = 0, F = A.length - 1; !(N > F || ((b[N++] = A[R++]), N > F)); )
				b[N++] = A[U++];
		}
		function z(A) {
			for (var b = A.byteLength, R = new Array(), U = 0, N = new DataView(A); b > 0; ) {
				var F = N.getInt8(U++);
				if (F < 0) {
					var te = -F;
					b -= te + 1;
					for (var ie = 0; ie < te; ie++) R.push(N.getUint8(U++));
				} else {
					var te = F;
					b -= 2;
					for (var ae = N.getUint8(U++), ie = 0; ie < te + 1; ie++) R.push(ae);
				}
			}
			return R;
		}
		function Y(A, b, R, U, N, F) {
			var Rt = new DataView(F.buffer),
				te = R[A.idx[0]].width,
				ie = R[A.idx[0]].height,
				ae = 3,
				he = Math.floor(te / 8),
				fe = Math.ceil(te / 8),
				pe = Math.ceil(ie / 8),
				ke = te - (fe - 1) * 8,
				Re = ie - (pe - 1) * 8,
				Oe = { value: 0 },
				qe = new Array(ae),
				je = new Array(ae),
				Ge = new Array(ae),
				Ue = new Array(ae),
				Yt = new Array(ae);
			for (let lt = 0; lt < ae; ++lt)
				(Yt[lt] = b[A.idx[lt]]),
					(qe[lt] = lt < 1 ? 0 : qe[lt - 1] + fe * pe),
					(je[lt] = new Float32Array(64)),
					(Ge[lt] = new Uint16Array(64)),
					(Ue[lt] = new Uint16Array(fe * 64));
			for (let lt = 0; lt < pe; ++lt) {
				var at = 8;
				lt == pe - 1 && (at = Re);
				var vt = 8;
				for (let Ht = 0; Ht < fe; ++Ht) {
					Ht == fe - 1 && (vt = ke);
					for (let St = 0; St < ae; ++St)
						Ge[St].fill(0), (Ge[St][0] = N[qe[St]++]), K(Oe, U, Ge[St]), re(Ge[St], je[St]), O(je[St]);
					T(je);
					for (let St = 0; St < ae; ++St) V(je[St], Ue[St], Ht * 64);
				}
				let bn = 0;
				for (let Ht = 0; Ht < ae; ++Ht) {
					const St = R[A.idx[Ht]].type;
					for (let qi = 8 * lt; qi < 8 * lt + at; ++qi) {
						bn = Yt[Ht][qi];
						for (let Do = 0; Do < he; ++Do) {
							const Ai = Do * 64 + (qi & 7) * 8;
							Rt.setUint16(bn + 0 * 2 * St, Ue[Ht][Ai + 0], !0),
								Rt.setUint16(bn + 1 * 2 * St, Ue[Ht][Ai + 1], !0),
								Rt.setUint16(bn + 2 * 2 * St, Ue[Ht][Ai + 2], !0),
								Rt.setUint16(bn + 3 * 2 * St, Ue[Ht][Ai + 3], !0),
								Rt.setUint16(bn + 4 * 2 * St, Ue[Ht][Ai + 4], !0),
								Rt.setUint16(bn + 5 * 2 * St, Ue[Ht][Ai + 5], !0),
								Rt.setUint16(bn + 6 * 2 * St, Ue[Ht][Ai + 6], !0),
								Rt.setUint16(bn + 7 * 2 * St, Ue[Ht][Ai + 7], !0),
								(bn += 8 * 2 * St);
						}
					}
					if (he != fe)
						for (let qi = 8 * lt; qi < 8 * lt + at; ++qi) {
							const Do = Yt[Ht][qi] + 8 * he * 2 * St,
								Ai = he * 64 + (qi & 7) * 8;
							for (let Cr = 0; Cr < vt; ++Cr) Rt.setUint16(Do + Cr * 2 * St, Ue[Ht][Ai + Cr], !0);
						}
				}
			}
			for (var Ti = new Uint16Array(te), Rt = new DataView(F.buffer), on = 0; on < ae; ++on) {
				R[A.idx[on]].decoded = !0;
				var Vt = R[A.idx[on]].type;
				if (R[on].type == 2)
					for (var ci = 0; ci < ie; ++ci) {
						const lt = Yt[on][ci];
						for (var Hn = 0; Hn < te; ++Hn) Ti[Hn] = Rt.getUint16(lt + Hn * 2 * Vt, !0);
						for (var Hn = 0; Hn < te; ++Hn) Rt.setFloat32(lt + Hn * 2 * Vt, J(Ti[Hn]), !0);
					}
			}
		}
		function K(A, b, R) {
			for (var U, N = 1; N < 64; )
				(U = b[A.value]), U == 65280 ? (N = 64) : U >> 8 == 255 ? (N += U & 255) : ((R[N] = U), N++), A.value++;
		}
		function re(A, b) {
			(b[0] = J(A[0])),
				(b[1] = J(A[1])),
				(b[2] = J(A[5])),
				(b[3] = J(A[6])),
				(b[4] = J(A[14])),
				(b[5] = J(A[15])),
				(b[6] = J(A[27])),
				(b[7] = J(A[28])),
				(b[8] = J(A[2])),
				(b[9] = J(A[4])),
				(b[10] = J(A[7])),
				(b[11] = J(A[13])),
				(b[12] = J(A[16])),
				(b[13] = J(A[26])),
				(b[14] = J(A[29])),
				(b[15] = J(A[42])),
				(b[16] = J(A[3])),
				(b[17] = J(A[8])),
				(b[18] = J(A[12])),
				(b[19] = J(A[17])),
				(b[20] = J(A[25])),
				(b[21] = J(A[30])),
				(b[22] = J(A[41])),
				(b[23] = J(A[43])),
				(b[24] = J(A[9])),
				(b[25] = J(A[11])),
				(b[26] = J(A[18])),
				(b[27] = J(A[24])),
				(b[28] = J(A[31])),
				(b[29] = J(A[40])),
				(b[30] = J(A[44])),
				(b[31] = J(A[53])),
				(b[32] = J(A[10])),
				(b[33] = J(A[19])),
				(b[34] = J(A[23])),
				(b[35] = J(A[32])),
				(b[36] = J(A[39])),
				(b[37] = J(A[45])),
				(b[38] = J(A[52])),
				(b[39] = J(A[54])),
				(b[40] = J(A[20])),
				(b[41] = J(A[22])),
				(b[42] = J(A[33])),
				(b[43] = J(A[38])),
				(b[44] = J(A[46])),
				(b[45] = J(A[51])),
				(b[46] = J(A[55])),
				(b[47] = J(A[60])),
				(b[48] = J(A[21])),
				(b[49] = J(A[34])),
				(b[50] = J(A[37])),
				(b[51] = J(A[47])),
				(b[52] = J(A[50])),
				(b[53] = J(A[56])),
				(b[54] = J(A[59])),
				(b[55] = J(A[61])),
				(b[56] = J(A[35])),
				(b[57] = J(A[36])),
				(b[58] = J(A[48])),
				(b[59] = J(A[49])),
				(b[60] = J(A[57])),
				(b[61] = J(A[58])),
				(b[62] = J(A[62])),
				(b[63] = J(A[63]));
		}
		function O(A) {
			const b = 0.5 * Math.cos(0.7853975),
				R = 0.5 * Math.cos(3.14159 / 16),
				U = 0.5 * Math.cos(3.14159 / 8),
				N = 0.5 * Math.cos((3 * 3.14159) / 16),
				F = 0.5 * Math.cos((5 * 3.14159) / 16),
				te = 0.5 * Math.cos((3 * 3.14159) / 8),
				ie = 0.5 * Math.cos((7 * 3.14159) / 16);
			for (var ae = new Array(4), he = new Array(4), fe = new Array(4), pe = new Array(4), ke = 0; ke < 8; ++ke) {
				var Re = ke * 8;
				(ae[0] = U * A[Re + 2]),
					(ae[1] = te * A[Re + 2]),
					(ae[2] = U * A[Re + 6]),
					(ae[3] = te * A[Re + 6]),
					(he[0] = R * A[Re + 1] + N * A[Re + 3] + F * A[Re + 5] + ie * A[Re + 7]),
					(he[1] = N * A[Re + 1] - ie * A[Re + 3] - R * A[Re + 5] - F * A[Re + 7]),
					(he[2] = F * A[Re + 1] - R * A[Re + 3] + ie * A[Re + 5] + N * A[Re + 7]),
					(he[3] = ie * A[Re + 1] - F * A[Re + 3] + N * A[Re + 5] - R * A[Re + 7]),
					(fe[0] = b * (A[Re + 0] + A[Re + 4])),
					(fe[3] = b * (A[Re + 0] - A[Re + 4])),
					(fe[1] = ae[0] + ae[3]),
					(fe[2] = ae[1] - ae[2]),
					(pe[0] = fe[0] + fe[1]),
					(pe[1] = fe[3] + fe[2]),
					(pe[2] = fe[3] - fe[2]),
					(pe[3] = fe[0] - fe[1]),
					(A[Re + 0] = pe[0] + he[0]),
					(A[Re + 1] = pe[1] + he[1]),
					(A[Re + 2] = pe[2] + he[2]),
					(A[Re + 3] = pe[3] + he[3]),
					(A[Re + 4] = pe[3] - he[3]),
					(A[Re + 5] = pe[2] - he[2]),
					(A[Re + 6] = pe[1] - he[1]),
					(A[Re + 7] = pe[0] - he[0]);
			}
			for (var Oe = 0; Oe < 8; ++Oe)
				(ae[0] = U * A[16 + Oe]),
					(ae[1] = te * A[16 + Oe]),
					(ae[2] = U * A[48 + Oe]),
					(ae[3] = te * A[48 + Oe]),
					(he[0] = R * A[8 + Oe] + N * A[24 + Oe] + F * A[40 + Oe] + ie * A[56 + Oe]),
					(he[1] = N * A[8 + Oe] - ie * A[24 + Oe] - R * A[40 + Oe] - F * A[56 + Oe]),
					(he[2] = F * A[8 + Oe] - R * A[24 + Oe] + ie * A[40 + Oe] + N * A[56 + Oe]),
					(he[3] = ie * A[8 + Oe] - F * A[24 + Oe] + N * A[40 + Oe] - R * A[56 + Oe]),
					(fe[0] = b * (A[Oe] + A[32 + Oe])),
					(fe[3] = b * (A[Oe] - A[32 + Oe])),
					(fe[1] = ae[0] + ae[3]),
					(fe[2] = ae[1] - ae[2]),
					(pe[0] = fe[0] + fe[1]),
					(pe[1] = fe[3] + fe[2]),
					(pe[2] = fe[3] - fe[2]),
					(pe[3] = fe[0] - fe[1]),
					(A[0 + Oe] = pe[0] + he[0]),
					(A[8 + Oe] = pe[1] + he[1]),
					(A[16 + Oe] = pe[2] + he[2]),
					(A[24 + Oe] = pe[3] + he[3]),
					(A[32 + Oe] = pe[3] - he[3]),
					(A[40 + Oe] = pe[2] - he[2]),
					(A[48 + Oe] = pe[1] - he[1]),
					(A[56 + Oe] = pe[0] - he[0]);
		}
		function T(A) {
			for (var b = 0; b < 64; ++b) {
				var R = A[0][b],
					U = A[1][b],
					N = A[2][b];
				(A[0][b] = R + 1.5747 * N), (A[1][b] = R - 0.1873 * U - 0.4682 * N), (A[2][b] = R + 1.8556 * U);
			}
		}
		function V(A, b, R) {
			for (var U = 0; U < 64; ++U) b[R + U] = ha.toHalfFloat(G(A[U]));
		}
		function G(A) {
			return A <= 1 ? Math.sign(A) * Math.pow(Math.abs(A), 2.2) : Math.sign(A) * Math.pow(S, Math.abs(A) - 1);
		}
		function ee(A) {
			return new DataView(A.array.buffer, A.offset.value, A.size);
		}
		function ne(A) {
			var b = A.viewer.buffer.slice(A.offset.value, A.offset.value + A.size),
				R = new Uint8Array(z(b)),
				U = new Uint8Array(R.length);
			return L(R), D(R, U), new DataView(U.buffer);
		}
		function _e(A) {
			var b = A.array.slice(A.offset.value, A.offset.value + A.size),
				R = bd(b),
				U = new Uint8Array(R.length);
			return L(R), D(R, U), new DataView(U.buffer);
		}
		function me(A) {
			for (
				var b = A.viewer,
					R = { value: A.offset.value },
					U = new Uint16Array(A.width * A.scanlineBlockSize * (A.channels * A.type)),
					N = new Uint8Array(8192),
					F = 0,
					te = new Array(A.channels),
					ie = 0;
				ie < A.channels;
				ie++
			)
				(te[ie] = {}),
					(te[ie].start = F),
					(te[ie].end = te[ie].start),
					(te[ie].nx = A.width),
					(te[ie].ny = A.lines),
					(te[ie].size = A.type),
					(F += te[ie].nx * te[ie].ny * te[ie].size);
			var ae = Ce(b, R),
				he = Ce(b, R);
			if (he >= 8192) throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';
			if (ae <= he) for (var ie = 0; ie < he - ae + 1; ie++) N[ie + ae] = Qe(b, R);
			var fe = new Uint16Array(65536),
				pe = M(N, fe),
				ke = Ve(b, R);
			Ne(A.array, b, R, ke, U, F);
			for (var ie = 0; ie < A.channels; ++ie)
				for (var Re = te[ie], Oe = 0; Oe < te[ie].size; ++Oe) be(U, Re.start + Oe, Re.nx, Re.size, Re.ny, Re.nx * Re.size, pe);
			oe(fe, U, F);
			for (var qe = 0, je = new Uint8Array(U.buffer.byteLength), Ge = 0; Ge < A.lines; Ge++)
				for (var Ue = 0; Ue < A.channels; Ue++) {
					var Re = te[Ue],
						Yt = Re.nx * Re.size,
						at = new Uint8Array(U.buffer, Re.end * 2, Yt * 2);
					je.set(at, qe), (qe += Yt * 2), (Re.end += Yt);
				}
			return new DataView(je.buffer);
		}
		function ye(A) {
			var b = A.array.slice(A.offset.value, A.offset.value + A.size),
				R = bd(b);
			const U = A.lines * A.channels * A.width,
				N = A.type == 1 ? new Uint16Array(U) : new Uint32Array(U);
			let F = 0,
				te = 0;
			const ie = new Array(4);
			for (let ae = 0; ae < A.lines; ae++)
				for (let he = 0; he < A.channels; he++) {
					let fe = 0;
					switch (A.type) {
						case 1:
							(ie[0] = F), (ie[1] = ie[0] + A.width), (F = ie[1] + A.width);
							for (let pe = 0; pe < A.width; ++pe) {
								const ke = (R[ie[0]++] << 8) | R[ie[1]++];
								(fe += ke), (N[te] = fe), te++;
							}
							break;
						case 2:
							(ie[0] = F), (ie[1] = ie[0] + A.width), (ie[2] = ie[1] + A.width), (F = ie[2] + A.width);
							for (let pe = 0; pe < A.width; ++pe) {
								const ke = (R[ie[0]++] << 24) | (R[ie[1]++] << 16) | (R[ie[2]++] << 8);
								(fe += ke), (N[te] = fe), te++;
							}
							break;
					}
				}
			return new DataView(N.buffer);
		}
		function De(A) {
			var b = A.viewer,
				R = { value: A.offset.value },
				U = new Uint8Array(A.width * A.lines * (A.channels * A.type * 2)),
				N = {
					version: Be(b, R),
					unknownUncompressedSize: Be(b, R),
					unknownCompressedSize: Be(b, R),
					acCompressedSize: Be(b, R),
					dcCompressedSize: Be(b, R),
					rleCompressedSize: Be(b, R),
					rleUncompressedSize: Be(b, R),
					rleRawSize: Be(b, R),
					totalAcUncompressedCount: Be(b, R),
					totalDcUncompressedCount: Be(b, R),
					acCompression: Be(b, R),
				};
			if (N.version < 2) throw 'EXRLoader.parse: ' + Ar.compression + ' version ' + N.version + ' is unsupported';
			for (var F = new Array(), te = Ce(b, R) - 2; te > 0; ) {
				var ie = ve(b.buffer, R),
					ae = Qe(b, R),
					he = (ae >> 2) & 3,
					fe = (ae >> 4) - 1,
					pe = new Int8Array([fe])[0],
					ke = Qe(b, R);
				F.push({ name: ie, index: pe, type: ke, compression: he }), (te -= ie.length + 3);
			}
			for (var Re = Ar.channels, Oe = new Array(A.channels), qe = 0; qe < A.channels; ++qe) {
				var je = (Oe[qe] = {}),
					Ge = Re[qe];
				(je.name = Ge.name),
					(je.compression = 0),
					(je.decoded = !1),
					(je.type = Ge.pixelType),
					(je.pLinear = Ge.pLinear),
					(je.width = A.width),
					(je.height = A.lines);
			}
			for (var Ue = { idx: new Array(3) }, Yt = 0; Yt < A.channels; ++Yt)
				for (var je = Oe[Yt], qe = 0; qe < F.length; ++qe) {
					var at = F[qe];
					je.name == at.name && ((je.compression = at.compression), at.index >= 0 && (Ue.idx[at.index] = Yt), (je.offset = Yt));
				}
			if (N.acCompressedSize > 0)
				switch (N.acCompression) {
					case 0:
						var Rt = new Uint16Array(N.totalAcUncompressedCount);
						Ne(A.array, b, R, N.acCompressedSize, Rt, N.totalAcUncompressedCount);
						break;
					case 1:
						var vt = A.array.slice(R.value, R.value + N.totalAcUncompressedCount),
							Ti = bd(vt),
							Rt = new Uint16Array(Ti.buffer);
						R.value += N.totalAcUncompressedCount;
						break;
				}
			if (N.dcCompressedSize > 0) {
				var on = { array: A.array, offset: R, size: N.dcCompressedSize },
					Vt = new Uint16Array(_e(on).buffer);
				R.value += N.dcCompressedSize;
			}
			if (N.rleRawSize > 0) {
				var vt = A.array.slice(R.value, R.value + N.rleCompressedSize),
					Ti = bd(vt),
					ci = z(Ti.buffer);
				R.value += N.rleCompressedSize;
			}
			for (var Hn = 0, lt = new Array(Oe.length), qe = 0; qe < lt.length; ++qe) lt[qe] = new Array();
			for (var bn = 0; bn < A.lines; ++bn) for (var Ht = 0; Ht < Oe.length; ++Ht) lt[Ht].push(Hn), (Hn += Oe[Ht].width * A.type * 2);
			Y(Ue, lt, Oe, Rt, Vt, U);
			for (var qe = 0; qe < Oe.length; ++qe) {
				var je = Oe[qe];
				if (!je.decoded)
					switch (je.compression) {
						case 2:
							for (var St = 0, qi = 0, bn = 0; bn < A.lines; ++bn) {
								for (var Do = lt[qe][St], Ai = 0; Ai < je.width; ++Ai) {
									for (var Cr = 0; Cr < 2 * je.type; ++Cr) U[Do++] = ci[qi + Cr * je.width * je.height];
									qi++;
								}
								St++;
							}
							break;
						case 1:
						default:
							throw 'EXRLoader.parse: unsupported channel compression';
					}
			}
			return new DataView(U.buffer);
		}
		function ve(A, b) {
			for (var R = new Uint8Array(A), U = 0; R[b.value + U] != 0; ) U += 1;
			var N = new TextDecoder().decode(R.slice(b.value, b.value + U));
			return (b.value = b.value + U + 1), N;
		}
		function Le(A, b, R) {
			var U = new TextDecoder().decode(new Uint8Array(A).slice(b.value, b.value + R));
			return (b.value = b.value + R), U;
		}
		function Ye(A, b) {
			var R = Ie(A, b),
				U = Ve(A, b);
			return [R, U];
		}
		function Xe(A, b) {
			var R = Ve(A, b),
				U = Ve(A, b);
			return [R, U];
		}
		function Ie(A, b) {
			var R = A.getInt32(b.value, !0);
			return (b.value = b.value + 4), R;
		}
		function Ve(A, b) {
			var R = A.getUint32(b.value, !0);
			return (b.value = b.value + 4), R;
		}
		function it(A, b) {
			var R = A[b.value];
			return (b.value = b.value + 1), R;
		}
		function Qe(A, b) {
			var R = A.getUint8(b.value);
			return (b.value = b.value + 1), R;
		}
		const Be = function (A, b) {
			let R;
			return (
				'getBigInt64' in DataView.prototype
					? (R = Number(A.getBigInt64(b.value, !0)))
					: (R = A.getUint32(b.value + 4, !0) + Number(A.getUint32(b.value, !0) << 32)),
				(b.value += 8),
				R
			);
		};
		function j(A, b) {
			var R = A.getFloat32(b.value, !0);
			return (b.value += 4), R;
		}
		function Me(A, b) {
			return ha.toHalfFloat(j(A, b));
		}
		function J(A) {
			var b = (A & 31744) >> 10,
				R = A & 1023;
			return (
				(A >> 15 ? -1 : 1) *
				(b ? (b === 31 ? (R ? NaN : 1 / 0) : Math.pow(2, b - 15) * (1 + R / 1024)) : 6103515625e-14 * (R / 1024))
			);
		}
		function Ce(A, b) {
			var R = A.getUint16(b.value, !0);
			return (b.value += 2), R;
		}
		function Fe(A, b) {
			return J(Ce(A, b));
		}
		function gt(A, b, R, U) {
			for (var N = R.value, F = []; R.value < N + U - 1; ) {
				var te = ve(b, R),
					ie = Ie(A, R),
					ae = Qe(A, R);
				R.value += 3;
				var he = Ie(A, R),
					fe = Ie(A, R);
				F.push({ name: te, pixelType: ie, pLinear: ae, xSampling: he, ySampling: fe });
			}
			return (R.value += 1), F;
		}
		function Bt(A, b) {
			var R = j(A, b),
				U = j(A, b),
				N = j(A, b),
				F = j(A, b),
				te = j(A, b),
				ie = j(A, b),
				ae = j(A, b),
				he = j(A, b);
			return { redX: R, redY: U, greenX: N, greenY: F, blueX: te, blueY: ie, whiteX: ae, whiteY: he };
		}
		function Kt(A, b) {
			var R = [
					'NO_COMPRESSION',
					'RLE_COMPRESSION',
					'ZIPS_COMPRESSION',
					'ZIP_COMPRESSION',
					'PIZ_COMPRESSION',
					'PXR24_COMPRESSION',
					'B44_COMPRESSION',
					'B44A_COMPRESSION',
					'DWAA_COMPRESSION',
					'DWAB_COMPRESSION',
				],
				U = Qe(A, b);
			return R[U];
		}
		function Pn(A, b) {
			var R = Ve(A, b),
				U = Ve(A, b),
				N = Ve(A, b),
				F = Ve(A, b);
			return { xMin: R, yMin: U, xMax: N, yMax: F };
		}
		function Ct(A, b) {
			var R = ['INCREASING_Y'],
				U = Qe(A, b);
			return R[U];
		}
		function Xi(A, b) {
			var R = j(A, b),
				U = j(A, b);
			return [R, U];
		}
		function Nn(A, b) {
			var R = j(A, b),
				U = j(A, b),
				N = j(A, b);
			return [R, U, N];
		}
		function _u(A, b, R, U, N) {
			if (U === 'string' || U === 'stringvector' || U === 'iccProfile') return Le(b, R, N);
			if (U === 'chlist') return gt(A, b, R, N);
			if (U === 'chromaticities') return Bt(A, R);
			if (U === 'compression') return Kt(A, R);
			if (U === 'box2i') return Pn(A, R);
			if (U === 'lineOrder') return Ct(A, R);
			if (U === 'float') return j(A, R);
			if (U === 'v2f') return Xi(A, R);
			if (U === 'v3f') return Nn(A, R);
			if (U === 'int') return Ie(A, R);
			if (U === 'rational') return Ye(A, R);
			if (U === 'timecode') return Xe(A, R);
			if (U === 'preview') return (R.value += N), 'skipped';
			R.value += N;
		}
		function yu(A, b, R) {
			const U = {};
			if (A.getUint32(0, !0) != 20000630) throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
			U.version = A.getUint8(4);
			const N = A.getUint8(5);
			(U.spec = { singleTile: !!(N & 2), longName: !!(N & 4), deepFormat: !!(N & 8), multiPart: !!(N & 16) }), (R.value = 8);
			for (var F = !0; F; ) {
				var te = ve(b, R);
				if (te == 0) F = !1;
				else {
					var ie = ve(b, R),
						ae = Ve(A, R),
						he = _u(A, b, R, ie, ae);
					he === void 0
						? console.warn("EXRLoader.parse: skipped unknown header attribute type '".concat(ie, "'."))
						: (U[te] = he);
				}
			}
			if (N & -5) throw (console.error('EXRHeader:', U), 'THREE.EXRLoader: provided file is currently unsupported.');
			return U;
		}
		function xu(A, b, R, U, N) {
			const F = {
				size: 0,
				viewer: b,
				array: R,
				offset: U,
				width: A.dataWindow.xMax - A.dataWindow.xMin + 1,
				height: A.dataWindow.yMax - A.dataWindow.yMin + 1,
				channels: A.channels.length,
				bytesPerLine: null,
				lines: null,
				inputSize: null,
				type: A.channels[0].pixelType,
				uncompress: null,
				getter: null,
				format: null,
				[Ic ? 'colorSpace' : 'encoding']: null,
			};
			switch (A.compression) {
				case 'NO_COMPRESSION':
					(F.lines = 1), (F.uncompress = ee);
					break;
				case 'RLE_COMPRESSION':
					(F.lines = 1), (F.uncompress = ne);
					break;
				case 'ZIPS_COMPRESSION':
					(F.lines = 1), (F.uncompress = _e);
					break;
				case 'ZIP_COMPRESSION':
					(F.lines = 16), (F.uncompress = _e);
					break;
				case 'PIZ_COMPRESSION':
					(F.lines = 32), (F.uncompress = me);
					break;
				case 'PXR24_COMPRESSION':
					(F.lines = 16), (F.uncompress = ye);
					break;
				case 'DWAA_COMPRESSION':
					(F.lines = 32), (F.uncompress = De);
					break;
				case 'DWAB_COMPRESSION':
					(F.lines = 256), (F.uncompress = De);
					break;
				default:
					throw 'EXRLoader.parse: ' + A.compression + ' is unsupported';
			}
			if (((F.scanlineBlockSize = F.lines), F.type == 1))
				switch (N) {
					case On:
						(F.getter = Fe), (F.inputSize = 2);
						break;
					case fi:
						(F.getter = Ce), (F.inputSize = 2);
						break;
				}
			else if (F.type == 2)
				switch (N) {
					case On:
						(F.getter = j), (F.inputSize = 4);
						break;
					case fi:
						(F.getter = Me), (F.inputSize = 4);
				}
			else throw 'EXRLoader.parse: unsupported pixelType ' + F.type + ' for ' + A.compression + '.';
			F.blockCount = (A.dataWindow.yMax + 1) / F.scanlineBlockSize;
			for (var te = 0; te < F.blockCount; te++) Be(b, U);
			F.outputChannels = F.channels == 3 ? 4 : F.channels;
			const ie = F.width * F.height * F.outputChannels;
			switch (N) {
				case On:
					(F.byteArray = new Float32Array(ie)), F.channels < F.outputChannels && F.byteArray.fill(1, 0, ie);
					break;
				case fi:
					(F.byteArray = new Uint16Array(ie)), F.channels < F.outputChannels && F.byteArray.fill(15360, 0, ie);
					break;
				default:
					console.error('THREE.EXRLoader: unsupported type: ', N);
					break;
			}
			return (
				(F.bytesPerLine = F.width * F.inputSize * F.channels),
				F.outputChannels == 4 ? (F.format = mi) : (F.format = Bp),
				Ic ? (F.colorSpace = 'srgb-linear') : (F.encoding = 3e3),
				F
			);
		}
		const Js = new DataView(e),
			bu = new Uint8Array(e),
			Rs = { value: 0 },
			Ar = yu(Js, e, Rs),
			dt = xu(Ar, Js, bu, Rs, this.type),
			wu = { value: 0 },
			Af = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
		for (let A = 0; A < dt.height / dt.scanlineBlockSize; A++) {
			const b = Ve(Js, Rs);
			(dt.size = Ve(Js, Rs)), (dt.lines = b + dt.scanlineBlockSize > dt.height ? dt.height - b : dt.scanlineBlockSize);
			const U = dt.size < dt.lines * dt.bytesPerLine ? dt.uncompress(dt) : ee(dt);
			Rs.value += dt.size;
			for (let N = 0; N < dt.scanlineBlockSize; N++) {
				const F = N + A * dt.scanlineBlockSize;
				if (F >= dt.height) break;
				for (let te = 0; te < dt.channels; te++) {
					const ie = Af[Ar.channels[te].name];
					for (let ae = 0; ae < dt.width; ae++) {
						wu.value = (N * (dt.channels * dt.width) + te * dt.width + ae) * dt.inputSize;
						const he = (dt.height - 1 - F) * (dt.width * dt.outputChannels) + ae * dt.outputChannels + ie;
						dt.byteArray[he] = dt.getter(U, wu);
					}
				}
			}
		}
		return {
			header: Ar,
			width: dt.width,
			height: dt.height,
			data: dt.byteArray,
			format: dt.format,
			[Ic ? 'colorSpace' : 'encoding']: dt[Ic ? 'colorSpace' : 'encoding'],
			type: this.type,
		};
	}
	setDataType(e) {
		return (this.type = e), this;
	}
	load(e, t, n, s) {
		function r(o, a) {
			Ic ? (o.colorSpace = a.colorSpace) : (o.encoding = a.encoding),
				(o.minFilter = Tt),
				(o.magFilter = Tt),
				(o.generateMipmaps = !1),
				(o.flipY = !1),
				t && t(o, a);
		}
		return super.load(e, r, n, s);
	}
}
const Rm = new WeakMap();
class ZF extends Qn {
	constructor(e) {
		super(e),
			(this.decoderPath = ''),
			(this.decoderConfig = {}),
			(this.decoderBinary = null),
			(this.decoderPending = null),
			(this.workerLimit = 4),
			(this.workerPool = []),
			(this.workerNextTaskID = 1),
			(this.workerSourceURL = ''),
			(this.defaultAttributeIDs = { position: 'POSITION', normal: 'NORMAL', color: 'COLOR', uv: 'TEX_COORD' }),
			(this.defaultAttributeTypes = { position: 'Float32Array', normal: 'Float32Array', color: 'Float32Array', uv: 'Float32Array' });
	}
	setDecoderPath(e) {
		return (this.decoderPath = e), this;
	}
	setDecoderConfig(e) {
		return (this.decoderConfig = e), this;
	}
	setWorkerLimit(e) {
		return (this.workerLimit = e), this;
	}
	load(e, t, n, s) {
		const r = new Si(this.manager);
		r.setPath(this.path),
			r.setResponseType('arraybuffer'),
			r.setRequestHeader(this.requestHeader),
			r.setWithCredentials(this.withCredentials),
			r.load(
				e,
				(o) => {
					const a = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 };
					this.decodeGeometry(o, a).then(t).catch(s);
				},
				n,
				s
			);
	}
	decodeDracoFile(e, t, n, s) {
		const r = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: s || this.defaultAttributeTypes, useUniqueIDs: !!n };
		this.decodeGeometry(e, r).then(t);
	}
	decodeGeometry(e, t) {
		for (const l in t.attributeTypes) {
			const c = t.attributeTypes[l];
			c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
		}
		const n = JSON.stringify(t);
		if (Rm.has(e)) {
			const l = Rm.get(e);
			if (l.key === n) return l.promise;
			if (e.byteLength === 0)
				throw new Error(
					'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.'
				);
		}
		let s;
		const r = this.workerNextTaskID++,
			o = e.byteLength,
			a = this._getWorker(r, o)
				.then(
					(l) => (
						(s = l),
						new Promise((c, h) => {
							(s._callbacks[r] = { resolve: c, reject: h }),
								s.postMessage({ type: 'decode', id: r, taskConfig: t, buffer: e }, [e]);
						})
					)
				)
				.then((l) => this._createGeometry(l.geometry));
		return (
			a
				.catch(() => !0)
				.then(() => {
					s && r && this._releaseTask(s, r);
				}),
			Rm.set(e, { key: n, promise: a }),
			a
		);
	}
	_createGeometry(e) {
		const t = new Ze();
		e.index && t.setIndex(new $e(e.index.array, 1));
		for (let n = 0; n < e.attributes.length; n++) {
			const s = e.attributes[n],
				r = s.name,
				o = s.array,
				a = s.itemSize;
			t.setAttribute(r, new $e(o, a));
		}
		return t;
	}
	_loadLibrary(e, t) {
		const n = new Si(this.manager);
		return (
			n.setPath(this.decoderPath),
			n.setResponseType(t),
			n.setWithCredentials(this.withCredentials),
			new Promise((s, r) => {
				n.load(e, s, void 0, r);
			})
		);
	}
	preload() {
		return this._initDecoder(), this;
	}
	_initDecoder() {
		if (this.decoderPending) return this.decoderPending;
		const e = typeof WebAssembly != 'object' || this.decoderConfig.type === 'js',
			t = [];
		return (
			e
				? t.push(this._loadLibrary('draco_decoder.js', 'text'))
				: (t.push(this._loadLibrary('draco_wasm_wrapper.js', 'text')),
				  t.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))),
			(this.decoderPending = Promise.all(t).then((n) => {
				const s = n[0];
				e || (this.decoderConfig.wasmBinary = n[1]);
				const r = JF.toString(),
					o = ['/* draco decoder */', s, '', '/* worker */', r.substring(r.indexOf('{') + 1, r.lastIndexOf('}'))].join('\n');
				this.workerSourceURL = URL.createObjectURL(new Blob([o]));
			})),
			this.decoderPending
		);
	}
	_getWorker(e, t) {
		return this._initDecoder().then(() => {
			if (this.workerPool.length < this.workerLimit) {
				const s = new Worker(this.workerSourceURL);
				(s._callbacks = {}),
					(s._taskCosts = {}),
					(s._taskLoad = 0),
					s.postMessage({ type: 'init', decoderConfig: this.decoderConfig }),
					(s.onmessage = function (r) {
						const o = r.data;
						switch (o.type) {
							case 'decode':
								s._callbacks[o.id].resolve(o);
								break;
							case 'error':
								s._callbacks[o.id].reject(o);
								break;
							default:
								console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
						}
					}),
					this.workerPool.push(s);
			} else
				this.workerPool.sort(function (s, r) {
					return s._taskLoad > r._taskLoad ? -1 : 1;
				});
			const n = this.workerPool[this.workerPool.length - 1];
			return (n._taskCosts[e] = t), (n._taskLoad += t), n;
		});
	}
	_releaseTask(e, t) {
		(e._taskLoad -= e._taskCosts[t]), delete e._callbacks[t], delete e._taskCosts[t];
	}
	debug() {
		console.log(
			'Task load: ',
			this.workerPool.map((e) => e._taskLoad)
		);
	}
	dispose() {
		for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
		return (this.workerPool.length = 0), this;
	}
}
function JF() {
	let i, e;
	onmessage = function (o) {
		const a = o.data;
		switch (a.type) {
			case 'init':
				(i = a.decoderConfig),
					(e = new Promise(function (h) {
						(i.onModuleLoaded = function (u) {
							h({ draco: u });
						}),
							DracoDecoderModule(i);
					}));
				break;
			case 'decode':
				const l = a.buffer,
					c = a.taskConfig;
				e.then((h) => {
					const u = h.draco,
						d = new u.Decoder(),
						p = new u.DecoderBuffer();
					p.Init(new Int8Array(l), l.byteLength);
					try {
						const g = t(u, d, p, c),
							v = g.attributes.map((m) => m.array.buffer);
						g.index && v.push(g.index.array.buffer), self.postMessage({ type: 'decode', id: a.id, geometry: g }, v);
					} catch (g) {
						console.error(g), self.postMessage({ type: 'error', id: a.id, error: g.message });
					} finally {
						u.destroy(p), u.destroy(d);
					}
				});
				break;
		}
	};
	function t(o, a, l, c) {
		const h = c.attributeIDs,
			u = c.attributeTypes;
		let d, p;
		const g = a.GetEncodedGeometryType(l);
		if (g === o.TRIANGULAR_MESH) (d = new o.Mesh()), (p = a.DecodeBufferToMesh(l, d));
		else if (g === o.POINT_CLOUD) (d = new o.PointCloud()), (p = a.DecodeBufferToPointCloud(l, d));
		else throw new Error('THREE.DRACOLoader: Unexpected geometry type.');
		if (!p.ok() || d.ptr === 0) throw new Error('THREE.DRACOLoader: Decoding failed: ' + p.error_msg());
		const v = { index: null, attributes: [] };
		for (const m in h) {
			const f = self[u[m]];
			let y, _;
			if (c.useUniqueIDs) (_ = h[m]), (y = a.GetAttributeByUniqueId(d, _));
			else {
				if (((_ = a.GetAttributeId(d, o[h[m]])), _ === -1)) continue;
				y = a.GetAttribute(d, _);
			}
			v.attributes.push(s(o, a, d, m, f, y));
		}
		return g === o.TRIANGULAR_MESH && (v.index = n(o, a, d)), o.destroy(d), v;
	}
	function n(o, a, l) {
		const h = l.num_faces() * 3,
			u = h * 4,
			d = o._malloc(u);
		a.GetTrianglesUInt32Array(l, u, d);
		const p = new Uint32Array(o.HEAPF32.buffer, d, h).slice();
		return o._free(d), { array: p, itemSize: 1 };
	}
	function s(o, a, l, c, h, u) {
		const d = u.num_components(),
			g = l.num_points() * d,
			v = g * h.BYTES_PER_ELEMENT,
			m = r(o, h),
			f = o._malloc(v);
		a.GetAttributeDataArrayForAllPoints(l, u, m, v, f);
		const y = new h(o.HEAPF32.buffer, f, g).slice();
		return o._free(f), { name: c, array: y, itemSize: d };
	}
	function r(o, a) {
		switch (a) {
			case Float32Array:
				return o.DT_FLOAT32;
			case Int8Array:
				return o.DT_INT8;
			case Int16Array:
				return o.DT_INT16;
			case Int32Array:
				return o.DT_INT32;
			case Uint8Array:
				return o.DT_UINT8;
			case Uint16Array:
				return o.DT_UINT16;
			case Uint32Array:
				return o.DT_UINT32;
		}
	}
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */ const Qt = { LEFT: 1, RIGHT: 2, MIDDLE: 4 },
	de = Object.freeze({
		NONE: 0,
		ROTATE: 1,
		TRUCK: 2,
		OFFSET: 4,
		DOLLY: 8,
		ZOOM: 16,
		TOUCH_ROTATE: 32,
		TOUCH_TRUCK: 64,
		TOUCH_OFFSET: 128,
		TOUCH_DOLLY: 256,
		TOUCH_ZOOM: 512,
		TOUCH_DOLLY_TRUCK: 1024,
		TOUCH_DOLLY_OFFSET: 2048,
		TOUCH_DOLLY_ROTATE: 4096,
		TOUCH_ZOOM_TRUCK: 8192,
		TOUCH_ZOOM_OFFSET: 16384,
		TOUCH_ZOOM_ROTATE: 32768,
	}),
	_l = { NONE: 0, IN: 1, OUT: -1 };
function Ko(i) {
	return i.isPerspectiveCamera;
}
function Yr(i) {
	return i.isOrthographicCamera;
}
const yl = Math.PI * 2,
	Ub = Math.PI / 2,
	bT = 1e-5,
	Dc = Math.PI / 180;
function ms(i, e, t) {
	return Math.max(e, Math.min(t, i));
}
function Gt(i, e = bT) {
	return Math.abs(i) < e;
}
function Lt(i, e, t = bT) {
	return Gt(i - e, t);
}
function Nb(i, e) {
	return Math.round(i / e) * e;
}
function Oc(i) {
	return isFinite(i) ? i : i < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Uc(i) {
	return Math.abs(i) < Number.MAX_VALUE ? i : i * (1 / 0);
}
function wd(i, e, t, n, s = 1 / 0, r) {
	n = Math.max(1e-4, n);
	const o = 2 / n,
		a = o * r,
		l = 1 / (1 + a + 0.48 * a * a + 0.235 * a * a * a);
	let c = i - e;
	const h = e,
		u = s * n;
	(c = ms(c, -u, u)), (e = i - c);
	const d = (t.value + o * c) * r;
	t.value = (t.value - o * d) * l;
	let p = e + (c + d) * l;
	return h - i > 0 == p > h && ((p = h), (t.value = (p - h) / r)), p;
}
function Fb(i, e, t, n, s = 1 / 0, r, o) {
	n = Math.max(1e-4, n);
	const a = 2 / n,
		l = a * r,
		c = 1 / (1 + l + 0.48 * l * l + 0.235 * l * l * l);
	let h = e.x,
		u = e.y,
		d = e.z,
		p = i.x - h,
		g = i.y - u,
		v = i.z - d;
	const m = h,
		f = u,
		y = d,
		_ = s * n,
		x = _ * _,
		E = p * p + g * g + v * v;
	if (E > x) {
		const Q = Math.sqrt(E);
		(p = (p / Q) * _), (g = (g / Q) * _), (v = (v / Q) * _);
	}
	(h = i.x - p), (u = i.y - g), (d = i.z - v);
	const w = (t.x + a * p) * r,
		C = (t.y + a * g) * r,
		P = (t.z + a * v) * r;
	(t.x = (t.x - a * w) * c),
		(t.y = (t.y - a * C) * c),
		(t.z = (t.z - a * P) * c),
		(o.x = h + (p + w) * c),
		(o.y = u + (g + C) * c),
		(o.z = d + (v + P) * c);
	const S = m - i.x,
		M = f - i.y,
		k = y - i.z,
		q = o.x - m,
		B = o.y - f,
		W = o.z - y;
	return (
		S * q + M * B + k * W > 0 && ((o.x = m), (o.y = f), (o.z = y), (t.x = (o.x - m) / r), (t.y = (o.y - f) / r), (t.z = (o.z - y) / r)),
		o
	);
}
function Pm(i, e) {
	e.set(0, 0),
		i.forEach((t) => {
			(e.x += t.clientX), (e.y += t.clientY);
		}),
		(e.x /= i.length),
		(e.y /= i.length);
}
function Lm(i, e) {
	return Yr(i) ? (console.warn(''.concat(e, ' is not supported in OrthographicCamera')), !0) : !1;
}
class QF {
	constructor() {
		this._listeners = {};
	}
	addEventListener(e, t) {
		const n = this._listeners;
		n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
	}
	hasEventListener(e, t) {
		const n = this._listeners;
		return n[e] !== void 0 && n[e].indexOf(t) !== -1;
	}
	removeEventListener(e, t) {
		const s = this._listeners[e];
		if (s !== void 0) {
			const r = s.indexOf(t);
			r !== -1 && s.splice(r, 1);
		}
	}
	removeAllEventListeners(e) {
		if (!e) {
			this._listeners = {};
			return;
		}
		Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
	}
	dispatchEvent(e) {
		const n = this._listeners[e.type];
		if (n !== void 0) {
			e.target = this;
			const s = n.slice(0);
			for (let r = 0, o = s.length; r < o; r++) s[r].call(this, e);
		}
	}
}
var Im;
const eB = '2.9.0',
	Sd = 1 / 8,
	tB = /Mac/.test((Im = globalThis == null ? void 0 : globalThis.navigator) === null || Im === void 0 ? void 0 : Im.platform);
let Ke, Bb, Md, Dm, hi, st, Mt, xl, Nc, Is, Ds, $o, kb, zb, ji, Fc, bl, Vb, Om, Hb, Um, Nm, Ed;
class Oh extends QF {
	static install(e) {
		(Ke = e.THREE),
			(Bb = Object.freeze(new Ke.Vector3(0, 0, 0))),
			(Md = Object.freeze(new Ke.Vector3(0, 1, 0))),
			(Dm = Object.freeze(new Ke.Vector3(0, 0, 1))),
			(hi = new Ke.Vector2()),
			(st = new Ke.Vector3()),
			(Mt = new Ke.Vector3()),
			(xl = new Ke.Vector3()),
			(Nc = new Ke.Vector3()),
			(Is = new Ke.Vector3()),
			(Ds = new Ke.Vector3()),
			($o = new Ke.Vector3()),
			(kb = new Ke.Vector3()),
			(zb = new Ke.Vector3()),
			(ji = new Ke.Spherical()),
			(Fc = new Ke.Spherical()),
			(bl = new Ke.Box3()),
			(Vb = new Ke.Box3()),
			(Om = new Ke.Sphere()),
			(Hb = new Ke.Quaternion()),
			(Um = new Ke.Quaternion()),
			(Nm = new Ke.Matrix4()),
			(Ed = new Ke.Raycaster());
	}
	static get ACTION() {
		return de;
	}
	constructor(e, t) {
		super(),
			(this.minPolarAngle = 0),
			(this.maxPolarAngle = Math.PI),
			(this.minAzimuthAngle = -1 / 0),
			(this.maxAzimuthAngle = 1 / 0),
			(this.minDistance = Number.EPSILON),
			(this.maxDistance = 1 / 0),
			(this.infinityDolly = !1),
			(this.minZoom = 0.01),
			(this.maxZoom = 1 / 0),
			(this.smoothTime = 0.25),
			(this.draggingSmoothTime = 0.125),
			(this.maxSpeed = 1 / 0),
			(this.azimuthRotateSpeed = 1),
			(this.polarRotateSpeed = 1),
			(this.dollySpeed = 1),
			(this.dollyDragInverted = !1),
			(this.truckSpeed = 2),
			(this.dollyToCursor = !1),
			(this.dragToOffset = !1),
			(this.verticalDragToForward = !1),
			(this.boundaryFriction = 0),
			(this.restThreshold = 0.01),
			(this.colliderMeshes = []),
			(this.cancel = () => {}),
			(this._enabled = !0),
			(this._state = de.NONE),
			(this._viewport = null),
			(this._changedDolly = 0),
			(this._changedZoom = 0),
			(this._hasRested = !0),
			(this._boundaryEnclosesCamera = !1),
			(this._needsUpdate = !0),
			(this._updatedLastTime = !1),
			(this._elementRect = new DOMRect()),
			(this._isDragging = !1),
			(this._dragNeedsUpdate = !0),
			(this._activePointers = []),
			(this._lockedPointer = null),
			(this._interactiveArea = new DOMRect(0, 0, 1, 1)),
			(this._isUserControllingRotate = !1),
			(this._isUserControllingDolly = !1),
			(this._isUserControllingTruck = !1),
			(this._isUserControllingOffset = !1),
			(this._isUserControllingZoom = !1),
			(this._lastDollyDirection = _l.NONE),
			(this._thetaVelocity = { value: 0 }),
			(this._phiVelocity = { value: 0 }),
			(this._radiusVelocity = { value: 0 }),
			(this._targetVelocity = new Ke.Vector3()),
			(this._focalOffsetVelocity = new Ke.Vector3()),
			(this._zoomVelocity = { value: 0 }),
			(this._truckInternal = (f, y, _) => {
				let x, E;
				if (Ko(this._camera)) {
					const w = st.copy(this._camera.position).sub(this._target),
						C = this._camera.getEffectiveFOV() * Dc,
						P = w.length() * Math.tan(C * 0.5);
					(x = (this.truckSpeed * f * P) / this._elementRect.height), (E = (this.truckSpeed * y * P) / this._elementRect.height);
				} else if (Yr(this._camera)) {
					const w = this._camera;
					(x = (f * (w.right - w.left)) / w.zoom / this._elementRect.width),
						(E = (y * (w.top - w.bottom)) / w.zoom / this._elementRect.height);
				} else return;
				this.verticalDragToForward
					? (_
							? this.setFocalOffset(this._focalOffsetEnd.x + x, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0)
							: this.truck(x, 0, !0),
					  this.forward(-E, !0))
					: _
					? this.setFocalOffset(this._focalOffsetEnd.x + x, this._focalOffsetEnd.y + E, this._focalOffsetEnd.z, !0)
					: this.truck(x, E, !0);
			}),
			(this._rotateInternal = (f, y) => {
				const _ = (yl * this.azimuthRotateSpeed * f) / this._elementRect.height,
					x = (yl * this.polarRotateSpeed * y) / this._elementRect.height;
				this.rotate(_, x, !0);
			}),
			(this._dollyInternal = (f, y, _) => {
				const x = Math.pow(0.95, -f * this.dollySpeed),
					E = this._sphericalEnd.radius,
					w = this._sphericalEnd.radius * x,
					C = ms(w, this.minDistance, this.maxDistance),
					P = C - w;
				this.infinityDolly && this.dollyToCursor
					? this._dollyToNoClamp(w, !0)
					: this.infinityDolly && !this.dollyToCursor
					? (this.dollyInFixed(P, !0), this._dollyToNoClamp(C, !0))
					: this._dollyToNoClamp(C, !0),
					this.dollyToCursor && ((this._changedDolly += (this.infinityDolly ? w : C) - E), this._dollyControlCoord.set(y, _)),
					(this._lastDollyDirection = Math.sign(-f));
			}),
			(this._zoomInternal = (f, y, _) => {
				const x = Math.pow(0.95, f * this.dollySpeed),
					E = this._zoom,
					w = this._zoom * x;
				this.zoomTo(w, !0), this.dollyToCursor && ((this._changedZoom += w - E), this._dollyControlCoord.set(y, _));
			}),
			typeof Ke > 'u' &&
				console.error(
					'camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.'
				),
			(this._camera = e),
			(this._yAxisUpSpace = new Ke.Quaternion().setFromUnitVectors(this._camera.up, Md)),
			(this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert()),
			(this._state = de.NONE),
			(this._target = new Ke.Vector3()),
			(this._targetEnd = this._target.clone()),
			(this._focalOffset = new Ke.Vector3()),
			(this._focalOffsetEnd = this._focalOffset.clone()),
			(this._spherical = new Ke.Spherical().setFromVector3(st.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace))),
			(this._sphericalEnd = this._spherical.clone()),
			(this._lastDistance = this._spherical.radius),
			(this._zoom = this._camera.zoom),
			(this._zoomEnd = this._zoom),
			(this._lastZoom = this._zoom),
			(this._nearPlaneCorners = [new Ke.Vector3(), new Ke.Vector3(), new Ke.Vector3(), new Ke.Vector3()]),
			this._updateNearPlaneCorners(),
			(this._boundary = new Ke.Box3(new Ke.Vector3(-1 / 0, -1 / 0, -1 / 0), new Ke.Vector3(1 / 0, 1 / 0, 1 / 0))),
			(this._cameraUp0 = this._camera.up.clone()),
			(this._target0 = this._target.clone()),
			(this._position0 = this._camera.position.clone()),
			(this._zoom0 = this._zoom),
			(this._focalOffset0 = this._focalOffset.clone()),
			(this._dollyControlCoord = new Ke.Vector2()),
			(this.mouseButtons = {
				left: de.ROTATE,
				middle: de.DOLLY,
				right: de.TRUCK,
				wheel: Ko(this._camera) ? de.DOLLY : Yr(this._camera) ? de.ZOOM : de.NONE,
			}),
			(this.touches = {
				one: de.TOUCH_ROTATE,
				two: Ko(this._camera) ? de.TOUCH_DOLLY_TRUCK : Yr(this._camera) ? de.TOUCH_ZOOM_TRUCK : de.NONE,
				three: de.TOUCH_TRUCK,
			});
		const n = new Ke.Vector2(),
			s = new Ke.Vector2(),
			r = new Ke.Vector2(),
			o = (f) => {
				if (!this._enabled || !this._domElement) return;
				if (
					this._interactiveArea.left !== 0 ||
					this._interactiveArea.top !== 0 ||
					this._interactiveArea.width !== 1 ||
					this._interactiveArea.height !== 1
				) {
					const x = this._domElement.getBoundingClientRect(),
						E = f.clientX / x.width,
						w = f.clientY / x.height;
					if (
						E < this._interactiveArea.left ||
						E > this._interactiveArea.right ||
						w < this._interactiveArea.top ||
						w > this._interactiveArea.bottom
					)
						return;
				}
				const y =
					f.pointerType !== 'mouse'
						? null
						: (f.buttons & Qt.LEFT) === Qt.LEFT
						? Qt.LEFT
						: (f.buttons & Qt.MIDDLE) === Qt.MIDDLE
						? Qt.MIDDLE
						: (f.buttons & Qt.RIGHT) === Qt.RIGHT
						? Qt.RIGHT
						: null;
				if (y !== null) {
					const x = this._findPointerByMouseButton(y);
					x && this._disposePointer(x);
				}
				if ((f.buttons & Qt.LEFT) === Qt.LEFT && this._lockedPointer) return;
				const _ = { pointerId: f.pointerId, clientX: f.clientX, clientY: f.clientY, deltaX: 0, deltaY: 0, mouseButton: y };
				this._activePointers.push(_),
					this._domElement.ownerDocument.removeEventListener('pointermove', a, { passive: !1 }),
					this._domElement.ownerDocument.removeEventListener('pointerup', l),
					this._domElement.ownerDocument.addEventListener('pointermove', a, { passive: !1 }),
					this._domElement.ownerDocument.addEventListener('pointerup', l),
					(this._isDragging = !0),
					d(f);
			},
			a = (f) => {
				f.cancelable && f.preventDefault();
				const y = f.pointerId,
					_ = this._lockedPointer || this._findPointerById(y);
				if (_) {
					if (
						((_.clientX = f.clientX),
						(_.clientY = f.clientY),
						(_.deltaX = f.movementX),
						(_.deltaY = f.movementY),
						(this._state = 0),
						f.pointerType === 'touch')
					)
						switch (this._activePointers.length) {
							case 1:
								this._state = this.touches.one;
								break;
							case 2:
								this._state = this.touches.two;
								break;
							case 3:
								this._state = this.touches.three;
								break;
						}
					else
						((!this._isDragging && this._lockedPointer) || (this._isDragging && (f.buttons & Qt.LEFT) === Qt.LEFT)) &&
							(this._state = this._state | this.mouseButtons.left),
							this._isDragging &&
								(f.buttons & Qt.MIDDLE) === Qt.MIDDLE &&
								(this._state = this._state | this.mouseButtons.middle),
							this._isDragging &&
								(f.buttons & Qt.RIGHT) === Qt.RIGHT &&
								(this._state = this._state | this.mouseButtons.right);
					p();
				}
			},
			l = (f) => {
				const y = this._findPointerById(f.pointerId);
				if (!(y && y === this._lockedPointer)) {
					if ((y && this._disposePointer(y), f.pointerType === 'touch'))
						switch (this._activePointers.length) {
							case 0:
								this._state = de.NONE;
								break;
							case 1:
								this._state = this.touches.one;
								break;
							case 2:
								this._state = this.touches.two;
								break;
							case 3:
								this._state = this.touches.three;
								break;
						}
					else this._state = de.NONE;
					g();
				}
			};
		let c = -1;
		const h = (f) => {
				if (!this._domElement || !this._enabled || this.mouseButtons.wheel === de.NONE) return;
				if (
					this._interactiveArea.left !== 0 ||
					this._interactiveArea.top !== 0 ||
					this._interactiveArea.width !== 1 ||
					this._interactiveArea.height !== 1
				) {
					const w = this._domElement.getBoundingClientRect(),
						C = f.clientX / w.width,
						P = f.clientY / w.height;
					if (
						C < this._interactiveArea.left ||
						C > this._interactiveArea.right ||
						P < this._interactiveArea.top ||
						P > this._interactiveArea.bottom
					)
						return;
				}
				if (
					(f.preventDefault(),
					this.dollyToCursor || this.mouseButtons.wheel === de.ROTATE || this.mouseButtons.wheel === de.TRUCK)
				) {
					const w = performance.now();
					c - w < 1e3 && this._getClientRect(this._elementRect), (c = w);
				}
				const y = tB ? -1 : -3,
					_ = f.deltaMode === 1 ? f.deltaY / y : f.deltaY / (y * 10),
					x = this.dollyToCursor ? ((f.clientX - this._elementRect.x) / this._elementRect.width) * 2 - 1 : 0,
					E = this.dollyToCursor ? ((f.clientY - this._elementRect.y) / this._elementRect.height) * -2 + 1 : 0;
				switch (this.mouseButtons.wheel) {
					case de.ROTATE: {
						this._rotateInternal(f.deltaX, f.deltaY), (this._isUserControllingRotate = !0);
						break;
					}
					case de.TRUCK: {
						this._truckInternal(f.deltaX, f.deltaY, !1), (this._isUserControllingTruck = !0);
						break;
					}
					case de.OFFSET: {
						this._truckInternal(f.deltaX, f.deltaY, !0), (this._isUserControllingOffset = !0);
						break;
					}
					case de.DOLLY: {
						this._dollyInternal(-_, x, E), (this._isUserControllingDolly = !0);
						break;
					}
					case de.ZOOM: {
						this._zoomInternal(-_, x, E), (this._isUserControllingZoom = !0);
						break;
					}
				}
				this.dispatchEvent({ type: 'control' });
			},
			u = (f) => {
				if (!(!this._domElement || !this._enabled)) {
					if (this.mouseButtons.right === Oh.ACTION.NONE) {
						const y = f instanceof PointerEvent ? f.pointerId : 0,
							_ = this._findPointerById(y);
						_ && this._disposePointer(_),
							this._domElement.ownerDocument.removeEventListener('pointermove', a, { passive: !1 }),
							this._domElement.ownerDocument.removeEventListener('pointerup', l);
						return;
					}
					f.preventDefault();
				}
			},
			d = (f) => {
				if (!this._enabled) return;
				if (
					(Pm(this._activePointers, hi),
					this._getClientRect(this._elementRect),
					n.copy(hi),
					s.copy(hi),
					this._activePointers.length >= 2)
				) {
					const _ = hi.x - this._activePointers[1].clientX,
						x = hi.y - this._activePointers[1].clientY,
						E = Math.sqrt(_ * _ + x * x);
					r.set(0, E);
					const w = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5,
						C = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
					s.set(w, C);
				}
				if (((this._state = 0), !f)) this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
				else if ('pointerType' in f && f.pointerType === 'touch')
					switch (this._activePointers.length) {
						case 1:
							this._state = this.touches.one;
							break;
						case 2:
							this._state = this.touches.two;
							break;
						case 3:
							this._state = this.touches.three;
							break;
					}
				else
					!this._lockedPointer && (f.buttons & Qt.LEFT) === Qt.LEFT && (this._state = this._state | this.mouseButtons.left),
						(f.buttons & Qt.MIDDLE) === Qt.MIDDLE && (this._state = this._state | this.mouseButtons.middle),
						(f.buttons & Qt.RIGHT) === Qt.RIGHT && (this._state = this._state | this.mouseButtons.right);
				((this._state & de.ROTATE) === de.ROTATE ||
					(this._state & de.TOUCH_ROTATE) === de.TOUCH_ROTATE ||
					(this._state & de.TOUCH_DOLLY_ROTATE) === de.TOUCH_DOLLY_ROTATE ||
					(this._state & de.TOUCH_ZOOM_ROTATE) === de.TOUCH_ZOOM_ROTATE) &&
					((this._sphericalEnd.theta = this._spherical.theta),
					(this._sphericalEnd.phi = this._spherical.phi),
					(this._thetaVelocity.value = 0),
					(this._phiVelocity.value = 0)),
					((this._state & de.TRUCK) === de.TRUCK ||
						(this._state & de.TOUCH_TRUCK) === de.TOUCH_TRUCK ||
						(this._state & de.TOUCH_DOLLY_TRUCK) === de.TOUCH_DOLLY_TRUCK ||
						(this._state & de.TOUCH_ZOOM_TRUCK) === de.TOUCH_ZOOM_TRUCK) &&
						(this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)),
					((this._state & de.DOLLY) === de.DOLLY ||
						(this._state & de.TOUCH_DOLLY) === de.TOUCH_DOLLY ||
						(this._state & de.TOUCH_DOLLY_TRUCK) === de.TOUCH_DOLLY_TRUCK ||
						(this._state & de.TOUCH_DOLLY_OFFSET) === de.TOUCH_DOLLY_OFFSET ||
						(this._state & de.TOUCH_DOLLY_ROTATE) === de.TOUCH_DOLLY_ROTATE) &&
						((this._sphericalEnd.radius = this._spherical.radius), (this._radiusVelocity.value = 0)),
					((this._state & de.ZOOM) === de.ZOOM ||
						(this._state & de.TOUCH_ZOOM) === de.TOUCH_ZOOM ||
						(this._state & de.TOUCH_ZOOM_TRUCK) === de.TOUCH_ZOOM_TRUCK ||
						(this._state & de.TOUCH_ZOOM_OFFSET) === de.TOUCH_ZOOM_OFFSET ||
						(this._state & de.TOUCH_ZOOM_ROTATE) === de.TOUCH_ZOOM_ROTATE) &&
						((this._zoomEnd = this._zoom), (this._zoomVelocity.value = 0)),
					((this._state & de.OFFSET) === de.OFFSET ||
						(this._state & de.TOUCH_OFFSET) === de.TOUCH_OFFSET ||
						(this._state & de.TOUCH_DOLLY_OFFSET) === de.TOUCH_DOLLY_OFFSET ||
						(this._state & de.TOUCH_ZOOM_OFFSET) === de.TOUCH_ZOOM_OFFSET) &&
						(this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)),
					this.dispatchEvent({ type: 'controlstart' });
			},
			p = () => {
				if (!this._enabled || !this._dragNeedsUpdate) return;
				(this._dragNeedsUpdate = !1), Pm(this._activePointers, hi);
				const y =
						this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement
							? this._lockedPointer || this._activePointers[0]
							: null,
					_ = y ? -y.deltaX : s.x - hi.x,
					x = y ? -y.deltaY : s.y - hi.y;
				if (
					(s.copy(hi),
					((this._state & de.ROTATE) === de.ROTATE ||
						(this._state & de.TOUCH_ROTATE) === de.TOUCH_ROTATE ||
						(this._state & de.TOUCH_DOLLY_ROTATE) === de.TOUCH_DOLLY_ROTATE ||
						(this._state & de.TOUCH_ZOOM_ROTATE) === de.TOUCH_ZOOM_ROTATE) &&
						(this._rotateInternal(_, x), (this._isUserControllingRotate = !0)),
					(this._state & de.DOLLY) === de.DOLLY || (this._state & de.ZOOM) === de.ZOOM)
				) {
					const E = this.dollyToCursor ? ((n.x - this._elementRect.x) / this._elementRect.width) * 2 - 1 : 0,
						w = this.dollyToCursor ? ((n.y - this._elementRect.y) / this._elementRect.height) * -2 + 1 : 0,
						C = this.dollyDragInverted ? -1 : 1;
					(this._state & de.DOLLY) === de.DOLLY
						? (this._dollyInternal(C * x * Sd, E, w), (this._isUserControllingDolly = !0))
						: (this._zoomInternal(C * x * Sd, E, w), (this._isUserControllingZoom = !0));
				}
				if (
					(this._state & de.TOUCH_DOLLY) === de.TOUCH_DOLLY ||
					(this._state & de.TOUCH_ZOOM) === de.TOUCH_ZOOM ||
					(this._state & de.TOUCH_DOLLY_TRUCK) === de.TOUCH_DOLLY_TRUCK ||
					(this._state & de.TOUCH_ZOOM_TRUCK) === de.TOUCH_ZOOM_TRUCK ||
					(this._state & de.TOUCH_DOLLY_OFFSET) === de.TOUCH_DOLLY_OFFSET ||
					(this._state & de.TOUCH_ZOOM_OFFSET) === de.TOUCH_ZOOM_OFFSET ||
					(this._state & de.TOUCH_DOLLY_ROTATE) === de.TOUCH_DOLLY_ROTATE ||
					(this._state & de.TOUCH_ZOOM_ROTATE) === de.TOUCH_ZOOM_ROTATE
				) {
					const E = hi.x - this._activePointers[1].clientX,
						w = hi.y - this._activePointers[1].clientY,
						C = Math.sqrt(E * E + w * w),
						P = r.y - C;
					r.set(0, C);
					const S = this.dollyToCursor ? ((s.x - this._elementRect.x) / this._elementRect.width) * 2 - 1 : 0,
						M = this.dollyToCursor ? ((s.y - this._elementRect.y) / this._elementRect.height) * -2 + 1 : 0;
					(this._state & de.TOUCH_DOLLY) === de.TOUCH_DOLLY ||
					(this._state & de.TOUCH_DOLLY_ROTATE) === de.TOUCH_DOLLY_ROTATE ||
					(this._state & de.TOUCH_DOLLY_TRUCK) === de.TOUCH_DOLLY_TRUCK ||
					(this._state & de.TOUCH_DOLLY_OFFSET) === de.TOUCH_DOLLY_OFFSET
						? (this._dollyInternal(P * Sd, S, M), (this._isUserControllingDolly = !0))
						: (this._zoomInternal(P * Sd, S, M), (this._isUserControllingZoom = !0));
				}
				((this._state & de.TRUCK) === de.TRUCK ||
					(this._state & de.TOUCH_TRUCK) === de.TOUCH_TRUCK ||
					(this._state & de.TOUCH_DOLLY_TRUCK) === de.TOUCH_DOLLY_TRUCK ||
					(this._state & de.TOUCH_ZOOM_TRUCK) === de.TOUCH_ZOOM_TRUCK) &&
					(this._truckInternal(_, x, !1), (this._isUserControllingTruck = !0)),
					((this._state & de.OFFSET) === de.OFFSET ||
						(this._state & de.TOUCH_OFFSET) === de.TOUCH_OFFSET ||
						(this._state & de.TOUCH_DOLLY_OFFSET) === de.TOUCH_DOLLY_OFFSET ||
						(this._state & de.TOUCH_ZOOM_OFFSET) === de.TOUCH_ZOOM_OFFSET) &&
						(this._truckInternal(_, x, !0), (this._isUserControllingOffset = !0)),
					this.dispatchEvent({ type: 'control' });
			},
			g = () => {
				Pm(this._activePointers, hi),
					s.copy(hi),
					(this._dragNeedsUpdate = !1),
					(this._activePointers.length === 0 ||
						(this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer)) &&
						(this._isDragging = !1),
					this._activePointers.length === 0 &&
						this._domElement &&
						(this._domElement.ownerDocument.removeEventListener('pointermove', a, { passive: !1 }),
						this._domElement.ownerDocument.removeEventListener('pointerup', l),
						this.dispatchEvent({ type: 'controlend' }));
			};
		(this.lockPointer = () => {
			!this._enabled ||
				!this._domElement ||
				(this.cancel(),
				(this._lockedPointer = { pointerId: -1, clientX: 0, clientY: 0, deltaX: 0, deltaY: 0, mouseButton: null }),
				this._activePointers.push(this._lockedPointer),
				this._domElement.ownerDocument.removeEventListener('pointermove', a, { passive: !1 }),
				this._domElement.ownerDocument.removeEventListener('pointerup', l),
				this._domElement.requestPointerLock(),
				this._domElement.ownerDocument.addEventListener('pointerlockchange', v),
				this._domElement.ownerDocument.addEventListener('pointerlockerror', m),
				this._domElement.ownerDocument.addEventListener('pointermove', a, { passive: !1 }),
				this._domElement.ownerDocument.addEventListener('pointerup', l),
				d());
		}),
			(this.unlockPointer = () => {
				var f, y, _;
				this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), (this._lockedPointer = null)),
					(f = this._domElement) === null || f === void 0 || f.ownerDocument.exitPointerLock(),
					(y = this._domElement) === null || y === void 0 || y.ownerDocument.removeEventListener('pointerlockchange', v),
					(_ = this._domElement) === null || _ === void 0 || _.ownerDocument.removeEventListener('pointerlockerror', m),
					this.cancel();
			});
		const v = () => {
				(this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement) || this.unlockPointer();
			},
			m = () => {
				this.unlockPointer();
			};
		(this._addAllEventListeners = (f) => {
			(this._domElement = f),
				(this._domElement.style.touchAction = 'none'),
				(this._domElement.style.userSelect = 'none'),
				(this._domElement.style.webkitUserSelect = 'none'),
				this._domElement.addEventListener('pointerdown', o),
				this._domElement.addEventListener('pointercancel', l),
				this._domElement.addEventListener('wheel', h, { passive: !1 }),
				this._domElement.addEventListener('contextmenu', u);
		}),
			(this._removeAllEventListeners = () => {
				this._domElement &&
					((this._domElement.style.touchAction = ''),
					(this._domElement.style.userSelect = ''),
					(this._domElement.style.webkitUserSelect = ''),
					this._domElement.removeEventListener('pointerdown', o),
					this._domElement.removeEventListener('pointercancel', l),
					this._domElement.removeEventListener('wheel', h, { passive: !1 }),
					this._domElement.removeEventListener('contextmenu', u),
					this._domElement.ownerDocument.removeEventListener('pointermove', a, { passive: !1 }),
					this._domElement.ownerDocument.removeEventListener('pointerup', l),
					this._domElement.ownerDocument.removeEventListener('pointerlockchange', v),
					this._domElement.ownerDocument.removeEventListener('pointerlockerror', m));
			}),
			(this.cancel = () => {
				this._state !== de.NONE && ((this._state = de.NONE), (this._activePointers.length = 0), g());
			}),
			t && this.connect(t),
			this.update(0);
	}
	get camera() {
		return this._camera;
	}
	set camera(e) {
		(this._camera = e),
			this.updateCameraUp(),
			this._camera.updateProjectionMatrix(),
			this._updateNearPlaneCorners(),
			(this._needsUpdate = !0);
	}
	get enabled() {
		return this._enabled;
	}
	set enabled(e) {
		(this._enabled = e),
			this._domElement &&
				(e
					? ((this._domElement.style.touchAction = 'none'),
					  (this._domElement.style.userSelect = 'none'),
					  (this._domElement.style.webkitUserSelect = 'none'))
					: (this.cancel(),
					  (this._domElement.style.touchAction = ''),
					  (this._domElement.style.userSelect = ''),
					  (this._domElement.style.webkitUserSelect = '')));
	}
	get active() {
		return !this._hasRested;
	}
	get currentAction() {
		return this._state;
	}
	get distance() {
		return this._spherical.radius;
	}
	set distance(e) {
		(this._spherical.radius === e && this._sphericalEnd.radius === e) ||
			((this._spherical.radius = e), (this._sphericalEnd.radius = e), (this._needsUpdate = !0));
	}
	get azimuthAngle() {
		return this._spherical.theta;
	}
	set azimuthAngle(e) {
		(this._spherical.theta === e && this._sphericalEnd.theta === e) ||
			((this._spherical.theta = e), (this._sphericalEnd.theta = e), (this._needsUpdate = !0));
	}
	get polarAngle() {
		return this._spherical.phi;
	}
	set polarAngle(e) {
		(this._spherical.phi === e && this._sphericalEnd.phi === e) ||
			((this._spherical.phi = e), (this._sphericalEnd.phi = e), (this._needsUpdate = !0));
	}
	get boundaryEnclosesCamera() {
		return this._boundaryEnclosesCamera;
	}
	set boundaryEnclosesCamera(e) {
		(this._boundaryEnclosesCamera = e), (this._needsUpdate = !0);
	}
	set interactiveArea(e) {
		(this._interactiveArea.width = ms(e.width, 0, 1)),
			(this._interactiveArea.height = ms(e.height, 0, 1)),
			(this._interactiveArea.x = ms(e.x, 0, 1 - this._interactiveArea.width)),
			(this._interactiveArea.y = ms(e.y, 0, 1 - this._interactiveArea.height));
	}
	addEventListener(e, t) {
		super.addEventListener(e, t);
	}
	removeEventListener(e, t) {
		super.removeEventListener(e, t);
	}
	rotate(e, t, n = !1) {
		return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);
	}
	rotateAzimuthTo(e, t = !1) {
		return this.rotateTo(e, this._sphericalEnd.phi, t);
	}
	rotatePolarTo(e, t = !1) {
		return this.rotateTo(this._sphericalEnd.theta, e, t);
	}
	rotateTo(e, t, n = !1) {
		this._isUserControllingRotate = !1;
		const s = ms(e, this.minAzimuthAngle, this.maxAzimuthAngle),
			r = ms(t, this.minPolarAngle, this.maxPolarAngle);
		(this._sphericalEnd.theta = s),
			(this._sphericalEnd.phi = r),
			this._sphericalEnd.makeSafe(),
			(this._needsUpdate = !0),
			n || ((this._spherical.theta = this._sphericalEnd.theta), (this._spherical.phi = this._sphericalEnd.phi));
		const o =
			!n ||
			(Lt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
				Lt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold));
		return this._createOnRestPromise(o);
	}
	dolly(e, t = !1) {
		return this.dollyTo(this._sphericalEnd.radius - e, t);
	}
	dollyTo(e, t = !1) {
		return (
			(this._isUserControllingDolly = !1),
			(this._lastDollyDirection = _l.NONE),
			(this._changedDolly = 0),
			this._dollyToNoClamp(ms(e, this.minDistance, this.maxDistance), t)
		);
	}
	_dollyToNoClamp(e, t = !1) {
		const n = this._sphericalEnd.radius;
		if (this.colliderMeshes.length >= 1) {
			const o = this._collisionTest(),
				a = Lt(o, this._spherical.radius);
			if (!(n > e) && a) return Promise.resolve();
			this._sphericalEnd.radius = Math.min(e, o);
		} else this._sphericalEnd.radius = e;
		(this._needsUpdate = !0), t || (this._spherical.radius = this._sphericalEnd.radius);
		const r = !t || Lt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
		return this._createOnRestPromise(r);
	}
	dollyInFixed(e, t = !1) {
		this._targetEnd.add(this._getCameraDirection(Nc).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
		const n =
			!t ||
			(Lt(this._target.x, this._targetEnd.x, this.restThreshold) &&
				Lt(this._target.y, this._targetEnd.y, this.restThreshold) &&
				Lt(this._target.z, this._targetEnd.z, this.restThreshold));
		return this._createOnRestPromise(n);
	}
	zoom(e, t = !1) {
		return this.zoomTo(this._zoomEnd + e, t);
	}
	zoomTo(e, t = !1) {
		(this._isUserControllingZoom = !1),
			(this._zoomEnd = ms(e, this.minZoom, this.maxZoom)),
			(this._needsUpdate = !0),
			t || (this._zoom = this._zoomEnd);
		const n = !t || Lt(this._zoom, this._zoomEnd, this.restThreshold);
		return (this._changedZoom = 0), this._createOnRestPromise(n);
	}
	pan(e, t, n = !1) {
		return console.warn('`pan` has been renamed to `truck`'), this.truck(e, t, n);
	}
	truck(e, t, n = !1) {
		this._camera.updateMatrix(),
			Is.setFromMatrixColumn(this._camera.matrix, 0),
			Ds.setFromMatrixColumn(this._camera.matrix, 1),
			Is.multiplyScalar(e),
			Ds.multiplyScalar(-t);
		const s = st.copy(Is).add(Ds),
			r = Mt.copy(this._targetEnd).add(s);
		return this.moveTo(r.x, r.y, r.z, n);
	}
	forward(e, t = !1) {
		st.setFromMatrixColumn(this._camera.matrix, 0), st.crossVectors(this._camera.up, st), st.multiplyScalar(e);
		const n = Mt.copy(this._targetEnd).add(st);
		return this.moveTo(n.x, n.y, n.z, t);
	}
	elevate(e, t = !1) {
		return (
			st.copy(this._camera.up).multiplyScalar(e),
			this.moveTo(this._targetEnd.x + st.x, this._targetEnd.y + st.y, this._targetEnd.z + st.z, t)
		);
	}
	moveTo(e, t, n, s = !1) {
		this._isUserControllingTruck = !1;
		const r = st.set(e, t, n).sub(this._targetEnd);
		this._encloseToBoundary(this._targetEnd, r, this.boundaryFriction),
			(this._needsUpdate = !0),
			s || this._target.copy(this._targetEnd);
		const o =
			!s ||
			(Lt(this._target.x, this._targetEnd.x, this.restThreshold) &&
				Lt(this._target.y, this._targetEnd.y, this.restThreshold) &&
				Lt(this._target.z, this._targetEnd.z, this.restThreshold));
		return this._createOnRestPromise(o);
	}
	lookInDirectionOf(e, t, n, s = !1) {
		const a = st.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
		return this.setPosition(a.x, a.y, a.z, s);
	}
	fitToBox(e, t, { cover: n = !1, paddingLeft: s = 0, paddingRight: r = 0, paddingBottom: o = 0, paddingTop: a = 0 } = {}) {
		const l = [],
			c = e.isBox3 ? bl.copy(e) : bl.setFromObject(e);
		c.isEmpty() && (console.warn('camera-controls: fitTo() cannot be used with an empty box. Aborting'), Promise.resolve());
		const h = Nb(this._sphericalEnd.theta, Ub),
			u = Nb(this._sphericalEnd.phi, Ub);
		l.push(this.rotateTo(h, u, t));
		const d = st.setFromSpherical(this._sphericalEnd).normalize(),
			p = Hb.setFromUnitVectors(d, Dm),
			g = Lt(Math.abs(d.y), 1);
		g && p.multiply(Um.setFromAxisAngle(Md, h)), p.multiply(this._yAxisUpSpaceInverse);
		const v = Vb.makeEmpty();
		Mt.copy(c.min).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.min).setX(c.max.x).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.min).setY(c.max.y).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.max).setZ(c.min.z).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.min).setZ(c.max.z).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.max).setY(c.min.y).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.max).setX(c.min.x).applyQuaternion(p),
			v.expandByPoint(Mt),
			Mt.copy(c.max).applyQuaternion(p),
			v.expandByPoint(Mt),
			(v.min.x -= s),
			(v.min.y -= o),
			(v.max.x += r),
			(v.max.y += a),
			p.setFromUnitVectors(Dm, d),
			g && p.premultiply(Um.invert()),
			p.premultiply(this._yAxisUpSpace);
		const m = v.getSize(st),
			f = v.getCenter(Mt).applyQuaternion(p);
		if (Ko(this._camera)) {
			const y = this.getDistanceToFitBox(m.x, m.y, m.z, n);
			l.push(this.moveTo(f.x, f.y, f.z, t)), l.push(this.dollyTo(y, t)), l.push(this.setFocalOffset(0, 0, 0, t));
		} else if (Yr(this._camera)) {
			const y = this._camera,
				_ = y.right - y.left,
				x = y.top - y.bottom,
				E = n ? Math.max(_ / m.x, x / m.y) : Math.min(_ / m.x, x / m.y);
			l.push(this.moveTo(f.x, f.y, f.z, t)), l.push(this.zoomTo(E, t)), l.push(this.setFocalOffset(0, 0, 0, t));
		}
		return Promise.all(l);
	}
	fitToSphere(e, t) {
		const n = [],
			r = 'isObject3D' in e ? Oh.createBoundingSphere(e, Om) : Om.copy(e);
		if ((n.push(this.moveTo(r.center.x, r.center.y, r.center.z, t)), Ko(this._camera))) {
			const o = this.getDistanceToFitSphere(r.radius);
			n.push(this.dollyTo(o, t));
		} else if (Yr(this._camera)) {
			const o = this._camera.right - this._camera.left,
				a = this._camera.top - this._camera.bottom,
				l = 2 * r.radius,
				c = Math.min(o / l, a / l);
			n.push(this.zoomTo(c, t));
		}
		return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);
	}
	setLookAt(e, t, n, s, r, o, a = !1) {
		(this._isUserControllingRotate = !1),
			(this._isUserControllingDolly = !1),
			(this._isUserControllingTruck = !1),
			(this._lastDollyDirection = _l.NONE),
			(this._changedDolly = 0);
		const l = Mt.set(s, r, o),
			c = st.set(e, t, n);
		this._targetEnd.copy(l),
			this._sphericalEnd.setFromVector3(c.sub(l).applyQuaternion(this._yAxisUpSpace)),
			this.normalizeRotations(),
			(this._needsUpdate = !0),
			a || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
		const h =
			!a ||
			(Lt(this._target.x, this._targetEnd.x, this.restThreshold) &&
				Lt(this._target.y, this._targetEnd.y, this.restThreshold) &&
				Lt(this._target.z, this._targetEnd.z, this.restThreshold) &&
				Lt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
				Lt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&
				Lt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold));
		return this._createOnRestPromise(h);
	}
	lerpLookAt(e, t, n, s, r, o, a, l, c, h, u, d, p, g = !1) {
		(this._isUserControllingRotate = !1),
			(this._isUserControllingDolly = !1),
			(this._isUserControllingTruck = !1),
			(this._lastDollyDirection = _l.NONE),
			(this._changedDolly = 0);
		const v = st.set(s, r, o),
			m = Mt.set(e, t, n);
		ji.setFromVector3(m.sub(v).applyQuaternion(this._yAxisUpSpace));
		const f = xl.set(h, u, d),
			y = Mt.set(a, l, c);
		Fc.setFromVector3(y.sub(f).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(v.lerp(f, p));
		const _ = Fc.theta - ji.theta,
			x = Fc.phi - ji.phi,
			E = Fc.radius - ji.radius;
		this._sphericalEnd.set(ji.radius + E * p, ji.phi + x * p, ji.theta + _ * p),
			this.normalizeRotations(),
			(this._needsUpdate = !0),
			g || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
		const w =
			!g ||
			(Lt(this._target.x, this._targetEnd.x, this.restThreshold) &&
				Lt(this._target.y, this._targetEnd.y, this.restThreshold) &&
				Lt(this._target.z, this._targetEnd.z, this.restThreshold) &&
				Lt(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) &&
				Lt(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) &&
				Lt(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold));
		return this._createOnRestPromise(w);
	}
	setPosition(e, t, n, s = !1) {
		return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, s);
	}
	setTarget(e, t, n, s = !1) {
		const r = this.getPosition(st),
			o = this.setLookAt(r.x, r.y, r.z, e, t, n, s);
		return (this._sphericalEnd.phi = ms(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle)), o;
	}
	setFocalOffset(e, t, n, s = !1) {
		(this._isUserControllingOffset = !1),
			this._focalOffsetEnd.set(e, t, n),
			(this._needsUpdate = !0),
			s || this._focalOffset.copy(this._focalOffsetEnd);
		const r =
			!s ||
			(Lt(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) &&
				Lt(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) &&
				Lt(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold));
		return this._createOnRestPromise(r);
	}
	setOrbitPoint(e, t, n) {
		this._camera.updateMatrixWorld(),
			Is.setFromMatrixColumn(this._camera.matrixWorldInverse, 0),
			Ds.setFromMatrixColumn(this._camera.matrixWorldInverse, 1),
			$o.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
		const s = st.set(e, t, n),
			r = s.distanceTo(this._camera.position),
			o = s.sub(this._camera.position);
		Is.multiplyScalar(o.x),
			Ds.multiplyScalar(o.y),
			$o.multiplyScalar(o.z),
			st.copy(Is).add(Ds).add($o),
			(st.z = st.z + r),
			this.dollyTo(r, !1),
			this.setFocalOffset(-st.x, st.y, -st.z, !1),
			this.moveTo(e, t, n, !1);
	}
	setBoundary(e) {
		if (!e) {
			this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), (this._needsUpdate = !0);
			return;
		}
		this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), (this._needsUpdate = !0);
	}
	setViewport(e, t, n, s) {
		if (e === null) {
			this._viewport = null;
			return;
		}
		(this._viewport = this._viewport || new Ke.Vector4()),
			typeof e == 'number' ? this._viewport.set(e, t, n, s) : this._viewport.copy(e);
	}
	getDistanceToFitBox(e, t, n, s = !1) {
		if (Lm(this._camera, 'getDistanceToFitBox')) return this._spherical.radius;
		const r = e / t,
			o = this._camera.getEffectiveFOV() * Dc,
			a = this._camera.aspect;
		return (((s ? r > a : r < a) ? t : e / a) * 0.5) / Math.tan(o * 0.5) + n * 0.5;
	}
	getDistanceToFitSphere(e) {
		if (Lm(this._camera, 'getDistanceToFitSphere')) return this._spherical.radius;
		const t = this._camera.getEffectiveFOV() * Dc,
			n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2,
			s = 1 < this._camera.aspect ? t : n;
		return e / Math.sin(s * 0.5);
	}
	getTarget(e, t = !0) {
		return (e && e.isVector3 ? e : new Ke.Vector3()).copy(t ? this._targetEnd : this._target);
	}
	getPosition(e, t = !0) {
		return (e && e.isVector3 ? e : new Ke.Vector3())
			.setFromSpherical(t ? this._sphericalEnd : this._spherical)
			.applyQuaternion(this._yAxisUpSpaceInverse)
			.add(t ? this._targetEnd : this._target);
	}
	getSpherical(e, t = !0) {
		return (e || new Ke.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
	}
	getFocalOffset(e, t = !0) {
		return (e && e.isVector3 ? e : new Ke.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
	}
	normalizeRotations() {
		(this._sphericalEnd.theta = this._sphericalEnd.theta % yl),
			this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += yl),
			(this._spherical.theta += yl * Math.round((this._sphericalEnd.theta - this._spherical.theta) / yl));
	}
	stop() {
		this._focalOffset.copy(this._focalOffsetEnd),
			this._target.copy(this._targetEnd),
			this._spherical.copy(this._sphericalEnd),
			(this._zoom = this._zoomEnd);
	}
	reset(e = !1) {
		if (
			!Lt(this._camera.up.x, this._cameraUp0.x) ||
			!Lt(this._camera.up.y, this._cameraUp0.y) ||
			!Lt(this._camera.up.z, this._cameraUp0.z)
		) {
			this._camera.up.copy(this._cameraUp0);
			const n = this.getPosition(st);
			this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
		}
		const t = [
			this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
			this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
			this.zoomTo(this._zoom0, e),
		];
		return Promise.all(t);
	}
	saveState() {
		this._cameraUp0.copy(this._camera.up),
			this.getTarget(this._target0),
			this.getPosition(this._position0),
			(this._zoom0 = this._zoom),
			this._focalOffset0.copy(this._focalOffset);
	}
	updateCameraUp() {
		this._yAxisUpSpace.setFromUnitVectors(this._camera.up, Md), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
	}
	applyCameraUp() {
		const e = st.subVectors(this._target, this._camera.position).normalize(),
			t = Mt.crossVectors(e, this._camera.up);
		this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
		const n = this.getPosition(st);
		this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
	}
	update(e) {
		const t = this._sphericalEnd.theta - this._spherical.theta,
			n = this._sphericalEnd.phi - this._spherical.phi,
			s = this._sphericalEnd.radius - this._spherical.radius,
			r = kb.subVectors(this._targetEnd, this._target),
			o = zb.subVectors(this._focalOffsetEnd, this._focalOffset),
			a = this._zoomEnd - this._zoom;
		if (Gt(t)) (this._thetaVelocity.value = 0), (this._spherical.theta = this._sphericalEnd.theta);
		else {
			const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
			(this._spherical.theta = wd(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, u, 1 / 0, e)),
				(this._needsUpdate = !0);
		}
		if (Gt(n)) (this._phiVelocity.value = 0), (this._spherical.phi = this._sphericalEnd.phi);
		else {
			const u = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
			(this._spherical.phi = wd(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, u, 1 / 0, e)),
				(this._needsUpdate = !0);
		}
		if (Gt(s)) (this._radiusVelocity.value = 0), (this._spherical.radius = this._sphericalEnd.radius);
		else {
			const u = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
			(this._spherical.radius = wd(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, u, this.maxSpeed, e)),
				(this._needsUpdate = !0);
		}
		if (Gt(r.x) && Gt(r.y) && Gt(r.z)) this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
		else {
			const u = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
			Fb(this._target, this._targetEnd, this._targetVelocity, u, this.maxSpeed, e, this._target), (this._needsUpdate = !0);
		}
		if (Gt(o.x) && Gt(o.y) && Gt(o.z)) this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
		else {
			const u = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
			Fb(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, u, this.maxSpeed, e, this._focalOffset),
				(this._needsUpdate = !0);
		}
		if (Gt(a)) (this._zoomVelocity.value = 0), (this._zoom = this._zoomEnd);
		else {
			const u = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
			this._zoom = wd(this._zoom, this._zoomEnd, this._zoomVelocity, u, 1 / 0, e);
		}
		if (this.dollyToCursor) {
			if (Ko(this._camera) && this._changedDolly !== 0) {
				const u = this._spherical.radius - this._lastDistance,
					d = this._camera,
					p = this._getCameraDirection(Nc),
					g = st.copy(p).cross(d.up).normalize();
				g.lengthSq() === 0 && (g.x = 1);
				const v = Mt.crossVectors(g, p),
					m = this._sphericalEnd.radius * Math.tan(d.getEffectiveFOV() * Dc * 0.5),
					y = (this._sphericalEnd.radius - u - this._sphericalEnd.radius) / this._sphericalEnd.radius,
					_ = xl
						.copy(this._targetEnd)
						.add(g.multiplyScalar(this._dollyControlCoord.x * m * d.aspect))
						.add(v.multiplyScalar(this._dollyControlCoord.y * m)),
					x = st.copy(this._targetEnd).lerp(_, y),
					E = this._lastDollyDirection === _l.IN && this._spherical.radius <= this.minDistance,
					w = this._lastDollyDirection === _l.OUT && this.maxDistance <= this._spherical.radius;
				if (this.infinityDolly && (E || w)) {
					(this._sphericalEnd.radius -= u), (this._spherical.radius -= u);
					const P = Mt.copy(p).multiplyScalar(-u);
					x.add(P);
				}
				this._boundary.clampPoint(x, x);
				const C = Mt.subVectors(x, this._targetEnd);
				this._targetEnd.copy(x), this._target.add(C), (this._changedDolly -= u), Gt(this._changedDolly) && (this._changedDolly = 0);
			} else if (Yr(this._camera) && this._changedZoom !== 0) {
				const u = this._zoom - this._lastZoom,
					d = this._camera,
					p = st.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (d.near + d.far) / (d.near - d.far)).unproject(d),
					g = Mt.set(0, 0, -1).applyQuaternion(d.quaternion),
					v = xl.copy(p).add(g.multiplyScalar(-p.dot(d.up))),
					f = -(this._zoom - u - this._zoom) / this._zoom,
					y = this._getCameraDirection(Nc),
					_ = this._targetEnd.dot(y),
					x = st.copy(this._targetEnd).lerp(v, f),
					E = x.dot(y),
					w = y.multiplyScalar(E - _);
				x.sub(w), this._boundary.clampPoint(x, x);
				const C = Mt.subVectors(x, this._targetEnd);
				this._targetEnd.copy(x), this._target.add(C), (this._changedZoom -= u), Gt(this._changedZoom) && (this._changedZoom = 0);
			}
		}
		this._camera.zoom !== this._zoom &&
			((this._camera.zoom = this._zoom),
			this._camera.updateProjectionMatrix(),
			this._updateNearPlaneCorners(),
			(this._needsUpdate = !0)),
			(this._dragNeedsUpdate = !0);
		const l = this._collisionTest();
		(this._spherical.radius = Math.min(this._spherical.radius, l)),
			this._spherical.makeSafe(),
			this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target),
			this._camera.lookAt(this._target),
			(!Gt(this._focalOffset.x) || !Gt(this._focalOffset.y) || !Gt(this._focalOffset.z)) &&
				(this._camera.updateMatrixWorld(),
				Is.setFromMatrixColumn(this._camera.matrix, 0),
				Ds.setFromMatrixColumn(this._camera.matrix, 1),
				$o.setFromMatrixColumn(this._camera.matrix, 2),
				Is.multiplyScalar(this._focalOffset.x),
				Ds.multiplyScalar(-this._focalOffset.y),
				$o.multiplyScalar(this._focalOffset.z),
				st.copy(Is).add(Ds).add($o),
				this._camera.position.add(st)),
			this._boundaryEnclosesCamera &&
				this._encloseToBoundary(
					this._camera.position.copy(this._target),
					st.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse),
					1
				);
		const h = this._needsUpdate;
		return (
			h && !this._updatedLastTime
				? ((this._hasRested = !1), this.dispatchEvent({ type: 'wake' }), this.dispatchEvent({ type: 'update' }))
				: h
				? (this.dispatchEvent({ type: 'update' }),
				  Gt(t, this.restThreshold) &&
						Gt(n, this.restThreshold) &&
						Gt(s, this.restThreshold) &&
						Gt(r.x, this.restThreshold) &&
						Gt(r.y, this.restThreshold) &&
						Gt(r.z, this.restThreshold) &&
						Gt(o.x, this.restThreshold) &&
						Gt(o.y, this.restThreshold) &&
						Gt(o.z, this.restThreshold) &&
						Gt(a, this.restThreshold) &&
						!this._hasRested &&
						((this._hasRested = !0), this.dispatchEvent({ type: 'rest' })))
				: !h && this._updatedLastTime && this.dispatchEvent({ type: 'sleep' }),
			(this._lastDistance = this._spherical.radius),
			(this._lastZoom = this._zoom),
			(this._updatedLastTime = h),
			(this._needsUpdate = !1),
			h
		);
	}
	toJSON() {
		return JSON.stringify({
			enabled: this._enabled,
			minDistance: this.minDistance,
			maxDistance: Oc(this.maxDistance),
			minZoom: this.minZoom,
			maxZoom: Oc(this.maxZoom),
			minPolarAngle: this.minPolarAngle,
			maxPolarAngle: Oc(this.maxPolarAngle),
			minAzimuthAngle: Oc(this.minAzimuthAngle),
			maxAzimuthAngle: Oc(this.maxAzimuthAngle),
			smoothTime: this.smoothTime,
			draggingSmoothTime: this.draggingSmoothTime,
			dollySpeed: this.dollySpeed,
			truckSpeed: this.truckSpeed,
			dollyToCursor: this.dollyToCursor,
			verticalDragToForward: this.verticalDragToForward,
			target: this._targetEnd.toArray(),
			position: st.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
			zoom: this._zoomEnd,
			focalOffset: this._focalOffsetEnd.toArray(),
			target0: this._target0.toArray(),
			position0: this._position0.toArray(),
			zoom0: this._zoom0,
			focalOffset0: this._focalOffset0.toArray(),
		});
	}
	fromJSON(e, t = !1) {
		const n = JSON.parse(e);
		(this.enabled = n.enabled),
			(this.minDistance = n.minDistance),
			(this.maxDistance = Uc(n.maxDistance)),
			(this.minZoom = n.minZoom),
			(this.maxZoom = Uc(n.maxZoom)),
			(this.minPolarAngle = n.minPolarAngle),
			(this.maxPolarAngle = Uc(n.maxPolarAngle)),
			(this.minAzimuthAngle = Uc(n.minAzimuthAngle)),
			(this.maxAzimuthAngle = Uc(n.maxAzimuthAngle)),
			(this.smoothTime = n.smoothTime),
			(this.draggingSmoothTime = n.draggingSmoothTime),
			(this.dollySpeed = n.dollySpeed),
			(this.truckSpeed = n.truckSpeed),
			(this.dollyToCursor = n.dollyToCursor),
			(this.verticalDragToForward = n.verticalDragToForward),
			this._target0.fromArray(n.target0),
			this._position0.fromArray(n.position0),
			(this._zoom0 = n.zoom0),
			this._focalOffset0.fromArray(n.focalOffset0),
			this.moveTo(n.target[0], n.target[1], n.target[2], t),
			ji.setFromVector3(st.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)),
			this.rotateTo(ji.theta, ji.phi, t),
			this.dollyTo(ji.radius, t),
			this.zoomTo(n.zoom, t),
			this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t),
			(this._needsUpdate = !0);
	}
	connect(e) {
		if (this._domElement) {
			console.warn('camera-controls is already connected.');
			return;
		}
		e.setAttribute('data-camera-controls-version', eB), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
	}
	disconnect() {
		this.cancel(),
			this._removeAllEventListeners(),
			this._domElement && (this._domElement.removeAttribute('data-camera-controls-version'), (this._domElement = void 0));
	}
	dispose() {
		this.removeAllEventListeners(), this.disconnect();
	}
	_getTargetDirection(e) {
		return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
	}
	_getCameraDirection(e) {
		return this._getTargetDirection(e).negate();
	}
	_findPointerById(e) {
		return this._activePointers.find((t) => t.pointerId === e);
	}
	_findPointerByMouseButton(e) {
		return this._activePointers.find((t) => t.mouseButton === e);
	}
	_disposePointer(e) {
		this._activePointers.splice(this._activePointers.indexOf(e), 1);
	}
	_encloseToBoundary(e, t, n) {
		const s = t.lengthSq();
		if (s === 0) return e;
		const r = Mt.copy(t).add(e),
			a = this._boundary.clampPoint(r, xl).sub(r),
			l = a.lengthSq();
		if (l === 0) return e.add(t);
		if (l === s) return e;
		if (n === 0) return e.add(t).add(a);
		{
			const c = 1 + (n * l) / t.dot(a);
			return e.add(Mt.copy(t).multiplyScalar(c)).add(a.multiplyScalar(1 - n));
		}
	}
	_updateNearPlaneCorners() {
		if (Ko(this._camera)) {
			const e = this._camera,
				t = e.near,
				n = e.getEffectiveFOV() * Dc,
				s = Math.tan(n * 0.5) * t,
				r = s * e.aspect;
			this._nearPlaneCorners[0].set(-r, -s, 0),
				this._nearPlaneCorners[1].set(r, -s, 0),
				this._nearPlaneCorners[2].set(r, s, 0),
				this._nearPlaneCorners[3].set(-r, s, 0);
		} else if (Yr(this._camera)) {
			const e = this._camera,
				t = 1 / e.zoom,
				n = e.left * t,
				s = e.right * t,
				r = e.top * t,
				o = e.bottom * t;
			this._nearPlaneCorners[0].set(n, r, 0),
				this._nearPlaneCorners[1].set(s, r, 0),
				this._nearPlaneCorners[2].set(s, o, 0),
				this._nearPlaneCorners[3].set(n, o, 0);
		}
	}
	_collisionTest() {
		let e = 1 / 0;
		if (!(this.colliderMeshes.length >= 1) || Lm(this._camera, '_collisionTest')) return e;
		const n = this._getTargetDirection(Nc);
		Nm.lookAt(Bb, n, this._camera.up);
		for (let s = 0; s < 4; s++) {
			const r = Mt.copy(this._nearPlaneCorners[s]);
			r.applyMatrix4(Nm);
			const o = xl.addVectors(this._target, r);
			Ed.set(o, n), (Ed.far = this._spherical.radius + 1);
			const a = Ed.intersectObjects(this.colliderMeshes);
			a.length !== 0 && a[0].distance < e && (e = a[0].distance);
		}
		return e;
	}
	_getClientRect(e) {
		if (!this._domElement) return;
		const t = this._domElement.getBoundingClientRect();
		return (
			(e.x = t.left),
			(e.y = t.top),
			this._viewport
				? ((e.x += this._viewport.x),
				  (e.y += t.height - this._viewport.w - this._viewport.y),
				  (e.width = this._viewport.z),
				  (e.height = this._viewport.w))
				: ((e.width = t.width), (e.height = t.height)),
			e
		);
	}
	_createOnRestPromise(e) {
		return e
			? Promise.resolve()
			: ((this._hasRested = !1),
			  this.dispatchEvent({ type: 'transitionstart' }),
			  new Promise((t) => {
					const n = () => {
						this.removeEventListener('rest', n), t();
					};
					this.addEventListener('rest', n);
			  }));
	}
	_addAllEventListeners(e) {}
	_removeAllEventListeners() {}
	get dampingFactor() {
		return console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.'), 0;
	}
	set dampingFactor(e) {
		console.warn('.dampingFactor has been deprecated. use smoothTime (in seconds) instead.');
	}
	get draggingDampingFactor() {
		return console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.'), 0;
	}
	set draggingDampingFactor(e) {
		console.warn('.draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.');
	}
	static createBoundingSphere(e, t = new Ke.Sphere()) {
		const n = t,
			s = n.center;
		bl.makeEmpty(),
			e.traverseVisible((o) => {
				o.isMesh && bl.expandByObject(o);
			}),
			bl.getCenter(s);
		let r = 0;
		return (
			e.traverseVisible((o) => {
				if (!o.isMesh) return;
				const a = o,
					l = a.geometry.clone();
				l.applyMatrix4(a.matrixWorld);
				const h = l.attributes.position;
				for (let u = 0, d = h.count; u < d; u++) st.fromBufferAttribute(h, u), (r = Math.max(r, s.distanceToSquared(st)));
			}),
			(n.radius = Math.sqrt(r)),
			n
		);
	}
}
/**
 * postprocessing v6.36.0 build Thu Jul 25 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rüschen
 * @license Zlib
 */ var Fm = 1 / 1e3,
	nB = 1e3,
	iB = class {
		constructor() {
			(this.startTime = performance.now()),
				(this.previousTime = 0),
				(this.currentTime = 0),
				(this._delta = 0),
				(this._elapsed = 0),
				(this._fixedDelta = 1e3 / 60),
				(this.timescale = 1),
				(this.useFixedDelta = !1),
				(this._autoReset = !1);
		}
		get autoReset() {
			return this._autoReset;
		}
		set autoReset(i) {
			typeof document < 'u' &&
				document.hidden !== void 0 &&
				(i ? document.addEventListener('visibilitychange', this) : document.removeEventListener('visibilitychange', this),
				(this._autoReset = i));
		}
		get delta() {
			return this._delta * Fm;
		}
		get fixedDelta() {
			return this._fixedDelta * Fm;
		}
		set fixedDelta(i) {
			this._fixedDelta = i * nB;
		}
		get elapsed() {
			return this._elapsed * Fm;
		}
		update(i) {
			this.useFixedDelta
				? (this._delta = this.fixedDelta)
				: ((this.previousTime = this.currentTime),
				  (this.currentTime = (i !== void 0 ? i : performance.now()) - this.startTime),
				  (this._delta = this.currentTime - this.previousTime)),
				(this._delta *= this.timescale),
				(this._elapsed += this._delta);
		}
		reset() {
			(this._delta = 0), (this._elapsed = 0), (this.currentTime = performance.now() - this.startTime);
		}
		getDelta() {
			return this.delta;
		}
		getElapsed() {
			return this.elapsed;
		}
		handleEvent(i) {
			document.hidden || (this.currentTime = performance.now() - this.startTime);
		}
		dispose() {
			this.autoReset = !1;
		}
	},
	sB = new Zh(),
	Vr = null;
function rB() {
	if (Vr === null) {
		const i = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
			e = new Float32Array([0, 0, 2, 0, 0, 2]);
		(Vr = new Ze()),
			Vr.setAttribute !== void 0
				? (Vr.setAttribute('position', new $e(i, 3)), Vr.setAttribute('uv', new $e(e, 2)))
				: (Vr.addAttribute('position', new $e(i, 3)), Vr.addAttribute('uv', new $e(e, 2)));
	}
	return Vr;
}
var cs = class wT {
		constructor(e = 'Pass', t = new Ch(), n = sB) {
			(this.name = e),
				(this.renderer = null),
				(this.scene = t),
				(this.camera = n),
				(this.screen = null),
				(this.rtt = !0),
				(this.needsSwap = !0),
				(this.needsDepthTexture = !1),
				(this.enabled = !0);
		}
		get renderToScreen() {
			return !this.rtt;
		}
		set renderToScreen(e) {
			if (this.rtt === e) {
				const t = this.fullscreenMaterial;
				t !== null && (t.needsUpdate = !0), (this.rtt = !e);
			}
		}
		set mainScene(e) {}
		set mainCamera(e) {}
		setRenderer(e) {
			this.renderer = e;
		}
		isEnabled() {
			return this.enabled;
		}
		setEnabled(e) {
			this.enabled = e;
		}
		get fullscreenMaterial() {
			return this.screen !== null ? this.screen.material : null;
		}
		set fullscreenMaterial(e) {
			let t = this.screen;
			t !== null
				? (t.material = e)
				: ((t = new bt(rB(), e)),
				  (t.frustumCulled = !1),
				  this.scene === null && (this.scene = new Ch()),
				  this.scene.add(t),
				  (this.screen = t));
		}
		getFullscreenMaterial() {
			return this.fullscreenMaterial;
		}
		setFullscreenMaterial(e) {
			this.fullscreenMaterial = e;
		}
		getDepthTexture() {
			return null;
		}
		setDepthTexture(e, t = yr) {}
		render(e, t, n, s, r) {
			throw new Error('Render method not implemented!');
		}
		setSize(e, t) {}
		initialize(e, t, n) {}
		dispose() {
			for (const e of Object.keys(this)) {
				const t = this[e];
				(t instanceof yn || t instanceof vn || t instanceof zt || t instanceof wT) && this[e].dispose();
			}
		}
	},
	oB = class extends cs {
		constructor() {
			super('ClearMaskPass', null, null), (this.needsSwap = !1);
		}
		render(i, e, t, n, s) {
			const r = i.state.buffers.stencil;
			r.setLocked(!1), r.setTest(!1);
		}
	},
	aB =
		'#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}',
	t0 = 'varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}',
	ST = class extends xn {
		constructor() {
			super({
				name: 'CopyMaterial',
				uniforms: { inputBuffer: new yt(null), opacity: new yt(1) },
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				fragmentShader: aB,
				vertexShader: t0,
			});
		}
		set inputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		setInputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		getOpacity(i) {
			return this.uniforms.opacity.value;
		}
		setOpacity(i) {
			this.uniforms.opacity.value = i;
		}
	},
	MT = class extends cs {
		constructor(i, e = !0) {
			super('CopyPass'),
				(this.fullscreenMaterial = new ST()),
				(this.needsSwap = !1),
				(this.renderTarget = i),
				i === void 0 &&
					((this.renderTarget = new yn(1, 1, { minFilter: Tt, magFilter: Tt, stencilBuffer: !1, depthBuffer: !1 })),
					(this.renderTarget.texture.name = 'CopyPass.Target')),
				(this.autoResize = e);
		}
		get resize() {
			return this.autoResize;
		}
		set resize(i) {
			this.autoResize = i;
		}
		get texture() {
			return this.renderTarget.texture;
		}
		getTexture() {
			return this.renderTarget.texture;
		}
		setAutoResizeEnabled(i) {
			this.autoResize = i;
		}
		render(i, e, t, n, s) {
			(this.fullscreenMaterial.inputBuffer = e.texture),
				i.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
				i.render(this.scene, this.camera);
		}
		setSize(i, e) {
			this.autoResize && this.renderTarget.setSize(i, e);
		}
		initialize(i, e, t) {
			t !== void 0 &&
				((this.renderTarget.texture.type = t),
				t !== Vn
					? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1')
					: i !== null && i.outputColorSpace === ot && (this.renderTarget.texture.colorSpace = ot));
		}
	},
	Gb = new Ee(),
	n0 = class extends cs {
		constructor(i = !0, e = !0, t = !1) {
			super('ClearPass', null, null),
				(this.needsSwap = !1),
				(this.color = i),
				(this.depth = e),
				(this.stencil = t),
				(this.overrideClearColor = null),
				(this.overrideClearAlpha = -1);
		}
		setClearFlags(i, e, t) {
			(this.color = i), (this.depth = e), (this.stencil = t);
		}
		getOverrideClearColor() {
			return this.overrideClearColor;
		}
		setOverrideClearColor(i) {
			this.overrideClearColor = i;
		}
		getOverrideClearAlpha() {
			return this.overrideClearAlpha;
		}
		setOverrideClearAlpha(i) {
			this.overrideClearAlpha = i;
		}
		render(i, e, t, n, s) {
			const r = this.overrideClearColor,
				o = this.overrideClearAlpha,
				a = i.getClearAlpha(),
				l = r !== null,
				c = o >= 0;
			l ? (i.getClearColor(Gb), i.setClearColor(r, c ? o : a)) : c && i.setClearAlpha(o),
				i.setRenderTarget(this.renderToScreen ? null : e),
				i.clear(this.color, this.depth, this.stencil),
				l ? i.setClearColor(Gb, a) : c && i.setClearAlpha(a);
		}
	},
	lB = class extends cs {
		constructor(i, e) {
			super('MaskPass', i, e), (this.needsSwap = !1), (this.clearPass = new n0(!1, !1, !0)), (this.inverse = !1);
		}
		set mainScene(i) {
			this.scene = i;
		}
		set mainCamera(i) {
			this.camera = i;
		}
		get inverted() {
			return this.inverse;
		}
		set inverted(i) {
			this.inverse = i;
		}
		get clear() {
			return this.clearPass.enabled;
		}
		set clear(i) {
			this.clearPass.enabled = i;
		}
		getClearPass() {
			return this.clearPass;
		}
		isInverted() {
			return this.inverted;
		}
		setInverted(i) {
			this.inverted = i;
		}
		render(i, e, t, n, s) {
			const r = i.getContext(),
				o = i.state.buffers,
				a = this.scene,
				l = this.camera,
				c = this.clearPass,
				h = this.inverted ? 0 : 1,
				u = 1 - h;
			o.color.setMask(!1),
				o.depth.setMask(!1),
				o.color.setLocked(!0),
				o.depth.setLocked(!0),
				o.stencil.setTest(!0),
				o.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE),
				o.stencil.setFunc(r.ALWAYS, h, 4294967295),
				o.stencil.setClear(u),
				o.stencil.setLocked(!0),
				this.clearPass.enabled && (this.renderToScreen ? c.render(i, null) : (c.render(i, e), c.render(i, t))),
				this.renderToScreen
					? (i.setRenderTarget(null), i.render(a, l))
					: (i.setRenderTarget(e), i.render(a, l), i.setRenderTarget(t), i.render(a, l)),
				o.color.setLocked(!1),
				o.depth.setLocked(!1),
				o.stencil.setLocked(!1),
				o.stencil.setFunc(r.EQUAL, 1, 4294967295),
				o.stencil.setOp(r.KEEP, r.KEEP, r.KEEP),
				o.stencil.setLocked(!0);
		}
	},
	cB = class {
		constructor(i = null, { depthBuffer: e = !0, stencilBuffer: t = !1, multisampling: n = 0, frameBufferType: s } = {}) {
			(this.renderer = null),
				(this.inputBuffer = this.createBuffer(e, t, s, n)),
				(this.outputBuffer = this.inputBuffer.clone()),
				(this.copyPass = new MT()),
				(this.depthTexture = null),
				(this.passes = []),
				(this.timer = new iB()),
				(this.autoRenderToScreen = !0),
				this.setRenderer(i);
		}
		get multisampling() {
			return this.inputBuffer.samples || 0;
		}
		set multisampling(i) {
			const e = this.inputBuffer,
				t = this.multisampling;
			t > 0 && i > 0
				? ((this.inputBuffer.samples = i), (this.outputBuffer.samples = i), this.inputBuffer.dispose(), this.outputBuffer.dispose())
				: t !== i &&
				  (this.inputBuffer.dispose(),
				  this.outputBuffer.dispose(),
				  (this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, i)),
				  (this.inputBuffer.depthTexture = this.depthTexture),
				  (this.outputBuffer = this.inputBuffer.clone()));
		}
		getTimer() {
			return this.timer;
		}
		getRenderer() {
			return this.renderer;
		}
		setRenderer(i) {
			if (((this.renderer = i), i !== null)) {
				const e = i.getSize(new ce()),
					t = i.getContext().getContextAttributes().alpha,
					n = this.inputBuffer.texture.type;
				n === Vn &&
					i.outputColorSpace === ot &&
					((this.inputBuffer.texture.colorSpace = ot),
					(this.outputBuffer.texture.colorSpace = ot),
					this.inputBuffer.dispose(),
					this.outputBuffer.dispose()),
					(i.autoClear = !1),
					this.setSize(e.width, e.height);
				for (const s of this.passes) s.initialize(i, t, n);
			}
		}
		replaceRenderer(i, e = !0) {
			const t = this.renderer,
				n = t.domElement.parentNode;
			return this.setRenderer(i), e && n !== null && (n.removeChild(t.domElement), n.appendChild(i.domElement)), t;
		}
		createDepthTexture() {
			const i = (this.depthTexture = new Wp());
			return (
				(this.inputBuffer.depthTexture = i),
				this.inputBuffer.dispose(),
				this.inputBuffer.stencilBuffer ? ((i.format = Ta), (i.type = Ba)) : (i.type = yo),
				i
			);
		}
		deleteDepthTexture() {
			if (this.depthTexture !== null) {
				this.depthTexture.dispose(), (this.depthTexture = null), (this.inputBuffer.depthTexture = null), this.inputBuffer.dispose();
				for (const i of this.passes) i.setDepthTexture(null);
			}
		}
		createBuffer(i, e, t, n) {
			const s = this.renderer,
				r = s === null ? new ce() : s.getDrawingBufferSize(new ce()),
				o = { minFilter: Tt, magFilter: Tt, stencilBuffer: e, depthBuffer: i, type: t },
				a = new yn(r.width, r.height, o);
			return (
				n > 0 && ((a.ignoreDepthForMultisampleCopy = !1), (a.samples = n)),
				t === Vn && s !== null && s.outputColorSpace === ot && (a.texture.colorSpace = ot),
				(a.texture.name = 'EffectComposer.Buffer'),
				(a.texture.generateMipmaps = !1),
				a
			);
		}
		setMainScene(i) {
			for (const e of this.passes) e.mainScene = i;
		}
		setMainCamera(i) {
			for (const e of this.passes) e.mainCamera = i;
		}
		addPass(i, e) {
			const t = this.passes,
				n = this.renderer,
				s = n.getDrawingBufferSize(new ce()),
				r = n.getContext().getContextAttributes().alpha,
				o = this.inputBuffer.texture.type;
			if (
				(i.setRenderer(n),
				i.setSize(s.width, s.height),
				i.initialize(n, r, o),
				this.autoRenderToScreen &&
					(t.length > 0 && (t[t.length - 1].renderToScreen = !1), i.renderToScreen && (this.autoRenderToScreen = !1)),
				e !== void 0 ? t.splice(e, 0, i) : t.push(i),
				this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0),
				i.needsDepthTexture || this.depthTexture !== null)
			)
				if (this.depthTexture === null) {
					const a = this.createDepthTexture();
					for (i of t) i.setDepthTexture(a);
				} else i.setDepthTexture(this.depthTexture);
		}
		removePass(i) {
			const e = this.passes,
				t = e.indexOf(i);
			if (t !== -1 && e.splice(t, 1).length > 0) {
				if (this.depthTexture !== null) {
					const r = (a, l) => a || l.needsDepthTexture;
					e.reduce(r, !1) || (i.getDepthTexture() === this.depthTexture && i.setDepthTexture(null), this.deleteDepthTexture());
				}
				this.autoRenderToScreen &&
					t === e.length &&
					((i.renderToScreen = !1), e.length > 0 && (e[e.length - 1].renderToScreen = !0));
			}
		}
		removeAllPasses() {
			const i = this.passes;
			this.deleteDepthTexture(),
				i.length > 0 && (this.autoRenderToScreen && (i[i.length - 1].renderToScreen = !1), (this.passes = []));
		}
		render(i) {
			const e = this.renderer,
				t = this.copyPass;
			let n = this.inputBuffer,
				s = this.outputBuffer,
				r = !1,
				o,
				a,
				l;
			i === void 0 && (this.timer.update(), (i = this.timer.getDelta()));
			for (const c of this.passes)
				c.enabled &&
					(c.render(e, n, s, i, r),
					c.needsSwap &&
						(r &&
							((t.renderToScreen = c.renderToScreen),
							(o = e.getContext()),
							(a = e.state.buffers.stencil),
							a.setFunc(o.NOTEQUAL, 1, 4294967295),
							t.render(e, n, s, i, r),
							a.setFunc(o.EQUAL, 1, 4294967295)),
						(l = n),
						(n = s),
						(s = l)),
					c instanceof lB ? (r = !0) : c instanceof oB && (r = !1));
		}
		setSize(i, e, t) {
			const n = this.renderer,
				s = n.getSize(new ce());
			(i === void 0 || e === void 0) && ((i = s.width), (e = s.height)), (s.width !== i || s.height !== e) && n.setSize(i, e, t);
			const r = n.getDrawingBufferSize(new ce());
			this.inputBuffer.setSize(r.width, r.height), this.outputBuffer.setSize(r.width, r.height);
			for (const o of this.passes) o.setSize(r.width, r.height);
		}
		reset() {
			this.dispose(), (this.autoRenderToScreen = !0);
		}
		dispose() {
			for (const i of this.passes) i.dispose();
			(this.passes = []),
				this.inputBuffer !== null && this.inputBuffer.dispose(),
				this.outputBuffer !== null && this.outputBuffer.dispose(),
				this.deleteDepthTexture(),
				this.copyPass.dispose(),
				this.timer.dispose();
		}
	},
	po = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
	Et = {
		FRAGMENT_HEAD: 'FRAGMENT_HEAD',
		FRAGMENT_MAIN_UV: 'FRAGMENT_MAIN_UV',
		FRAGMENT_MAIN_IMAGE: 'FRAGMENT_MAIN_IMAGE',
		VERTEX_HEAD: 'VERTEX_HEAD',
		VERTEX_MAIN_SUPPORT: 'VERTEX_MAIN_SUPPORT',
	},
	hB = class {
		constructor() {
			(this.shaderParts = new Map([
				[Et.FRAGMENT_HEAD, null],
				[Et.FRAGMENT_MAIN_UV, null],
				[Et.FRAGMENT_MAIN_IMAGE, null],
				[Et.VERTEX_HEAD, null],
				[Et.VERTEX_MAIN_SUPPORT, null],
			])),
				(this.defines = new Map()),
				(this.uniforms = new Map()),
				(this.blendModes = new Map()),
				(this.extensions = new Set()),
				(this.attributes = po.NONE),
				(this.varyings = new Set()),
				(this.uvTransformation = !1),
				(this.readDepth = !1),
				(this.colorSpace = Es);
		}
	},
	Bm = !1,
	Wb = class {
		constructor(i = null) {
			(this.originalMaterials = new Map()),
				(this.material = null),
				(this.materials = null),
				(this.materialsBackSide = null),
				(this.materialsDoubleSide = null),
				(this.materialsFlatShaded = null),
				(this.materialsFlatShadedBackSide = null),
				(this.materialsFlatShadedDoubleSide = null),
				this.setMaterial(i),
				(this.meshCount = 0),
				(this.replaceMaterial = (e) => {
					if (e.isMesh) {
						let t;
						if (e.material.flatShading)
							switch (e.material.side) {
								case mn:
									t = this.materialsFlatShadedDoubleSide;
									break;
								case gn:
									t = this.materialsFlatShadedBackSide;
									break;
								default:
									t = this.materialsFlatShaded;
									break;
							}
						else
							switch (e.material.side) {
								case mn:
									t = this.materialsDoubleSide;
									break;
								case gn:
									t = this.materialsBackSide;
									break;
								default:
									t = this.materials;
									break;
							}
						this.originalMaterials.set(e, e.material),
							e.isSkinnedMesh ? (e.material = t[2]) : e.isInstancedMesh ? (e.material = t[1]) : (e.material = t[0]),
							++this.meshCount;
					}
				});
		}
		cloneMaterial(i) {
			if (!(i instanceof xn)) return i.clone();
			const e = i.uniforms,
				t = new Map();
			for (const s in e) {
				const r = e[s].value;
				r.isRenderTargetTexture && ((e[s].value = null), t.set(s, r));
			}
			const n = i.clone();
			for (const s of t) (e[s[0]].value = s[1]), (n.uniforms[s[0]].value = s[1]);
			return n;
		}
		setMaterial(i) {
			if ((this.disposeMaterials(), (this.material = i), i !== null)) {
				const e = (this.materials = [this.cloneMaterial(i), this.cloneMaterial(i), this.cloneMaterial(i)]);
				for (const t of e) (t.uniforms = Object.assign({}, i.uniforms)), (t.side = Ms);
				(e[2].skinning = !0),
					(this.materialsBackSide = e.map((t) => {
						const n = this.cloneMaterial(t);
						return (n.uniforms = Object.assign({}, i.uniforms)), (n.side = gn), n;
					})),
					(this.materialsDoubleSide = e.map((t) => {
						const n = this.cloneMaterial(t);
						return (n.uniforms = Object.assign({}, i.uniforms)), (n.side = mn), n;
					})),
					(this.materialsFlatShaded = e.map((t) => {
						const n = this.cloneMaterial(t);
						return (n.uniforms = Object.assign({}, i.uniforms)), (n.flatShading = !0), n;
					})),
					(this.materialsFlatShadedBackSide = e.map((t) => {
						const n = this.cloneMaterial(t);
						return (n.uniforms = Object.assign({}, i.uniforms)), (n.flatShading = !0), (n.side = gn), n;
					})),
					(this.materialsFlatShadedDoubleSide = e.map((t) => {
						const n = this.cloneMaterial(t);
						return (n.uniforms = Object.assign({}, i.uniforms)), (n.flatShading = !0), (n.side = mn), n;
					}));
			}
		}
		render(i, e, t) {
			const n = i.shadowMap.enabled;
			if (((i.shadowMap.enabled = !1), Bm)) {
				const s = this.originalMaterials;
				(this.meshCount = 0), e.traverse(this.replaceMaterial), i.render(e, t);
				for (const r of s) r[0].material = r[1];
				this.meshCount !== s.size && s.clear();
			} else {
				const s = e.overrideMaterial;
				(e.overrideMaterial = this.material), i.render(e, t), (e.overrideMaterial = s);
			}
			i.shadowMap.enabled = n;
		}
		disposeMaterials() {
			if (this.material !== null) {
				const i = this.materials
					.concat(this.materialsBackSide)
					.concat(this.materialsDoubleSide)
					.concat(this.materialsFlatShaded)
					.concat(this.materialsFlatShadedBackSide)
					.concat(this.materialsFlatShadedDoubleSide);
				for (const e of i) e.dispose();
			}
		}
		dispose() {
			this.originalMaterials.clear(), this.disposeMaterials();
		}
		static get workaroundEnabled() {
			return Bm;
		}
		static set workaroundEnabled(i) {
			Bm = i;
		}
	},
	Hr = -1,
	Ni = class extends Hi {
		constructor(i, e = Hr, t = Hr, n = 1) {
			super(),
				(this.resizable = i),
				(this.baseSize = new ce(1, 1)),
				(this.preferredSize = new ce(e, t)),
				(this.target = this.preferredSize),
				(this.s = n),
				(this.effectiveSize = new ce()),
				this.addEventListener('change', () => this.updateEffectiveSize()),
				this.updateEffectiveSize();
		}
		updateEffectiveSize() {
			const i = this.baseSize,
				e = this.preferredSize,
				t = this.effectiveSize,
				n = this.scale;
			e.width !== Hr
				? (t.width = e.width)
				: e.height !== Hr
				? (t.width = Math.round(e.height * (i.width / Math.max(i.height, 1))))
				: (t.width = Math.round(i.width * n)),
				e.height !== Hr
					? (t.height = e.height)
					: e.width !== Hr
					? (t.height = Math.round(e.width / Math.max(i.width / Math.max(i.height, 1), 1)))
					: (t.height = Math.round(i.height * n));
		}
		get width() {
			return this.effectiveSize.width;
		}
		set width(i) {
			this.preferredWidth = i;
		}
		get height() {
			return this.effectiveSize.height;
		}
		set height(i) {
			this.preferredHeight = i;
		}
		getWidth() {
			return this.width;
		}
		getHeight() {
			return this.height;
		}
		get scale() {
			return this.s;
		}
		set scale(i) {
			this.s !== i &&
				((this.s = i),
				this.preferredSize.setScalar(Hr),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		getScale() {
			return this.scale;
		}
		setScale(i) {
			this.scale = i;
		}
		get baseWidth() {
			return this.baseSize.width;
		}
		set baseWidth(i) {
			this.baseSize.width !== i &&
				((this.baseSize.width = i),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		getBaseWidth() {
			return this.baseWidth;
		}
		setBaseWidth(i) {
			this.baseWidth = i;
		}
		get baseHeight() {
			return this.baseSize.height;
		}
		set baseHeight(i) {
			this.baseSize.height !== i &&
				((this.baseSize.height = i),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		getBaseHeight() {
			return this.baseHeight;
		}
		setBaseHeight(i) {
			this.baseHeight = i;
		}
		setBaseSize(i, e) {
			(this.baseSize.width !== i || this.baseSize.height !== e) &&
				(this.baseSize.set(i, e),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		get preferredWidth() {
			return this.preferredSize.width;
		}
		set preferredWidth(i) {
			this.preferredSize.width !== i &&
				((this.preferredSize.width = i),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		getPreferredWidth() {
			return this.preferredWidth;
		}
		setPreferredWidth(i) {
			this.preferredWidth = i;
		}
		get preferredHeight() {
			return this.preferredSize.height;
		}
		set preferredHeight(i) {
			this.preferredSize.height !== i &&
				((this.preferredSize.height = i),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		getPreferredHeight() {
			return this.preferredHeight;
		}
		setPreferredHeight(i) {
			this.preferredHeight = i;
		}
		setPreferredSize(i, e) {
			(this.preferredSize.width !== i || this.preferredSize.height !== e) &&
				(this.preferredSize.set(i, e),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height));
		}
		copy(i) {
			(this.s = i.scale),
				this.baseSize.set(i.baseWidth, i.baseHeight),
				this.preferredSize.set(i.preferredWidth, i.preferredHeight),
				this.dispatchEvent({ type: 'change' }),
				this.resizable.setSize(this.baseSize.width, this.baseSize.height);
		}
		static get AUTO_SIZE() {
			return Hr;
		}
	},
	uB = class extends Set {
		constructor(i, e = 10) {
			super(), (this.l = e), (this.exclusive = !1), i !== void 0 && this.set(i);
		}
		get layer() {
			return this.l;
		}
		set layer(i) {
			const e = this.l;
			for (const t of this) t.layers.disable(e), t.layers.enable(i);
			this.l = i;
		}
		getLayer() {
			return this.layer;
		}
		setLayer(i) {
			this.layer = i;
		}
		isExclusive() {
			return this.exclusive;
		}
		setExclusive(i) {
			this.exclusive = i;
		}
		clear() {
			const i = this.layer;
			for (const e of this) e.layers.disable(i);
			return super.clear();
		}
		set(i) {
			this.clear();
			for (const e of i) this.add(e);
			return this;
		}
		indexOf(i) {
			return this.has(i) ? 0 : -1;
		}
		add(i) {
			return this.exclusive ? i.layers.set(this.layer) : i.layers.enable(this.layer), super.add(i);
		}
		delete(i) {
			return this.has(i) && i.layers.disable(this.layer), super.delete(i);
		}
		toggle(i) {
			let e;
			return this.has(i) ? (this.delete(i), (e = !1)) : (this.add(i), (e = !0)), e;
		}
		setVisible(i) {
			for (const e of this) i ? e.layers.enable(0) : e.layers.disable(0);
			return this;
		}
	},
	ht = {
		SKIP: 9,
		SET: 30,
		ADD: 0,
		ALPHA: 1,
		AVERAGE: 2,
		COLOR: 3,
		COLOR_BURN: 4,
		COLOR_DODGE: 5,
		DARKEN: 6,
		DIFFERENCE: 7,
		DIVIDE: 8,
		DST: 9,
		EXCLUSION: 10,
		HARD_LIGHT: 11,
		HARD_MIX: 12,
		HUE: 13,
		INVERT: 14,
		INVERT_RGB: 15,
		LIGHTEN: 16,
		LINEAR_BURN: 17,
		LINEAR_DODGE: 18,
		LINEAR_LIGHT: 19,
		LUMINOSITY: 20,
		MULTIPLY: 21,
		NEGATION: 22,
		NORMAL: 23,
		OVERLAY: 24,
		PIN_LIGHT: 25,
		REFLECT: 26,
		SATURATION: 27,
		SCREEN: 28,
		SOFT_LIGHT: 29,
		SRC: 30,
		SUBTRACT: 31,
		VIVID_LIGHT: 32,
	},
	dB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}',
	pB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}',
	fB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}',
	mB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}',
	gB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}',
	vB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}',
	_B = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}',
	yB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}',
	xB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}',
	bB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}',
	wB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}',
	SB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}',
	MB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}',
	EB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}',
	TB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}',
	AB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}',
	CB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}',
	RB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}',
	PB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}',
	LB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}',
	IB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}',
	DB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}',
	OB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}',
	UB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}',
	NB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}',
	FB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}',
	BB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}',
	kB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}',
	zB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}',
	VB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}',
	HB = 'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}',
	GB =
		'vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}',
	WB = new Map([
		[ht.ADD, dB],
		[ht.ALPHA, pB],
		[ht.AVERAGE, fB],
		[ht.COLOR, mB],
		[ht.COLOR_BURN, gB],
		[ht.COLOR_DODGE, vB],
		[ht.DARKEN, _B],
		[ht.DIFFERENCE, yB],
		[ht.DIVIDE, xB],
		[ht.DST, null],
		[ht.EXCLUSION, bB],
		[ht.HARD_LIGHT, wB],
		[ht.HARD_MIX, SB],
		[ht.HUE, MB],
		[ht.INVERT, EB],
		[ht.INVERT_RGB, TB],
		[ht.LIGHTEN, AB],
		[ht.LINEAR_BURN, CB],
		[ht.LINEAR_DODGE, RB],
		[ht.LINEAR_LIGHT, PB],
		[ht.LUMINOSITY, LB],
		[ht.MULTIPLY, IB],
		[ht.NEGATION, DB],
		[ht.NORMAL, OB],
		[ht.OVERLAY, UB],
		[ht.PIN_LIGHT, NB],
		[ht.REFLECT, FB],
		[ht.SATURATION, BB],
		[ht.SCREEN, kB],
		[ht.SOFT_LIGHT, zB],
		[ht.SRC, VB],
		[ht.SUBTRACT, HB],
		[ht.VIVID_LIGHT, GB],
	]),
	XB = class extends Hi {
		constructor(i, e = 1) {
			super(), (this._blendFunction = i), (this.opacity = new yt(e));
		}
		getOpacity() {
			return this.opacity.value;
		}
		setOpacity(i) {
			this.opacity.value = i;
		}
		get blendFunction() {
			return this._blendFunction;
		}
		set blendFunction(i) {
			(this._blendFunction = i), this.dispatchEvent({ type: 'change' });
		}
		getBlendFunction() {
			return this.blendFunction;
		}
		setBlendFunction(i) {
			this.blendFunction = i;
		}
		getShaderCode() {
			return WB.get(this.blendFunction);
		}
	},
	i0 = { VERY_SMALL: 0, SMALL: 1, MEDIUM: 2, LARGE: 3, VERY_LARGE: 4, HUGE: 5 },
	qB =
		'#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}',
	YB =
		'uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}',
	jB = [
		new Float32Array([0, 0]),
		new Float32Array([0, 1, 1]),
		new Float32Array([0, 1, 1, 2]),
		new Float32Array([0, 1, 2, 2, 3]),
		new Float32Array([0, 1, 2, 3, 4, 4, 5]),
		new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
	],
	KB = class extends xn {
		constructor(i = new Pt()) {
			super({
				name: 'KawaseBlurMaterial',
				uniforms: { inputBuffer: new yt(null), texelSize: new yt(new Pt()), scale: new yt(1), kernel: new yt(0) },
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				fragmentShader: qB,
				vertexShader: YB,
			}),
				this.setTexelSize(i.x, i.y),
				(this.kernelSize = i0.MEDIUM);
		}
		set inputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		setInputBuffer(i) {
			this.inputBuffer = i;
		}
		get kernelSequence() {
			return jB[this.kernelSize];
		}
		get scale() {
			return this.uniforms.scale.value;
		}
		set scale(i) {
			this.uniforms.scale.value = i;
		}
		getScale() {
			return this.uniforms.scale.value;
		}
		setScale(i) {
			this.uniforms.scale.value = i;
		}
		getKernel() {
			return null;
		}
		get kernel() {
			return this.uniforms.kernel.value;
		}
		set kernel(i) {
			this.uniforms.kernel.value = i;
		}
		setKernel(i) {
			this.kernel = i;
		}
		setTexelSize(i, e) {
			this.uniforms.texelSize.value.set(i, e, i * 0.5, e * 0.5);
		}
		setSize(i, e) {
			const t = 1 / i,
				n = 1 / e;
			this.uniforms.texelSize.value.set(t, n, t * 0.5, n * 0.5);
		}
	},
	$B = class extends cs {
		constructor({
			kernelSize: i = i0.MEDIUM,
			resolutionScale: e = 0.5,
			width: t = Ni.AUTO_SIZE,
			height: n = Ni.AUTO_SIZE,
			resolutionX: s = t,
			resolutionY: r = n,
		} = {}) {
			super('KawaseBlurPass'),
				(this.renderTargetA = new yn(1, 1, { depthBuffer: !1 })),
				(this.renderTargetA.texture.name = 'Blur.Target.A'),
				(this.renderTargetB = this.renderTargetA.clone()),
				(this.renderTargetB.texture.name = 'Blur.Target.B');
			const o = (this.resolution = new Ni(this, s, r, e));
			o.addEventListener('change', (a) => this.setSize(o.baseWidth, o.baseHeight)),
				(this._blurMaterial = new KB()),
				(this._blurMaterial.kernelSize = i),
				(this.copyMaterial = new ST());
		}
		getResolution() {
			return this.resolution;
		}
		get blurMaterial() {
			return this._blurMaterial;
		}
		set blurMaterial(i) {
			this._blurMaterial = i;
		}
		get dithering() {
			return this.copyMaterial.dithering;
		}
		set dithering(i) {
			this.copyMaterial.dithering = i;
		}
		get kernelSize() {
			return this.blurMaterial.kernelSize;
		}
		set kernelSize(i) {
			this.blurMaterial.kernelSize = i;
		}
		get width() {
			return this.resolution.width;
		}
		set width(i) {
			this.resolution.preferredWidth = i;
		}
		get height() {
			return this.resolution.height;
		}
		set height(i) {
			this.resolution.preferredHeight = i;
		}
		get scale() {
			return this.blurMaterial.scale;
		}
		set scale(i) {
			this.blurMaterial.scale = i;
		}
		getScale() {
			return this.blurMaterial.scale;
		}
		setScale(i) {
			this.blurMaterial.scale = i;
		}
		getKernelSize() {
			return this.kernelSize;
		}
		setKernelSize(i) {
			this.kernelSize = i;
		}
		getResolutionScale() {
			return this.resolution.scale;
		}
		setResolutionScale(i) {
			this.resolution.scale = i;
		}
		render(i, e, t, n, s) {
			const r = this.scene,
				o = this.camera,
				a = this.renderTargetA,
				l = this.renderTargetB,
				c = this.blurMaterial,
				h = c.kernelSequence;
			let u = e;
			this.fullscreenMaterial = c;
			for (let d = 0, p = h.length; d < p; ++d) {
				const g = d & 1 ? l : a;
				(c.kernel = h[d]), (c.inputBuffer = u.texture), i.setRenderTarget(g), i.render(r, o), (u = g);
			}
			(this.fullscreenMaterial = this.copyMaterial),
				(this.copyMaterial.inputBuffer = u.texture),
				i.setRenderTarget(this.renderToScreen ? null : t),
				i.render(r, o);
		}
		setSize(i, e) {
			const t = this.resolution;
			t.setBaseSize(i, e);
			const n = t.width,
				s = t.height;
			this.renderTargetA.setSize(n, s), this.renderTargetB.setSize(n, s), this.blurMaterial.setSize(i, e);
		}
		initialize(i, e, t) {
			t !== void 0 &&
				((this.renderTargetA.texture.type = t),
				(this.renderTargetB.texture.type = t),
				t !== Vn
					? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'),
					  (this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'))
					: i !== null &&
					  i.outputColorSpace === ot &&
					  ((this.renderTargetA.texture.colorSpace = ot), (this.renderTargetB.texture.colorSpace = ot)));
		}
		static get AUTO_SIZE() {
			return Ni.AUTO_SIZE;
		}
	},
	ZB =
		'#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}',
	JB = class extends xn {
		constructor(i = !1, e = null) {
			super({
				name: 'LuminanceMaterial',
				defines: { THREE_REVISION: Co.replace(/\D+/g, '') },
				uniforms: { inputBuffer: new yt(null), threshold: new yt(0), smoothing: new yt(1), range: new yt(null) },
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				fragmentShader: ZB,
				vertexShader: t0,
			}),
				(this.colorOutput = i),
				(this.luminanceRange = e);
		}
		set inputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		setInputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		get threshold() {
			return this.uniforms.threshold.value;
		}
		set threshold(i) {
			this.smoothing > 0 || i > 0 ? (this.defines.THRESHOLD = '1') : delete this.defines.THRESHOLD,
				(this.uniforms.threshold.value = i);
		}
		getThreshold() {
			return this.threshold;
		}
		setThreshold(i) {
			this.threshold = i;
		}
		get smoothing() {
			return this.uniforms.smoothing.value;
		}
		set smoothing(i) {
			this.threshold > 0 || i > 0 ? (this.defines.THRESHOLD = '1') : delete this.defines.THRESHOLD,
				(this.uniforms.smoothing.value = i);
		}
		getSmoothingFactor() {
			return this.smoothing;
		}
		setSmoothingFactor(i) {
			this.smoothing = i;
		}
		get useThreshold() {
			return this.threshold > 0 || this.smoothing > 0;
		}
		set useThreshold(i) {}
		get colorOutput() {
			return this.defines.COLOR !== void 0;
		}
		set colorOutput(i) {
			i ? (this.defines.COLOR = '1') : delete this.defines.COLOR, (this.needsUpdate = !0);
		}
		isColorOutputEnabled(i) {
			return this.colorOutput;
		}
		setColorOutputEnabled(i) {
			this.colorOutput = i;
		}
		get useRange() {
			return this.luminanceRange !== null;
		}
		set useRange(i) {
			this.luminanceRange = null;
		}
		get luminanceRange() {
			return this.uniforms.range.value;
		}
		set luminanceRange(i) {
			i !== null ? (this.defines.RANGE = '1') : delete this.defines.RANGE, (this.uniforms.range.value = i), (this.needsUpdate = !0);
		}
		getLuminanceRange() {
			return this.luminanceRange;
		}
		setLuminanceRange(i) {
			this.luminanceRange = i;
		}
	},
	QB = class extends cs {
		constructor({
			renderTarget: i,
			luminanceRange: e,
			colorOutput: t,
			resolutionScale: n = 1,
			width: s = Ni.AUTO_SIZE,
			height: r = Ni.AUTO_SIZE,
			resolutionX: o = s,
			resolutionY: a = r,
		} = {}) {
			super('LuminancePass'),
				(this.fullscreenMaterial = new JB(t, e)),
				(this.needsSwap = !1),
				(this.renderTarget = i),
				this.renderTarget === void 0 &&
					((this.renderTarget = new yn(1, 1, { depthBuffer: !1 })), (this.renderTarget.texture.name = 'LuminancePass.Target'));
			const l = (this.resolution = new Ni(this, o, a, n));
			l.addEventListener('change', (c) => this.setSize(l.baseWidth, l.baseHeight));
		}
		get texture() {
			return this.renderTarget.texture;
		}
		getTexture() {
			return this.renderTarget.texture;
		}
		getResolution() {
			return this.resolution;
		}
		render(i, e, t, n, s) {
			const r = this.fullscreenMaterial;
			(r.inputBuffer = e.texture),
				i.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
				i.render(this.scene, this.camera);
		}
		setSize(i, e) {
			const t = this.resolution;
			t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height);
		}
		initialize(i, e, t) {
			t !== void 0 &&
				t !== Vn &&
				((this.renderTarget.texture.type = t), (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'));
		}
	},
	ek =
		'#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}',
	tk =
		'uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}',
	nk = class extends xn {
		constructor() {
			super({
				name: 'DownsamplingMaterial',
				uniforms: { inputBuffer: new yt(null), texelSize: new yt(new ce()) },
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				fragmentShader: ek,
				vertexShader: tk,
			});
		}
		set inputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		setSize(i, e) {
			this.uniforms.texelSize.value.set(1 / i, 1 / e);
		}
	},
	ik =
		'#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}',
	sk =
		'uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}',
	rk = class extends xn {
		constructor() {
			super({
				name: 'UpsamplingMaterial',
				uniforms: { inputBuffer: new yt(null), supportBuffer: new yt(null), texelSize: new yt(new ce()), radius: new yt(0.85) },
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				fragmentShader: ik,
				vertexShader: sk,
			});
		}
		set inputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		set supportBuffer(i) {
			this.uniforms.supportBuffer.value = i;
		}
		get radius() {
			return this.uniforms.radius.value;
		}
		set radius(i) {
			this.uniforms.radius.value = i;
		}
		setSize(i, e) {
			this.uniforms.texelSize.value.set(1 / i, 1 / e);
		}
	},
	ok = class extends cs {
		constructor() {
			super('MipmapBlurPass'),
				(this.needsSwap = !1),
				(this.renderTarget = new yn(1, 1, { depthBuffer: !1 })),
				(this.renderTarget.texture.name = 'Upsampling.Mipmap0'),
				(this.downsamplingMipmaps = []),
				(this.upsamplingMipmaps = []),
				(this.downsamplingMaterial = new nk()),
				(this.upsamplingMaterial = new rk()),
				(this.resolution = new ce());
		}
		get texture() {
			return this.renderTarget.texture;
		}
		get levels() {
			return this.downsamplingMipmaps.length;
		}
		set levels(i) {
			if (this.levels !== i) {
				const e = this.renderTarget;
				this.dispose(), (this.downsamplingMipmaps = []), (this.upsamplingMipmaps = []);
				for (let t = 0; t < i; ++t) {
					const n = e.clone();
					(n.texture.name = 'Downsampling.Mipmap' + t), this.downsamplingMipmaps.push(n);
				}
				this.upsamplingMipmaps.push(e);
				for (let t = 1, n = i - 1; t < n; ++t) {
					const s = e.clone();
					(s.texture.name = 'Upsampling.Mipmap' + t), this.upsamplingMipmaps.push(s);
				}
				this.setSize(this.resolution.x, this.resolution.y);
			}
		}
		get radius() {
			return this.upsamplingMaterial.radius;
		}
		set radius(i) {
			this.upsamplingMaterial.radius = i;
		}
		render(i, e, t, n, s) {
			const { scene: r, camera: o } = this,
				{ downsamplingMaterial: a, upsamplingMaterial: l } = this,
				{ downsamplingMipmaps: c, upsamplingMipmaps: h } = this;
			let u = e;
			this.fullscreenMaterial = a;
			for (let d = 0, p = c.length; d < p; ++d) {
				const g = c[d];
				a.setSize(u.width, u.height), (a.inputBuffer = u.texture), i.setRenderTarget(g), i.render(r, o), (u = g);
			}
			this.fullscreenMaterial = l;
			for (let d = h.length - 1; d >= 0; --d) {
				const p = h[d];
				l.setSize(u.width, u.height),
					(l.inputBuffer = u.texture),
					(l.supportBuffer = c[d].texture),
					i.setRenderTarget(p),
					i.render(r, o),
					(u = p);
			}
		}
		setSize(i, e) {
			const t = this.resolution;
			t.set(i, e);
			let n = t.width,
				s = t.height;
			for (let r = 0, o = this.downsamplingMipmaps.length; r < o; ++r)
				(n = Math.round(n * 0.5)),
					(s = Math.round(s * 0.5)),
					this.downsamplingMipmaps[r].setSize(n, s),
					r < this.upsamplingMipmaps.length && this.upsamplingMipmaps[r].setSize(n, s);
		}
		initialize(i, e, t) {
			if (t !== void 0) {
				const n = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
				for (const s of n) s.texture.type = t;
				if (t !== Vn)
					(this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1'),
						(this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1');
				else if (i !== null && i.outputColorSpace === ot) for (const s of n) s.texture.colorSpace = ot;
			}
		}
		dispose() {
			super.dispose();
			for (const i of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) i.dispose();
		}
	},
	ET = class extends Hi {
		constructor(
			i,
			e,
			{
				attributes: t = po.NONE,
				blendFunction: n = ht.NORMAL,
				defines: s = new Map(),
				uniforms: r = new Map(),
				extensions: o = null,
				vertexShader: a = null,
			} = {}
		) {
			super(),
				(this.name = i),
				(this.renderer = null),
				(this.attributes = t),
				(this.fragmentShader = e),
				(this.vertexShader = a),
				(this.defines = s),
				(this.uniforms = r),
				(this.extensions = o),
				(this.blendMode = new XB(n)),
				this.blendMode.addEventListener('change', (l) => this.setChanged()),
				(this._inputColorSpace = Es),
				(this._outputColorSpace = xs);
		}
		get inputColorSpace() {
			return this._inputColorSpace;
		}
		set inputColorSpace(i) {
			(this._inputColorSpace = i), this.setChanged();
		}
		get outputColorSpace() {
			return this._outputColorSpace;
		}
		set outputColorSpace(i) {
			(this._outputColorSpace = i), this.setChanged();
		}
		set mainScene(i) {}
		set mainCamera(i) {}
		getName() {
			return this.name;
		}
		setRenderer(i) {
			this.renderer = i;
		}
		getDefines() {
			return this.defines;
		}
		getUniforms() {
			return this.uniforms;
		}
		getExtensions() {
			return this.extensions;
		}
		getBlendMode() {
			return this.blendMode;
		}
		getAttributes() {
			return this.attributes;
		}
		setAttributes(i) {
			(this.attributes = i), this.setChanged();
		}
		getFragmentShader() {
			return this.fragmentShader;
		}
		setFragmentShader(i) {
			(this.fragmentShader = i), this.setChanged();
		}
		getVertexShader() {
			return this.vertexShader;
		}
		setVertexShader(i) {
			(this.vertexShader = i), this.setChanged();
		}
		setChanged() {
			this.dispatchEvent({ type: 'change' });
		}
		setDepthTexture(i, e = yr) {}
		update(i, e, t) {}
		setSize(i, e) {}
		initialize(i, e, t) {}
		dispose() {
			for (const i of Object.keys(this)) {
				const e = this[i];
				(e instanceof yn || e instanceof vn || e instanceof zt || e instanceof cs) && this[i].dispose();
			}
		}
	},
	ak =
		'#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}',
	lk = class extends ET {
		constructor({
			blendFunction: i = ht.SCREEN,
			luminanceThreshold: e = 0.9,
			luminanceSmoothing: t = 0.025,
			mipmapBlur: n = !1,
			intensity: s = 1,
			radius: r = 0.85,
			levels: o = 8,
			kernelSize: a = i0.LARGE,
			resolutionScale: l = 0.5,
			width: c = Ni.AUTO_SIZE,
			height: h = Ni.AUTO_SIZE,
			resolutionX: u = c,
			resolutionY: d = h,
		} = {}) {
			super('BloomEffect', ak, {
				blendFunction: i,
				uniforms: new Map([
					['map', new yt(null)],
					['intensity', new yt(s)],
				]),
			}),
				(this.renderTarget = new yn(1, 1, { depthBuffer: !1 })),
				(this.renderTarget.texture.name = 'Bloom.Target'),
				(this.blurPass = new $B({ kernelSize: a })),
				(this.luminancePass = new QB({ colorOutput: !0 })),
				(this.luminanceMaterial.threshold = e),
				(this.luminanceMaterial.smoothing = t),
				(this.mipmapBlurPass = new ok()),
				(this.mipmapBlurPass.enabled = n),
				(this.mipmapBlurPass.radius = r),
				(this.mipmapBlurPass.levels = o),
				(this.uniforms.get('map').value = n ? this.mipmapBlurPass.texture : this.renderTarget.texture);
			const p = (this.resolution = new Ni(this, u, d, l));
			p.addEventListener('change', (g) => this.setSize(p.baseWidth, p.baseHeight));
		}
		get texture() {
			return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
		}
		getTexture() {
			return this.texture;
		}
		getResolution() {
			return this.resolution;
		}
		getBlurPass() {
			return this.blurPass;
		}
		getLuminancePass() {
			return this.luminancePass;
		}
		get luminanceMaterial() {
			return this.luminancePass.fullscreenMaterial;
		}
		getLuminanceMaterial() {
			return this.luminancePass.fullscreenMaterial;
		}
		get width() {
			return this.resolution.width;
		}
		set width(i) {
			this.resolution.preferredWidth = i;
		}
		get height() {
			return this.resolution.height;
		}
		set height(i) {
			this.resolution.preferredHeight = i;
		}
		get dithering() {
			return this.blurPass.dithering;
		}
		set dithering(i) {
			this.blurPass.dithering = i;
		}
		get kernelSize() {
			return this.blurPass.kernelSize;
		}
		set kernelSize(i) {
			this.blurPass.kernelSize = i;
		}
		get distinction() {
			return console.warn(this.name, 'distinction was removed'), 1;
		}
		set distinction(i) {
			console.warn(this.name, 'distinction was removed');
		}
		get intensity() {
			return this.uniforms.get('intensity').value;
		}
		set intensity(i) {
			this.uniforms.get('intensity').value = i;
		}
		getIntensity() {
			return this.intensity;
		}
		setIntensity(i) {
			this.intensity = i;
		}
		getResolutionScale() {
			return this.resolution.scale;
		}
		setResolutionScale(i) {
			this.resolution.scale = i;
		}
		update(i, e, t) {
			const n = this.renderTarget,
				s = this.luminancePass;
			s.enabled
				? (s.render(i, e),
				  this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(i, s.renderTarget) : this.blurPass.render(i, s.renderTarget, n))
				: this.mipmapBlurPass.enabled
				? this.mipmapBlurPass.render(i, e)
				: this.blurPass.render(i, e, n);
		}
		setSize(i, e) {
			const t = this.resolution;
			t.setBaseSize(i, e),
				this.renderTarget.setSize(t.width, t.height),
				this.blurPass.resolution.copy(t),
				this.luminancePass.setSize(i, e),
				this.mipmapBlurPass.setSize(i, e);
		}
		initialize(i, e, t) {
			this.blurPass.initialize(i, e, t),
				this.luminancePass.initialize(i, e, t),
				this.mipmapBlurPass.initialize(i, e, t),
				t !== void 0 &&
					((this.renderTarget.texture.type = t),
					i !== null && i.outputColorSpace === ot && (this.renderTarget.texture.colorSpace = ot));
		}
	},
	ck = class extends cs {
		constructor(i, e = 'inputBuffer') {
			super('ShaderPass'), (this.fullscreenMaterial = i), (this.input = e);
		}
		setInput(i) {
			this.input = i;
		}
		render(i, e, t, n, s) {
			const r = this.fullscreenMaterial.uniforms;
			e !== null && r !== void 0 && r[this.input] !== void 0 && (r[this.input].value = e.texture),
				i.setRenderTarget(this.renderToScreen ? null : t),
				i.render(this.scene, this.camera);
		}
		initialize(i, e, t) {
			t !== void 0 && t !== Vn && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1');
		}
	},
	hk =
		'#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ONE_OVER_TWELVE 0.08333333333333333\nvarying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;vec4 fxaa(const in vec4 inputColor,const in vec2 uv){float lumaCenter=luminance(inputColor.rgb);float lumaDown=luminance(texture2D(inputBuffer,vUvDown).rgb);float lumaUp=luminance(texture2D(inputBuffer,vUvUp).rgb);float lumaLeft=luminance(texture2D(inputBuffer,vUvLeft).rgb);float lumaRight=luminance(texture2D(inputBuffer,vUvRight).rgb);float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return inputColor;}float lumaDownLeft=luminance(texture2D(inputBuffer,vUvDownLeft).rgb);float lumaUpRight=luminance(texture2D(inputBuffer,vUvUpRight).rgb);float lumaUpLeft=luminance(texture2D(inputBuffer,vUvUpLeft).rgb);float lumaDownRight=luminance(texture2D(inputBuffer,vUvDownRight).rgb);float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=(abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners));float edgeVertical=(abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners));bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal?texelSize.y:texelSize.x;float luma1=isHorizontal?lumaDown:lumaLeft;float luma2=isHorizontal?lumaUp:lumaRight;float gradient1=abs(luma1-lumaCenter);float gradient2=abs(luma2-lumaCenter);bool is1Steepest=gradient1>=gradient2;float gradientScaled=0.25*max(gradient1,gradient2);float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=uv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal?vec2(texelSize.x,0.0):vec2(0.0,texelSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);float lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<SAMPLES;++i){if(!reached1){lumaEnd1=luminance(texture2D(inputBuffer,uv1).rgb);lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=luminance(texture2D(inputBuffer,uv2).rgb);lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal?(uv.x-uv1.x):(uv.y-uv1.y);float distance2=isHorizontal?(uv2.x-uv.x):(uv2.y-uv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1?correctVariation1:correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation?pixelOffset:0.0;float lumaAverage=ONE_OVER_TWELVE*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=uv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(inputBuffer,finalUv);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=fxaa(inputColor,uv);}',
	uk =
		'varying vec2 vUvDown;varying vec2 vUvUp;varying vec2 vUvLeft;varying vec2 vUvRight;varying vec2 vUvDownLeft;varying vec2 vUvUpRight;varying vec2 vUvUpLeft;varying vec2 vUvDownRight;void mainSupport(const in vec2 uv){vUvDown=uv+vec2(0.0,-1.0)*texelSize;vUvUp=uv+vec2(0.0,1.0)*texelSize;vUvRight=uv+vec2(1.0,0.0)*texelSize;vUvLeft=uv+vec2(-1.0,0.0)*texelSize;vUvDownLeft=uv+vec2(-1.0,-1.0)*texelSize;vUvUpRight=uv+vec2(1.0,1.0)*texelSize;vUvUpLeft=uv+vec2(-1.0,1.0)*texelSize;vUvDownRight=uv+vec2(1.0,-1.0)*texelSize;}',
	dk = class extends ET {
		constructor({ blendFunction: i = ht.SRC } = {}) {
			super('FXAAEffect', hk, {
				vertexShader: uk,
				blendFunction: i,
				defines: new Map([
					['EDGE_THRESHOLD_MIN', '0.0312'],
					['EDGE_THRESHOLD_MAX', '0.125'],
					['SUBPIXEL_QUALITY', '0.75'],
					['SAMPLES', '12'],
				]),
			});
		}
		get minEdgeThreshold() {
			return Number(this.defines.get('EDGE_THRESHOLD_MIN'));
		}
		set minEdgeThreshold(i) {
			this.defines.set('EDGE_THRESHOLD_MIN', i.toFixed(12)), this.setChanged();
		}
		get maxEdgeThreshold() {
			return Number(this.defines.get('EDGE_THRESHOLD_MAX'));
		}
		set maxEdgeThreshold(i) {
			this.defines.set('EDGE_THRESHOLD_MAX', i.toFixed(12)), this.setChanged();
		}
		get subpixelQuality() {
			return Number(this.defines.get('SUBPIXEL_QUALITY'));
		}
		set subpixelQuality(i) {
			this.defines.set('SUBPIXEL_QUALITY', i.toFixed(12)), this.setChanged();
		}
		get samples() {
			return Number(this.defines.get('SAMPLES'));
		}
		set samples(i) {
			this.defines.set('SAMPLES', i.toFixed(0)), this.setChanged();
		}
	},
	oh = { DEFAULT: 0, KEEP_MAX_DEPTH: 1, DISCARD_MAX_DEPTH: 2 },
	pk =
		'#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;\n#else\nuniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;\n#endif\nuniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}varying vec2 vUv;void main(){vec2 depth;\n#if DEPTH_PACKING_0 == 3201\ndepth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));\n#else\ndepth.x=texture2D(depthBuffer0,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;\n#endif\n#endif\n#if DEPTH_PACKING_1 == 3201\ndepth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));\n#else\ndepth.y=texture2D(depthBuffer1,vUv).r;\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;\n#endif\n#endif\nbool isMaxDepth=(depth.x==1.0);\n#ifdef PERSPECTIVE_CAMERA\ndepth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);\n#endif\n#if DEPTH_TEST_STRATEGY == 0\nbool keep=depthTest(depth.x,depth.y);\n#elif DEPTH_TEST_STRATEGY == 1\nbool keep=isMaxDepth||depthTest(depth.x,depth.y);\n#else\nbool keep=!isMaxDepth&&depthTest(depth.x,depth.y);\n#endif\nif(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}',
	fk = class extends xn {
		constructor() {
			super({
				name: 'DepthMaskMaterial',
				defines: { DEPTH_EPSILON: '0.0001', DEPTH_PACKING_0: '0', DEPTH_PACKING_1: '0', DEPTH_TEST_STRATEGY: oh.KEEP_MAX_DEPTH },
				uniforms: {
					inputBuffer: new yt(null),
					depthBuffer0: new yt(null),
					depthBuffer1: new yt(null),
					cameraNearFar: new yt(new ce(1, 1)),
				},
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				fragmentShader: pk,
				vertexShader: t0,
			}),
				(this.depthMode = ep);
		}
		set depthBuffer0(i) {
			this.uniforms.depthBuffer0.value = i;
		}
		set depthPacking0(i) {
			(this.defines.DEPTH_PACKING_0 = i.toFixed(0)), (this.needsUpdate = !0);
		}
		setDepthBuffer0(i, e = yr) {
			(this.depthBuffer0 = i), (this.depthPacking0 = e);
		}
		set depthBuffer1(i) {
			this.uniforms.depthBuffer1.value = i;
		}
		set depthPacking1(i) {
			(this.defines.DEPTH_PACKING_1 = i.toFixed(0)), (this.needsUpdate = !0);
		}
		setDepthBuffer1(i, e = yr) {
			(this.depthBuffer1 = i), (this.depthPacking1 = e);
		}
		get maxDepthStrategy() {
			return Number(this.defines.DEPTH_TEST_STRATEGY);
		}
		set maxDepthStrategy(i) {
			(this.defines.DEPTH_TEST_STRATEGY = i.toFixed(0)), (this.needsUpdate = !0);
		}
		get keepFar() {
			return this.maxDepthStrategy;
		}
		set keepFar(i) {
			this.maxDepthStrategy = i ? oh.KEEP_MAX_DEPTH : oh.DISCARD_MAX_DEPTH;
		}
		getMaxDepthStrategy() {
			return this.maxDepthStrategy;
		}
		setMaxDepthStrategy(i) {
			this.maxDepthStrategy = i;
		}
		get epsilon() {
			return Number(this.defines.DEPTH_EPSILON);
		}
		set epsilon(i) {
			(this.defines.DEPTH_EPSILON = i.toFixed(16)), (this.needsUpdate = !0);
		}
		getEpsilon() {
			return this.epsilon;
		}
		setEpsilon(i) {
			this.epsilon = i;
		}
		get depthMode() {
			return Number(this.defines.DEPTH_MODE);
		}
		set depthMode(i) {
			let e;
			switch (i) {
				case l_:
					e = 'false';
					break;
				case c_:
					e = 'true';
					break;
				case vh:
					e = 'abs(d1 - d0) <= DEPTH_EPSILON';
					break;
				case Op:
					e = 'abs(d1 - d0) > DEPTH_EPSILON';
					break;
				case ep:
					e = 'd0 > d1';
					break;
				case jl:
					e = 'd0 >= d1';
					break;
				case h_:
					e = 'd0 <= d1';
					break;
				case u_:
				default:
					e = 'd0 < d1';
					break;
			}
			(this.defines.DEPTH_MODE = i.toFixed(0)), (this.defines['depthTest(d0, d1)'] = e), (this.needsUpdate = !0);
		}
		getDepthMode() {
			return this.depthMode;
		}
		setDepthMode(i) {
			this.depthMode = i;
		}
		adoptCameraSettings(i) {
			this.copyCameraSettings(i);
		}
		copyCameraSettings(i) {
			i &&
				(this.uniforms.cameraNearFar.value.set(i.near, i.far),
				i instanceof fn ? (this.defines.PERSPECTIVE_CAMERA = '1') : delete this.defines.PERSPECTIVE_CAMERA,
				(this.needsUpdate = !0));
		}
	},
	TT = class extends cs {
		constructor(i, e, t = null) {
			super('RenderPass', i, e),
				(this.needsSwap = !1),
				(this.clearPass = new n0()),
				(this.overrideMaterialManager = t === null ? null : new Wb(t)),
				(this.ignoreBackground = !1),
				(this.skipShadowMapUpdate = !1),
				(this.selection = null);
		}
		set mainScene(i) {
			this.scene = i;
		}
		set mainCamera(i) {
			this.camera = i;
		}
		get renderToScreen() {
			return super.renderToScreen;
		}
		set renderToScreen(i) {
			(super.renderToScreen = i), (this.clearPass.renderToScreen = i);
		}
		get overrideMaterial() {
			const i = this.overrideMaterialManager;
			return i !== null ? i.material : null;
		}
		set overrideMaterial(i) {
			const e = this.overrideMaterialManager;
			i !== null
				? e !== null
					? e.setMaterial(i)
					: (this.overrideMaterialManager = new Wb(i))
				: e !== null && (e.dispose(), (this.overrideMaterialManager = null));
		}
		getOverrideMaterial() {
			return this.overrideMaterial;
		}
		setOverrideMaterial(i) {
			this.overrideMaterial = i;
		}
		get clear() {
			return this.clearPass.enabled;
		}
		set clear(i) {
			this.clearPass.enabled = i;
		}
		getSelection() {
			return this.selection;
		}
		setSelection(i) {
			this.selection = i;
		}
		isBackgroundDisabled() {
			return this.ignoreBackground;
		}
		setBackgroundDisabled(i) {
			this.ignoreBackground = i;
		}
		isShadowMapDisabled() {
			return this.skipShadowMapUpdate;
		}
		setShadowMapDisabled(i) {
			this.skipShadowMapUpdate = i;
		}
		getClearPass() {
			return this.clearPass;
		}
		render(i, e, t, n, s) {
			const r = this.scene,
				o = this.camera,
				a = this.selection,
				l = o.layers.mask,
				c = r.background,
				h = i.shadowMap.autoUpdate,
				u = this.renderToScreen ? null : e;
			a !== null && o.layers.set(a.getLayer()),
				this.skipShadowMapUpdate && (i.shadowMap.autoUpdate = !1),
				(this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (r.background = null),
				this.clearPass.enabled && this.clearPass.render(i, e),
				i.setRenderTarget(u),
				this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(i, r, o) : i.render(r, o),
				(o.layers.mask = l),
				(r.background = c),
				(i.shadowMap.autoUpdate = h);
		}
	},
	mk = class extends cs {
		constructor(
			i,
			e,
			{
				renderTarget: t,
				resolutionScale: n = 1,
				width: s = Ni.AUTO_SIZE,
				height: r = Ni.AUTO_SIZE,
				resolutionX: o = s,
				resolutionY: a = r,
			} = {}
		) {
			super('DepthPass'), (this.needsSwap = !1), (this.renderPass = new TT(i, e, new qp({ depthPacking: zp })));
			const l = this.renderPass;
			(l.skipShadowMapUpdate = !0), (l.ignoreBackground = !0);
			const c = l.clearPass;
			(c.overrideClearColor = new Ee(16777215)),
				(c.overrideClearAlpha = 1),
				(this.renderTarget = t),
				this.renderTarget === void 0 &&
					((this.renderTarget = new yn(1, 1, { minFilter: It, magFilter: It })),
					(this.renderTarget.texture.name = 'DepthPass.Target'));
			const h = (this.resolution = new Ni(this, o, a, n));
			h.addEventListener('change', (u) => this.setSize(h.baseWidth, h.baseHeight));
		}
		set mainScene(i) {
			this.renderPass.mainScene = i;
		}
		set mainCamera(i) {
			this.renderPass.mainCamera = i;
		}
		get texture() {
			return this.renderTarget.texture;
		}
		getTexture() {
			return this.renderTarget.texture;
		}
		getResolution() {
			return this.resolution;
		}
		getResolutionScale() {
			return this.resolution.scale;
		}
		setResolutionScale(i) {
			this.resolution.scale = i;
		}
		render(i, e, t, n, s) {
			const r = this.renderToScreen ? null : this.renderTarget;
			this.renderPass.render(i, r);
		}
		setSize(i, e) {
			const t = this.resolution;
			t.setBaseSize(i, e), this.renderTarget.setSize(t.width, t.height);
		}
	},
	gk = class extends lk {
		constructor(i, e, t) {
			super(t),
				this.setAttributes(this.getAttributes() | po.DEPTH),
				(this.camera = e),
				(this.depthPass = new mk(i, e)),
				(this.clearPass = new n0(!0, !1, !1)),
				(this.clearPass.overrideClearColor = new Ee(0)),
				(this.depthMaskPass = new ck(new fk()));
			const n = this.depthMaskMaterial;
			n.copyCameraSettings(e),
				(n.depthBuffer1 = this.depthPass.texture),
				(n.depthPacking1 = zp),
				(n.depthMode = vh),
				(this.renderTargetMasked = new yn(1, 1, { depthBuffer: !1 })),
				(this.renderTargetMasked.texture.name = 'Bloom.Masked'),
				(this.selection = new uB()),
				(this.selection.layer = 11),
				(this._inverted = !1),
				(this._ignoreBackground = !1);
		}
		set mainScene(i) {
			this.depthPass.mainScene = i;
		}
		set mainCamera(i) {
			(this.camera = i), (this.depthPass.mainCamera = i), this.depthMaskMaterial.copyCameraSettings(i);
		}
		getSelection() {
			return this.selection;
		}
		get depthMaskMaterial() {
			return this.depthMaskPass.fullscreenMaterial;
		}
		get inverted() {
			return this._inverted;
		}
		set inverted(i) {
			(this._inverted = i), (this.depthMaskMaterial.depthMode = i ? Op : vh);
		}
		isInverted() {
			return this.inverted;
		}
		setInverted(i) {
			this.inverted = i;
		}
		get ignoreBackground() {
			return this._ignoreBackground;
		}
		set ignoreBackground(i) {
			(this._ignoreBackground = i), (this.depthMaskMaterial.maxDepthStrategy = i ? oh.DISCARD_MAX_DEPTH : oh.KEEP_MAX_DEPTH);
		}
		isBackgroundDisabled() {
			return this.ignoreBackground;
		}
		setBackgroundDisabled(i) {
			this.ignoreBackground = i;
		}
		setDepthTexture(i, e = yr) {
			(this.depthMaskMaterial.depthBuffer0 = i), (this.depthMaskMaterial.depthPacking0 = e);
		}
		update(i, e, t) {
			const n = this.camera,
				s = this.selection,
				r = this.inverted;
			let o = e;
			if (this.ignoreBackground || !r || s.size > 0) {
				const a = n.layers.mask;
				n.layers.set(s.layer),
					this.depthPass.render(i),
					(n.layers.mask = a),
					(o = this.renderTargetMasked),
					this.clearPass.render(i, o),
					this.depthMaskPass.render(i, e, o);
			}
			super.update(i, o, t);
		}
		setSize(i, e) {
			super.setSize(i, e), this.renderTargetMasked.setSize(i, e), this.depthPass.setSize(i, e);
		}
		initialize(i, e, t) {
			super.initialize(i, e, t),
				this.clearPass.initialize(i, e, t),
				this.depthPass.initialize(i, e, t),
				this.depthMaskPass.initialize(i, e, t),
				i !== null && i.capabilities.logarithmicDepthBuffer && (this.depthMaskPass.fullscreenMaterial.defines.LOG_DEPTH = '1'),
				t !== void 0 &&
					((this.renderTargetMasked.texture.type = t),
					i !== null && i.outputColorSpace === ot && (this.renderTargetMasked.texture.colorSpace = ot));
		}
	},
	vk =
		'#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}',
	_k =
		'uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}',
	yk = class extends xn {
		constructor(i, e, t, n, s = !1) {
			super({
				name: 'EffectMaterial',
				defines: { THREE_REVISION: Co.replace(/\D+/g, ''), DEPTH_PACKING: '0', ENCODE_OUTPUT: '1' },
				uniforms: {
					inputBuffer: new yt(null),
					depthBuffer: new yt(null),
					resolution: new yt(new ce()),
					texelSize: new yt(new ce()),
					cameraNear: new yt(0.3),
					cameraFar: new yt(1e3),
					aspect: new yt(1),
					time: new yt(0),
				},
				blending: jn,
				toneMapped: !1,
				depthWrite: !1,
				depthTest: !1,
				dithering: s,
			}),
				i && this.setShaderParts(i),
				e && this.setDefines(e),
				t && this.setUniforms(t),
				this.copyCameraSettings(n);
		}
		set inputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		setInputBuffer(i) {
			this.uniforms.inputBuffer.value = i;
		}
		get depthBuffer() {
			return this.uniforms.depthBuffer.value;
		}
		set depthBuffer(i) {
			this.uniforms.depthBuffer.value = i;
		}
		get depthPacking() {
			return Number(this.defines.DEPTH_PACKING);
		}
		set depthPacking(i) {
			(this.defines.DEPTH_PACKING = i.toFixed(0)), (this.needsUpdate = !0);
		}
		setDepthBuffer(i, e = yr) {
			(this.depthBuffer = i), (this.depthPacking = e);
		}
		setShaderData(i) {
			this.setShaderParts(i.shaderParts), this.setDefines(i.defines), this.setUniforms(i.uniforms), this.setExtensions(i.extensions);
		}
		setShaderParts(i) {
			return (
				(this.fragmentShader = vk
					.replace(Et.FRAGMENT_HEAD, i.get(Et.FRAGMENT_HEAD) || '')
					.replace(Et.FRAGMENT_MAIN_UV, i.get(Et.FRAGMENT_MAIN_UV) || '')
					.replace(Et.FRAGMENT_MAIN_IMAGE, i.get(Et.FRAGMENT_MAIN_IMAGE) || '')),
				(this.vertexShader = _k
					.replace(Et.VERTEX_HEAD, i.get(Et.VERTEX_HEAD) || '')
					.replace(Et.VERTEX_MAIN_SUPPORT, i.get(Et.VERTEX_MAIN_SUPPORT) || '')),
				(this.needsUpdate = !0),
				this
			);
		}
		setDefines(i) {
			for (const e of i.entries()) this.defines[e[0]] = e[1];
			return (this.needsUpdate = !0), this;
		}
		setUniforms(i) {
			for (const e of i.entries()) this.uniforms[e[0]] = e[1];
			return this;
		}
		setExtensions(i) {
			this.extensions = {};
			for (const e of i) this.extensions[e] = !0;
			return this;
		}
		get encodeOutput() {
			return this.defines.ENCODE_OUTPUT !== void 0;
		}
		set encodeOutput(i) {
			this.encodeOutput !== i &&
				(i ? (this.defines.ENCODE_OUTPUT = '1') : delete this.defines.ENCODE_OUTPUT, (this.needsUpdate = !0));
		}
		isOutputEncodingEnabled(i) {
			return this.encodeOutput;
		}
		setOutputEncodingEnabled(i) {
			this.encodeOutput = i;
		}
		get time() {
			return this.uniforms.time.value;
		}
		set time(i) {
			this.uniforms.time.value = i;
		}
		setDeltaTime(i) {
			this.uniforms.time.value += i;
		}
		adoptCameraSettings(i) {
			this.copyCameraSettings(i);
		}
		copyCameraSettings(i) {
			i &&
				((this.uniforms.cameraNear.value = i.near),
				(this.uniforms.cameraFar.value = i.far),
				i instanceof fn ? (this.defines.PERSPECTIVE_CAMERA = '1') : delete this.defines.PERSPECTIVE_CAMERA,
				(this.needsUpdate = !0));
		}
		setSize(i, e) {
			const t = this.uniforms;
			t.resolution.value.set(i, e), t.texelSize.value.set(1 / i, 1 / e), (t.aspect.value = i / e);
		}
		static get Section() {
			return Et;
		}
	};
function Xb(i, e, t) {
	for (const n of e) {
		const s = '$1' + i + n.charAt(0).toUpperCase() + n.slice(1),
			r = new RegExp('([^\\.])(\\b' + n + '\\b)', 'g');
		for (const o of t.entries()) o[1] !== null && t.set(o[0], o[1].replace(r, s));
	}
}
function xk(i, e, t) {
	let n = e.getFragmentShader(),
		s = e.getVertexShader();
	const r = n !== void 0 && /mainImage/.test(n),
		o = n !== void 0 && /mainUv/.test(n);
	if (((t.attributes |= e.getAttributes()), n === void 0)) throw new Error('Missing fragment shader ('.concat(e.name, ')'));
	if (o && t.attributes & po.CONVOLUTION)
		throw new Error('Effects that transform UVs are incompatible with convolution effects ('.concat(e.name, ')'));
	if (!r && !o) throw new Error('Could not find mainImage or mainUv function ('.concat(e.name, ')'));
	{
		const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
			l = t.shaderParts;
		let c = l.get(Et.FRAGMENT_HEAD) || '',
			h = l.get(Et.FRAGMENT_MAIN_UV) || '',
			u = l.get(Et.FRAGMENT_MAIN_IMAGE) || '',
			d = l.get(Et.VERTEX_HEAD) || '',
			p = l.get(Et.VERTEX_MAIN_SUPPORT) || '';
		const g = new Set(),
			v = new Set();
		if ((o && ((h += '	'.concat(i, 'MainUv(UV);\n')), (t.uvTransformation = !0)), s !== null && /mainSupport/.test(s))) {
			const y = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
			(p += '	'.concat(i, 'MainSupport(')), (p += y ? 'vUv);\n' : ');\n');
			for (const _ of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
				for (const x of _[1].split(/\s*,\s*/)) t.varyings.add(x), g.add(x), v.add(x);
			for (const _ of s.matchAll(a)) v.add(_[1]);
		}
		for (const y of n.matchAll(a)) v.add(y[1]);
		for (const y of e.defines.keys()) v.add(y.replace(/\([\w\s,]*\)/g, ''));
		for (const y of e.uniforms.keys()) v.add(y);
		v.delete('while'),
			v.delete('for'),
			v.delete('if'),
			e.uniforms.forEach((y, _) => t.uniforms.set(i + _.charAt(0).toUpperCase() + _.slice(1), y)),
			e.defines.forEach((y, _) => t.defines.set(i + _.charAt(0).toUpperCase() + _.slice(1), y));
		const m = new Map([
			['fragment', n],
			['vertex', s],
		]);
		Xb(i, v, t.defines), Xb(i, v, m), (n = m.get('fragment')), (s = m.get('vertex'));
		const f = e.blendMode;
		if ((t.blendModes.set(f.blendFunction, f), r)) {
			e.inputColorSpace !== null &&
				e.inputColorSpace !== t.colorSpace &&
				(u += e.inputColorSpace === ot ? 'color0 = sRGBTransferOETF(color0);\n	' : 'color0 = sRGBToLinear(color0);\n	'),
				e.outputColorSpace !== xs
					? (t.colorSpace = e.outputColorSpace)
					: e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
			const y = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
			(u += ''.concat(i, 'MainImage(color0, UV, ')),
				t.attributes & po.DEPTH && y.test(n) && ((u += 'depth, '), (t.readDepth = !0)),
				(u += 'color1);\n	');
			const _ = i + 'BlendOpacity';
			t.uniforms.set(_, f.opacity),
				(u += 'color0 = blend'.concat(f.blendFunction, '(color0, color1, ').concat(_, ');\n\n	')),
				(c += 'uniform float '.concat(_, ';\n\n'));
		}
		if (
			((c += n + '\n'),
			s !== null && (d += s + '\n'),
			l.set(Et.FRAGMENT_HEAD, c),
			l.set(Et.FRAGMENT_MAIN_UV, h),
			l.set(Et.FRAGMENT_MAIN_IMAGE, u),
			l.set(Et.VERTEX_HEAD, d),
			l.set(Et.VERTEX_MAIN_SUPPORT, p),
			e.extensions !== null)
		)
			for (const y of e.extensions) t.extensions.add(y);
	}
}
var bk = class extends cs {
	constructor(i, ...e) {
		super('EffectPass'),
			(this.fullscreenMaterial = new yk(null, null, null, i)),
			(this.listener = (t) => this.handleEvent(t)),
			(this.effects = []),
			this.setEffects(e),
			(this.skipRendering = !1),
			(this.minTime = 1),
			(this.maxTime = Number.POSITIVE_INFINITY),
			(this.timeScale = 1);
	}
	set mainScene(i) {
		for (const e of this.effects) e.mainScene = i;
	}
	set mainCamera(i) {
		this.fullscreenMaterial.copyCameraSettings(i);
		for (const e of this.effects) e.mainCamera = i;
	}
	get encodeOutput() {
		return this.fullscreenMaterial.encodeOutput;
	}
	set encodeOutput(i) {
		this.fullscreenMaterial.encodeOutput = i;
	}
	get dithering() {
		return this.fullscreenMaterial.dithering;
	}
	set dithering(i) {
		const e = this.fullscreenMaterial;
		(e.dithering = i), (e.needsUpdate = !0);
	}
	setEffects(i) {
		for (const e of this.effects) e.removeEventListener('change', this.listener);
		this.effects = i.sort((e, t) => t.attributes - e.attributes);
		for (const e of this.effects) e.addEventListener('change', this.listener);
	}
	updateMaterial() {
		const i = new hB();
		let e = 0;
		for (const o of this.effects)
			if (o.blendMode.blendFunction === ht.DST) i.attributes |= o.getAttributes() & po.DEPTH;
			else {
				if (i.attributes & o.getAttributes() & po.CONVOLUTION)
					throw new Error('Convolution effects cannot be merged ('.concat(o.name, ')'));
				xk('e' + e++, o, i);
			}
		let t = i.shaderParts.get(Et.FRAGMENT_HEAD),
			n = i.shaderParts.get(Et.FRAGMENT_MAIN_IMAGE),
			s = i.shaderParts.get(Et.FRAGMENT_MAIN_UV);
		const r = /\bblend\b/g;
		for (const o of i.blendModes.values()) t += o.getShaderCode().replace(r, 'blend'.concat(o.blendFunction)) + '\n';
		i.attributes & po.DEPTH
			? (i.readDepth && (n = 'float depth = readDepth(UV);\n\n	' + n), (this.needsDepthTexture = this.getDepthTexture() === null))
			: (this.needsDepthTexture = !1),
			i.colorSpace === ot && (n += 'color0 = sRGBToLinear(color0);\n	'),
			i.uvTransformation
				? ((s = 'vec2 transformedUv = vUv;\n' + s), i.defines.set('UV', 'transformedUv'))
				: i.defines.set('UV', 'vUv'),
			i.shaderParts.set(Et.FRAGMENT_HEAD, t),
			i.shaderParts.set(Et.FRAGMENT_MAIN_IMAGE, n),
			i.shaderParts.set(Et.FRAGMENT_MAIN_UV, s);
		for (const [o, a] of i.shaderParts) a !== null && i.shaderParts.set(o, a.trim().replace(/^#/, '\n#'));
		(this.skipRendering = e === 0), (this.needsSwap = !this.skipRendering), this.fullscreenMaterial.setShaderData(i);
	}
	recompile() {
		this.updateMaterial();
	}
	getDepthTexture() {
		return this.fullscreenMaterial.depthBuffer;
	}
	setDepthTexture(i, e = yr) {
		(this.fullscreenMaterial.depthBuffer = i), (this.fullscreenMaterial.depthPacking = e);
		for (const t of this.effects) t.setDepthTexture(i, e);
	}
	render(i, e, t, n, s) {
		for (const r of this.effects) r.update(i, e, n);
		if (!this.skipRendering || this.renderToScreen) {
			const r = this.fullscreenMaterial;
			(r.inputBuffer = e.texture),
				(r.time += n * this.timeScale),
				i.setRenderTarget(this.renderToScreen ? null : t),
				i.render(this.scene, this.camera);
		}
	}
	setSize(i, e) {
		this.fullscreenMaterial.setSize(i, e);
		for (const t of this.effects) t.setSize(i, e);
	}
	initialize(i, e, t) {
		this.renderer = i;
		for (const n of this.effects) n.initialize(i, e, t);
		this.updateMaterial(), t !== void 0 && t !== Vn && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = '1');
	}
	dispose() {
		super.dispose();
		for (const i of this.effects) i.removeEventListener('change', this.listener), i.dispose();
	}
	handleEvent(i) {
		switch (i.type) {
			case 'change':
				this.recompile();
				break;
		}
	}
};
/*! Tweakpane 4.0.4 (c) 2016 cocopon, licensed under the MIT license. */ function qt(i) {
	return i == null;
}
function s0(i) {
	return i !== null && typeof i == 'object';
}
function pv(i) {
	return i !== null && typeof i == 'object';
}
function wk(i, e) {
	if (i.length !== e.length) return !1;
	for (let t = 0; t < i.length; t++) if (i[t] !== e[t]) return !1;
	return !0;
}
function Ia(i, e) {
	return Array.from(new Set([...Object.keys(i), ...Object.keys(e)])).reduce((n, s) => {
		const r = i[s],
			o = e[s];
		return pv(r) && pv(o)
			? Object.assign(Object.assign({}, n), { [s]: Ia(r, o) })
			: Object.assign(Object.assign({}, n), { [s]: s in e ? o : r });
	}, {});
}
function r0(i) {
	return s0(i) ? 'target' in i : !1;
}
const Sk = {
	alreadydisposed: () => 'View has been already disposed',
	invalidparams: (i) => "Invalid parameters for '".concat(i.name, "'"),
	nomatchingcontroller: (i) => "No matching controller for '".concat(i.key, "'"),
	nomatchingview: (i) => "No matching view for '".concat(JSON.stringify(i.params), "'"),
	notbindable: () => 'Value is not bindable',
	notcompatible: (i) => "Not compatible with  plugin '".concat(i.id, "'"),
	propertynotfound: (i) => "Property '".concat(i.name, "' not found"),
	shouldneverhappen: () => 'This error should never happen',
};
class cn {
	static alreadyDisposed() {
		return new cn({ type: 'alreadydisposed' });
	}
	static notBindable() {
		return new cn({ type: 'notbindable' });
	}
	static notCompatible(e, t) {
		return new cn({ type: 'notcompatible', context: { id: ''.concat(e, '.').concat(t) } });
	}
	static propertyNotFound(e) {
		return new cn({ type: 'propertynotfound', context: { name: e } });
	}
	static shouldNeverHappen() {
		return new cn({ type: 'shouldneverhappen' });
	}
	constructor(e) {
		var t;
		(this.message = (t = Sk[e.type](e.context)) !== null && t !== void 0 ? t : 'Unexpected error'),
			(this.name = this.constructor.name),
			(this.stack = new Error(this.message).stack),
			(this.type = e.type);
	}
	toString() {
		return this.message;
	}
}
class op {
	constructor(e, t) {
		(this.obj_ = e), (this.key = t);
	}
	static isBindable(e) {
		return !(e === null || (typeof e != 'object' && typeof e != 'function'));
	}
	read() {
		return this.obj_[this.key];
	}
	write(e) {
		this.obj_[this.key] = e;
	}
	writeProperty(e, t) {
		const n = this.read();
		if (!op.isBindable(n)) throw cn.notBindable();
		if (!(e in n)) throw cn.propertyNotFound(e);
		n[e] = t;
	}
}
class Mn {
	constructor() {
		this.observers_ = {};
	}
	on(e, t, n) {
		var s;
		let r = this.observers_[e];
		return (
			r || (r = this.observers_[e] = []),
			r.push({ handler: t, key: (s = n == null ? void 0 : n.key) !== null && s !== void 0 ? s : t }),
			this
		);
	}
	off(e, t) {
		const n = this.observers_[e];
		return n && (this.observers_[e] = n.filter((s) => s.key !== t)), this;
	}
	emit(e, t) {
		const n = this.observers_[e];
		n &&
			n.forEach((s) => {
				s.handler(t);
			});
	}
}
class Mk {
	constructor(e, t) {
		var n;
		(this.constraint_ = t == null ? void 0 : t.constraint),
			(this.equals_ = (n = t == null ? void 0 : t.equals) !== null && n !== void 0 ? n : (s, r) => s === r),
			(this.emitter = new Mn()),
			(this.rawValue_ = e);
	}
	get constraint() {
		return this.constraint_;
	}
	get rawValue() {
		return this.rawValue_;
	}
	set rawValue(e) {
		this.setRawValue(e, { forceEmit: !1, last: !0 });
	}
	setRawValue(e, t) {
		const n = t != null ? t : { forceEmit: !1, last: !0 },
			s = this.constraint_ ? this.constraint_.constrain(e) : e,
			r = this.rawValue_;
		(this.equals_(r, s) && !n.forceEmit) ||
			(this.emitter.emit('beforechange', { sender: this }),
			(this.rawValue_ = s),
			this.emitter.emit('change', { options: n, previousRawValue: r, rawValue: s, sender: this }));
	}
}
class Ek {
	constructor(e) {
		(this.emitter = new Mn()), (this.value_ = e);
	}
	get rawValue() {
		return this.value_;
	}
	set rawValue(e) {
		this.setRawValue(e, { forceEmit: !1, last: !0 });
	}
	setRawValue(e, t) {
		const n = t != null ? t : { forceEmit: !1, last: !0 },
			s = this.value_;
		(s === e && !n.forceEmit) ||
			(this.emitter.emit('beforechange', { sender: this }),
			(this.value_ = e),
			this.emitter.emit('change', { options: n, previousRawValue: s, rawValue: this.value_, sender: this }));
	}
}
class Tk {
	constructor(e) {
		(this.emitter = new Mn()),
			(this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this)),
			(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.value_ = e),
			this.value_.emitter.on('beforechange', this.onValueBeforeChange_),
			this.value_.emitter.on('change', this.onValueChange_);
	}
	get rawValue() {
		return this.value_.rawValue;
	}
	onValueBeforeChange_(e) {
		this.emitter.emit('beforechange', Object.assign(Object.assign({}, e), { sender: this }));
	}
	onValueChange_(e) {
		this.emitter.emit('change', Object.assign(Object.assign({}, e), { sender: this }));
	}
}
function Jt(i, e) {
	const t = e == null ? void 0 : e.constraint,
		n = e == null ? void 0 : e.equals;
	return !t && !n ? new Ek(i) : new Mk(i, e);
}
function Ak(i) {
	return [
		new Tk(i),
		(e, t) => {
			i.setRawValue(e, t);
		},
	];
}
class ut {
	constructor(e) {
		(this.emitter = new Mn()), (this.valMap_ = e);
		for (const t in this.valMap_)
			this.valMap_[t].emitter.on('change', () => {
				this.emitter.emit('change', { key: t, sender: this });
			});
	}
	static createCore(e) {
		return Object.keys(e).reduce((n, s) => Object.assign(n, { [s]: Jt(e[s]) }), {});
	}
	static fromObject(e) {
		const t = this.createCore(e);
		return new ut(t);
	}
	get(e) {
		return this.valMap_[e].rawValue;
	}
	set(e, t) {
		this.valMap_[e].rawValue = t;
	}
	value(e) {
		return this.valMap_[e];
	}
}
class au {
	constructor(e) {
		this.values = ut.fromObject({ max: e.max, min: e.min });
	}
	constrain(e) {
		const t = this.values.get('max'),
			n = this.values.get('min');
		return Math.min(Math.max(e, n), t);
	}
}
class Ck {
	constructor(e) {
		this.values = ut.fromObject({ max: e.max, min: e.min });
	}
	constrain(e) {
		const t = this.values.get('max'),
			n = this.values.get('min');
		let s = e;
		return qt(n) || (s = Math.max(s, n)), qt(t) || (s = Math.min(s, t)), s;
	}
}
class Rk {
	constructor(e, t = 0) {
		(this.step = e), (this.origin = t);
	}
	constrain(e) {
		const t = this.origin % this.step,
			n = Math.round((e - t) / this.step);
		return t + n * this.step;
	}
}
class Pk {
	constructor(e) {
		this.text = e;
	}
	evaluate() {
		return Number(this.text);
	}
	toString() {
		return this.text;
	}
}
const Lk = {
	'**': (i, e) => Math.pow(i, e),
	'*': (i, e) => i * e,
	'/': (i, e) => i / e,
	'%': (i, e) => i % e,
	'+': (i, e) => i + e,
	'-': (i, e) => i - e,
	'<<': (i, e) => i << e,
	'>>': (i, e) => i >> e,
	'>>>': (i, e) => i >>> e,
	'&': (i, e) => i & e,
	'^': (i, e) => i ^ e,
	'|': (i, e) => i | e,
};
class Ik {
	constructor(e, t, n) {
		(this.left = t), (this.operator = e), (this.right = n);
	}
	evaluate() {
		const e = Lk[this.operator];
		if (!e) throw new Error("unexpected binary operator: '".concat(this.operator));
		return e(this.left.evaluate(), this.right.evaluate());
	}
	toString() {
		return ['b(', this.left.toString(), this.operator, this.right.toString(), ')'].join(' ');
	}
}
const Dk = { '+': (i) => i, '-': (i) => -i, '~': (i) => ~i };
class Ok {
	constructor(e, t) {
		(this.operator = e), (this.expression = t);
	}
	evaluate() {
		const e = Dk[this.operator];
		if (!e) throw new Error("unexpected unary operator: '".concat(this.operator));
		return e(this.expression.evaluate());
	}
	toString() {
		return ['u(', this.operator, this.expression.toString(), ')'].join(' ');
	}
}
function o0(i) {
	return (e, t) => {
		for (let n = 0; n < i.length; n++) {
			const s = i[n](e, t);
			if (s !== '') return s;
		}
		return '';
	};
}
function Uh(i, e) {
	var t;
	const n = i.substr(e).match(/^\s+/);
	return (t = n && n[0]) !== null && t !== void 0 ? t : '';
}
function Uk(i, e) {
	const t = i.substr(e, 1);
	return t.match(/^[1-9]$/) ? t : '';
}
function Nh(i, e) {
	var t;
	const n = i.substr(e).match(/^[0-9]+/);
	return (t = n && n[0]) !== null && t !== void 0 ? t : '';
}
function Nk(i, e) {
	const t = Nh(i, e);
	if (t !== '') return t;
	const n = i.substr(e, 1);
	if (((e += 1), n !== '-' && n !== '+')) return '';
	const s = Nh(i, e);
	return s === '' ? '' : n + s;
}
function a0(i, e) {
	const t = i.substr(e, 1);
	if (((e += 1), t.toLowerCase() !== 'e')) return '';
	const n = Nk(i, e);
	return n === '' ? '' : t + n;
}
function AT(i, e) {
	const t = i.substr(e, 1);
	if (t === '0') return t;
	const n = Uk(i, e);
	return (e += n.length), n === '' ? '' : n + Nh(i, e);
}
function Fk(i, e) {
	const t = AT(i, e);
	if (((e += t.length), t === '')) return '';
	const n = i.substr(e, 1);
	if (((e += n.length), n !== '.')) return '';
	const s = Nh(i, e);
	return (e += s.length), t + n + s + a0(i, e);
}
function Bk(i, e) {
	const t = i.substr(e, 1);
	if (((e += t.length), t !== '.')) return '';
	const n = Nh(i, e);
	return (e += n.length), n === '' ? '' : t + n + a0(i, e);
}
function kk(i, e) {
	const t = AT(i, e);
	return (e += t.length), t === '' ? '' : t + a0(i, e);
}
const zk = o0([Fk, Bk, kk]);
function Vk(i, e) {
	var t;
	const n = i.substr(e).match(/^[01]+/);
	return (t = n && n[0]) !== null && t !== void 0 ? t : '';
}
function Hk(i, e) {
	const t = i.substr(e, 2);
	if (((e += t.length), t.toLowerCase() !== '0b')) return '';
	const n = Vk(i, e);
	return n === '' ? '' : t + n;
}
function Gk(i, e) {
	var t;
	const n = i.substr(e).match(/^[0-7]+/);
	return (t = n && n[0]) !== null && t !== void 0 ? t : '';
}
function Wk(i, e) {
	const t = i.substr(e, 2);
	if (((e += t.length), t.toLowerCase() !== '0o')) return '';
	const n = Gk(i, e);
	return n === '' ? '' : t + n;
}
function Xk(i, e) {
	var t;
	const n = i.substr(e).match(/^[0-9a-f]+/i);
	return (t = n && n[0]) !== null && t !== void 0 ? t : '';
}
function qk(i, e) {
	const t = i.substr(e, 2);
	if (((e += t.length), t.toLowerCase() !== '0x')) return '';
	const n = Xk(i, e);
	return n === '' ? '' : t + n;
}
const Yk = o0([Hk, Wk, qk]),
	jk = o0([Yk, zk]);
function Kk(i, e) {
	const t = jk(i, e);
	return (e += t.length), t === '' ? null : { evaluable: new Pk(t), cursor: e };
}
function $k(i, e) {
	const t = i.substr(e, 1);
	if (((e += t.length), t !== '(')) return null;
	const n = RT(i, e);
	if (!n) return null;
	(e = n.cursor), (e += Uh(i, e).length);
	const s = i.substr(e, 1);
	return (e += s.length), s !== ')' ? null : { evaluable: n.evaluable, cursor: e };
}
function Zk(i, e) {
	var t;
	return (t = Kk(i, e)) !== null && t !== void 0 ? t : $k(i, e);
}
function CT(i, e) {
	const t = Zk(i, e);
	if (t) return t;
	const n = i.substr(e, 1);
	if (((e += n.length), n !== '+' && n !== '-' && n !== '~')) return null;
	const s = CT(i, e);
	return s ? ((e = s.cursor), { cursor: e, evaluable: new Ok(n, s.evaluable) }) : null;
}
function Jk(i, e, t) {
	t += Uh(e, t).length;
	const n = i.filter((s) => e.startsWith(s, t))[0];
	return n ? ((t += n.length), (t += Uh(e, t).length), { cursor: t, operator: n }) : null;
}
function Qk(i, e) {
	return (t, n) => {
		const s = i(t, n);
		if (!s) return null;
		n = s.cursor;
		let r = s.evaluable;
		for (;;) {
			const o = Jk(e, t, n);
			if (!o) break;
			n = o.cursor;
			const a = i(t, n);
			if (!a) return null;
			(n = a.cursor), (r = new Ik(o.operator, r, a.evaluable));
		}
		return r ? { cursor: n, evaluable: r } : null;
	};
}
const ez = [['**'], ['*', '/', '%'], ['+', '-'], ['<<', '>>>', '>>'], ['&'], ['^'], ['|']].reduce((i, e) => Qk(i, e), CT);
function RT(i, e) {
	return (e += Uh(i, e).length), ez(i, e);
}
function tz(i) {
	const e = RT(i, 0);
	return !e || e.cursor + Uh(i, e.cursor).length !== i.length ? null : e.evaluable;
}
function br(i) {
	var e;
	const t = tz(i);
	return (e = t == null ? void 0 : t.evaluate()) !== null && e !== void 0 ? e : null;
}
function PT(i) {
	if (typeof i == 'number') return i;
	if (typeof i == 'string') {
		const e = br(i);
		if (!qt(e)) return e;
	}
	return 0;
}
function nz(i) {
	return String(i);
}
function Mi(i) {
	return (e) => e.toFixed(Math.max(Math.min(i, 20), 0));
}
function Dt(i, e, t, n, s) {
	const r = (i - e) / (t - e);
	return n + r * (s - n);
}
function qb(i) {
	return String(i.toFixed(10)).split('.')[1].replace(/0+$/, '').length;
}
function Tn(i, e, t) {
	return Math.min(Math.max(i, e), t);
}
function LT(i, e) {
	return ((i % e) + e) % e;
}
function iz(i, e) {
	return qt(i.step) ? Math.max(qb(e), 2) : qb(i.step);
}
function IT(i) {
	var e;
	return (e = i.step) !== null && e !== void 0 ? e : 1;
}
function DT(i, e) {
	var t;
	const n = Math.abs((t = i.step) !== null && t !== void 0 ? t : e);
	return n === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(n)) - 1);
}
function OT(i, e) {
	return qt(i.step) ? null : new Rk(i.step, e);
}
function UT(i) {
	return !qt(i.max) && !qt(i.min)
		? new au({ max: i.max, min: i.min })
		: !qt(i.max) || !qt(i.min)
		? new Ck({ max: i.max, min: i.min })
		: null;
}
function NT(i, e) {
	var t, n, s;
	return {
		formatter: (t = i.format) !== null && t !== void 0 ? t : Mi(iz(i, e)),
		keyScale: (n = i.keyScale) !== null && n !== void 0 ? n : IT(i),
		pointerScale: (s = i.pointerScale) !== null && s !== void 0 ? s : DT(i, e),
	};
}
function FT(i) {
	return {
		format: i.optional.function,
		keyScale: i.optional.number,
		max: i.optional.number,
		min: i.optional.number,
		pointerScale: i.optional.number,
		step: i.optional.number,
	};
}
function l0(i) {
	return { constraint: i.constraint, textProps: ut.fromObject(NT(i.params, i.initialValue)) };
}
class Xa {
	constructor(e) {
		this.controller = e;
	}
	get element() {
		return this.controller.view.element;
	}
	get disabled() {
		return this.controller.viewProps.get('disabled');
	}
	set disabled(e) {
		this.controller.viewProps.set('disabled', e);
	}
	get hidden() {
		return this.controller.viewProps.get('hidden');
	}
	set hidden(e) {
		this.controller.viewProps.set('hidden', e);
	}
	dispose() {
		this.controller.viewProps.set('disposed', !0);
	}
	importState(e) {
		return this.controller.importState(e);
	}
	exportState() {
		return this.controller.exportState();
	}
}
class _f {
	constructor(e) {
		this.target = e;
	}
}
class lu extends _f {
	constructor(e, t, n) {
		super(e), (this.value = t), (this.last = n != null ? n : !0);
	}
}
class sz extends _f {
	constructor(e, t) {
		super(e), (this.expanded = t);
	}
}
class rz extends _f {
	constructor(e, t) {
		super(e), (this.index = t);
	}
}
class oz extends _f {
	constructor(e, t) {
		super(e), (this.native = t);
	}
}
class Fh extends Xa {
	constructor(e) {
		super(e),
			(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.emitter_ = new Mn()),
			this.controller.value.emitter.on('change', this.onValueChange_);
	}
	get label() {
		return this.controller.labelController.props.get('label');
	}
	set label(e) {
		this.controller.labelController.props.set('label', e);
	}
	get key() {
		return this.controller.value.binding.target.key;
	}
	get tag() {
		return this.controller.tag;
	}
	set tag(e) {
		this.controller.tag = e;
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
	refresh() {
		this.controller.value.fetch();
	}
	onValueChange_(e) {
		const t = this.controller.value;
		this.emitter_.emit('change', new lu(this, t.binding.target.read(), e.options.last));
	}
}
class az {
	constructor(e, t) {
		(this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this)),
			(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.binding = t),
			(this.value_ = e),
			this.value_.emitter.on('beforechange', this.onValueBeforeChange_),
			this.value_.emitter.on('change', this.onValueChange_),
			(this.emitter = new Mn());
	}
	get rawValue() {
		return this.value_.rawValue;
	}
	set rawValue(e) {
		this.value_.rawValue = e;
	}
	setRawValue(e, t) {
		this.value_.setRawValue(e, t);
	}
	fetch() {
		this.value_.rawValue = this.binding.read();
	}
	push() {
		this.binding.write(this.value_.rawValue);
	}
	onValueBeforeChange_(e) {
		this.emitter.emit('beforechange', Object.assign(Object.assign({}, e), { sender: this }));
	}
	onValueChange_(e) {
		this.push(), this.emitter.emit('change', Object.assign(Object.assign({}, e), { sender: this }));
	}
}
function lz(i) {
	if (!('binding' in i)) return !1;
	const e = i.binding;
	return r0(e) && 'read' in e && 'write' in e;
}
function cz(i, e) {
	const n = Object.keys(e).reduce((s, r) => {
		if (s === void 0) return;
		const o = e[r],
			a = o(i[r]);
		return a.succeeded ? Object.assign(Object.assign({}, s), { [r]: a.value }) : void 0;
	}, {});
	return n;
}
function hz(i, e) {
	return i.reduce((t, n) => {
		if (t === void 0) return;
		const s = e(n);
		if (!(!s.succeeded || s.value === void 0)) return [...t, s.value];
	}, []);
}
function uz(i) {
	return i === null ? !1 : typeof i == 'object';
}
function or(i) {
	return (e) => (t) => {
		if (!e && t === void 0) return { succeeded: !1, value: void 0 };
		if (e && t === void 0) return { succeeded: !0, value: void 0 };
		const n = i(t);
		return n !== void 0 ? { succeeded: !0, value: n } : { succeeded: !1, value: void 0 };
	};
}
function Yb(i) {
	return {
		custom: (e) => or(e)(i),
		boolean: or((e) => (typeof e == 'boolean' ? e : void 0))(i),
		number: or((e) => (typeof e == 'number' ? e : void 0))(i),
		string: or((e) => (typeof e == 'string' ? e : void 0))(i),
		function: or((e) => (typeof e == 'function' ? e : void 0))(i),
		constant: (e) => or((t) => (t === e ? e : void 0))(i),
		raw: or((e) => e)(i),
		object: (e) =>
			or((t) => {
				if (uz(t)) return cz(t, e);
			})(i),
		array: (e) =>
			or((t) => {
				if (Array.isArray(t)) return hz(t, e);
			})(i),
	};
}
const fv = { optional: Yb(!0), required: Yb(!1) };
function rn(i, e) {
	const t = e(fv),
		n = fv.required.object(t)(i);
	return n.succeeded ? n.value : void 0;
}
function Gi(i, e, t, n) {
	if (e && !e(i)) return !1;
	const s = rn(i, t);
	return s ? n(s) : !1;
}
function Wi(i, e) {
	var t;
	return Ia((t = i == null ? void 0 : i()) !== null && t !== void 0 ? t : {}, e);
}
function ya(i) {
	return 'value' in i;
}
function BT(i) {
	if (!s0(i) || !('binding' in i)) return !1;
	const e = i.binding;
	return r0(e);
}
const Gs = 'http://www.w3.org/2000/svg';
function ap(i) {
	i.offsetHeight;
}
function dz(i, e) {
	const t = i.style.transition;
	(i.style.transition = 'none'), e(), (i.style.transition = t);
}
function c0(i) {
	return i.ontouchstart !== void 0;
}
function pz() {
	return globalThis;
}
function fz() {
	return pz().document;
}
function mz(i) {
	const e = i.ownerDocument.defaultView;
	return e && 'document' in e ? i.getContext('2d', { willReadFrequently: !0 }) : null;
}
const gz = {
	check: '<path d="M2 8l4 4l8 -8"/>',
	dropdown: '<path d="M5 7h6l-3 3 z"/>',
	p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function yf(i, e) {
	const t = i.createElementNS(Gs, 'svg');
	return (t.innerHTML = gz[e]), t;
}
function kT(i, e, t) {
	i.insertBefore(e, i.children[t]);
}
function h0(i) {
	i.parentElement && i.parentElement.removeChild(i);
}
function zT(i) {
	for (; i.children.length > 0; ) i.removeChild(i.children[0]);
}
function vz(i) {
	for (; i.childNodes.length > 0; ) i.removeChild(i.childNodes[0]);
}
function VT(i) {
	return i.relatedTarget ? i.relatedTarget : 'explicitOriginalTarget' in i ? i.explicitOriginalTarget : null;
}
function vr(i, e) {
	i.emitter.on('change', (t) => {
		e(t.rawValue);
	}),
		e(i.rawValue);
}
function Ks(i, e, t) {
	vr(i.value(e), t);
}
const _z = 'tp';
function wt(i) {
	return (t, n) => [_z, '-', i, 'v', t ? '_'.concat(t) : '', n ? '-'.concat(n) : ''].join('');
}
const Bc = wt('lbl');
function yz(i, e) {
	const t = i.createDocumentFragment();
	return (
		e
			.split('\n')
			.map((s) => i.createTextNode(s))
			.forEach((s, r) => {
				r > 0 && t.appendChild(i.createElement('br')), t.appendChild(s);
			}),
		t
	);
}
class HT {
	constructor(e, t) {
		(this.element = e.createElement('div')), this.element.classList.add(Bc()), t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(Bc('l')),
			Ks(t.props, 'label', (r) => {
				qt(r)
					? this.element.classList.add(Bc(void 0, 'nol'))
					: (this.element.classList.remove(Bc(void 0, 'nol')), vz(n), n.appendChild(yz(e, r)));
			}),
			this.element.appendChild(n),
			(this.labelElement = n);
		const s = e.createElement('div');
		s.classList.add(Bc('v')), this.element.appendChild(s), (this.valueElement = s);
	}
}
class GT {
	constructor(e, t) {
		(this.props = t.props),
			(this.valueController = t.valueController),
			(this.viewProps = t.valueController.viewProps),
			(this.view = new HT(e, { props: t.props, viewProps: this.viewProps })),
			this.view.valueElement.appendChild(this.valueController.view.element);
	}
	importProps(e) {
		return Gi(
			e,
			null,
			(t) => ({ label: t.optional.string }),
			(t) => (this.props.set('label', t.label), !0)
		);
	}
	exportProps() {
		return Wi(null, { label: this.props.get('label') });
	}
}
function xz() {
	return ['veryfirst', 'first', 'last', 'verylast'];
}
const jb = wt(''),
	Kb = { veryfirst: 'vfst', first: 'fst', last: 'lst', verylast: 'vlst' };
class xf {
	constructor(e) {
		(this.parent_ = null), (this.blade = e.blade), (this.view = e.view), (this.viewProps = e.viewProps);
		const t = this.view.element;
		this.blade.value('positions').emitter.on('change', () => {
			xz().forEach((n) => {
				t.classList.remove(jb(void 0, Kb[n]));
			}),
				this.blade.get('positions').forEach((n) => {
					t.classList.add(jb(void 0, Kb[n]));
				});
		}),
			this.viewProps.handleDispose(() => {
				h0(t);
			});
	}
	get parent() {
		return this.parent_;
	}
	set parent(e) {
		(this.parent_ = e), this.viewProps.set('parent', this.parent_ ? this.parent_.viewProps : null);
	}
	importState(e) {
		return Gi(
			e,
			null,
			(t) => ({ disabled: t.required.boolean, hidden: t.required.boolean }),
			(t) => (this.viewProps.importState(t), !0)
		);
	}
	exportState() {
		return Wi(null, Object.assign({}, this.viewProps.exportState()));
	}
}
class Da extends xf {
	constructor(e, t) {
		if (t.value !== t.valueController.value) throw cn.shouldNeverHappen();
		const n = t.valueController.viewProps,
			s = new GT(e, { blade: t.blade, props: t.props, valueController: t.valueController });
		super(Object.assign(Object.assign({}, t), { view: new HT(e, { props: t.props, viewProps: n }), viewProps: n })),
			(this.labelController = s),
			(this.value = t.value),
			(this.valueController = t.valueController),
			this.view.valueElement.appendChild(this.valueController.view.element);
	}
	importState(e) {
		return Gi(
			e,
			(t) => {
				var n, s, r;
				return (
					super.importState(t) &&
					this.labelController.importProps(t) &&
					((r = (s = (n = this.valueController).importProps) === null || s === void 0 ? void 0 : s.call(n, e)) !== null &&
					r !== void 0
						? r
						: !0)
				);
			},
			(t) => ({ value: t.optional.raw }),
			(t) => (t.value && (this.value.rawValue = t.value), !0)
		);
	}
	exportState() {
		var e, t, n;
		return Wi(
			() => super.exportState(),
			Object.assign(
				Object.assign({ value: this.value.rawValue }, this.labelController.exportProps()),
				(n = (t = (e = this.valueController).exportProps) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0
					? n
					: {}
			)
		);
	}
}
function $b(i) {
	const e = Object.assign({}, i);
	return delete e.value, e;
}
class WT extends Da {
	constructor(e, t) {
		super(e, t), (this.tag = t.tag);
	}
	importState(e) {
		return Gi(
			e,
			(t) => super.importState($b(e)),
			(t) => ({ tag: t.optional.string }),
			(t) => ((this.tag = t.tag), !0)
		);
	}
	exportState() {
		return Wi(() => $b(super.exportState()), {
			binding: { key: this.value.binding.target.key, value: this.value.binding.target.read() },
			tag: this.tag,
		});
	}
}
function bz(i) {
	return ya(i) && BT(i.value);
}
class wz extends WT {
	importState(e) {
		return Gi(
			e,
			(t) => super.importState(t),
			(t) => ({ binding: t.required.object({ value: t.required.raw }) }),
			(t) => (this.value.binding.inject(t.binding.value), this.value.fetch(), !0)
		);
	}
}
function Sz(i) {
	return ya(i) && lz(i.value);
}
function XT(i, e) {
	for (; i.length < e; ) i.push(void 0);
}
function Mz(i) {
	const e = [];
	return XT(e, i), e;
}
function Ez(i) {
	const e = i.indexOf(void 0);
	return e < 0 ? i : i.slice(0, e);
}
function Tz(i, e) {
	const t = [...Ez(i), e];
	return t.length > i.length ? t.splice(0, t.length - i.length) : XT(t, i.length), t;
}
class Az {
	constructor(e) {
		(this.emitter = new Mn()),
			(this.onTick_ = this.onTick_.bind(this)),
			(this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this)),
			(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.binding = e.binding),
			(this.value_ = Jt(Mz(e.bufferSize))),
			this.value_.emitter.on('beforechange', this.onValueBeforeChange_),
			this.value_.emitter.on('change', this.onValueChange_),
			(this.ticker = e.ticker),
			this.ticker.emitter.on('tick', this.onTick_),
			this.fetch();
	}
	get rawValue() {
		return this.value_.rawValue;
	}
	set rawValue(e) {
		this.value_.rawValue = e;
	}
	setRawValue(e, t) {
		this.value_.setRawValue(e, t);
	}
	fetch() {
		this.value_.rawValue = Tz(this.value_.rawValue, this.binding.read());
	}
	onTick_() {
		this.fetch();
	}
	onValueBeforeChange_(e) {
		this.emitter.emit('beforechange', Object.assign(Object.assign({}, e), { sender: this }));
	}
	onValueChange_(e) {
		this.emitter.emit('change', Object.assign(Object.assign({}, e), { sender: this }));
	}
}
function Cz(i) {
	if (!('binding' in i)) return !1;
	const e = i.binding;
	return r0(e) && 'read' in e && !('write' in e);
}
class Rz extends WT {
	exportState() {
		return Wi(() => super.exportState(), { binding: { readonly: !0 } });
	}
}
function Pz(i) {
	return ya(i) && Cz(i.value);
}
class Lz extends Xa {
	get label() {
		return this.controller.labelController.props.get('label');
	}
	set label(e) {
		this.controller.labelController.props.set('label', e);
	}
	get title() {
		var e;
		return (e = this.controller.buttonController.props.get('title')) !== null && e !== void 0 ? e : '';
	}
	set title(e) {
		this.controller.buttonController.props.set('title', e);
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.controller.buttonController.emitter.on(e, (r) => {
				n(new oz(this, r.nativeEvent));
			}),
			this
		);
	}
	off(e, t) {
		return this.controller.buttonController.emitter.off(e, t), this;
	}
}
function Iz(i, e, t) {
	t ? i.classList.add(e) : i.classList.remove(e);
}
function dc(i, e) {
	return (t) => {
		Iz(i, e, t);
	};
}
function u0(i, e) {
	vr(i, (t) => {
		e.textContent = t != null ? t : '';
	});
}
const km = wt('btn');
class Dz {
	constructor(e, t) {
		(this.element = e.createElement('div')), this.element.classList.add(km()), t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('button');
		n.classList.add(km('b')), t.viewProps.bindDisabled(n), this.element.appendChild(n), (this.buttonElement = n);
		const s = e.createElement('div');
		s.classList.add(km('t')), u0(t.props.value('title'), s), this.buttonElement.appendChild(s);
	}
}
class Oz {
	constructor(e, t) {
		(this.emitter = new Mn()),
			(this.onClick_ = this.onClick_.bind(this)),
			(this.props = t.props),
			(this.viewProps = t.viewProps),
			(this.view = new Dz(e, { props: this.props, viewProps: this.viewProps })),
			this.view.buttonElement.addEventListener('click', this.onClick_);
	}
	importProps(e) {
		return Gi(
			e,
			null,
			(t) => ({ title: t.optional.string }),
			(t) => (this.props.set('title', t.title), !0)
		);
	}
	exportProps() {
		return Wi(null, { title: this.props.get('title') });
	}
	onClick_(e) {
		this.emitter.emit('click', { nativeEvent: e, sender: this });
	}
}
class Zb extends xf {
	constructor(e, t) {
		const n = new Oz(e, { props: t.buttonProps, viewProps: t.viewProps }),
			s = new GT(e, { blade: t.blade, props: t.labelProps, valueController: n });
		super({ blade: t.blade, view: s.view, viewProps: t.viewProps }), (this.buttonController = n), (this.labelController = s);
	}
	importState(e) {
		return Gi(
			e,
			(t) => super.importState(t) && this.buttonController.importProps(t) && this.labelController.importProps(t),
			() => ({}),
			() => !0
		);
	}
	exportState() {
		return Wi(
			() => super.exportState(),
			Object.assign(Object.assign({}, this.buttonController.exportProps()), this.labelController.exportProps())
		);
	}
}
class qT {
	constructor(e) {
		const [t, n] = e.split('-'),
			s = t.split('.');
		(this.major = parseInt(s[0], 10)),
			(this.minor = parseInt(s[1], 10)),
			(this.patch = parseInt(s[2], 10)),
			(this.prerelease = n != null ? n : null);
	}
	toString() {
		const e = [this.major, this.minor, this.patch].join('.');
		return this.prerelease !== null ? [e, this.prerelease].join('-') : e;
	}
}
const pc = new qT('2.0.4');
function li(i) {
	return Object.assign({ core: pc }, i);
}
const Uz = li({
	id: 'button',
	type: 'blade',
	accept(i) {
		const e = rn(i, (t) => ({ title: t.required.string, view: t.required.constant('button'), label: t.optional.string }));
		return e ? { params: e } : null;
	},
	controller(i) {
		return new Zb(i.document, {
			blade: i.blade,
			buttonProps: ut.fromObject({ title: i.params.title }),
			labelProps: ut.fromObject({ label: i.params.label }),
			viewProps: i.viewProps,
		});
	},
	api(i) {
		return i.controller instanceof Zb ? new Lz(i.controller) : null;
	},
});
function Nz(i, e) {
	return i.addBlade(Object.assign(Object.assign({}, e), { view: 'button' }));
}
function Fz(i, e) {
	return i.addBlade(Object.assign(Object.assign({}, e), { view: 'folder' }));
}
function Bz(i, e) {
	return i.addBlade(Object.assign(Object.assign({}, e), { view: 'tab' }));
}
function kz(i) {
	return s0(i) ? 'refresh' in i && typeof i.refresh == 'function' : !1;
}
function zz(i, e) {
	if (!op.isBindable(i)) throw cn.notBindable();
	return new op(i, e);
}
class Vz {
	constructor(e, t) {
		(this.onRackValueChange_ = this.onRackValueChange_.bind(this)),
			(this.controller_ = e),
			(this.emitter_ = new Mn()),
			(this.pool_ = t),
			this.controller_.rack.emitter.on('valuechange', this.onRackValueChange_);
	}
	get children() {
		return this.controller_.rack.children.map((e) => this.pool_.createApi(e));
	}
	addBinding(e, t, n) {
		const s = n != null ? n : {},
			r = this.controller_.element.ownerDocument,
			o = this.pool_.createBinding(r, zz(e, t), s),
			a = this.pool_.createBindingApi(o);
		return this.add(a, s.index);
	}
	addFolder(e) {
		return Fz(this, e);
	}
	addButton(e) {
		return Nz(this, e);
	}
	addTab(e) {
		return Bz(this, e);
	}
	add(e, t) {
		const n = e.controller;
		return this.controller_.rack.add(n, t), e;
	}
	remove(e) {
		this.controller_.rack.remove(e.controller);
	}
	addBlade(e) {
		const t = this.controller_.element.ownerDocument,
			n = this.pool_.createBlade(t, e),
			s = this.pool_.createApi(n);
		return this.add(s, e.index);
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
	refresh() {
		this.children.forEach((e) => {
			kz(e) && e.refresh();
		});
	}
	onRackValueChange_(e) {
		const t = e.bladeController,
			n = this.pool_.createApi(t),
			s = BT(t.value) ? t.value.binding : null;
		this.emitter_.emit('change', new lu(n, s ? s.target.read() : t.value.rawValue, e.options.last));
	}
}
class d0 extends Xa {
	constructor(e, t) {
		super(e), (this.rackApi_ = new Vz(e.rackController, t));
	}
	refresh() {
		this.rackApi_.refresh();
	}
}
class p0 extends xf {
	constructor(e) {
		super({ blade: e.blade, view: e.view, viewProps: e.rackController.viewProps }), (this.rackController = e.rackController);
	}
	importState(e) {
		return Gi(
			e,
			(t) => super.importState(t),
			(t) => ({ children: t.required.array(t.required.raw) }),
			(t) => this.rackController.rack.children.every((n, s) => n.importState(t.children[s]))
		);
	}
	exportState() {
		return Wi(() => super.exportState(), { children: this.rackController.rack.children.map((e) => e.exportState()) });
	}
}
function mv(i) {
	return 'rackController' in i;
}
class Hz {
	constructor(e) {
		(this.emitter = new Mn()),
			(this.items_ = []),
			(this.cache_ = new Set()),
			(this.onSubListAdd_ = this.onSubListAdd_.bind(this)),
			(this.onSubListRemove_ = this.onSubListRemove_.bind(this)),
			(this.extract_ = e);
	}
	get items() {
		return this.items_;
	}
	allItems() {
		return Array.from(this.cache_);
	}
	find(e) {
		for (const t of this.allItems()) if (e(t)) return t;
		return null;
	}
	includes(e) {
		return this.cache_.has(e);
	}
	add(e, t) {
		if (this.includes(e)) throw cn.shouldNeverHappen();
		const n = t !== void 0 ? t : this.items_.length;
		this.items_.splice(n, 0, e), this.cache_.add(e);
		const s = this.extract_(e);
		s &&
			(s.emitter.on('add', this.onSubListAdd_),
			s.emitter.on('remove', this.onSubListRemove_),
			s.allItems().forEach((r) => {
				this.cache_.add(r);
			})),
			this.emitter.emit('add', { index: n, item: e, root: this, target: this });
	}
	remove(e) {
		const t = this.items_.indexOf(e);
		if (t < 0) return;
		this.items_.splice(t, 1), this.cache_.delete(e);
		const n = this.extract_(e);
		n &&
			(n.allItems().forEach((s) => {
				this.cache_.delete(s);
			}),
			n.emitter.off('add', this.onSubListAdd_),
			n.emitter.off('remove', this.onSubListRemove_)),
			this.emitter.emit('remove', { index: t, item: e, root: this, target: this });
	}
	onSubListAdd_(e) {
		this.cache_.add(e.item), this.emitter.emit('add', { index: e.index, item: e.item, root: this, target: e.target });
	}
	onSubListRemove_(e) {
		this.cache_.delete(e.item), this.emitter.emit('remove', { index: e.index, item: e.item, root: this, target: e.target });
	}
}
function Gz(i, e) {
	for (let t = 0; t < i.length; t++) {
		const n = i[t];
		if (ya(n) && n.value === e) return n;
	}
	return null;
}
function Wz(i) {
	return mv(i) ? i.rackController.rack.bcSet_ : null;
}
class Xz {
	constructor(e) {
		var t, n;
		(this.emitter = new Mn()),
			(this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this)),
			(this.onSetAdd_ = this.onSetAdd_.bind(this)),
			(this.onSetRemove_ = this.onSetRemove_.bind(this)),
			(this.onChildDispose_ = this.onChildDispose_.bind(this)),
			(this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this)),
			(this.onChildValueChange_ = this.onChildValueChange_.bind(this)),
			(this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this)),
			(this.onRackLayout_ = this.onRackLayout_.bind(this)),
			(this.onRackValueChange_ = this.onRackValueChange_.bind(this)),
			(this.blade_ = (t = e.blade) !== null && t !== void 0 ? t : null),
			(n = this.blade_) === null || n === void 0 || n.value('positions').emitter.on('change', this.onBladePositionsChange_),
			(this.viewProps = e.viewProps),
			(this.bcSet_ = new Hz(Wz)),
			this.bcSet_.emitter.on('add', this.onSetAdd_),
			this.bcSet_.emitter.on('remove', this.onSetRemove_);
	}
	get children() {
		return this.bcSet_.items;
	}
	add(e, t) {
		var n;
		(n = e.parent) === null || n === void 0 || n.remove(e), (e.parent = this), this.bcSet_.add(e, t);
	}
	remove(e) {
		(e.parent = null), this.bcSet_.remove(e);
	}
	find(e) {
		return this.bcSet_.allItems().filter(e);
	}
	onSetAdd_(e) {
		this.updatePositions_();
		const t = e.target === e.root;
		if ((this.emitter.emit('add', { bladeController: e.item, index: e.index, root: t, sender: this }), !t)) return;
		const n = e.item;
		if (
			(n.viewProps.emitter.on('change', this.onChildViewPropsChange_),
			n.blade.value('positions').emitter.on('change', this.onChildPositionsChange_),
			n.viewProps.handleDispose(this.onChildDispose_),
			ya(n))
		)
			n.value.emitter.on('change', this.onChildValueChange_);
		else if (mv(n)) {
			const s = n.rackController.rack;
			if (s) {
				const r = s.emitter;
				r.on('layout', this.onRackLayout_), r.on('valuechange', this.onRackValueChange_);
			}
		}
	}
	onSetRemove_(e) {
		this.updatePositions_();
		const t = e.target === e.root;
		if ((this.emitter.emit('remove', { bladeController: e.item, root: t, sender: this }), !t)) return;
		const n = e.item;
		if (ya(n)) n.value.emitter.off('change', this.onChildValueChange_);
		else if (mv(n)) {
			const s = n.rackController.rack;
			if (s) {
				const r = s.emitter;
				r.off('layout', this.onRackLayout_), r.off('valuechange', this.onRackValueChange_);
			}
		}
	}
	updatePositions_() {
		const e = this.bcSet_.items.filter((s) => !s.viewProps.get('hidden')),
			t = e[0],
			n = e[e.length - 1];
		this.bcSet_.items.forEach((s) => {
			const r = [];
			s === t && (r.push('first'), (!this.blade_ || this.blade_.get('positions').includes('veryfirst')) && r.push('veryfirst')),
				s === n && (r.push('last'), (!this.blade_ || this.blade_.get('positions').includes('verylast')) && r.push('verylast')),
				s.blade.set('positions', r);
		});
	}
	onChildPositionsChange_() {
		this.updatePositions_(), this.emitter.emit('layout', { sender: this });
	}
	onChildViewPropsChange_(e) {
		this.updatePositions_(), this.emitter.emit('layout', { sender: this });
	}
	onChildDispose_() {
		this.bcSet_.items
			.filter((t) => t.viewProps.get('disposed'))
			.forEach((t) => {
				this.bcSet_.remove(t);
			});
	}
	onChildValueChange_(e) {
		const t = Gz(this.find(ya), e.sender);
		if (!t) throw cn.alreadyDisposed();
		this.emitter.emit('valuechange', { bladeController: t, options: e.options, sender: this });
	}
	onRackLayout_(e) {
		this.updatePositions_(), this.emitter.emit('layout', { sender: this });
	}
	onRackValueChange_(e) {
		this.emitter.emit('valuechange', { bladeController: e.bladeController, options: e.options, sender: this });
	}
	onBladePositionsChange_() {
		this.updatePositions_();
	}
}
class f0 {
	constructor(e) {
		(this.onRackAdd_ = this.onRackAdd_.bind(this)),
			(this.onRackRemove_ = this.onRackRemove_.bind(this)),
			(this.element = e.element),
			(this.viewProps = e.viewProps);
		const t = new Xz({ blade: e.root ? void 0 : e.blade, viewProps: e.viewProps });
		t.emitter.on('add', this.onRackAdd_),
			t.emitter.on('remove', this.onRackRemove_),
			(this.rack = t),
			this.viewProps.handleDispose(() => {
				for (let n = this.rack.children.length - 1; n >= 0; n--) this.rack.children[n].viewProps.set('disposed', !0);
			});
	}
	onRackAdd_(e) {
		e.root && kT(this.element, e.bladeController.view.element, e.index);
	}
	onRackRemove_(e) {
		e.root && h0(e.bladeController.view.element);
	}
}
function fc() {
	return new ut({ positions: Jt([], { equals: wk }) });
}
class cu extends ut {
	constructor(e) {
		super(e);
	}
	static create(e) {
		const t = { completed: !0, expanded: e, expandedHeight: null, shouldFixHeight: !1, temporaryExpanded: null },
			n = ut.createCore(t);
		return new cu(n);
	}
	get styleExpanded() {
		var e;
		return (e = this.get('temporaryExpanded')) !== null && e !== void 0 ? e : this.get('expanded');
	}
	get styleHeight() {
		if (!this.styleExpanded) return '0';
		const e = this.get('expandedHeight');
		return this.get('shouldFixHeight') && !qt(e) ? ''.concat(e, 'px') : 'auto';
	}
	bindExpandedClass(e, t) {
		const n = () => {
			this.styleExpanded ? e.classList.add(t) : e.classList.remove(t);
		};
		Ks(this, 'expanded', n), Ks(this, 'temporaryExpanded', n);
	}
	cleanUpTransition() {
		this.set('shouldFixHeight', !1), this.set('expandedHeight', null), this.set('completed', !0);
	}
}
function qz(i, e) {
	let t = 0;
	return (
		dz(e, () => {
			i.set('expandedHeight', null),
				i.set('temporaryExpanded', !0),
				ap(e),
				(t = e.clientHeight),
				i.set('temporaryExpanded', null),
				ap(e);
		}),
		t
	);
}
function Jb(i, e) {
	e.style.height = i.styleHeight;
}
function m0(i, e) {
	i.value('expanded').emitter.on('beforechange', () => {
		if ((i.set('completed', !1), qt(i.get('expandedHeight')))) {
			const t = qz(i, e);
			t > 0 && i.set('expandedHeight', t);
		}
		i.set('shouldFixHeight', !0), ap(e);
	}),
		i.emitter.on('change', () => {
			Jb(i, e);
		}),
		Jb(i, e),
		e.addEventListener('transitionend', (t) => {
			t.propertyName === 'height' && i.cleanUpTransition();
		});
}
class YT extends d0 {
	constructor(e, t) {
		super(e, t),
			(this.emitter_ = new Mn()),
			this.controller.foldable.value('expanded').emitter.on('change', (n) => {
				this.emitter_.emit('fold', new sz(this, n.sender.rawValue));
			}),
			this.rackApi_.on('change', (n) => {
				this.emitter_.emit('change', n);
			});
	}
	get expanded() {
		return this.controller.foldable.get('expanded');
	}
	set expanded(e) {
		this.controller.foldable.set('expanded', e);
	}
	get title() {
		return this.controller.props.get('title');
	}
	set title(e) {
		this.controller.props.set('title', e);
	}
	get children() {
		return this.rackApi_.children;
	}
	addBinding(e, t, n) {
		return this.rackApi_.addBinding(e, t, n);
	}
	addFolder(e) {
		return this.rackApi_.addFolder(e);
	}
	addButton(e) {
		return this.rackApi_.addButton(e);
	}
	addTab(e) {
		return this.rackApi_.addTab(e);
	}
	add(e, t) {
		return this.rackApi_.add(e, t);
	}
	remove(e) {
		this.rackApi_.remove(e);
	}
	addBlade(e) {
		return this.rackApi_.addBlade(e);
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
}
const jT = wt('cnt');
class Yz {
	constructor(e, t) {
		var n;
		(this.className_ = wt((n = t.viewName) !== null && n !== void 0 ? n : 'fld')),
			(this.element = e.createElement('div')),
			this.element.classList.add(this.className_(), jT()),
			t.viewProps.bindClassModifiers(this.element),
			(this.foldable_ = t.foldable),
			this.foldable_.bindExpandedClass(this.element, this.className_(void 0, 'expanded')),
			Ks(this.foldable_, 'completed', dc(this.element, this.className_(void 0, 'cpl')));
		const s = e.createElement('button');
		s.classList.add(this.className_('b')),
			Ks(t.props, 'title', (c) => {
				qt(c)
					? this.element.classList.add(this.className_(void 0, 'not'))
					: this.element.classList.remove(this.className_(void 0, 'not'));
			}),
			t.viewProps.bindDisabled(s),
			this.element.appendChild(s),
			(this.buttonElement = s);
		const r = e.createElement('div');
		r.classList.add(this.className_('i')), this.element.appendChild(r);
		const o = e.createElement('div');
		o.classList.add(this.className_('t')), u0(t.props.value('title'), o), this.buttonElement.appendChild(o), (this.titleElement = o);
		const a = e.createElement('div');
		a.classList.add(this.className_('m')), this.buttonElement.appendChild(a);
		const l = e.createElement('div');
		l.classList.add(this.className_('c')), this.element.appendChild(l), (this.containerElement = l);
	}
}
class gv extends p0 {
	constructor(e, t) {
		var n;
		const s = cu.create((n = t.expanded) !== null && n !== void 0 ? n : !0),
			r = new Yz(e, { foldable: s, props: t.props, viewName: t.root ? 'rot' : void 0, viewProps: t.viewProps });
		super(
			Object.assign(Object.assign({}, t), {
				rackController: new f0({ blade: t.blade, element: r.containerElement, root: t.root, viewProps: t.viewProps }),
				view: r,
			})
		),
			(this.onTitleClick_ = this.onTitleClick_.bind(this)),
			(this.props = t.props),
			(this.foldable = s),
			m0(this.foldable, this.view.containerElement),
			this.rackController.rack.emitter.on('add', () => {
				this.foldable.cleanUpTransition();
			}),
			this.rackController.rack.emitter.on('remove', () => {
				this.foldable.cleanUpTransition();
			}),
			this.view.buttonElement.addEventListener('click', this.onTitleClick_);
	}
	get document() {
		return this.view.element.ownerDocument;
	}
	importState(e) {
		return Gi(
			e,
			(t) => super.importState(t),
			(t) => ({ expanded: t.required.boolean, title: t.optional.string }),
			(t) => (this.foldable.set('expanded', t.expanded), this.props.set('title', t.title), !0)
		);
	}
	exportState() {
		return Wi(() => super.exportState(), { expanded: this.foldable.get('expanded'), title: this.props.get('title') });
	}
	onTitleClick_() {
		this.foldable.set('expanded', !this.foldable.get('expanded'));
	}
}
const jz = li({
		id: 'folder',
		type: 'blade',
		accept(i) {
			const e = rn(i, (t) => ({ title: t.required.string, view: t.required.constant('folder'), expanded: t.optional.boolean }));
			return e ? { params: e } : null;
		},
		controller(i) {
			return new gv(i.document, {
				blade: i.blade,
				expanded: i.params.expanded,
				props: ut.fromObject({ title: i.params.title }),
				viewProps: i.viewProps,
			});
		},
		api(i) {
			return i.controller instanceof gv ? new YT(i.controller, i.pool) : null;
		},
	}),
	Kz = wt('');
function Qb(i, e) {
	return dc(i, Kz(void 0, e));
}
class Tr extends ut {
	constructor(e) {
		var t;
		super(e),
			(this.onDisabledChange_ = this.onDisabledChange_.bind(this)),
			(this.onParentChange_ = this.onParentChange_.bind(this)),
			(this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this)),
			([this.globalDisabled_, this.setGlobalDisabled_] = Ak(Jt(this.getGlobalDisabled_()))),
			this.value('disabled').emitter.on('change', this.onDisabledChange_),
			this.value('parent').emitter.on('change', this.onParentChange_),
			(t = this.get('parent')) === null || t === void 0 || t.globalDisabled.emitter.on('change', this.onParentGlobalDisabledChange_);
	}
	static create(e) {
		var t, n, s;
		const r = e != null ? e : {};
		return new Tr(
			ut.createCore({
				disabled: (t = r.disabled) !== null && t !== void 0 ? t : !1,
				disposed: !1,
				hidden: (n = r.hidden) !== null && n !== void 0 ? n : !1,
				parent: (s = r.parent) !== null && s !== void 0 ? s : null,
			})
		);
	}
	get globalDisabled() {
		return this.globalDisabled_;
	}
	bindClassModifiers(e) {
		vr(this.globalDisabled_, Qb(e, 'disabled')), Ks(this, 'hidden', Qb(e, 'hidden'));
	}
	bindDisabled(e) {
		vr(this.globalDisabled_, (t) => {
			e.disabled = t;
		});
	}
	bindTabIndex(e) {
		vr(this.globalDisabled_, (t) => {
			e.tabIndex = t ? -1 : 0;
		});
	}
	handleDispose(e) {
		this.value('disposed').emitter.on('change', (t) => {
			t && e();
		});
	}
	importState(e) {
		this.set('disabled', e.disabled), this.set('hidden', e.hidden);
	}
	exportState() {
		return { disabled: this.get('disabled'), hidden: this.get('hidden') };
	}
	getGlobalDisabled_() {
		const e = this.get('parent');
		return (e ? e.globalDisabled.rawValue : !1) || this.get('disabled');
	}
	updateGlobalDisabled_() {
		this.setGlobalDisabled_(this.getGlobalDisabled_());
	}
	onDisabledChange_() {
		this.updateGlobalDisabled_();
	}
	onParentGlobalDisabledChange_() {
		this.updateGlobalDisabled_();
	}
	onParentChange_(e) {
		var t;
		const n = e.previousRawValue;
		n == null || n.globalDisabled.emitter.off('change', this.onParentGlobalDisabledChange_),
			(t = this.get('parent')) === null || t === void 0 || t.globalDisabled.emitter.on('change', this.onParentGlobalDisabledChange_),
			this.updateGlobalDisabled_();
	}
}
const ew = wt('tbp');
class $z {
	constructor(e, t) {
		(this.element = e.createElement('div')), this.element.classList.add(ew()), t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(ew('c')), this.element.appendChild(n), (this.containerElement = n);
	}
}
const kc = wt('tbi');
class Zz {
	constructor(e, t) {
		(this.element = e.createElement('div')),
			this.element.classList.add(kc()),
			t.viewProps.bindClassModifiers(this.element),
			Ks(t.props, 'selected', (r) => {
				r ? this.element.classList.add(kc(void 0, 'sel')) : this.element.classList.remove(kc(void 0, 'sel'));
			});
		const n = e.createElement('button');
		n.classList.add(kc('b')), t.viewProps.bindDisabled(n), this.element.appendChild(n), (this.buttonElement = n);
		const s = e.createElement('div');
		s.classList.add(kc('t')), u0(t.props.value('title'), s), this.buttonElement.appendChild(s), (this.titleElement = s);
	}
}
class Jz {
	constructor(e, t) {
		(this.emitter = new Mn()),
			(this.onClick_ = this.onClick_.bind(this)),
			(this.props = t.props),
			(this.viewProps = t.viewProps),
			(this.view = new Zz(e, { props: t.props, viewProps: t.viewProps })),
			this.view.buttonElement.addEventListener('click', this.onClick_);
	}
	onClick_() {
		this.emitter.emit('click', { sender: this });
	}
}
class vv extends p0 {
	constructor(e, t) {
		const n = new $z(e, { viewProps: t.viewProps });
		super(
			Object.assign(Object.assign({}, t), {
				rackController: new f0({ blade: t.blade, element: n.containerElement, viewProps: t.viewProps }),
				view: n,
			})
		),
			(this.onItemClick_ = this.onItemClick_.bind(this)),
			(this.ic_ = new Jz(e, { props: t.itemProps, viewProps: Tr.create() })),
			this.ic_.emitter.on('click', this.onItemClick_),
			(this.props = t.props),
			Ks(this.props, 'selected', (s) => {
				this.itemController.props.set('selected', s), this.viewProps.set('hidden', !s);
			});
	}
	get itemController() {
		return this.ic_;
	}
	importState(e) {
		return Gi(
			e,
			(t) => super.importState(t),
			(t) => ({ selected: t.required.boolean, title: t.required.string }),
			(t) => (this.ic_.props.set('selected', t.selected), this.ic_.props.set('title', t.title), !0)
		);
	}
	exportState() {
		return Wi(() => super.exportState(), { selected: this.ic_.props.get('selected'), title: this.ic_.props.get('title') });
	}
	onItemClick_() {
		this.props.set('selected', !0);
	}
}
class Qz extends d0 {
	constructor(e, t) {
		super(e, t),
			(this.emitter_ = new Mn()),
			(this.onSelect_ = this.onSelect_.bind(this)),
			(this.pool_ = t),
			this.rackApi_.on('change', (n) => {
				this.emitter_.emit('change', n);
			}),
			this.controller.tab.selectedIndex.emitter.on('change', this.onSelect_);
	}
	get pages() {
		return this.rackApi_.children;
	}
	addPage(e) {
		const t = this.controller.view.element.ownerDocument,
			n = new vv(t, {
				blade: fc(),
				itemProps: ut.fromObject({ selected: !1, title: e.title }),
				props: ut.fromObject({ selected: !1 }),
				viewProps: Tr.create(),
			}),
			s = this.pool_.createApi(n);
		return this.rackApi_.add(s, e.index);
	}
	removePage(e) {
		this.rackApi_.remove(this.rackApi_.children[e]);
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
	onSelect_(e) {
		this.emitter_.emit('select', new rz(this, e.rawValue));
	}
}
class eV extends d0 {
	get title() {
		var e;
		return (e = this.controller.itemController.props.get('title')) !== null && e !== void 0 ? e : '';
	}
	set title(e) {
		this.controller.itemController.props.set('title', e);
	}
	get selected() {
		return this.controller.props.get('selected');
	}
	set selected(e) {
		this.controller.props.set('selected', e);
	}
	get children() {
		return this.rackApi_.children;
	}
	addButton(e) {
		return this.rackApi_.addButton(e);
	}
	addFolder(e) {
		return this.rackApi_.addFolder(e);
	}
	addTab(e) {
		return this.rackApi_.addTab(e);
	}
	add(e, t) {
		this.rackApi_.add(e, t);
	}
	remove(e) {
		this.rackApi_.remove(e);
	}
	addBinding(e, t, n) {
		return this.rackApi_.addBinding(e, t, n);
	}
	addBlade(e) {
		return this.rackApi_.addBlade(e);
	}
}
const tw = -1;
class tV {
	constructor() {
		(this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this)),
			(this.empty = Jt(!0)),
			(this.selectedIndex = Jt(tw)),
			(this.items_ = []);
	}
	add(e, t) {
		const n = t != null ? t : this.items_.length;
		this.items_.splice(n, 0, e), e.emitter.on('change', this.onItemSelectedChange_), this.keepSelection_();
	}
	remove(e) {
		const t = this.items_.indexOf(e);
		t < 0 || (this.items_.splice(t, 1), e.emitter.off('change', this.onItemSelectedChange_), this.keepSelection_());
	}
	keepSelection_() {
		if (this.items_.length === 0) {
			(this.selectedIndex.rawValue = tw), (this.empty.rawValue = !0);
			return;
		}
		const e = this.items_.findIndex((t) => t.rawValue);
		e < 0
			? (this.items_.forEach((t, n) => {
					t.rawValue = n === 0;
			  }),
			  (this.selectedIndex.rawValue = 0))
			: (this.items_.forEach((t, n) => {
					t.rawValue = n === e;
			  }),
			  (this.selectedIndex.rawValue = e)),
			(this.empty.rawValue = !1);
	}
	onItemSelectedChange_(e) {
		if (e.rawValue) {
			const t = this.items_.findIndex((n) => n === e.sender);
			this.items_.forEach((n, s) => {
				n.rawValue = s === t;
			}),
				(this.selectedIndex.rawValue = t);
		} else this.keepSelection_();
	}
}
const zc = wt('tab');
class nV {
	constructor(e, t) {
		(this.element = e.createElement('div')),
			this.element.classList.add(zc(), jT()),
			t.viewProps.bindClassModifiers(this.element),
			vr(t.empty, dc(this.element, zc(void 0, 'nop')));
		const n = e.createElement('div');
		n.classList.add(zc('t')), this.element.appendChild(n), (this.itemsElement = n);
		const s = e.createElement('div');
		s.classList.add(zc('i')), this.element.appendChild(s);
		const r = e.createElement('div');
		r.classList.add(zc('c')), this.element.appendChild(r), (this.contentsElement = r);
	}
}
class nw extends p0 {
	constructor(e, t) {
		const n = new tV(),
			s = new nV(e, { empty: n.empty, viewProps: t.viewProps });
		super({ blade: t.blade, rackController: new f0({ blade: t.blade, element: s.contentsElement, viewProps: t.viewProps }), view: s }),
			(this.onRackAdd_ = this.onRackAdd_.bind(this)),
			(this.onRackRemove_ = this.onRackRemove_.bind(this));
		const r = this.rackController.rack;
		r.emitter.on('add', this.onRackAdd_), r.emitter.on('remove', this.onRackRemove_), (this.tab = n);
	}
	add(e, t) {
		this.rackController.rack.add(e, t);
	}
	remove(e) {
		this.rackController.rack.remove(this.rackController.rack.children[e]);
	}
	onRackAdd_(e) {
		if (!e.root) return;
		const t = e.bladeController;
		kT(this.view.itemsElement, t.itemController.view.element, e.index),
			t.itemController.viewProps.set('parent', this.viewProps),
			this.tab.add(t.props.value('selected'));
	}
	onRackRemove_(e) {
		if (!e.root) return;
		const t = e.bladeController;
		h0(t.itemController.view.element), t.itemController.viewProps.set('parent', null), this.tab.remove(t.props.value('selected'));
	}
}
const KT = li({
	id: 'tab',
	type: 'blade',
	accept(i) {
		const e = rn(i, (t) => ({
			pages: t.required.array(t.required.object({ title: t.required.string })),
			view: t.required.constant('tab'),
		}));
		return !e || e.pages.length === 0 ? null : { params: e };
	},
	controller(i) {
		const e = new nw(i.document, { blade: i.blade, viewProps: i.viewProps });
		return (
			i.params.pages.forEach((t) => {
				const n = new vv(i.document, {
					blade: fc(),
					itemProps: ut.fromObject({ selected: !1, title: t.title }),
					props: ut.fromObject({ selected: !1 }),
					viewProps: Tr.create(),
				});
				e.add(n);
			}),
			e
		);
	},
	api(i) {
		return i.controller instanceof nw ? new Qz(i.controller, i.pool) : i.controller instanceof vv ? new eV(i.controller, i.pool) : null;
	},
});
function iV(i, e) {
	const t = i.accept(e.params);
	if (!t) return null;
	const n = rn(e.params, (s) => ({ disabled: s.optional.boolean, hidden: s.optional.boolean }));
	return i.controller({
		blade: fc(),
		document: e.document,
		params: Object.assign(Object.assign({}, t.params), {
			disabled: n == null ? void 0 : n.disabled,
			hidden: n == null ? void 0 : n.hidden,
		}),
		viewProps: Tr.create({ disabled: n == null ? void 0 : n.disabled, hidden: n == null ? void 0 : n.hidden }),
	});
}
class g0 extends Fh {
	get options() {
		return this.controller.valueController.props.get('options');
	}
	set options(e) {
		this.controller.valueController.props.set('options', e);
	}
}
class sV {
	constructor() {
		(this.disabled = !1), (this.emitter = new Mn());
	}
	dispose() {}
	tick() {
		this.disabled || this.emitter.emit('tick', { sender: this });
	}
}
class rV {
	constructor(e, t) {
		(this.disabled_ = !1),
			(this.timerId_ = null),
			(this.onTick_ = this.onTick_.bind(this)),
			(this.doc_ = e),
			(this.emitter = new Mn()),
			(this.interval_ = t),
			this.setTimer_();
	}
	get disabled() {
		return this.disabled_;
	}
	set disabled(e) {
		(this.disabled_ = e), this.disabled_ ? this.clearTimer_() : this.setTimer_();
	}
	dispose() {
		this.clearTimer_();
	}
	clearTimer_() {
		if (this.timerId_ === null) return;
		const e = this.doc_.defaultView;
		e && e.clearInterval(this.timerId_), (this.timerId_ = null);
	}
	setTimer_() {
		if ((this.clearTimer_(), this.interval_ <= 0)) return;
		const e = this.doc_.defaultView;
		e && (this.timerId_ = e.setInterval(this.onTick_, this.interval_));
	}
	onTick_() {
		this.disabled_ || this.emitter.emit('tick', { sender: this });
	}
}
class hu {
	constructor(e) {
		this.constraints = e;
	}
	constrain(e) {
		return this.constraints.reduce((t, n) => n.constrain(t), e);
	}
}
function lp(i, e) {
	if (i instanceof e) return i;
	if (i instanceof hu) {
		const t = i.constraints.reduce((n, s) => n || (s instanceof e ? s : null), null);
		if (t) return t;
	}
	return null;
}
class uu {
	constructor(e) {
		this.values = ut.fromObject({ options: e });
	}
	constrain(e) {
		const t = this.values.get('options');
		return t.length === 0 || t.filter((s) => s.value === e).length > 0 ? e : t[0].value;
	}
}
function du(i) {
	var e;
	const t = fv;
	if (Array.isArray(i))
		return (e = rn({ items: i }, (n) => ({
			items: n.required.array(n.required.object({ text: n.required.string, value: n.required.raw })),
		}))) === null || e === void 0
			? void 0
			: e.items;
	if (typeof i == 'object') return t.required.raw(i).value;
}
function v0(i) {
	if (Array.isArray(i)) return i;
	const e = [];
	return (
		Object.keys(i).forEach((t) => {
			e.push({ text: t, value: i[t] });
		}),
		e
	);
}
function _0(i) {
	return qt(i) ? null : new uu(v0(i));
}
const zm = wt('lst');
class oV {
	constructor(e, t) {
		(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.props_ = t.props),
			(this.element = e.createElement('div')),
			this.element.classList.add(zm()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('select');
		n.classList.add(zm('s')), t.viewProps.bindDisabled(n), this.element.appendChild(n), (this.selectElement = n);
		const s = e.createElement('div');
		s.classList.add(zm('m')),
			s.appendChild(yf(e, 'dropdown')),
			this.element.appendChild(s),
			t.value.emitter.on('change', this.onValueChange_),
			(this.value_ = t.value),
			Ks(this.props_, 'options', (r) => {
				zT(this.selectElement),
					r.forEach((o) => {
						const a = e.createElement('option');
						(a.textContent = o.text), this.selectElement.appendChild(a);
					}),
					this.update_();
			});
	}
	update_() {
		const e = this.props_.get('options').map((t) => t.value);
		this.selectElement.selectedIndex = e.indexOf(this.value_.rawValue);
	}
	onValueChange_() {
		this.update_();
	}
}
class wo {
	constructor(e, t) {
		(this.onSelectChange_ = this.onSelectChange_.bind(this)),
			(this.props = t.props),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new oV(e, { props: this.props, value: this.value, viewProps: this.viewProps })),
			this.view.selectElement.addEventListener('change', this.onSelectChange_);
	}
	onSelectChange_(e) {
		const t = e.currentTarget;
		this.value.rawValue = this.props.get('options')[t.selectedIndex].value;
	}
	importProps(e) {
		return Gi(
			e,
			null,
			(t) => ({ options: t.required.custom(du) }),
			(t) => (this.props.set('options', v0(t.options)), !0)
		);
	}
	exportProps() {
		return Wi(null, { options: this.props.get('options') });
	}
}
const iw = wt('pop');
class aV {
	constructor(e, t) {
		(this.element = e.createElement('div')),
			this.element.classList.add(iw()),
			t.viewProps.bindClassModifiers(this.element),
			vr(t.shows, dc(this.element, iw(void 0, 'v')));
	}
}
class $T {
	constructor(e, t) {
		(this.shows = Jt(!1)), (this.viewProps = t.viewProps), (this.view = new aV(e, { shows: this.shows, viewProps: this.viewProps }));
	}
}
const sw = wt('txt');
class lV {
	constructor(e, t) {
		(this.onChange_ = this.onChange_.bind(this)),
			(this.element = e.createElement('div')),
			this.element.classList.add(sw()),
			t.viewProps.bindClassModifiers(this.element),
			(this.props_ = t.props),
			this.props_.emitter.on('change', this.onChange_);
		const n = e.createElement('input');
		n.classList.add(sw('i')),
			(n.type = 'text'),
			t.viewProps.bindDisabled(n),
			this.element.appendChild(n),
			(this.inputElement = n),
			t.value.emitter.on('change', this.onChange_),
			(this.value_ = t.value),
			this.refresh();
	}
	refresh() {
		const e = this.props_.get('formatter');
		this.inputElement.value = e(this.value_.rawValue);
	}
	onChange_() {
		this.refresh();
	}
}
class Bh {
	constructor(e, t) {
		(this.onInputChange_ = this.onInputChange_.bind(this)),
			(this.parser_ = t.parser),
			(this.props = t.props),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new lV(e, { props: t.props, value: this.value, viewProps: this.viewProps })),
			this.view.inputElement.addEventListener('change', this.onInputChange_);
	}
	onInputChange_(e) {
		const n = e.currentTarget.value,
			s = this.parser_(n);
		qt(s) || (this.value.rawValue = s), this.view.refresh();
	}
}
function cV(i) {
	return String(i);
}
function ZT(i) {
	return i === 'false' ? !1 : !!i;
}
function rw(i) {
	return cV(i);
}
function hV(i) {
	return (e) => i.reduce((t, n) => (t !== null ? t : n(e)), null);
}
const uV = Mi(0);
function cp(i) {
	return uV(i) + '%';
}
function JT(i) {
	return String(i);
}
function _v(i) {
	return i;
}
function mc({ primary: i, secondary: e, forward: t, backward: n }) {
	let s = !1;
	function r(o) {
		s || ((s = !0), o(), (s = !1));
	}
	i.emitter.on('change', (o) => {
		r(() => {
			e.setRawValue(t(i.rawValue, e.rawValue), o.options);
		});
	}),
		e.emitter.on('change', (o) => {
			r(() => {
				i.setRawValue(n(i.rawValue, e.rawValue), o.options);
			}),
				r(() => {
					e.setRawValue(t(i.rawValue, e.rawValue), o.options);
				});
		}),
		r(() => {
			e.setRawValue(t(i.rawValue, e.rawValue), { forceEmit: !1, last: !0 });
		});
}
function gi(i, e) {
	const t = i * (e.altKey ? 0.1 : 1) * (e.shiftKey ? 10 : 1);
	return e.upKey ? +t : e.downKey ? -t : 0;
}
function kh(i) {
	return { altKey: i.altKey, downKey: i.key === 'ArrowDown', shiftKey: i.shiftKey, upKey: i.key === 'ArrowUp' };
}
function wr(i) {
	return { altKey: i.altKey, downKey: i.key === 'ArrowLeft', shiftKey: i.shiftKey, upKey: i.key === 'ArrowRight' };
}
function dV(i) {
	return i === 'ArrowUp' || i === 'ArrowDown';
}
function QT(i) {
	return dV(i) || i === 'ArrowLeft' || i === 'ArrowRight';
}
function Vm(i, e) {
	var t, n;
	const s = e.ownerDocument.defaultView,
		r = e.getBoundingClientRect();
	return {
		x: i.pageX - (((t = s && s.scrollX) !== null && t !== void 0 ? t : 0) + r.left),
		y: i.pageY - (((n = s && s.scrollY) !== null && n !== void 0 ? n : 0) + r.top),
	};
}
class qa {
	constructor(e) {
		(this.lastTouch_ = null),
			(this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this)),
			(this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this)),
			(this.onMouseDown_ = this.onMouseDown_.bind(this)),
			(this.onTouchEnd_ = this.onTouchEnd_.bind(this)),
			(this.onTouchMove_ = this.onTouchMove_.bind(this)),
			(this.onTouchStart_ = this.onTouchStart_.bind(this)),
			(this.elem_ = e),
			(this.emitter = new Mn()),
			e.addEventListener('touchstart', this.onTouchStart_, { passive: !1 }),
			e.addEventListener('touchmove', this.onTouchMove_, { passive: !0 }),
			e.addEventListener('touchend', this.onTouchEnd_),
			e.addEventListener('mousedown', this.onMouseDown_);
	}
	computePosition_(e) {
		const t = this.elem_.getBoundingClientRect();
		return { bounds: { width: t.width, height: t.height }, point: e ? { x: e.x, y: e.y } : null };
	}
	onMouseDown_(e) {
		var t;
		e.preventDefault(), (t = e.currentTarget) === null || t === void 0 || t.focus();
		const n = this.elem_.ownerDocument;
		n.addEventListener('mousemove', this.onDocumentMouseMove_),
			n.addEventListener('mouseup', this.onDocumentMouseUp_),
			this.emitter.emit('down', {
				altKey: e.altKey,
				data: this.computePosition_(Vm(e, this.elem_)),
				sender: this,
				shiftKey: e.shiftKey,
			});
	}
	onDocumentMouseMove_(e) {
		this.emitter.emit('move', { altKey: e.altKey, data: this.computePosition_(Vm(e, this.elem_)), sender: this, shiftKey: e.shiftKey });
	}
	onDocumentMouseUp_(e) {
		const t = this.elem_.ownerDocument;
		t.removeEventListener('mousemove', this.onDocumentMouseMove_),
			t.removeEventListener('mouseup', this.onDocumentMouseUp_),
			this.emitter.emit('up', {
				altKey: e.altKey,
				data: this.computePosition_(Vm(e, this.elem_)),
				sender: this,
				shiftKey: e.shiftKey,
			});
	}
	onTouchStart_(e) {
		e.preventDefault();
		const t = e.targetTouches.item(0),
			n = this.elem_.getBoundingClientRect();
		this.emitter.emit('down', {
			altKey: e.altKey,
			data: this.computePosition_(t ? { x: t.clientX - n.left, y: t.clientY - n.top } : void 0),
			sender: this,
			shiftKey: e.shiftKey,
		}),
			(this.lastTouch_ = t);
	}
	onTouchMove_(e) {
		const t = e.targetTouches.item(0),
			n = this.elem_.getBoundingClientRect();
		this.emitter.emit('move', {
			altKey: e.altKey,
			data: this.computePosition_(t ? { x: t.clientX - n.left, y: t.clientY - n.top } : void 0),
			sender: this,
			shiftKey: e.shiftKey,
		}),
			(this.lastTouch_ = t);
	}
	onTouchEnd_(e) {
		var t;
		const n = (t = e.targetTouches.item(0)) !== null && t !== void 0 ? t : this.lastTouch_,
			s = this.elem_.getBoundingClientRect();
		this.emitter.emit('up', {
			altKey: e.altKey,
			data: this.computePosition_(n ? { x: n.clientX - s.left, y: n.clientY - s.top } : void 0),
			sender: this,
			shiftKey: e.shiftKey,
		});
	}
}
const Ki = wt('txt');
class pV {
	constructor(e, t) {
		(this.onChange_ = this.onChange_.bind(this)),
			(this.props_ = t.props),
			this.props_.emitter.on('change', this.onChange_),
			(this.element = e.createElement('div')),
			this.element.classList.add(Ki(), Ki(void 0, 'num')),
			t.arrayPosition && this.element.classList.add(Ki(void 0, t.arrayPosition)),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('input');
		n.classList.add(Ki('i')),
			(n.type = 'text'),
			t.viewProps.bindDisabled(n),
			this.element.appendChild(n),
			(this.inputElement = n),
			(this.onDraggingChange_ = this.onDraggingChange_.bind(this)),
			(this.dragging_ = t.dragging),
			this.dragging_.emitter.on('change', this.onDraggingChange_),
			this.element.classList.add(Ki()),
			this.inputElement.classList.add(Ki('i'));
		const s = e.createElement('div');
		s.classList.add(Ki('k')), this.element.appendChild(s), (this.knobElement = s);
		const r = e.createElementNS(Gs, 'svg');
		r.classList.add(Ki('g')), this.knobElement.appendChild(r);
		const o = e.createElementNS(Gs, 'path');
		o.classList.add(Ki('gb')), r.appendChild(o), (this.guideBodyElem_ = o);
		const a = e.createElementNS(Gs, 'path');
		a.classList.add(Ki('gh')), r.appendChild(a), (this.guideHeadElem_ = a);
		const l = e.createElement('div');
		l.classList.add(wt('tt')()),
			this.knobElement.appendChild(l),
			(this.tooltipElem_ = l),
			t.value.emitter.on('change', this.onChange_),
			(this.value = t.value),
			this.refresh();
	}
	onDraggingChange_(e) {
		if (e.rawValue === null) {
			this.element.classList.remove(Ki(void 0, 'drg'));
			return;
		}
		this.element.classList.add(Ki(void 0, 'drg'));
		const t = e.rawValue / this.props_.get('pointerScale'),
			n = t + (t > 0 ? -1 : t < 0 ? 1 : 0),
			s = Tn(-n, -4, 4);
		this.guideHeadElem_.setAttributeNS(
			null,
			'd',
			[
				'M '
					.concat(n + s, ',0 L')
					.concat(n, ',4 L')
					.concat(n + s, ',8'),
				'M '.concat(t, ',-1 L').concat(t, ',9'),
			].join(' ')
		),
			this.guideBodyElem_.setAttributeNS(null, 'd', 'M 0,4 L'.concat(t, ',4'));
		const r = this.props_.get('formatter');
		(this.tooltipElem_.textContent = r(this.value.rawValue)), (this.tooltipElem_.style.left = ''.concat(t, 'px'));
	}
	refresh() {
		const e = this.props_.get('formatter');
		this.inputElement.value = e(this.value.rawValue);
	}
	onChange_() {
		this.refresh();
	}
}
class pu {
	constructor(e, t) {
		var n;
		(this.originRawValue_ = 0),
			(this.onInputChange_ = this.onInputChange_.bind(this)),
			(this.onInputKeyDown_ = this.onInputKeyDown_.bind(this)),
			(this.onInputKeyUp_ = this.onInputKeyUp_.bind(this)),
			(this.onPointerDown_ = this.onPointerDown_.bind(this)),
			(this.onPointerMove_ = this.onPointerMove_.bind(this)),
			(this.onPointerUp_ = this.onPointerUp_.bind(this)),
			(this.parser_ = t.parser),
			(this.props = t.props),
			(this.sliderProps_ = (n = t.sliderProps) !== null && n !== void 0 ? n : null),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.dragging_ = Jt(null)),
			(this.view = new pV(e, {
				arrayPosition: t.arrayPosition,
				dragging: this.dragging_,
				props: this.props,
				value: this.value,
				viewProps: this.viewProps,
			})),
			this.view.inputElement.addEventListener('change', this.onInputChange_),
			this.view.inputElement.addEventListener('keydown', this.onInputKeyDown_),
			this.view.inputElement.addEventListener('keyup', this.onInputKeyUp_);
		const s = new qa(this.view.knobElement);
		s.emitter.on('down', this.onPointerDown_), s.emitter.on('move', this.onPointerMove_), s.emitter.on('up', this.onPointerUp_);
	}
	constrainValue_(e) {
		var t, n;
		const s = (t = this.sliderProps_) === null || t === void 0 ? void 0 : t.get('min'),
			r = (n = this.sliderProps_) === null || n === void 0 ? void 0 : n.get('max');
		let o = e;
		return s !== void 0 && (o = Math.max(o, s)), r !== void 0 && (o = Math.min(o, r)), o;
	}
	onInputChange_(e) {
		const n = e.currentTarget.value,
			s = this.parser_(n);
		qt(s) || (this.value.rawValue = this.constrainValue_(s)), this.view.refresh();
	}
	onInputKeyDown_(e) {
		const t = gi(this.props.get('keyScale'), kh(e));
		t !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + t), { forceEmit: !1, last: !1 });
	}
	onInputKeyUp_(e) {
		gi(this.props.get('keyScale'), kh(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
	}
	onPointerDown_() {
		(this.originRawValue_ = this.value.rawValue), (this.dragging_.rawValue = 0);
	}
	computeDraggingValue_(e) {
		if (!e.point) return null;
		const t = e.point.x - e.bounds.width / 2;
		return this.constrainValue_(this.originRawValue_ + t * this.props.get('pointerScale'));
	}
	onPointerMove_(e) {
		const t = this.computeDraggingValue_(e.data);
		t !== null &&
			(this.value.setRawValue(t, { forceEmit: !1, last: !1 }),
			(this.dragging_.rawValue = this.value.rawValue - this.originRawValue_));
	}
	onPointerUp_(e) {
		const t = this.computeDraggingValue_(e.data);
		t !== null && (this.value.setRawValue(t, { forceEmit: !0, last: !0 }), (this.dragging_.rawValue = null));
	}
}
const Hm = wt('sld');
class fV {
	constructor(e, t) {
		(this.onChange_ = this.onChange_.bind(this)),
			(this.props_ = t.props),
			this.props_.emitter.on('change', this.onChange_),
			(this.element = e.createElement('div')),
			this.element.classList.add(Hm()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(Hm('t')), t.viewProps.bindTabIndex(n), this.element.appendChild(n), (this.trackElement = n);
		const s = e.createElement('div');
		s.classList.add(Hm('k')),
			this.trackElement.appendChild(s),
			(this.knobElement = s),
			t.value.emitter.on('change', this.onChange_),
			(this.value = t.value),
			this.update_();
	}
	update_() {
		const e = Tn(Dt(this.value.rawValue, this.props_.get('min'), this.props_.get('max'), 0, 100), 0, 100);
		this.knobElement.style.width = ''.concat(e, '%');
	}
	onChange_() {
		this.update_();
	}
}
class mV {
	constructor(e, t) {
		(this.onKeyDown_ = this.onKeyDown_.bind(this)),
			(this.onKeyUp_ = this.onKeyUp_.bind(this)),
			(this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this)),
			(this.onPointerUp_ = this.onPointerUp_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.props = t.props),
			(this.view = new fV(e, { props: this.props, value: this.value, viewProps: this.viewProps })),
			(this.ptHandler_ = new qa(this.view.trackElement)),
			this.ptHandler_.emitter.on('down', this.onPointerDownOrMove_),
			this.ptHandler_.emitter.on('move', this.onPointerDownOrMove_),
			this.ptHandler_.emitter.on('up', this.onPointerUp_),
			this.view.trackElement.addEventListener('keydown', this.onKeyDown_),
			this.view.trackElement.addEventListener('keyup', this.onKeyUp_);
	}
	handlePointerEvent_(e, t) {
		e.point &&
			this.value.setRawValue(
				Dt(Tn(e.point.x, 0, e.bounds.width), 0, e.bounds.width, this.props.get('min'), this.props.get('max')),
				t
			);
	}
	onPointerDownOrMove_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
	}
	onKeyDown_(e) {
		const t = gi(this.props.get('keyScale'), wr(e));
		t !== 0 && this.value.setRawValue(this.value.rawValue + t, { forceEmit: !1, last: !1 });
	}
	onKeyUp_(e) {
		gi(this.props.get('keyScale'), wr(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
	}
}
const Gm = wt('sldtxt');
class gV {
	constructor(e, t) {
		(this.element = e.createElement('div')), this.element.classList.add(Gm());
		const n = e.createElement('div');
		n.classList.add(Gm('s')), (this.sliderView_ = t.sliderView), n.appendChild(this.sliderView_.element), this.element.appendChild(n);
		const s = e.createElement('div');
		s.classList.add(Gm('t')), (this.textView_ = t.textView), s.appendChild(this.textView_.element), this.element.appendChild(s);
	}
}
class hp {
	constructor(e, t) {
		(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.sliderC_ = new mV(e, { props: t.sliderProps, value: t.value, viewProps: this.viewProps })),
			(this.textC_ = new pu(e, {
				parser: t.parser,
				props: t.textProps,
				sliderProps: t.sliderProps,
				value: t.value,
				viewProps: t.viewProps,
			})),
			(this.view = new gV(e, { sliderView: this.sliderC_.view, textView: this.textC_.view }));
	}
	get sliderController() {
		return this.sliderC_;
	}
	get textController() {
		return this.textC_;
	}
	importProps(e) {
		return Gi(
			e,
			null,
			(t) => ({ max: t.required.number, min: t.required.number }),
			(t) => {
				const n = this.sliderC_.props;
				return n.set('max', t.max), n.set('min', t.min), !0;
			}
		);
	}
	exportProps() {
		const e = this.sliderC_.props;
		return Wi(null, { max: e.get('max'), min: e.get('min') });
	}
}
function e1(i) {
	return {
		sliderProps: new ut({ keyScale: i.keyScale, max: i.max, min: i.min }),
		textProps: new ut({ formatter: Jt(i.formatter), keyScale: i.keyScale, pointerScale: Jt(i.pointerScale) }),
	};
}
const vV = { containerUnitSize: 'cnt-usz' };
function t1(i) {
	return '--'.concat(vV[i]);
}
function zh(i) {
	return FT(i);
}
function to(i) {
	if (pv(i)) return rn(i, zh);
}
function pr(i, e) {
	if (!i) return;
	const t = [],
		n = OT(i, e);
	n && t.push(n);
	const s = UT(i);
	return s && t.push(s), new hu(t);
}
function _V(i) {
	return i ? i.major === pc.major : !1;
}
function n1(i) {
	if (i === 'inline' || i === 'popup') return i;
}
function fu(i, e) {
	i.write(e);
}
const Td = wt('ckb');
class yV {
	constructor(e, t) {
		(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.element = e.createElement('div')),
			this.element.classList.add(Td()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('label');
		n.classList.add(Td('l')), this.element.appendChild(n), (this.labelElement = n);
		const s = e.createElement('input');
		s.classList.add(Td('i')),
			(s.type = 'checkbox'),
			this.labelElement.appendChild(s),
			(this.inputElement = s),
			t.viewProps.bindDisabled(this.inputElement);
		const r = e.createElement('div');
		r.classList.add(Td('w')), this.labelElement.appendChild(r);
		const o = yf(e, 'check');
		r.appendChild(o), t.value.emitter.on('change', this.onValueChange_), (this.value = t.value), this.update_();
	}
	update_() {
		this.inputElement.checked = this.value.rawValue;
	}
	onValueChange_() {
		this.update_();
	}
}
class xV {
	constructor(e, t) {
		(this.onInputChange_ = this.onInputChange_.bind(this)),
			(this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new yV(e, { value: this.value, viewProps: this.viewProps })),
			this.view.inputElement.addEventListener('change', this.onInputChange_),
			this.view.labelElement.addEventListener('mousedown', this.onLabelMouseDown_);
	}
	onInputChange_(e) {
		const t = e.currentTarget;
		(this.value.rawValue = t.checked), e.preventDefault(), e.stopPropagation();
	}
	onLabelMouseDown_(e) {
		e.preventDefault();
	}
}
function bV(i) {
	const e = [],
		t = _0(i.options);
	return t && e.push(t), new hu(e);
}
const wV = li({
		id: 'input-bool',
		type: 'input',
		accept: (i, e) => {
			if (typeof i != 'boolean') return null;
			const t = rn(e, (n) => ({ options: n.optional.custom(du), readonly: n.optional.constant(!1) }));
			return t ? { initialValue: i, params: t } : null;
		},
		binding: { reader: (i) => ZT, constraint: (i) => bV(i.params), writer: (i) => fu },
		controller: (i) => {
			const e = i.document,
				t = i.value,
				n = i.constraint,
				s = n && lp(n, uu);
			return s
				? new wo(e, { props: new ut({ options: s.values.value('options') }), value: t, viewProps: i.viewProps })
				: new xV(e, { value: t, viewProps: i.viewProps });
		},
		api(i) {
			return typeof i.controller.value.rawValue != 'boolean'
				? null
				: i.controller.valueController instanceof wo
				? new g0(i.controller)
				: null;
		},
	}),
	Zo = wt('col');
class SV {
	constructor(e, t) {
		(this.element = e.createElement('div')),
			this.element.classList.add(Zo()),
			t.foldable.bindExpandedClass(this.element, Zo(void 0, 'expanded')),
			Ks(t.foldable, 'completed', dc(this.element, Zo(void 0, 'cpl')));
		const n = e.createElement('div');
		n.classList.add(Zo('h')), this.element.appendChild(n);
		const s = e.createElement('div');
		s.classList.add(Zo('s')), n.appendChild(s), (this.swatchElement = s);
		const r = e.createElement('div');
		if ((r.classList.add(Zo('t')), n.appendChild(r), (this.textElement = r), t.pickerLayout === 'inline')) {
			const o = e.createElement('div');
			o.classList.add(Zo('p')), this.element.appendChild(o), (this.pickerElement = o);
		} else this.pickerElement = null;
	}
}
function MV(i, e, t) {
	const n = Tn(i / 255, 0, 1),
		s = Tn(e / 255, 0, 1),
		r = Tn(t / 255, 0, 1),
		o = Math.max(n, s, r),
		a = Math.min(n, s, r),
		l = o - a;
	let c = 0,
		h = 0;
	const u = (a + o) / 2;
	return (
		l !== 0 &&
			((h = l / (1 - Math.abs(o + a - 1))),
			n === o ? (c = (s - r) / l) : s === o ? (c = 2 + (r - n) / l) : (c = 4 + (n - s) / l),
			(c = c / 6 + (c < 0 ? 1 : 0))),
		[c * 360, h * 100, u * 100]
	);
}
function EV(i, e, t) {
	const n = ((i % 360) + 360) % 360,
		s = Tn(e / 100, 0, 1),
		r = Tn(t / 100, 0, 1),
		o = (1 - Math.abs(2 * r - 1)) * s,
		a = o * (1 - Math.abs(((n / 60) % 2) - 1)),
		l = r - o / 2;
	let c, h, u;
	return (
		n >= 0 && n < 60
			? ([c, h, u] = [o, a, 0])
			: n >= 60 && n < 120
			? ([c, h, u] = [a, o, 0])
			: n >= 120 && n < 180
			? ([c, h, u] = [0, o, a])
			: n >= 180 && n < 240
			? ([c, h, u] = [0, a, o])
			: n >= 240 && n < 300
			? ([c, h, u] = [a, 0, o])
			: ([c, h, u] = [o, 0, a]),
		[(c + l) * 255, (h + l) * 255, (u + l) * 255]
	);
}
function TV(i, e, t) {
	const n = Tn(i / 255, 0, 1),
		s = Tn(e / 255, 0, 1),
		r = Tn(t / 255, 0, 1),
		o = Math.max(n, s, r),
		a = Math.min(n, s, r),
		l = o - a;
	let c;
	l === 0
		? (c = 0)
		: o === n
		? (c = 60 * (((((s - r) / l) % 6) + 6) % 6))
		: o === s
		? (c = 60 * ((r - n) / l + 2))
		: (c = 60 * ((n - s) / l + 4));
	const h = o === 0 ? 0 : l / o,
		u = o;
	return [c, h * 100, u * 100];
}
function i1(i, e, t) {
	const n = LT(i, 360),
		s = Tn(e / 100, 0, 1),
		r = Tn(t / 100, 0, 1),
		o = r * s,
		a = o * (1 - Math.abs(((n / 60) % 2) - 1)),
		l = r - o;
	let c, h, u;
	return (
		n >= 0 && n < 60
			? ([c, h, u] = [o, a, 0])
			: n >= 60 && n < 120
			? ([c, h, u] = [a, o, 0])
			: n >= 120 && n < 180
			? ([c, h, u] = [0, o, a])
			: n >= 180 && n < 240
			? ([c, h, u] = [0, a, o])
			: n >= 240 && n < 300
			? ([c, h, u] = [a, 0, o])
			: ([c, h, u] = [o, 0, a]),
		[(c + l) * 255, (h + l) * 255, (u + l) * 255]
	);
}
function AV(i, e, t) {
	const n = t + (e * (100 - Math.abs(2 * t - 100))) / 200;
	return [i, n !== 0 ? (e * (100 - Math.abs(2 * t - 100))) / n : 0, t + (e * (100 - Math.abs(2 * t - 100))) / (2 * 100)];
}
function CV(i, e, t) {
	const n = 100 - Math.abs((t * (200 - e)) / 100 - 100);
	return [i, n !== 0 ? (e * t) / n : 0, (t * (200 - e)) / (2 * 100)];
}
function $s(i) {
	return [i[0], i[1], i[2]];
}
function bf(i, e) {
	return [i[0], i[1], i[2], e];
}
const RV = {
	hsl: { hsl: (i, e, t) => [i, e, t], hsv: AV, rgb: EV },
	hsv: { hsl: CV, hsv: (i, e, t) => [i, e, t], rgb: i1 },
	rgb: { hsl: MV, hsv: TV, rgb: (i, e, t) => [i, e, t] },
};
function ec(i, e) {
	return [
		e === 'float' ? 1 : i === 'rgb' ? 255 : 360,
		e === 'float' ? 1 : i === 'rgb' ? 255 : 100,
		e === 'float' ? 1 : i === 'rgb' ? 255 : 100,
	];
}
function PV(i, e) {
	return i === e ? e : LT(i, e);
}
function s1(i, e, t) {
	var n;
	const s = ec(e, t);
	return [
		e === 'rgb' ? Tn(i[0], 0, s[0]) : PV(i[0], s[0]),
		Tn(i[1], 0, s[1]),
		Tn(i[2], 0, s[2]),
		Tn((n = i[3]) !== null && n !== void 0 ? n : 1, 0, 1),
	];
}
function ow(i, e, t, n) {
	const s = ec(e, t),
		r = ec(e, n);
	return i.map((o, a) => (o / s[a]) * r[a]);
}
function r1(i, e, t) {
	const n = ow(i, e.mode, e.type, 'int'),
		s = RV[e.mode][t.mode](...n);
	return ow(s, t.mode, 'int', t.type);
}
class At {
	static black() {
		return new At([0, 0, 0], 'rgb');
	}
	constructor(e, t) {
		(this.type = 'int'), (this.mode = t), (this.comps_ = s1(e, t, this.type));
	}
	getComponents(e) {
		return bf(
			r1($s(this.comps_), { mode: this.mode, type: this.type }, { mode: e != null ? e : this.mode, type: this.type }),
			this.comps_[3]
		);
	}
	toRgbaObject() {
		const e = this.getComponents('rgb');
		return { r: e[0], g: e[1], b: e[2], a: e[3] };
	}
}
const Gr = wt('colp');
class LV {
	constructor(e, t) {
		(this.alphaViews_ = null),
			(this.element = e.createElement('div')),
			this.element.classList.add(Gr()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(Gr('hsv'));
		const s = e.createElement('div');
		s.classList.add(Gr('sv')), (this.svPaletteView_ = t.svPaletteView), s.appendChild(this.svPaletteView_.element), n.appendChild(s);
		const r = e.createElement('div');
		r.classList.add(Gr('h')),
			(this.hPaletteView_ = t.hPaletteView),
			r.appendChild(this.hPaletteView_.element),
			n.appendChild(r),
			this.element.appendChild(n);
		const o = e.createElement('div');
		if (
			(o.classList.add(Gr('rgb')),
			(this.textsView_ = t.textsView),
			o.appendChild(this.textsView_.element),
			this.element.appendChild(o),
			t.alphaViews)
		) {
			this.alphaViews_ = { palette: t.alphaViews.palette, text: t.alphaViews.text };
			const a = e.createElement('div');
			a.classList.add(Gr('a'));
			const l = e.createElement('div');
			l.classList.add(Gr('ap')), l.appendChild(this.alphaViews_.palette.element), a.appendChild(l);
			const c = e.createElement('div');
			c.classList.add(Gr('at')), c.appendChild(this.alphaViews_.text.element), a.appendChild(c), this.element.appendChild(a);
		}
	}
	get allFocusableElements() {
		const e = [
			this.svPaletteView_.element,
			this.hPaletteView_.element,
			this.textsView_.modeSelectElement,
			...this.textsView_.inputViews.map((t) => t.inputElement),
		];
		return this.alphaViews_ && e.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement), e;
	}
}
function IV(i) {
	return i === 'int' ? 'int' : i === 'float' ? 'float' : void 0;
}
function y0(i) {
	return rn(i, (e) => ({
		color: e.optional.object({ alpha: e.optional.boolean, type: e.optional.custom(IV) }),
		expanded: e.optional.boolean,
		picker: e.optional.custom(n1),
		readonly: e.optional.constant(!1),
	}));
}
function Oa(i) {
	return i ? 0.1 : 1;
}
function o1(i) {
	var e;
	return (e = i.color) === null || e === void 0 ? void 0 : e.type;
}
class x0 {
	constructor(e, t) {
		(this.type = 'float'), (this.mode = t), (this.comps_ = s1(e, t, this.type));
	}
	getComponents(e) {
		return bf(
			r1($s(this.comps_), { mode: this.mode, type: this.type }, { mode: e != null ? e : this.mode, type: this.type }),
			this.comps_[3]
		);
	}
	toRgbaObject() {
		const e = this.getComponents('rgb');
		return { r: e[0], g: e[1], b: e[2], a: e[3] };
	}
}
const DV = { int: (i, e) => new At(i, e), float: (i, e) => new x0(i, e) };
function b0(i, e, t) {
	return DV[t](i, e);
}
function OV(i) {
	return i.type === 'float';
}
function UV(i) {
	return i.type === 'int';
}
function NV(i) {
	const e = i.getComponents(),
		t = ec(i.mode, 'int');
	return new At(
		[Math.round(Dt(e[0], 0, 1, 0, t[0])), Math.round(Dt(e[1], 0, 1, 0, t[1])), Math.round(Dt(e[2], 0, 1, 0, t[2])), e[3]],
		i.mode
	);
}
function FV(i) {
	const e = i.getComponents(),
		t = ec(i.mode, 'int');
	return new x0([Dt(e[0], 0, t[0], 0, 1), Dt(e[1], 0, t[1], 0, 1), Dt(e[2], 0, t[2], 0, 1), e[3]], i.mode);
}
function ai(i, e) {
	if (i.type === e) return i;
	if (UV(i) && e === 'float') return FV(i);
	if (OV(i) && e === 'int') return NV(i);
	throw cn.shouldNeverHappen();
}
function BV(i, e) {
	return i.alpha === e.alpha && i.mode === e.mode && i.notation === e.notation && i.type === e.type;
}
function ns(i, e) {
	const t = i.match(/^(.+)%$/);
	return Math.min(t ? parseFloat(t[1]) * 0.01 * e : parseFloat(i), e);
}
const kV = { deg: (i) => i, grad: (i) => (i * 360) / 400, rad: (i) => (i * 360) / (2 * Math.PI), turn: (i) => i * 360 };
function a1(i) {
	const e = i.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
	if (!e) return parseFloat(i);
	const t = parseFloat(e[1]),
		n = e[2];
	return kV[n](t);
}
function l1(i) {
	const e = i.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [ns(e[1], 255), ns(e[2], 255), ns(e[3], 255)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function zV(i) {
	const e = l1(i);
	return e ? new At(e, 'rgb') : null;
}
function c1(i) {
	const e = i.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [ns(e[1], 255), ns(e[2], 255), ns(e[3], 255), ns(e[4], 1)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function VV(i) {
	const e = c1(i);
	return e ? new At(e, 'rgb') : null;
}
function h1(i) {
	const e = i.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
	if (!e) return null;
	const t = [a1(e[1]), ns(e[2], 100), ns(e[3], 100)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function HV(i) {
	const e = h1(i);
	return e ? new At(e, 'hsl') : null;
}
function u1(i) {
	const e = i.match(
		/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/
	);
	if (!e) return null;
	const t = [a1(e[1]), ns(e[2], 100), ns(e[3], 100), ns(e[4], 1)];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function GV(i) {
	const e = u1(i);
	return e ? new At(e, 'hsl') : null;
}
function d1(i) {
	const e = i.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
	if (e) return [parseInt(e[1] + e[1], 16), parseInt(e[2] + e[2], 16), parseInt(e[3] + e[3], 16)];
	const t = i.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
	return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : null;
}
function WV(i) {
	const e = d1(i);
	return e ? new At(e, 'rgb') : null;
}
function p1(i) {
	const e = i.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
	if (e)
		return [
			parseInt(e[1] + e[1], 16),
			parseInt(e[2] + e[2], 16),
			parseInt(e[3] + e[3], 16),
			Dt(parseInt(e[4] + e[4], 16), 0, 255, 0, 1),
		];
	const t = i.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
	return t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16), Dt(parseInt(t[4], 16), 0, 255, 0, 1)] : null;
}
function XV(i) {
	const e = p1(i);
	return e ? new At(e, 'rgb') : null;
}
function f1(i) {
	const e = i.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
	if (!e) return null;
	const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) ? null : t;
}
function qV(i) {
	return (e) => {
		const t = f1(e);
		return t ? b0(t, 'rgb', i) : null;
	};
}
function m1(i) {
	const e = i.match(
		/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/
	);
	if (!e) return null;
	const t = [parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]), parseFloat(e[4])];
	return isNaN(t[0]) || isNaN(t[1]) || isNaN(t[2]) || isNaN(t[3]) ? null : t;
}
function YV(i) {
	return (e) => {
		const t = m1(e);
		return t ? b0(t, 'rgb', i) : null;
	};
}
const jV = [
	{ parser: d1, result: { alpha: !1, mode: 'rgb', notation: 'hex' } },
	{ parser: p1, result: { alpha: !0, mode: 'rgb', notation: 'hex' } },
	{ parser: l1, result: { alpha: !1, mode: 'rgb', notation: 'func' } },
	{ parser: c1, result: { alpha: !0, mode: 'rgb', notation: 'func' } },
	{ parser: h1, result: { alpha: !1, mode: 'hsl', notation: 'func' } },
	{ parser: u1, result: { alpha: !0, mode: 'hsl', notation: 'func' } },
	{ parser: f1, result: { alpha: !1, mode: 'rgb', notation: 'object' } },
	{ parser: m1, result: { alpha: !0, mode: 'rgb', notation: 'object' } },
];
function KV(i) {
	return jV.reduce((e, { parser: t, result: n }) => e || (t(i) ? n : null), null);
}
function $V(i, e = 'int') {
	const t = KV(i);
	return t
		? t.notation === 'hex' && e !== 'float'
			? Object.assign(Object.assign({}, t), { type: 'int' })
			: t.notation === 'func'
			? Object.assign(Object.assign({}, t), { type: e })
			: null
		: null;
}
function mu(i) {
	const e = [WV, XV, zV, VV, HV, GV];
	e.push(qV('int'), YV('int'));
	const t = hV(e);
	return (n) => {
		const s = t(n);
		return s ? ai(s, i) : null;
	};
}
function ZV(i) {
	const e = mu('int');
	if (typeof i != 'string') return At.black();
	const t = e(i);
	return t != null ? t : At.black();
}
function g1(i) {
	const e = Tn(Math.floor(i), 0, 255).toString(16);
	return e.length === 1 ? '0'.concat(e) : e;
}
function w0(i, e = '#') {
	const t = $s(i.getComponents('rgb')).map(g1).join('');
	return ''.concat(e).concat(t);
}
function S0(i, e = '#') {
	const t = i.getComponents('rgb'),
		n = [t[0], t[1], t[2], t[3] * 255].map(g1).join('');
	return ''.concat(e).concat(n);
}
function v1(i) {
	const e = Mi(0),
		t = ai(i, 'int'),
		n = $s(t.getComponents('rgb')).map((s) => e(s));
	return 'rgb('.concat(n.join(', '), ')');
}
function Hd(i) {
	const e = Mi(2),
		t = Mi(0),
		s = ai(i, 'int')
			.getComponents('rgb')
			.map((r, o) => (o === 3 ? e : t)(r));
	return 'rgba('.concat(s.join(', '), ')');
}
function JV(i) {
	const e = [Mi(0), cp, cp],
		t = ai(i, 'int'),
		n = $s(t.getComponents('hsl')).map((s, r) => e[r](s));
	return 'hsl('.concat(n.join(', '), ')');
}
function QV(i) {
	const e = [Mi(0), cp, cp, Mi(2)],
		n = ai(i, 'int')
			.getComponents('hsl')
			.map((s, r) => e[r](s));
	return 'hsla('.concat(n.join(', '), ')');
}
function _1(i, e) {
	const t = Mi(e === 'float' ? 2 : 0),
		n = ['r', 'g', 'b'],
		s = ai(i, e),
		r = $s(s.getComponents('rgb')).map((o, a) => ''.concat(n[a], ': ').concat(t(o)));
	return '{'.concat(r.join(', '), '}');
}
function eH(i) {
	return (e) => _1(e, i);
}
function y1(i, e) {
	const t = Mi(2),
		n = Mi(e === 'float' ? 2 : 0),
		s = ['r', 'g', 'b', 'a'],
		o = ai(i, e)
			.getComponents('rgb')
			.map((a, l) => {
				const c = l === 3 ? t : n;
				return ''.concat(s[l], ': ').concat(c(a));
			});
	return '{'.concat(o.join(', '), '}');
}
function tH(i) {
	return (e) => y1(e, i);
}
const nH = [
	{ format: { alpha: !1, mode: 'rgb', notation: 'hex', type: 'int' }, stringifier: w0 },
	{ format: { alpha: !0, mode: 'rgb', notation: 'hex', type: 'int' }, stringifier: S0 },
	{ format: { alpha: !1, mode: 'rgb', notation: 'func', type: 'int' }, stringifier: v1 },
	{ format: { alpha: !0, mode: 'rgb', notation: 'func', type: 'int' }, stringifier: Hd },
	{ format: { alpha: !1, mode: 'hsl', notation: 'func', type: 'int' }, stringifier: JV },
	{ format: { alpha: !0, mode: 'hsl', notation: 'func', type: 'int' }, stringifier: QV },
	...['int', 'float'].reduce(
		(i, e) => [
			...i,
			{ format: { alpha: !1, mode: 'rgb', notation: 'object', type: e }, stringifier: eH(e) },
			{ format: { alpha: !0, mode: 'rgb', notation: 'object', type: e }, stringifier: tH(e) },
		],
		[]
	),
];
function x1(i) {
	return nH.reduce((e, t) => e || (BV(t.format, i) ? t.stringifier : null), null);
}
const Vc = wt('apl');
class iH {
	constructor(e, t) {
		(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.value = t.value),
			this.value.emitter.on('change', this.onValueChange_),
			(this.element = e.createElement('div')),
			this.element.classList.add(Vc()),
			t.viewProps.bindClassModifiers(this.element),
			t.viewProps.bindTabIndex(this.element);
		const n = e.createElement('div');
		n.classList.add(Vc('b')), this.element.appendChild(n);
		const s = e.createElement('div');
		s.classList.add(Vc('c')), n.appendChild(s), (this.colorElem_ = s);
		const r = e.createElement('div');
		r.classList.add(Vc('m')), this.element.appendChild(r), (this.markerElem_ = r);
		const o = e.createElement('div');
		o.classList.add(Vc('p')), this.markerElem_.appendChild(o), (this.previewElem_ = o), this.update_();
	}
	update_() {
		const e = this.value.rawValue,
			t = e.getComponents('rgb'),
			n = new At([t[0], t[1], t[2], 0], 'rgb'),
			s = new At([t[0], t[1], t[2], 255], 'rgb'),
			r = ['to right', Hd(n), Hd(s)];
		(this.colorElem_.style.background = 'linear-gradient('.concat(r.join(','), ')')), (this.previewElem_.style.backgroundColor = Hd(e));
		const o = Dt(t[3], 0, 1, 0, 100);
		this.markerElem_.style.left = ''.concat(o, '%');
	}
	onValueChange_() {
		this.update_();
	}
}
class sH {
	constructor(e, t) {
		(this.onKeyDown_ = this.onKeyDown_.bind(this)),
			(this.onKeyUp_ = this.onKeyUp_.bind(this)),
			(this.onPointerDown_ = this.onPointerDown_.bind(this)),
			(this.onPointerMove_ = this.onPointerMove_.bind(this)),
			(this.onPointerUp_ = this.onPointerUp_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new iH(e, { value: this.value, viewProps: this.viewProps })),
			(this.ptHandler_ = new qa(this.view.element)),
			this.ptHandler_.emitter.on('down', this.onPointerDown_),
			this.ptHandler_.emitter.on('move', this.onPointerMove_),
			this.ptHandler_.emitter.on('up', this.onPointerUp_),
			this.view.element.addEventListener('keydown', this.onKeyDown_),
			this.view.element.addEventListener('keyup', this.onKeyUp_);
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const n = e.point.x / e.bounds.width,
			s = this.value.rawValue,
			[r, o, a] = s.getComponents('hsv');
		this.value.setRawValue(new At([r, o, a, n], 'hsv'), t);
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
	}
	onKeyDown_(e) {
		const t = gi(Oa(!0), wr(e));
		if (t === 0) return;
		const n = this.value.rawValue,
			[s, r, o, a] = n.getComponents('hsv');
		this.value.setRawValue(new At([s, r, o, a + t], 'hsv'), { forceEmit: !1, last: !1 });
	}
	onKeyUp_(e) {
		gi(Oa(!0), wr(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
	}
}
const wl = wt('coltxt');
function rH(i) {
	const e = i.createElement('select'),
		t = [
			{ text: 'RGB', value: 'rgb' },
			{ text: 'HSL', value: 'hsl' },
			{ text: 'HSV', value: 'hsv' },
			{ text: 'HEX', value: 'hex' },
		];
	return (
		e.appendChild(
			t.reduce((n, s) => {
				const r = i.createElement('option');
				return (r.textContent = s.text), (r.value = s.value), n.appendChild(r), n;
			}, i.createDocumentFragment())
		),
		e
	);
}
class oH {
	constructor(e, t) {
		(this.element = e.createElement('div')), this.element.classList.add(wl()), t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(wl('m')),
			(this.modeElem_ = rH(e)),
			this.modeElem_.classList.add(wl('ms')),
			n.appendChild(this.modeSelectElement),
			t.viewProps.bindDisabled(this.modeElem_);
		const s = e.createElement('div');
		s.classList.add(wl('mm')), s.appendChild(yf(e, 'dropdown')), n.appendChild(s), this.element.appendChild(n);
		const r = e.createElement('div');
		r.classList.add(wl('w')),
			this.element.appendChild(r),
			(this.inputsElem_ = r),
			(this.inputViews_ = t.inputViews),
			this.applyInputViews_(),
			vr(t.mode, (o) => {
				this.modeElem_.value = o;
			});
	}
	get modeSelectElement() {
		return this.modeElem_;
	}
	get inputViews() {
		return this.inputViews_;
	}
	set inputViews(e) {
		(this.inputViews_ = e), this.applyInputViews_();
	}
	applyInputViews_() {
		zT(this.inputsElem_);
		const e = this.element.ownerDocument;
		this.inputViews_.forEach((t) => {
			const n = e.createElement('div');
			n.classList.add(wl('c')), n.appendChild(t.element), this.inputsElem_.appendChild(n);
		});
	}
}
function aH(i) {
	return Mi(i === 'float' ? 2 : 0);
}
function lH(i, e, t) {
	const n = ec(i, e)[t];
	return new au({ min: 0, max: n });
}
function cH(i, e, t) {
	return new pu(i, {
		arrayPosition: t === 0 ? 'fst' : t === 2 ? 'lst' : 'mid',
		parser: e.parser,
		props: ut.fromObject({ formatter: aH(e.colorType), keyScale: Oa(!1), pointerScale: e.colorType === 'float' ? 0.01 : 1 }),
		value: Jt(0, { constraint: lH(e.colorMode, e.colorType, t) }),
		viewProps: e.viewProps,
	});
}
function hH(i, e) {
	const t = { colorMode: e.colorMode, colorType: e.colorType, parser: br, viewProps: e.viewProps };
	return [0, 1, 2].map((n) => {
		const s = cH(i, t, n);
		return (
			mc({
				primary: e.value,
				secondary: s.value,
				forward(r) {
					return ai(r, e.colorType).getComponents(e.colorMode)[n];
				},
				backward(r, o) {
					const a = e.colorMode,
						c = ai(r, e.colorType).getComponents(a);
					c[n] = o;
					const h = b0(bf($s(c), c[3]), a, e.colorType);
					return ai(h, 'int');
				},
			}),
			s
		);
	});
}
function uH(i, e) {
	const t = new Bh(i, { parser: mu('int'), props: ut.fromObject({ formatter: w0 }), value: Jt(At.black()), viewProps: e.viewProps });
	return (
		mc({
			primary: e.value,
			secondary: t.value,
			forward: (n) => new At($s(n.getComponents()), n.mode),
			backward: (n, s) => new At(bf($s(s.getComponents(n.mode)), n.getComponents()[3]), n.mode),
		}),
		[t]
	);
}
function dH(i) {
	return i !== 'hex';
}
class pH {
	constructor(e, t) {
		(this.onModeSelectChange_ = this.onModeSelectChange_.bind(this)),
			(this.colorType_ = t.colorType),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.colorMode = Jt(this.value.rawValue.mode)),
			(this.ccs_ = this.createComponentControllers_(e)),
			(this.view = new oH(e, {
				mode: this.colorMode,
				inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
				viewProps: this.viewProps,
			})),
			this.view.modeSelectElement.addEventListener('change', this.onModeSelectChange_);
	}
	createComponentControllers_(e) {
		const t = this.colorMode.rawValue;
		return dH(t)
			? hH(e, { colorMode: t, colorType: this.colorType_, value: this.value, viewProps: this.viewProps })
			: uH(e, { value: this.value, viewProps: this.viewProps });
	}
	onModeSelectChange_(e) {
		const t = e.currentTarget;
		(this.colorMode.rawValue = t.value),
			(this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument)),
			(this.view.inputViews = this.ccs_.map((n) => n.view));
	}
}
const Wm = wt('hpl');
class fH {
	constructor(e, t) {
		(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.value = t.value),
			this.value.emitter.on('change', this.onValueChange_),
			(this.element = e.createElement('div')),
			this.element.classList.add(Wm()),
			t.viewProps.bindClassModifiers(this.element),
			t.viewProps.bindTabIndex(this.element);
		const n = e.createElement('div');
		n.classList.add(Wm('c')), this.element.appendChild(n);
		const s = e.createElement('div');
		s.classList.add(Wm('m')), this.element.appendChild(s), (this.markerElem_ = s), this.update_();
	}
	update_() {
		const e = this.value.rawValue,
			[t] = e.getComponents('hsv');
		this.markerElem_.style.backgroundColor = v1(new At([t, 100, 100], 'hsv'));
		const n = Dt(t, 0, 360, 0, 100);
		this.markerElem_.style.left = ''.concat(n, '%');
	}
	onValueChange_() {
		this.update_();
	}
}
class mH {
	constructor(e, t) {
		(this.onKeyDown_ = this.onKeyDown_.bind(this)),
			(this.onKeyUp_ = this.onKeyUp_.bind(this)),
			(this.onPointerDown_ = this.onPointerDown_.bind(this)),
			(this.onPointerMove_ = this.onPointerMove_.bind(this)),
			(this.onPointerUp_ = this.onPointerUp_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new fH(e, { value: this.value, viewProps: this.viewProps })),
			(this.ptHandler_ = new qa(this.view.element)),
			this.ptHandler_.emitter.on('down', this.onPointerDown_),
			this.ptHandler_.emitter.on('move', this.onPointerMove_),
			this.ptHandler_.emitter.on('up', this.onPointerUp_),
			this.view.element.addEventListener('keydown', this.onKeyDown_),
			this.view.element.addEventListener('keyup', this.onKeyUp_);
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const n = Dt(Tn(e.point.x, 0, e.bounds.width), 0, e.bounds.width, 0, 360),
			s = this.value.rawValue,
			[, r, o, a] = s.getComponents('hsv');
		this.value.setRawValue(new At([n, r, o, a], 'hsv'), t);
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
	}
	onKeyDown_(e) {
		const t = gi(Oa(!1), wr(e));
		if (t === 0) return;
		const n = this.value.rawValue,
			[s, r, o, a] = n.getComponents('hsv');
		this.value.setRawValue(new At([s + t, r, o, a], 'hsv'), { forceEmit: !1, last: !1 });
	}
	onKeyUp_(e) {
		gi(Oa(!1), wr(e)) !== 0 && this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
	}
}
const Xm = wt('svp'),
	aw = 64;
class gH {
	constructor(e, t) {
		(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.value = t.value),
			this.value.emitter.on('change', this.onValueChange_),
			(this.element = e.createElement('div')),
			this.element.classList.add(Xm()),
			t.viewProps.bindClassModifiers(this.element),
			t.viewProps.bindTabIndex(this.element);
		const n = e.createElement('canvas');
		(n.height = aw), (n.width = aw), n.classList.add(Xm('c')), this.element.appendChild(n), (this.canvasElement = n);
		const s = e.createElement('div');
		s.classList.add(Xm('m')), this.element.appendChild(s), (this.markerElem_ = s), this.update_();
	}
	update_() {
		const e = mz(this.canvasElement);
		if (!e) return;
		const n = this.value.rawValue.getComponents('hsv'),
			s = this.canvasElement.width,
			r = this.canvasElement.height,
			o = e.getImageData(0, 0, s, r),
			a = o.data;
		for (let h = 0; h < r; h++)
			for (let u = 0; u < s; u++) {
				const d = Dt(u, 0, s, 0, 100),
					p = Dt(h, 0, r, 100, 0),
					g = i1(n[0], d, p),
					v = (h * s + u) * 4;
				(a[v] = g[0]), (a[v + 1] = g[1]), (a[v + 2] = g[2]), (a[v + 3] = 255);
			}
		e.putImageData(o, 0, 0);
		const l = Dt(n[1], 0, 100, 0, 100);
		this.markerElem_.style.left = ''.concat(l, '%');
		const c = Dt(n[2], 0, 100, 100, 0);
		this.markerElem_.style.top = ''.concat(c, '%');
	}
	onValueChange_() {
		this.update_();
	}
}
class vH {
	constructor(e, t) {
		(this.onKeyDown_ = this.onKeyDown_.bind(this)),
			(this.onKeyUp_ = this.onKeyUp_.bind(this)),
			(this.onPointerDown_ = this.onPointerDown_.bind(this)),
			(this.onPointerMove_ = this.onPointerMove_.bind(this)),
			(this.onPointerUp_ = this.onPointerUp_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new gH(e, { value: this.value, viewProps: this.viewProps })),
			(this.ptHandler_ = new qa(this.view.element)),
			this.ptHandler_.emitter.on('down', this.onPointerDown_),
			this.ptHandler_.emitter.on('move', this.onPointerMove_),
			this.ptHandler_.emitter.on('up', this.onPointerUp_),
			this.view.element.addEventListener('keydown', this.onKeyDown_),
			this.view.element.addEventListener('keyup', this.onKeyUp_);
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const n = Dt(e.point.x, 0, e.bounds.width, 0, 100),
			s = Dt(e.point.y, 0, e.bounds.height, 100, 0),
			[r, , , o] = this.value.rawValue.getComponents('hsv');
		this.value.setRawValue(new At([r, n, s, o], 'hsv'), t);
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
	}
	onKeyDown_(e) {
		QT(e.key) && e.preventDefault();
		const [t, n, s, r] = this.value.rawValue.getComponents('hsv'),
			o = Oa(!1),
			a = gi(o, wr(e)),
			l = gi(o, kh(e));
		(a === 0 && l === 0) || this.value.setRawValue(new At([t, n + a, s + l, r], 'hsv'), { forceEmit: !1, last: !1 });
	}
	onKeyUp_(e) {
		const t = Oa(!1),
			n = gi(t, wr(e)),
			s = gi(t, kh(e));
		(n === 0 && s === 0) || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
	}
}
class _H {
	constructor(e, t) {
		(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.hPaletteC_ = new mH(e, { value: this.value, viewProps: this.viewProps })),
			(this.svPaletteC_ = new vH(e, { value: this.value, viewProps: this.viewProps })),
			(this.alphaIcs_ = t.supportsAlpha
				? {
						palette: new sH(e, { value: this.value, viewProps: this.viewProps }),
						text: new pu(e, {
							parser: br,
							props: ut.fromObject({ pointerScale: 0.01, keyScale: 0.1, formatter: Mi(2) }),
							value: Jt(0, { constraint: new au({ min: 0, max: 1 }) }),
							viewProps: this.viewProps,
						}),
				  }
				: null),
			this.alphaIcs_ &&
				mc({
					primary: this.value,
					secondary: this.alphaIcs_.text.value,
					forward: (n) => n.getComponents()[3],
					backward: (n, s) => {
						const r = n.getComponents();
						return (r[3] = s), new At(r, n.mode);
					},
				}),
			(this.textsC_ = new pH(e, { colorType: t.colorType, value: this.value, viewProps: this.viewProps })),
			(this.view = new LV(e, {
				alphaViews: this.alphaIcs_ ? { palette: this.alphaIcs_.palette.view, text: this.alphaIcs_.text.view } : null,
				hPaletteView: this.hPaletteC_.view,
				supportsAlpha: t.supportsAlpha,
				svPaletteView: this.svPaletteC_.view,
				textsView: this.textsC_.view,
				viewProps: this.viewProps,
			}));
	}
	get textsController() {
		return this.textsC_;
	}
}
const qm = wt('colsw');
class yH {
	constructor(e, t) {
		(this.onValueChange_ = this.onValueChange_.bind(this)),
			t.value.emitter.on('change', this.onValueChange_),
			(this.value = t.value),
			(this.element = e.createElement('div')),
			this.element.classList.add(qm()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(qm('sw')), this.element.appendChild(n), (this.swatchElem_ = n);
		const s = e.createElement('button');
		s.classList.add(qm('b')), t.viewProps.bindDisabled(s), this.element.appendChild(s), (this.buttonElement = s), this.update_();
	}
	update_() {
		const e = this.value.rawValue;
		this.swatchElem_.style.backgroundColor = S0(e);
	}
	onValueChange_() {
		this.update_();
	}
}
class xH {
	constructor(e, t) {
		(this.value = t.value), (this.viewProps = t.viewProps), (this.view = new yH(e, { value: this.value, viewProps: this.viewProps }));
	}
}
class M0 {
	constructor(e, t) {
		(this.onButtonBlur_ = this.onButtonBlur_.bind(this)),
			(this.onButtonClick_ = this.onButtonClick_.bind(this)),
			(this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
			(this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.foldable_ = cu.create(t.expanded)),
			(this.swatchC_ = new xH(e, { value: this.value, viewProps: this.viewProps }));
		const n = this.swatchC_.view.buttonElement;
		n.addEventListener('blur', this.onButtonBlur_),
			n.addEventListener('click', this.onButtonClick_),
			(this.textC_ = new Bh(e, {
				parser: t.parser,
				props: ut.fromObject({ formatter: t.formatter }),
				value: this.value,
				viewProps: this.viewProps,
			})),
			(this.view = new SV(e, { foldable: this.foldable_, pickerLayout: t.pickerLayout })),
			this.view.swatchElement.appendChild(this.swatchC_.view.element),
			this.view.textElement.appendChild(this.textC_.view.element),
			(this.popC_ = t.pickerLayout === 'popup' ? new $T(e, { viewProps: this.viewProps }) : null);
		const s = new _H(e, { colorType: t.colorType, supportsAlpha: t.supportsAlpha, value: this.value, viewProps: this.viewProps });
		s.view.allFocusableElements.forEach((r) => {
			r.addEventListener('blur', this.onPopupChildBlur_), r.addEventListener('keydown', this.onPopupChildKeydown_);
		}),
			(this.pickerC_ = s),
			this.popC_
				? (this.view.element.appendChild(this.popC_.view.element),
				  this.popC_.view.element.appendChild(s.view.element),
				  mc({ primary: this.foldable_.value('expanded'), secondary: this.popC_.shows, forward: (r) => r, backward: (r, o) => o }))
				: this.view.pickerElement &&
				  (this.view.pickerElement.appendChild(this.pickerC_.view.element), m0(this.foldable_, this.view.pickerElement));
	}
	get textController() {
		return this.textC_;
	}
	onButtonBlur_(e) {
		if (!this.popC_) return;
		const t = this.view.element,
			n = e.relatedTarget;
		(!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
	}
	onButtonClick_() {
		this.foldable_.set('expanded', !this.foldable_.get('expanded')),
			this.foldable_.get('expanded') && this.pickerC_.view.allFocusableElements[0].focus();
	}
	onPopupChildBlur_(e) {
		if (!this.popC_) return;
		const t = this.popC_.view.element,
			n = VT(e);
		(n && t.contains(n)) || (n && n === this.swatchC_.view.buttonElement && !c0(t.ownerDocument)) || (this.popC_.shows.rawValue = !1);
	}
	onPopupChildKeydown_(e) {
		this.popC_
			? e.key === 'Escape' && (this.popC_.shows.rawValue = !1)
			: this.view.pickerElement && e.key === 'Escape' && this.swatchC_.view.buttonElement.focus();
	}
}
function bH(i) {
	return $s(i.getComponents('rgb')).reduce((e, t) => (e << 8) | (Math.floor(t) & 255), 0);
}
function wH(i) {
	return (
		i.getComponents('rgb').reduce((e, t, n) => {
			const s = Math.floor(n === 3 ? t * 255 : t) & 255;
			return (e << 8) | s;
		}, 0) >>> 0
	);
}
function SH(i) {
	return new At([(i >> 16) & 255, (i >> 8) & 255, i & 255], 'rgb');
}
function MH(i) {
	return new At([(i >> 24) & 255, (i >> 16) & 255, (i >> 8) & 255, Dt(i & 255, 0, 255, 0, 1)], 'rgb');
}
function EH(i) {
	return typeof i != 'number' ? At.black() : SH(i);
}
function TH(i) {
	return typeof i != 'number' ? At.black() : MH(i);
}
function Gd(i, e) {
	return typeof i != 'object' || qt(i) ? !1 : e in i && typeof i[e] == 'number';
}
function b1(i) {
	return Gd(i, 'r') && Gd(i, 'g') && Gd(i, 'b');
}
function w1(i) {
	return b1(i) && Gd(i, 'a');
}
function S1(i) {
	return b1(i);
}
function E0(i, e) {
	if (i.mode !== e.mode || i.type !== e.type) return !1;
	const t = i.getComponents(),
		n = e.getComponents();
	for (let s = 0; s < t.length; s++) if (t[s] !== n[s]) return !1;
	return !0;
}
function lw(i) {
	return 'a' in i ? [i.r, i.g, i.b, i.a] : [i.r, i.g, i.b];
}
function AH(i) {
	const e = x1(i);
	return e
		? (t, n) => {
				fu(t, e(n));
		  }
		: null;
}
function CH(i) {
	const e = i ? wH : bH;
	return (t, n) => {
		fu(t, e(n));
	};
}
function RH(i, e, t) {
	const s = ai(e, t).toRgbaObject();
	i.writeProperty('r', s.r), i.writeProperty('g', s.g), i.writeProperty('b', s.b), i.writeProperty('a', s.a);
}
function PH(i, e, t) {
	const s = ai(e, t).toRgbaObject();
	i.writeProperty('r', s.r), i.writeProperty('g', s.g), i.writeProperty('b', s.b);
}
function LH(i, e) {
	return (t, n) => {
		i ? RH(t, n, e) : PH(t, n, e);
	};
}
function IH(i) {
	var e;
	return !!(!((e = i == null ? void 0 : i.color) === null || e === void 0) && e.alpha);
}
function DH(i) {
	return i ? (e) => S0(e, '0x') : (e) => w0(e, '0x');
}
function OH(i) {
	return 'color' in i || i.view === 'color';
}
const UH = li({
	id: 'input-color-number',
	type: 'input',
	accept: (i, e) => {
		if (typeof i != 'number' || !OH(e)) return null;
		const t = y0(e);
		return t ? { initialValue: i, params: Object.assign(Object.assign({}, t), { supportsAlpha: IH(e) }) } : null;
	},
	binding: { reader: (i) => (i.params.supportsAlpha ? TH : EH), equals: E0, writer: (i) => CH(i.params.supportsAlpha) },
	controller: (i) => {
		var e, t;
		return new M0(i.document, {
			colorType: 'int',
			expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
			formatter: DH(i.params.supportsAlpha),
			parser: mu('int'),
			pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : 'popup',
			supportsAlpha: i.params.supportsAlpha,
			value: i.value,
			viewProps: i.viewProps,
		});
	},
});
function NH(i, e) {
	if (!S1(i)) return ai(At.black(), e);
	if (e === 'int') {
		const t = lw(i);
		return new At(t, 'rgb');
	}
	if (e === 'float') {
		const t = lw(i);
		return new x0(t, 'rgb');
	}
	return ai(At.black(), 'int');
}
function FH(i) {
	return w1(i);
}
function BH(i) {
	return (e) => {
		const t = NH(e, i);
		return ai(t, 'int');
	};
}
function kH(i, e) {
	return (t) => (i ? y1(t, e) : _1(t, e));
}
const zH = li({
		id: 'input-color-object',
		type: 'input',
		accept: (i, e) => {
			var t;
			if (!S1(i)) return null;
			const n = y0(e);
			return n
				? {
						initialValue: i,
						params: Object.assign(Object.assign({}, n), { colorType: (t = o1(e)) !== null && t !== void 0 ? t : 'int' }),
				  }
				: null;
		},
		binding: { reader: (i) => BH(i.params.colorType), equals: E0, writer: (i) => LH(FH(i.initialValue), i.params.colorType) },
		controller: (i) => {
			var e, t;
			const n = w1(i.initialValue);
			return new M0(i.document, {
				colorType: i.params.colorType,
				expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
				formatter: kH(n, i.params.colorType),
				parser: mu('int'),
				pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : 'popup',
				supportsAlpha: n,
				value: i.value,
				viewProps: i.viewProps,
			});
		},
	}),
	VH = li({
		id: 'input-color-string',
		type: 'input',
		accept: (i, e) => {
			if (typeof i != 'string' || e.view === 'text') return null;
			const t = $V(i, o1(e));
			if (!t) return null;
			const n = x1(t);
			if (!n) return null;
			const s = y0(e);
			return s ? { initialValue: i, params: Object.assign(Object.assign({}, s), { format: t, stringifier: n }) } : null;
		},
		binding: {
			reader: () => ZV,
			equals: E0,
			writer: (i) => {
				const e = AH(i.params.format);
				if (!e) throw cn.notBindable();
				return e;
			},
		},
		controller: (i) => {
			var e, t;
			return new M0(i.document, {
				colorType: i.params.format.type,
				expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
				formatter: i.params.stringifier,
				parser: mu('int'),
				pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : 'popup',
				supportsAlpha: i.params.format.alpha,
				value: i.value,
				viewProps: i.viewProps,
			});
		},
	});
class T0 {
	constructor(e) {
		(this.components = e.components), (this.asm_ = e.assembly);
	}
	constrain(e) {
		const t = this.asm_.toComponents(e).map((n, s) => {
			var r, o;
			return (o = (r = this.components[s]) === null || r === void 0 ? void 0 : r.constrain(n)) !== null && o !== void 0 ? o : n;
		});
		return this.asm_.fromComponents(t);
	}
}
const cw = wt('pndtxt');
class HH {
	constructor(e, t) {
		(this.textViews = t.textViews),
			(this.element = e.createElement('div')),
			this.element.classList.add(cw()),
			this.textViews.forEach((n) => {
				const s = e.createElement('div');
				s.classList.add(cw('a')), s.appendChild(n.element), this.element.appendChild(s);
			});
	}
}
function GH(i, e, t) {
	return new pu(i, {
		arrayPosition: t === 0 ? 'fst' : t === e.axes.length - 1 ? 'lst' : 'mid',
		parser: e.parser,
		props: e.axes[t].textProps,
		value: Jt(0, { constraint: e.axes[t].constraint }),
		viewProps: e.viewProps,
	});
}
class A0 {
	constructor(e, t) {
		(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.acs_ = t.axes.map((n, s) => GH(e, t, s))),
			this.acs_.forEach((n, s) => {
				mc({
					primary: this.value,
					secondary: n.value,
					forward: (r) => t.assembly.toComponents(r)[s],
					backward: (r, o) => {
						const a = t.assembly.toComponents(r);
						return (a[s] = o), t.assembly.fromComponents(a);
					},
				});
			}),
			(this.view = new HH(e, { textViews: this.acs_.map((n) => n.view) }));
	}
	get textControllers() {
		return this.acs_;
	}
}
class WH extends Fh {
	get max() {
		return this.controller.valueController.sliderController.props.get('max');
	}
	set max(e) {
		this.controller.valueController.sliderController.props.set('max', e);
	}
	get min() {
		return this.controller.valueController.sliderController.props.get('min');
	}
	set min(e) {
		this.controller.valueController.sliderController.props.set('min', e);
	}
}
function XH(i, e) {
	const t = [],
		n = OT(i, e);
	n && t.push(n);
	const s = UT(i);
	s && t.push(s);
	const r = _0(i.options);
	return r && t.push(r), new hu(t);
}
const qH = li({
	id: 'input-number',
	type: 'input',
	accept: (i, e) => {
		if (typeof i != 'number') return null;
		const t = rn(e, (n) =>
			Object.assign(Object.assign({}, FT(n)), { options: n.optional.custom(du), readonly: n.optional.constant(!1) })
		);
		return t ? { initialValue: i, params: t } : null;
	},
	binding: { reader: (i) => PT, constraint: (i) => XH(i.params, i.initialValue), writer: (i) => fu },
	controller: (i) => {
		const e = i.value,
			t = i.constraint,
			n = t && lp(t, uu);
		if (n) return new wo(i.document, { props: new ut({ options: n.values.value('options') }), value: e, viewProps: i.viewProps });
		const s = NT(i.params, e.rawValue),
			r = t && lp(t, au);
		return r
			? new hp(
					i.document,
					Object.assign(
						Object.assign(
							{},
							e1(
								Object.assign(Object.assign({}, s), {
									keyScale: Jt(s.keyScale),
									max: r.values.value('max'),
									min: r.values.value('min'),
								})
							)
						),
						{ parser: br, value: e, viewProps: i.viewProps }
					)
			  )
			: new pu(i.document, { parser: br, props: ut.fromObject(s), value: e, viewProps: i.viewProps });
	},
	api(i) {
		return typeof i.controller.value.rawValue != 'number'
			? null
			: i.controller.valueController instanceof hp
			? new WH(i.controller)
			: i.controller.valueController instanceof wo
			? new g0(i.controller)
			: null;
	},
});
class fo {
	constructor(e = 0, t = 0) {
		(this.x = e), (this.y = t);
	}
	getComponents() {
		return [this.x, this.y];
	}
	static isObject(e) {
		if (qt(e)) return !1;
		const t = e.x,
			n = e.y;
		return !(typeof t != 'number' || typeof n != 'number');
	}
	static equals(e, t) {
		return e.x === t.x && e.y === t.y;
	}
	toObject() {
		return { x: this.x, y: this.y };
	}
}
const M1 = { toComponents: (i) => i.getComponents(), fromComponents: (i) => new fo(...i) },
	Sl = wt('p2d');
class YH {
	constructor(e, t) {
		(this.element = e.createElement('div')),
			this.element.classList.add(Sl()),
			t.viewProps.bindClassModifiers(this.element),
			vr(t.expanded, dc(this.element, Sl(void 0, 'expanded')));
		const n = e.createElement('div');
		n.classList.add(Sl('h')), this.element.appendChild(n);
		const s = e.createElement('button');
		s.classList.add(Sl('b')), s.appendChild(yf(e, 'p2dpad')), t.viewProps.bindDisabled(s), n.appendChild(s), (this.buttonElement = s);
		const r = e.createElement('div');
		if ((r.classList.add(Sl('t')), n.appendChild(r), (this.textElement = r), t.pickerLayout === 'inline')) {
			const o = e.createElement('div');
			o.classList.add(Sl('p')), this.element.appendChild(o), (this.pickerElement = o);
		} else this.pickerElement = null;
	}
}
const Wr = wt('p2dp');
class jH {
	constructor(e, t) {
		(this.onFoldableChange_ = this.onFoldableChange_.bind(this)),
			(this.onPropsChange_ = this.onPropsChange_.bind(this)),
			(this.onValueChange_ = this.onValueChange_.bind(this)),
			(this.props_ = t.props),
			this.props_.emitter.on('change', this.onPropsChange_),
			(this.element = e.createElement('div')),
			this.element.classList.add(Wr()),
			t.layout === 'popup' && this.element.classList.add(Wr(void 0, 'p')),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('div');
		n.classList.add(Wr('p')), t.viewProps.bindTabIndex(n), this.element.appendChild(n), (this.padElement = n);
		const s = e.createElementNS(Gs, 'svg');
		s.classList.add(Wr('g')), this.padElement.appendChild(s), (this.svgElem_ = s);
		const r = e.createElementNS(Gs, 'line');
		r.classList.add(Wr('ax')),
			r.setAttributeNS(null, 'x1', '0'),
			r.setAttributeNS(null, 'y1', '50%'),
			r.setAttributeNS(null, 'x2', '100%'),
			r.setAttributeNS(null, 'y2', '50%'),
			this.svgElem_.appendChild(r);
		const o = e.createElementNS(Gs, 'line');
		o.classList.add(Wr('ax')),
			o.setAttributeNS(null, 'x1', '50%'),
			o.setAttributeNS(null, 'y1', '0'),
			o.setAttributeNS(null, 'x2', '50%'),
			o.setAttributeNS(null, 'y2', '100%'),
			this.svgElem_.appendChild(o);
		const a = e.createElementNS(Gs, 'line');
		a.classList.add(Wr('l')),
			a.setAttributeNS(null, 'x1', '50%'),
			a.setAttributeNS(null, 'y1', '50%'),
			this.svgElem_.appendChild(a),
			(this.lineElem_ = a);
		const l = e.createElement('div');
		l.classList.add(Wr('m')),
			this.padElement.appendChild(l),
			(this.markerElem_ = l),
			t.value.emitter.on('change', this.onValueChange_),
			(this.value = t.value),
			this.update_();
	}
	get allFocusableElements() {
		return [this.padElement];
	}
	update_() {
		const [e, t] = this.value.rawValue.getComponents(),
			n = this.props_.get('max'),
			s = Dt(e, -n, +n, 0, 100),
			r = Dt(t, -n, +n, 0, 100),
			o = this.props_.get('invertsY') ? 100 - r : r;
		this.lineElem_.setAttributeNS(null, 'x2', ''.concat(s, '%')),
			this.lineElem_.setAttributeNS(null, 'y2', ''.concat(o, '%')),
			(this.markerElem_.style.left = ''.concat(s, '%')),
			(this.markerElem_.style.top = ''.concat(o, '%'));
	}
	onValueChange_() {
		this.update_();
	}
	onPropsChange_() {
		this.update_();
	}
	onFoldableChange_() {
		this.update_();
	}
}
function hw(i, e, t) {
	return [gi(e[0], wr(i)), gi(e[1], kh(i)) * (t ? 1 : -1)];
}
class KH {
	constructor(e, t) {
		(this.onPadKeyDown_ = this.onPadKeyDown_.bind(this)),
			(this.onPadKeyUp_ = this.onPadKeyUp_.bind(this)),
			(this.onPointerDown_ = this.onPointerDown_.bind(this)),
			(this.onPointerMove_ = this.onPointerMove_.bind(this)),
			(this.onPointerUp_ = this.onPointerUp_.bind(this)),
			(this.props = t.props),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new jH(e, { layout: t.layout, props: this.props, value: this.value, viewProps: this.viewProps })),
			(this.ptHandler_ = new qa(this.view.padElement)),
			this.ptHandler_.emitter.on('down', this.onPointerDown_),
			this.ptHandler_.emitter.on('move', this.onPointerMove_),
			this.ptHandler_.emitter.on('up', this.onPointerUp_),
			this.view.padElement.addEventListener('keydown', this.onPadKeyDown_),
			this.view.padElement.addEventListener('keyup', this.onPadKeyUp_);
	}
	handlePointerEvent_(e, t) {
		if (!e.point) return;
		const n = this.props.get('max'),
			s = Dt(e.point.x, 0, e.bounds.width, -n, +n),
			r = Dt(this.props.get('invertsY') ? e.bounds.height - e.point.y : e.point.y, 0, e.bounds.height, -n, +n);
		this.value.setRawValue(new fo(s, r), t);
	}
	onPointerDown_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerMove_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !1, last: !1 });
	}
	onPointerUp_(e) {
		this.handlePointerEvent_(e.data, { forceEmit: !0, last: !0 });
	}
	onPadKeyDown_(e) {
		QT(e.key) && e.preventDefault();
		const [t, n] = hw(e, [this.props.get('xKeyScale'), this.props.get('yKeyScale')], this.props.get('invertsY'));
		(t === 0 && n === 0) ||
			this.value.setRawValue(new fo(this.value.rawValue.x + t, this.value.rawValue.y + n), { forceEmit: !1, last: !1 });
	}
	onPadKeyUp_(e) {
		const [t, n] = hw(e, [this.props.get('xKeyScale'), this.props.get('yKeyScale')], this.props.get('invertsY'));
		(t === 0 && n === 0) || this.value.setRawValue(this.value.rawValue, { forceEmit: !0, last: !0 });
	}
}
class $H {
	constructor(e, t) {
		var n, s;
		(this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this)),
			(this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this)),
			(this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this)),
			(this.onPadButtonClick_ = this.onPadButtonClick_.bind(this)),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.foldable_ = cu.create(t.expanded)),
			(this.popC_ = t.pickerLayout === 'popup' ? new $T(e, { viewProps: this.viewProps }) : null);
		const r = new KH(e, {
			layout: t.pickerLayout,
			props: new ut({
				invertsY: Jt(t.invertsY),
				max: Jt(t.max),
				xKeyScale: t.axes[0].textProps.value('keyScale'),
				yKeyScale: t.axes[1].textProps.value('keyScale'),
			}),
			value: this.value,
			viewProps: this.viewProps,
		});
		r.view.allFocusableElements.forEach((o) => {
			o.addEventListener('blur', this.onPopupChildBlur_), o.addEventListener('keydown', this.onPopupChildKeydown_);
		}),
			(this.pickerC_ = r),
			(this.textC_ = new A0(e, { assembly: M1, axes: t.axes, parser: t.parser, value: this.value, viewProps: this.viewProps })),
			(this.view = new YH(e, {
				expanded: this.foldable_.value('expanded'),
				pickerLayout: t.pickerLayout,
				viewProps: this.viewProps,
			})),
			this.view.textElement.appendChild(this.textC_.view.element),
			(n = this.view.buttonElement) === null || n === void 0 || n.addEventListener('blur', this.onPadButtonBlur_),
			(s = this.view.buttonElement) === null || s === void 0 || s.addEventListener('click', this.onPadButtonClick_),
			this.popC_
				? (this.view.element.appendChild(this.popC_.view.element),
				  this.popC_.view.element.appendChild(this.pickerC_.view.element),
				  mc({ primary: this.foldable_.value('expanded'), secondary: this.popC_.shows, forward: (o) => o, backward: (o, a) => a }))
				: this.view.pickerElement &&
				  (this.view.pickerElement.appendChild(this.pickerC_.view.element), m0(this.foldable_, this.view.pickerElement));
	}
	get textController() {
		return this.textC_;
	}
	onPadButtonBlur_(e) {
		if (!this.popC_) return;
		const t = this.view.element,
			n = e.relatedTarget;
		(!n || !t.contains(n)) && (this.popC_.shows.rawValue = !1);
	}
	onPadButtonClick_() {
		this.foldable_.set('expanded', !this.foldable_.get('expanded')),
			this.foldable_.get('expanded') && this.pickerC_.view.allFocusableElements[0].focus();
	}
	onPopupChildBlur_(e) {
		if (!this.popC_) return;
		const t = this.popC_.view.element,
			n = VT(e);
		(n && t.contains(n)) || (n && n === this.view.buttonElement && !c0(t.ownerDocument)) || (this.popC_.shows.rawValue = !1);
	}
	onPopupChildKeydown_(e) {
		this.popC_
			? e.key === 'Escape' && (this.popC_.shows.rawValue = !1)
			: this.view.pickerElement && e.key === 'Escape' && this.view.buttonElement.focus();
	}
}
function ZH(i) {
	return fo.isObject(i) ? new fo(i.x, i.y) : new fo();
}
function JH(i, e) {
	i.writeProperty('x', e.x), i.writeProperty('y', e.y);
}
function QH(i, e) {
	return new T0({
		assembly: M1,
		components: [pr(Object.assign(Object.assign({}, i), i.x), e.x), pr(Object.assign(Object.assign({}, i), i.y), e.y)],
	});
}
function uw(i, e) {
	var t, n;
	if (!qt(i.min) || !qt(i.max))
		return Math.max(Math.abs((t = i.min) !== null && t !== void 0 ? t : 0), Math.abs((n = i.max) !== null && n !== void 0 ? n : 0));
	const s = IT(i);
	return Math.max(Math.abs(s) * 10, Math.abs(e) * 10);
}
function e4(i, e) {
	var t, n;
	const s = uw(Ia(i, (t = i.x) !== null && t !== void 0 ? t : {}), e.x),
		r = uw(Ia(i, (n = i.y) !== null && n !== void 0 ? n : {}), e.y);
	return Math.max(s, r);
}
function t4(i) {
	if (!('y' in i)) return !1;
	const e = i.y;
	return e && 'inverted' in e ? !!e.inverted : !1;
}
const n4 = li({
	id: 'input-point2d',
	type: 'input',
	accept: (i, e) => {
		if (!fo.isObject(i)) return null;
		const t = rn(e, (n) =>
			Object.assign(Object.assign({}, zh(n)), {
				expanded: n.optional.boolean,
				picker: n.optional.custom(n1),
				readonly: n.optional.constant(!1),
				x: n.optional.custom(to),
				y: n.optional.object(Object.assign(Object.assign({}, zh(n)), { inverted: n.optional.boolean })),
			})
		);
		return t ? { initialValue: i, params: t } : null;
	},
	binding: { reader: () => ZH, constraint: (i) => QH(i.params, i.initialValue), equals: fo.equals, writer: () => JH },
	controller: (i) => {
		var e, t;
		const n = i.document,
			s = i.value,
			r = i.constraint,
			o = [i.params.x, i.params.y];
		return new $H(n, {
			axes: s.rawValue.getComponents().map((a, l) => {
				var c;
				return l0({
					constraint: r.components[l],
					initialValue: a,
					params: Ia(i.params, (c = o[l]) !== null && c !== void 0 ? c : {}),
				});
			}),
			expanded: (e = i.params.expanded) !== null && e !== void 0 ? e : !1,
			invertsY: t4(i.params),
			max: e4(i.params, s.rawValue),
			parser: br,
			pickerLayout: (t = i.params.picker) !== null && t !== void 0 ? t : 'popup',
			value: s,
			viewProps: i.viewProps,
		});
	},
});
class kl {
	constructor(e = 0, t = 0, n = 0) {
		(this.x = e), (this.y = t), (this.z = n);
	}
	getComponents() {
		return [this.x, this.y, this.z];
	}
	static isObject(e) {
		if (qt(e)) return !1;
		const t = e.x,
			n = e.y,
			s = e.z;
		return !(typeof t != 'number' || typeof n != 'number' || typeof s != 'number');
	}
	static equals(e, t) {
		return e.x === t.x && e.y === t.y && e.z === t.z;
	}
	toObject() {
		return { x: this.x, y: this.y, z: this.z };
	}
}
const E1 = { toComponents: (i) => i.getComponents(), fromComponents: (i) => new kl(...i) };
function i4(i) {
	return kl.isObject(i) ? new kl(i.x, i.y, i.z) : new kl();
}
function s4(i, e) {
	i.writeProperty('x', e.x), i.writeProperty('y', e.y), i.writeProperty('z', e.z);
}
function r4(i, e) {
	return new T0({
		assembly: E1,
		components: [
			pr(Object.assign(Object.assign({}, i), i.x), e.x),
			pr(Object.assign(Object.assign({}, i), i.y), e.y),
			pr(Object.assign(Object.assign({}, i), i.z), e.z),
		],
	});
}
const o4 = li({
	id: 'input-point3d',
	type: 'input',
	accept: (i, e) => {
		if (!kl.isObject(i)) return null;
		const t = rn(e, (n) =>
			Object.assign(Object.assign({}, zh(n)), {
				readonly: n.optional.constant(!1),
				x: n.optional.custom(to),
				y: n.optional.custom(to),
				z: n.optional.custom(to),
			})
		);
		return t ? { initialValue: i, params: t } : null;
	},
	binding: { reader: (i) => i4, constraint: (i) => r4(i.params, i.initialValue), equals: kl.equals, writer: (i) => s4 },
	controller: (i) => {
		const e = i.value,
			t = i.constraint,
			n = [i.params.x, i.params.y, i.params.z];
		return new A0(i.document, {
			assembly: E1,
			axes: e.rawValue.getComponents().map((s, r) => {
				var o;
				return l0({
					constraint: t.components[r],
					initialValue: s,
					params: Ia(i.params, (o = n[r]) !== null && o !== void 0 ? o : {}),
				});
			}),
			parser: br,
			value: e,
			viewProps: i.viewProps,
		});
	},
});
class zl {
	constructor(e = 0, t = 0, n = 0, s = 0) {
		(this.x = e), (this.y = t), (this.z = n), (this.w = s);
	}
	getComponents() {
		return [this.x, this.y, this.z, this.w];
	}
	static isObject(e) {
		if (qt(e)) return !1;
		const t = e.x,
			n = e.y,
			s = e.z,
			r = e.w;
		return !(typeof t != 'number' || typeof n != 'number' || typeof s != 'number' || typeof r != 'number');
	}
	static equals(e, t) {
		return e.x === t.x && e.y === t.y && e.z === t.z && e.w === t.w;
	}
	toObject() {
		return { x: this.x, y: this.y, z: this.z, w: this.w };
	}
}
const T1 = { toComponents: (i) => i.getComponents(), fromComponents: (i) => new zl(...i) };
function a4(i) {
	return zl.isObject(i) ? new zl(i.x, i.y, i.z, i.w) : new zl();
}
function l4(i, e) {
	i.writeProperty('x', e.x), i.writeProperty('y', e.y), i.writeProperty('z', e.z), i.writeProperty('w', e.w);
}
function c4(i, e) {
	return new T0({
		assembly: T1,
		components: [
			pr(Object.assign(Object.assign({}, i), i.x), e.x),
			pr(Object.assign(Object.assign({}, i), i.y), e.y),
			pr(Object.assign(Object.assign({}, i), i.z), e.z),
			pr(Object.assign(Object.assign({}, i), i.w), e.w),
		],
	});
}
const h4 = li({
	id: 'input-point4d',
	type: 'input',
	accept: (i, e) => {
		if (!zl.isObject(i)) return null;
		const t = rn(e, (n) =>
			Object.assign(Object.assign({}, zh(n)), {
				readonly: n.optional.constant(!1),
				w: n.optional.custom(to),
				x: n.optional.custom(to),
				y: n.optional.custom(to),
				z: n.optional.custom(to),
			})
		);
		return t ? { initialValue: i, params: t } : null;
	},
	binding: { reader: (i) => a4, constraint: (i) => c4(i.params, i.initialValue), equals: zl.equals, writer: (i) => l4 },
	controller: (i) => {
		const e = i.value,
			t = i.constraint,
			n = [i.params.x, i.params.y, i.params.z, i.params.w];
		return new A0(i.document, {
			assembly: T1,
			axes: e.rawValue.getComponents().map((s, r) => {
				var o;
				return l0({
					constraint: t.components[r],
					initialValue: s,
					params: Ia(i.params, (o = n[r]) !== null && o !== void 0 ? o : {}),
				});
			}),
			parser: br,
			value: e,
			viewProps: i.viewProps,
		});
	},
});
function u4(i) {
	const e = [],
		t = _0(i.options);
	return t && e.push(t), new hu(e);
}
const d4 = li({
		id: 'input-string',
		type: 'input',
		accept: (i, e) => {
			if (typeof i != 'string') return null;
			const t = rn(e, (n) => ({ readonly: n.optional.constant(!1), options: n.optional.custom(du) }));
			return t ? { initialValue: i, params: t } : null;
		},
		binding: { reader: (i) => JT, constraint: (i) => u4(i.params), writer: (i) => fu },
		controller: (i) => {
			const e = i.document,
				t = i.value,
				n = i.constraint,
				s = n && lp(n, uu);
			return s
				? new wo(e, { props: new ut({ options: s.values.value('options') }), value: t, viewProps: i.viewProps })
				: new Bh(e, { parser: (r) => r, props: ut.fromObject({ formatter: _v }), value: t, viewProps: i.viewProps });
		},
		api(i) {
			return typeof i.controller.value.rawValue != 'string'
				? null
				: i.controller.valueController instanceof wo
				? new g0(i.controller)
				: null;
		},
	}),
	gu = { monitor: { defaultInterval: 200, defaultRows: 3 } },
	dw = wt('mll');
class p4 {
	constructor(e, t) {
		(this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
			(this.formatter_ = t.formatter),
			(this.element = e.createElement('div')),
			this.element.classList.add(dw()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('textarea');
		n.classList.add(dw('i')),
			(n.style.height = 'calc(var('.concat(t1('containerUnitSize'), ') * ').concat(t.rows, ')')),
			(n.readOnly = !0),
			t.viewProps.bindDisabled(n),
			this.element.appendChild(n),
			(this.textareaElem_ = n),
			t.value.emitter.on('change', this.onValueUpdate_),
			(this.value = t.value),
			this.update_();
	}
	update_() {
		const e = this.textareaElem_,
			t = e.scrollTop === e.scrollHeight - e.clientHeight,
			n = [];
		this.value.rawValue.forEach((s) => {
			s !== void 0 && n.push(this.formatter_(s));
		}),
			(e.textContent = n.join('\n')),
			t && (e.scrollTop = e.scrollHeight);
	}
	onValueUpdate_() {
		this.update_();
	}
}
class C0 {
	constructor(e, t) {
		(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new p4(e, { formatter: t.formatter, rows: t.rows, value: this.value, viewProps: this.viewProps }));
	}
}
const pw = wt('sgl');
class f4 {
	constructor(e, t) {
		(this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
			(this.formatter_ = t.formatter),
			(this.element = e.createElement('div')),
			this.element.classList.add(pw()),
			t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('input');
		n.classList.add(pw('i')),
			(n.readOnly = !0),
			(n.type = 'text'),
			t.viewProps.bindDisabled(n),
			this.element.appendChild(n),
			(this.inputElement = n),
			t.value.emitter.on('change', this.onValueUpdate_),
			(this.value = t.value),
			this.update_();
	}
	update_() {
		const e = this.value.rawValue,
			t = e[e.length - 1];
		this.inputElement.value = t !== void 0 ? this.formatter_(t) : '';
	}
	onValueUpdate_() {
		this.update_();
	}
}
class R0 {
	constructor(e, t) {
		(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.view = new f4(e, { formatter: t.formatter, value: this.value, viewProps: this.viewProps }));
	}
}
const m4 = li({
	id: 'monitor-bool',
	type: 'monitor',
	accept: (i, e) => {
		if (typeof i != 'boolean') return null;
		const t = rn(e, (n) => ({ readonly: n.required.constant(!0), rows: n.optional.number }));
		return t ? { initialValue: i, params: t } : null;
	},
	binding: { reader: (i) => ZT },
	controller: (i) => {
		var e;
		return i.value.rawValue.length === 1
			? new R0(i.document, { formatter: rw, value: i.value, viewProps: i.viewProps })
			: new C0(i.document, {
					formatter: rw,
					rows: (e = i.params.rows) !== null && e !== void 0 ? e : gu.monitor.defaultRows,
					value: i.value,
					viewProps: i.viewProps,
			  });
	},
});
class g4 extends Fh {
	get max() {
		return this.controller.valueController.props.get('max');
	}
	set max(e) {
		this.controller.valueController.props.set('max', e);
	}
	get min() {
		return this.controller.valueController.props.get('min');
	}
	set min(e) {
		this.controller.valueController.props.set('min', e);
	}
}
const Xr = wt('grl');
class v4 {
	constructor(e, t) {
		(this.onCursorChange_ = this.onCursorChange_.bind(this)),
			(this.onValueUpdate_ = this.onValueUpdate_.bind(this)),
			(this.element = e.createElement('div')),
			this.element.classList.add(Xr()),
			t.viewProps.bindClassModifiers(this.element),
			(this.formatter_ = t.formatter),
			(this.props_ = t.props),
			(this.cursor_ = t.cursor),
			this.cursor_.emitter.on('change', this.onCursorChange_);
		const n = e.createElementNS(Gs, 'svg');
		n.classList.add(Xr('g')),
			(n.style.height = 'calc(var('.concat(t1('containerUnitSize'), ') * ').concat(t.rows, ')')),
			this.element.appendChild(n),
			(this.svgElem_ = n);
		const s = e.createElementNS(Gs, 'polyline');
		this.svgElem_.appendChild(s), (this.lineElem_ = s);
		const r = e.createElement('div');
		r.classList.add(Xr('t'), wt('tt')()),
			this.element.appendChild(r),
			(this.tooltipElem_ = r),
			t.value.emitter.on('change', this.onValueUpdate_),
			(this.value = t.value),
			this.update_();
	}
	get graphElement() {
		return this.svgElem_;
	}
	update_() {
		const { clientWidth: e, clientHeight: t } = this.element,
			n = this.value.rawValue.length - 1,
			s = this.props_.get('min'),
			r = this.props_.get('max'),
			o = [];
		this.value.rawValue.forEach((u, d) => {
			if (u === void 0) return;
			const p = Dt(d, 0, n, 0, e),
				g = Dt(u, s, r, t, 0);
			o.push([p, g].join(','));
		}),
			this.lineElem_.setAttributeNS(null, 'points', o.join(' '));
		const a = this.tooltipElem_,
			l = this.value.rawValue[this.cursor_.rawValue];
		if (l === void 0) {
			a.classList.remove(Xr('t', 'a'));
			return;
		}
		const c = Dt(this.cursor_.rawValue, 0, n, 0, e),
			h = Dt(l, s, r, t, 0);
		(a.style.left = ''.concat(c, 'px')),
			(a.style.top = ''.concat(h, 'px')),
			(a.textContent = ''.concat(this.formatter_(l))),
			a.classList.contains(Xr('t', 'a')) || (a.classList.add(Xr('t', 'a'), Xr('t', 'in')), ap(a), a.classList.remove(Xr('t', 'in')));
	}
	onValueUpdate_() {
		this.update_();
	}
	onCursorChange_() {
		this.update_();
	}
}
class A1 {
	constructor(e, t) {
		if (
			((this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this)),
			(this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this)),
			(this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this)),
			(this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this)),
			(this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this)),
			(this.props = t.props),
			(this.value = t.value),
			(this.viewProps = t.viewProps),
			(this.cursor_ = Jt(-1)),
			(this.view = new v4(e, {
				cursor: this.cursor_,
				formatter: t.formatter,
				rows: t.rows,
				props: this.props,
				value: this.value,
				viewProps: this.viewProps,
			})),
			!c0(e))
		)
			this.view.element.addEventListener('mousemove', this.onGraphMouseMove_),
				this.view.element.addEventListener('mouseleave', this.onGraphMouseLeave_);
		else {
			const n = new qa(this.view.element);
			n.emitter.on('down', this.onGraphPointerDown_),
				n.emitter.on('move', this.onGraphPointerMove_),
				n.emitter.on('up', this.onGraphPointerUp_);
		}
	}
	importProps(e) {
		return Gi(
			e,
			null,
			(t) => ({ max: t.required.number, min: t.required.number }),
			(t) => (this.props.set('max', t.max), this.props.set('min', t.min), !0)
		);
	}
	exportProps() {
		return Wi(null, { max: this.props.get('max'), min: this.props.get('min') });
	}
	onGraphMouseLeave_() {
		this.cursor_.rawValue = -1;
	}
	onGraphMouseMove_(e) {
		const { clientWidth: t } = this.view.element;
		this.cursor_.rawValue = Math.floor(Dt(e.offsetX, 0, t, 0, this.value.rawValue.length));
	}
	onGraphPointerDown_(e) {
		this.onGraphPointerMove_(e);
	}
	onGraphPointerMove_(e) {
		if (!e.data.point) {
			this.cursor_.rawValue = -1;
			return;
		}
		this.cursor_.rawValue = Math.floor(Dt(e.data.point.x, 0, e.data.bounds.width, 0, this.value.rawValue.length));
	}
	onGraphPointerUp_() {
		this.cursor_.rawValue = -1;
	}
}
function yv(i) {
	return qt(i.format) ? Mi(2) : i.format;
}
function _4(i) {
	var e;
	return i.value.rawValue.length === 1
		? new R0(i.document, { formatter: yv(i.params), value: i.value, viewProps: i.viewProps })
		: new C0(i.document, {
				formatter: yv(i.params),
				rows: (e = i.params.rows) !== null && e !== void 0 ? e : gu.monitor.defaultRows,
				value: i.value,
				viewProps: i.viewProps,
		  });
}
function y4(i) {
	var e, t, n;
	return new A1(i.document, {
		formatter: yv(i.params),
		rows: (e = i.params.rows) !== null && e !== void 0 ? e : gu.monitor.defaultRows,
		props: ut.fromObject({
			max: (t = i.params.max) !== null && t !== void 0 ? t : 100,
			min: (n = i.params.min) !== null && n !== void 0 ? n : 0,
		}),
		value: i.value,
		viewProps: i.viewProps,
	});
}
function fw(i) {
	return i.view === 'graph';
}
const x4 = li({
		id: 'monitor-number',
		type: 'monitor',
		accept: (i, e) => {
			if (typeof i != 'number') return null;
			const t = rn(e, (n) => ({
				format: n.optional.function,
				max: n.optional.number,
				min: n.optional.number,
				readonly: n.required.constant(!0),
				rows: n.optional.number,
				view: n.optional.string,
			}));
			return t ? { initialValue: i, params: t } : null;
		},
		binding: { defaultBufferSize: (i) => (fw(i) ? 64 : 1), reader: (i) => PT },
		controller: (i) => (fw(i.params) ? y4(i) : _4(i)),
		api: (i) => (i.controller.valueController instanceof A1 ? new g4(i.controller) : null),
	}),
	b4 = li({
		id: 'monitor-string',
		type: 'monitor',
		accept: (i, e) => {
			if (typeof i != 'string') return null;
			const t = rn(e, (n) => ({ multiline: n.optional.boolean, readonly: n.required.constant(!0), rows: n.optional.number }));
			return t ? { initialValue: i, params: t } : null;
		},
		binding: { reader: (i) => JT },
		controller: (i) => {
			var e;
			const t = i.value;
			return t.rawValue.length > 1 || i.params.multiline
				? new C0(i.document, {
						formatter: _v,
						rows: (e = i.params.rows) !== null && e !== void 0 ? e : gu.monitor.defaultRows,
						value: t,
						viewProps: i.viewProps,
				  })
				: new R0(i.document, { formatter: _v, value: t, viewProps: i.viewProps });
		},
	});
class w4 {
	constructor() {
		this.map_ = new Map();
	}
	get(e) {
		var t;
		return (t = this.map_.get(e)) !== null && t !== void 0 ? t : null;
	}
	has(e) {
		return this.map_.has(e);
	}
	add(e, t) {
		return (
			this.map_.set(e, t),
			e.viewProps.handleDispose(() => {
				this.map_.delete(e);
			}),
			t
		);
	}
}
class S4 {
	constructor(e) {
		(this.target = e.target), (this.reader_ = e.reader), (this.writer_ = e.writer);
	}
	read() {
		return this.reader_(this.target.read());
	}
	write(e) {
		this.writer_(this.target, e);
	}
	inject(e) {
		this.write(this.reader_(e));
	}
}
function M4(i, e) {
	var t;
	const n = i.accept(e.target.read(), e.params);
	if (qt(n)) return null;
	const s = { target: e.target, initialValue: n.initialValue, params: n.params },
		r = rn(e.params, (u) => ({
			disabled: u.optional.boolean,
			hidden: u.optional.boolean,
			label: u.optional.string,
			tag: u.optional.string,
		})),
		o = i.binding.reader(s),
		a = i.binding.constraint ? i.binding.constraint(s) : void 0,
		l = new S4({ reader: o, target: e.target, writer: i.binding.writer(s) }),
		c = new az(Jt(o(n.initialValue), { constraint: a, equals: i.binding.equals }), l),
		h = i.controller({
			constraint: a,
			document: e.document,
			initialValue: n.initialValue,
			params: n.params,
			value: c,
			viewProps: Tr.create({ disabled: r == null ? void 0 : r.disabled, hidden: r == null ? void 0 : r.hidden }),
		});
	return new wz(e.document, {
		blade: fc(),
		props: ut.fromObject({
			label: 'label' in e.params ? ((t = r == null ? void 0 : r.label) !== null && t !== void 0 ? t : null) : e.target.key,
		}),
		tag: r == null ? void 0 : r.tag,
		value: c,
		valueController: h,
	});
}
class E4 {
	constructor(e) {
		(this.target = e.target), (this.reader_ = e.reader);
	}
	read() {
		return this.reader_(this.target.read());
	}
}
function T4(i, e) {
	return e === 0 ? new sV() : new rV(i, e != null ? e : gu.monitor.defaultInterval);
}
function A4(i, e) {
	var t, n, s;
	const r = i.accept(e.target.read(), e.params);
	if (qt(r)) return null;
	const o = { target: e.target, initialValue: r.initialValue, params: r.params },
		a = rn(e.params, (d) => ({
			bufferSize: d.optional.number,
			disabled: d.optional.boolean,
			hidden: d.optional.boolean,
			interval: d.optional.number,
			label: d.optional.string,
		})),
		l = i.binding.reader(o),
		c =
			(n =
				(t = a == null ? void 0 : a.bufferSize) !== null && t !== void 0
					? t
					: i.binding.defaultBufferSize && i.binding.defaultBufferSize(r.params)) !== null && n !== void 0
				? n
				: 1,
		h = new Az({
			binding: new E4({ reader: l, target: e.target }),
			bufferSize: c,
			ticker: T4(e.document, a == null ? void 0 : a.interval),
		}),
		u = i.controller({
			document: e.document,
			params: r.params,
			value: h,
			viewProps: Tr.create({ disabled: a == null ? void 0 : a.disabled, hidden: a == null ? void 0 : a.hidden }),
		});
	return (
		u.viewProps.bindDisabled(h.ticker),
		u.viewProps.handleDispose(() => {
			h.ticker.dispose();
		}),
		new Rz(e.document, {
			blade: fc(),
			props: ut.fromObject({
				label: 'label' in e.params ? ((s = a == null ? void 0 : a.label) !== null && s !== void 0 ? s : null) : e.target.key,
			}),
			value: h,
			valueController: u,
		})
	);
}
class C4 {
	constructor(e) {
		(this.pluginsMap_ = { blades: [], inputs: [], monitors: [] }), (this.apiCache_ = e);
	}
	getAll() {
		return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors];
	}
	register(e, t) {
		if (!_V(t.core)) throw cn.notCompatible(e, t.id);
		t.type === 'blade'
			? this.pluginsMap_.blades.unshift(t)
			: t.type === 'input'
			? this.pluginsMap_.inputs.unshift(t)
			: t.type === 'monitor' && this.pluginsMap_.monitors.unshift(t);
	}
	createInput_(e, t, n) {
		return this.pluginsMap_.inputs.reduce((s, r) => (s != null ? s : M4(r, { document: e, target: t, params: n })), null);
	}
	createMonitor_(e, t, n) {
		return this.pluginsMap_.monitors.reduce((s, r) => (s != null ? s : A4(r, { document: e, params: n, target: t })), null);
	}
	createBinding(e, t, n) {
		const s = t.read();
		if (qt(s)) throw new cn({ context: { key: t.key }, type: 'nomatchingcontroller' });
		const r = this.createInput_(e, t, n);
		if (r) return r;
		const o = this.createMonitor_(e, t, n);
		if (o) return o;
		throw new cn({ context: { key: t.key }, type: 'nomatchingcontroller' });
	}
	createBlade(e, t) {
		const n = this.pluginsMap_.blades.reduce((s, r) => (s != null ? s : iV(r, { document: e, params: t })), null);
		if (!n) throw new cn({ type: 'nomatchingview', context: { params: t } });
		return n;
	}
	createInputBindingApi_(e) {
		const t = this.pluginsMap_.inputs.reduce((n, s) => {
			var r, o;
			return (
				n ||
				((o = (r = s.api) === null || r === void 0 ? void 0 : r.call(s, { controller: e })) !== null && o !== void 0 ? o : null)
			);
		}, null);
		return this.apiCache_.add(e, t != null ? t : new Fh(e));
	}
	createMonitorBindingApi_(e) {
		const t = this.pluginsMap_.monitors.reduce((n, s) => {
			var r, o;
			return (
				n ||
				((o = (r = s.api) === null || r === void 0 ? void 0 : r.call(s, { controller: e })) !== null && o !== void 0 ? o : null)
			);
		}, null);
		return this.apiCache_.add(e, t != null ? t : new Fh(e));
	}
	createBindingApi(e) {
		if (this.apiCache_.has(e)) return this.apiCache_.get(e);
		if (Sz(e)) return this.createInputBindingApi_(e);
		if (Pz(e)) return this.createMonitorBindingApi_(e);
		throw cn.shouldNeverHappen();
	}
	createApi(e) {
		if (this.apiCache_.has(e)) return this.apiCache_.get(e);
		if (bz(e)) return this.createBindingApi(e);
		const t = this.pluginsMap_.blades.reduce((n, s) => (n != null ? n : s.api({ controller: e, pool: this })), null);
		if (!t) throw cn.shouldNeverHappen();
		return this.apiCache_.add(e, t);
	}
}
const R4 = new w4();
function P4() {
	const i = new C4(R4);
	return (
		[n4, o4, h4, d4, qH, VH, zH, UH, wV, m4, b4, x4, Uz, jz, KT].forEach((e) => {
			i.register('core', e);
		}),
		i
	);
}
class L4 extends Xa {
	constructor(e) {
		super(e),
			(this.emitter_ = new Mn()),
			this.controller.value.emitter.on('change', (t) => {
				this.emitter_.emit('change', new lu(this, t.rawValue));
			});
	}
	get label() {
		return this.controller.labelController.props.get('label');
	}
	set label(e) {
		this.controller.labelController.props.set('label', e);
	}
	get options() {
		return this.controller.valueController.props.get('options');
	}
	set options(e) {
		this.controller.valueController.props.set('options', e);
	}
	get value() {
		return this.controller.value.rawValue;
	}
	set value(e) {
		this.controller.value.rawValue = e;
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
}
class I4 extends Xa {}
class D4 extends Xa {
	constructor(e) {
		super(e),
			(this.emitter_ = new Mn()),
			this.controller.value.emitter.on('change', (t) => {
				this.emitter_.emit('change', new lu(this, t.rawValue));
			});
	}
	get label() {
		return this.controller.labelController.props.get('label');
	}
	set label(e) {
		this.controller.labelController.props.set('label', e);
	}
	get max() {
		return this.controller.valueController.sliderController.props.get('max');
	}
	set max(e) {
		this.controller.valueController.sliderController.props.set('max', e);
	}
	get min() {
		return this.controller.valueController.sliderController.props.get('min');
	}
	set min(e) {
		this.controller.valueController.sliderController.props.set('min', e);
	}
	get value() {
		return this.controller.value.rawValue;
	}
	set value(e) {
		this.controller.value.rawValue = e;
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
}
class O4 extends Xa {
	constructor(e) {
		super(e),
			(this.emitter_ = new Mn()),
			this.controller.value.emitter.on('change', (t) => {
				this.emitter_.emit('change', new lu(this, t.rawValue));
			});
	}
	get label() {
		return this.controller.labelController.props.get('label');
	}
	set label(e) {
		this.controller.labelController.props.set('label', e);
	}
	get formatter() {
		return this.controller.valueController.props.get('formatter');
	}
	set formatter(e) {
		this.controller.valueController.props.set('formatter', e);
	}
	get value() {
		return this.controller.value.rawValue;
	}
	set value(e) {
		this.controller.value.rawValue = e;
	}
	on(e, t) {
		const n = t.bind(this);
		return (
			this.emitter_.on(
				e,
				(s) => {
					n(s);
				},
				{ key: t }
			),
			this
		);
	}
	off(e, t) {
		return this.emitter_.off(e, t), this;
	}
}
const U4 = (function () {
	return {
		id: 'list',
		type: 'blade',
		core: pc,
		accept(i) {
			const e = rn(i, (t) => ({
				options: t.required.custom(du),
				value: t.required.raw,
				view: t.required.constant('list'),
				label: t.optional.string,
			}));
			return e ? { params: e } : null;
		},
		controller(i) {
			const e = new uu(v0(i.params.options)),
				t = Jt(i.params.value, { constraint: e }),
				n = new wo(i.document, { props: new ut({ options: e.values.value('options') }), value: t, viewProps: i.viewProps });
			return new Da(i.document, { blade: i.blade, props: ut.fromObject({ label: i.params.label }), value: t, valueController: n });
		},
		api(i) {
			return !(i.controller instanceof Da) || !(i.controller.valueController instanceof wo) ? null : new L4(i.controller);
		},
	};
})();
class N4 extends YT {
	constructor(e, t) {
		super(e, t);
	}
	get element() {
		return this.controller.view.element;
	}
}
class F4 extends gv {
	constructor(e, t) {
		super(e, { expanded: t.expanded, blade: t.blade, props: t.props, root: !0, viewProps: t.viewProps });
	}
}
const mw = wt('spr');
class B4 {
	constructor(e, t) {
		(this.element = e.createElement('div')), this.element.classList.add(mw()), t.viewProps.bindClassModifiers(this.element);
		const n = e.createElement('hr');
		n.classList.add(mw('r')), this.element.appendChild(n);
	}
}
class gw extends xf {
	constructor(e, t) {
		super(Object.assign(Object.assign({}, t), { view: new B4(e, { viewProps: t.viewProps }) }));
	}
}
const k4 = {
		id: 'separator',
		type: 'blade',
		core: pc,
		accept(i) {
			const e = rn(i, (t) => ({ view: t.required.constant('separator') }));
			return e ? { params: e } : null;
		},
		controller(i) {
			return new gw(i.document, { blade: i.blade, viewProps: i.viewProps });
		},
		api(i) {
			return i.controller instanceof gw ? new I4(i.controller) : null;
		},
	},
	z4 = {
		id: 'slider',
		type: 'blade',
		core: pc,
		accept(i) {
			const e = rn(i, (t) => ({
				max: t.required.number,
				min: t.required.number,
				view: t.required.constant('slider'),
				format: t.optional.function,
				label: t.optional.string,
				value: t.optional.number,
			}));
			return e ? { params: e } : null;
		},
		controller(i) {
			var e, t;
			const n = (e = i.params.value) !== null && e !== void 0 ? e : 0,
				s = new au({ max: i.params.max, min: i.params.min }),
				r = Jt(n, { constraint: s }),
				o = new hp(
					i.document,
					Object.assign(
						Object.assign(
							{},
							e1({
								formatter: (t = i.params.format) !== null && t !== void 0 ? t : nz,
								keyScale: Jt(1),
								max: s.values.value('max'),
								min: s.values.value('min'),
								pointerScale: DT(i.params, n),
							})
						),
						{ parser: br, value: r, viewProps: i.viewProps }
					)
				);
			return new Da(i.document, { blade: i.blade, props: ut.fromObject({ label: i.params.label }), value: r, valueController: o });
		},
		api(i) {
			return !(i.controller instanceof Da) || !(i.controller.valueController instanceof hp) ? null : new D4(i.controller);
		},
	},
	V4 = (function () {
		return {
			id: 'text',
			type: 'blade',
			core: pc,
			accept(i) {
				const e = rn(i, (t) => ({
					parse: t.required.function,
					value: t.required.raw,
					view: t.required.constant('text'),
					format: t.optional.function,
					label: t.optional.string,
				}));
				return e ? { params: e } : null;
			},
			controller(i) {
				var e;
				const t = Jt(i.params.value),
					n = new Bh(i.document, {
						parser: i.params.parse,
						props: ut.fromObject({ formatter: (e = i.params.format) !== null && e !== void 0 ? e : (s) => String(s) }),
						value: t,
						viewProps: i.viewProps,
					});
				return new Da(i.document, {
					blade: i.blade,
					props: ut.fromObject({ label: i.params.label }),
					value: t,
					valueController: n,
				});
			},
			api(i) {
				return !(i.controller instanceof Da) || !(i.controller.valueController instanceof Bh) ? null : new O4(i.controller);
			},
		};
	})();
function H4(i) {
	const e = i.createElement('div');
	return e.classList.add(wt('dfw')()), i.body && i.body.appendChild(e), e;
}
function G4(i, e, t) {
	if (i.querySelector('style[data-tp-style='.concat(e, ']'))) return;
	const n = i.createElement('style');
	(n.dataset.tpStyle = e), (n.textContent = t), i.head.appendChild(n);
}
class W4 extends N4 {
	constructor(e) {
		var t, n;
		const s = e != null ? e : {},
			r = (t = s.document) !== null && t !== void 0 ? t : fz(),
			o = P4(),
			a = new F4(r, { expanded: s.expanded, blade: fc(), props: ut.fromObject({ title: s.title }), viewProps: Tr.create() });
		super(a, o),
			(this.pool_ = o),
			(this.containerElem_ = (n = s.container) !== null && n !== void 0 ? n : H4(r)),
			this.containerElem_.appendChild(this.element),
			(this.doc_ = r),
			(this.usesDefaultWrapper_ = !s.container),
			this.setUpDefaultPlugins_();
	}
	get document() {
		if (!this.doc_) throw cn.alreadyDisposed();
		return this.doc_;
	}
	dispose() {
		const e = this.containerElem_;
		if (!e) throw cn.alreadyDisposed();
		if (this.usesDefaultWrapper_) {
			const t = e.parentElement;
			t && t.removeChild(e);
		}
		(this.containerElem_ = null), (this.doc_ = null), super.dispose();
	}
	registerPlugin(e) {
		e.css && G4(this.document, 'plugin-'.concat(e.id), e.css),
			('plugin' in e ? [e.plugin] : 'plugins' in e ? e.plugins : []).forEach((n) => {
				this.pool_.register(e.id, n);
			});
	}
	setUpDefaultPlugins_() {
		this.registerPlugin({
			id: 'default',
			css: '.tp-tbiv_b,.tp-coltxtv_ms,.tp-colswv_b,.tp-ckbv_i,.tp-sglv_i,.tp-mllv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-rotv_b,.tp-fldv_b,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--bld-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--cnt-usz);line-height:var(--cnt-usz);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tbpv_c>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-vp))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tbpv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tbpv_c>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--cnt-usp)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tbpv_c>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tbpv_c>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tbpv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-vp)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tbpv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tbpv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tbpv_c>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tbpv_c>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--bld-br);border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tbpv_c .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--bld-br)}.tp-tbpv_c>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tbpv_c>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tbpv_c>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--bld-br)}.tp-tbpv_c .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--bld-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);overflow:hidden;padding-left:var(--cnt-hp);padding-right:calc(4px + var(--cnt-usz) + var(--cnt-hp));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-hp) + (var(--cnt-usz) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-vp);padding-top:var(--cnt-vp);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--cnt-usz);line-height:var(--cnt-usz);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-sglv_i,.tp-mllv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--bld-br);box-sizing:border-box;color:var(--mo-fg);height:var(--cnt-usz);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-sglv_i::-webkit-scrollbar,.tp-mllv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-sglv_i::-webkit-scrollbar-corner,.tp-mllv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-sglv_i::-webkit-scrollbar-thumb,.tp-mllv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-rotv{--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-br: var(--tp-base-border-radius, 6px);--bs-ff: var(--tp-base-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--bld-br: var(--tp-blade-border-radius, 2px);--bld-hp: var(--tp-blade-horizontal-padding, 4px);--bld-vw: var(--tp-blade-value-width, 160px);--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--cnt-hp: var(--tp-container-horizontal-padding, 4px);--cnt-vp: var(--tp-container-vertical-padding, 4px);--cnt-usp: var(--tp-container-unit-spacing, 4px);--cnt-usz: var(--tp-container-unit-size, 20px);--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--bld-br);cursor:pointer;display:block;height:var(--cnt-usz);position:relative;width:var(--cnt-usz)}.tp-ckbv_w svg{display:block;height:16px;inset:0;margin:auto;opacity:0;position:absolute;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--cnt-usz)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--cnt-usp);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--cnt-usp)}.tp-colpv_rgb{display:flex;margin-top:var(--cnt-usp);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-vp);padding-top:calc(var(--cnt-vp) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-hp));position:absolute;right:calc(-1*var(--cnt-hp));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--bld-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--cnt-usz)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--cnt-usz);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{inset:0;position:absolute}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--bld-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--bld-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;inset:0;position:absolute}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--bld-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{cursor:pointer;display:block;height:var(--cnt-usz);left:0;position:absolute;top:0;width:var(--cnt-usz)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--bld-br);content:"";display:block;inset:0;position:absolute}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--bld-br);color:var(--lbl-fg);cursor:pointer;height:var(--cnt-usz);line-height:var(--cnt-usz);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--cnt-usz)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-hp);padding-right:var(--cnt-hp)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:var(--bld-vw)}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 var(--bld-hp);width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--cnt-usz)*3);line-height:var(--cnt-usz);padding-left:var(--bld-hp);padding-right:var(--bld-hp);resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--cnt-usz);margin-right:4px;position:relative;width:var(--cnt-usz)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--cnt-usp);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-hp));right:calc(-1*var(--cnt-hp));top:var(--cnt-usz)}.tp-p2dpv{padding-left:calc(var(--cnt-usz) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:var(--bld-vw);padding:var(--cnt-vp) var(--cnt-hp);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--cnt-usz);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin:auto;position:absolute}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;content:"";display:block;height:2px;inset:0;margin-bottom:auto;margin-top:auto;position:absolute}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--bld-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--cnt-usz) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--cnt-usz) + 4px);width:max(var(--bs-br),4px)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-hp) + 4px);padding-right:calc(var(--cnt-hp) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);content:"";inset:0 0 2px;pointer-events:none;position:absolute}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--cnt-usz) + 4px);line-height:calc(var(--cnt-usz) + 4px);opacity:.5;overflow:hidden;position:relative;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-tbpv_c{padding-bottom:var(--cnt-vp);padding-left:4px;padding-top:var(--cnt-vp)}.tp-txtv{position:relative}.tp-txtv_i{padding-left:var(--bld-hp);padding-right:var(--bld-hp)}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:calc(var(--bld-hp) - 5px);position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--cnt-usz) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--bld-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--bs-ff);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--cnt-usz) + var(--cnt-hp));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0;transition-delay:0s;transition-duration:0s}.tp-rotv.tp-rotv-not>.tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst.tp-fldv-expanded>.tp-fldv_b{transition-delay:0s;transition-duration:0s}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-vp))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}',
			plugins: [U4, k4, z4, KT, V4],
		});
	}
}
new qT('4.0.4');
const X4 = ({ follow: i = !0, lockX: e = !1, lockY: t = !1, lockZ: n = !1 } = {}) => {
	const s = new Ui(),
		r = { follow: i, lockX: e, lockY: t, lockZ: n };
	function o(a) {
		const { follow: l, lockX: c, lockY: h, lockZ: u } = r;
		if (!l) return;
		const d = s.rotation.clone();
		a.getWorldQuaternion(s.quaternion), c && (s.rotation.x = d.x), h && (s.rotation.y = d.y), u && (s.rotation.z = d.z);
	}
	return {
		group: s,
		update: o,
		updateProps(a) {
			Object.assign(r, a);
		},
	};
};
function cr(i) {
	if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	return i;
}
function C1(i, e) {
	(i.prototype = Object.create(e.prototype)), (i.prototype.constructor = i), (i.__proto__ = e);
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var ki = { autoSleep: 120, force3D: 'auto', nullTargetWarn: 1, units: { lineHeight: '' } },
	tc = { duration: 0.5, overwrite: !1, delay: 0 },
	P0,
	Kn,
	Zt,
	is = 1e8,
	Xt = 1 / is,
	xv = Math.PI * 2,
	q4 = xv / 4,
	Y4 = 0,
	R1 = Math.sqrt,
	j4 = Math.cos,
	K4 = Math.sin,
	Un = function (e) {
		return typeof e == 'string';
	},
	hn = function (e) {
		return typeof e == 'function';
	},
	Sr = function (e) {
		return typeof e == 'number';
	},
	L0 = function (e) {
		return typeof e > 'u';
	},
	Zs = function (e) {
		return typeof e == 'object';
	},
	vi = function (e) {
		return e !== !1;
	},
	I0 = function () {
		return typeof window < 'u';
	},
	Ad = function (e) {
		return hn(e) || Un(e);
	},
	P1 = (typeof ArrayBuffer == 'function' && ArrayBuffer.isView) || function () {},
	$n = Array.isArray,
	bv = /(?:-?\.?\d|\.)+/gi,
	L1 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
	Ll = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
	Ym = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
	I1 = /[+-]=-?[.\d]+/,
	D1 = /[^,'"\[\]\s]+/gi,
	$4 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
	tn,
	Ns,
	wv,
	D0,
	Vi = {},
	up = {},
	O1,
	U1 = function (e) {
		return (up = Ua(e, Vi)) && Ei;
	},
	O0 = function (e, t) {
		return console.warn('Invalid property', e, 'set to', t, 'Missing plugin? gsap.registerPlugin()');
	},
	Vh = function (e, t) {
		return !t && console.warn(e);
	},
	N1 = function (e, t) {
		return (e && (Vi[e] = t) && up && (up[e] = t)) || Vi;
	},
	Hh = function () {
		return 0;
	},
	Z4 = { suppressEvents: !0, isStart: !0, kill: !1 },
	Wd = { suppressEvents: !0, kill: !1 },
	J4 = { suppressEvents: !0 },
	U0 = {},
	mo = [],
	Sv = {},
	F1,
	Pi = {},
	jm = {},
	vw = 30,
	Xd = [],
	N0 = '',
	F0 = function (e) {
		var t = e[0],
			n,
			s;
		if ((Zs(t) || hn(t) || (e = [e]), !(n = (t._gsap || {}).harness))) {
			for (s = Xd.length; s-- && !Xd[s].targetTest(t); );
			n = Xd[s];
		}
		for (s = e.length; s--; ) (e[s] && (e[s]._gsap || (e[s]._gsap = new aA(e[s], n)))) || e.splice(s, 1);
		return e;
	},
	xa = function (e) {
		return e._gsap || F0(ss(e))[0]._gsap;
	},
	B1 = function (e, t, n) {
		return (n = e[t]) && hn(n) ? e[t]() : (L0(n) && e.getAttribute && e.getAttribute(t)) || n;
	},
	_i = function (e, t) {
		return (e = e.split(',')).forEach(t) || e;
	},
	pn = function (e) {
		return Math.round(e * 1e5) / 1e5 || 0;
	},
	In = function (e) {
		return Math.round(e * 1e7) / 1e7 || 0;
	},
	Vl = function (e, t) {
		var n = t.charAt(0),
			s = parseFloat(t.substr(2));
		return (e = parseFloat(e)), n === '+' ? e + s : n === '-' ? e - s : n === '*' ? e * s : e / s;
	},
	Q4 = function (e, t) {
		for (var n = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < n; );
		return s < n;
	},
	dp = function () {
		var e = mo.length,
			t = mo.slice(0),
			n,
			s;
		for (Sv = {}, mo.length = 0, n = 0; n < e; n++) (s = t[n]), s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0);
	},
	k1 = function (e, t, n, s) {
		mo.length && !Kn && dp(), e.render(t, n, Kn && t < 0 && (e._initted || e._startAt)), mo.length && !Kn && dp();
	},
	z1 = function (e) {
		var t = parseFloat(e);
		return (t || t === 0) && (e + '').match(D1).length < 2 ? t : Un(e) ? e.trim() : e;
	},
	V1 = function (e) {
		return e;
	},
	os = function (e, t) {
		for (var n in t) n in e || (e[n] = t[n]);
		return e;
	},
	e5 = function (e) {
		return function (t, n) {
			for (var s in n) s in t || (s === 'duration' && e) || s === 'ease' || (t[s] = n[s]);
		};
	},
	Ua = function (e, t) {
		for (var n in t) e[n] = t[n];
		return e;
	},
	_w = function i(e, t) {
		for (var n in t)
			n !== '__proto__' && n !== 'constructor' && n !== 'prototype' && (e[n] = Zs(t[n]) ? i(e[n] || (e[n] = {}), t[n]) : t[n]);
		return e;
	},
	pp = function (e, t) {
		var n = {},
			s;
		for (s in e) s in t || (n[s] = e[s]);
		return n;
	},
	ah = function (e) {
		var t = e.parent || tn,
			n = e.keyframes ? e5($n(e.keyframes)) : os;
		if (vi(e.inherit)) for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
		return e;
	},
	t5 = function (e, t) {
		for (var n = e.length, s = n === t.length; s && n-- && e[n] === t[n]; );
		return n < 0;
	},
	H1 = function (e, t, n, s, r) {
		var o = e[s],
			a;
		if (r) for (a = t[r]; o && o[r] > a; ) o = o._prev;
		return (
			o ? ((t._next = o._next), (o._next = t)) : ((t._next = e[n]), (e[n] = t)),
			t._next ? (t._next._prev = t) : (e[s] = t),
			(t._prev = o),
			(t.parent = t._dp = e),
			t
		);
	},
	wf = function (e, t, n, s) {
		n === void 0 && (n = '_first'), s === void 0 && (s = '_last');
		var r = t._prev,
			o = t._next;
		r ? (r._next = o) : e[n] === t && (e[n] = o), o ? (o._prev = r) : e[s] === t && (e[s] = r), (t._next = t._prev = t.parent = null);
	},
	So = function (e, t) {
		e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), (e._act = 0);
	},
	ba = function (e, t) {
		if (e && (!t || t._end > e._dur || t._start < 0)) for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
		return e;
	},
	n5 = function (e) {
		for (var t = e.parent; t && t.parent; ) (t._dirty = 1), t.totalDuration(), (t = t.parent);
		return e;
	},
	Mv = function (e, t, n, s) {
		return e._startAt && (Kn ? e._startAt.revert(Wd) : (e.vars.immediateRender && !e.vars.autoRevert) || e._startAt.render(t, !0, s));
	},
	i5 = function i(e) {
		return !e || (e._ts && i(e.parent));
	},
	yw = function (e) {
		return e._repeat ? nc(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
	},
	nc = function (e, t) {
		var n = Math.floor((e /= t));
		return e && n === e ? n - 1 : n;
	},
	fp = function (e, t) {
		return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
	},
	Sf = function (e) {
		return (e._end = In(e._start + (e._tDur / Math.abs(e._ts || e._rts || Xt) || 0)));
	},
	Mf = function (e, t) {
		var n = e._dp;
		return (
			n &&
				n.smoothChildTiming &&
				e._ts &&
				((e._start = In(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts))),
				Sf(e),
				n._dirty || ba(n, e)),
			e
		);
	},
	G1 = function (e, t) {
		var n;
		if (
			((t._time || (!t._dur && t._initted) || (t._start < e._time && (t._dur || !t.add))) &&
				((n = fp(e.rawTime(), t)), (!t._dur || vu(0, t.totalDuration(), n) - t._tTime > Xt) && t.render(n, !0)),
			ba(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
		) {
			if (e._dur < e.duration()) for (n = e; n._dp; ) n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
			e._zTime = -Xt;
		}
	},
	ks = function (e, t, n, s) {
		return (
			t.parent && So(t),
			(t._start = In((Sr(n) ? n : n || e !== tn ? $i(e, n, t) : e._time) + t._delay)),
			(t._end = In(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0))),
			H1(e, t, '_first', '_last', e._sort ? '_start' : 0),
			Ev(t) || (e._recent = t),
			s || G1(e, t),
			e._ts < 0 && Mf(e, e._tTime),
			e
		);
	},
	W1 = function (e, t) {
		return (Vi.ScrollTrigger || O0('scrollTrigger', t)) && Vi.ScrollTrigger.create(t, e);
	},
	X1 = function (e, t, n, s, r) {
		if ((k0(e, t, r), !e._initted)) return 1;
		if (!n && e._pt && !Kn && ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) && F1 !== Ii.frame)
			return mo.push(e), (e._lazy = [r, s]), 1;
	},
	s5 = function i(e) {
		var t = e.parent;
		return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || i(t));
	},
	Ev = function (e) {
		var t = e.data;
		return t === 'isFromStart' || t === 'isStart';
	},
	r5 = function (e, t, n, s) {
		var r = e.ratio,
			o = t < 0 || (!t && ((!e._start && s5(e) && !(!e._initted && Ev(e))) || ((e._ts < 0 || e._dp._ts < 0) && !Ev(e)))) ? 0 : 1,
			a = e._rDelay,
			l = 0,
			c,
			h,
			u;
		if (
			(a &&
				e._repeat &&
				((l = vu(0, e._tDur, t)),
				(h = nc(l, a)),
				e._yoyo && h & 1 && (o = 1 - o),
				h !== nc(e._tTime, a) && ((r = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
			o !== r || Kn || s || e._zTime === Xt || (!t && e._zTime))
		) {
			if (!e._initted && X1(e, t, s, n, l)) return;
			for (
				u = e._zTime,
					e._zTime = t || (n ? Xt : 0),
					n || (n = t && !u),
					e.ratio = o,
					e._from && (o = 1 - o),
					e._time = 0,
					e._tTime = l,
					c = e._pt;
				c;

			)
				c.r(o, c.d), (c = c._next);
			t < 0 && Mv(e, t, n, !0),
				e._onUpdate && !n && Fi(e, 'onUpdate'),
				l && e._repeat && !n && e.parent && Fi(e, 'onRepeat'),
				(t >= e._tDur || t < 0) &&
					e.ratio === o &&
					(o && So(e, 1), !n && !Kn && (Fi(e, o ? 'onComplete' : 'onReverseComplete', !0), e._prom && e._prom()));
		} else e._zTime || (e._zTime = t);
	},
	o5 = function (e, t, n) {
		var s;
		if (n > t)
			for (s = e._first; s && s._start <= n; ) {
				if (s.data === 'isPause' && s._start > t) return s;
				s = s._next;
			}
		else
			for (s = e._last; s && s._start >= n; ) {
				if (s.data === 'isPause' && s._start < t) return s;
				s = s._prev;
			}
	},
	ic = function (e, t, n, s) {
		var r = e._repeat,
			o = In(t) || 0,
			a = e._tTime / e._tDur;
		return (
			a && !s && (e._time *= o / e._dur),
			(e._dur = o),
			(e._tDur = r ? (r < 0 ? 1e10 : In(o * (r + 1) + e._rDelay * r)) : o),
			a > 0 && !s && Mf(e, (e._tTime = e._tDur * a)),
			e.parent && Sf(e),
			n || ba(e.parent, e),
			e
		);
	},
	xw = function (e) {
		return e instanceof oi ? ba(e) : ic(e, e._dur);
	},
	a5 = { _start: 0, endTime: Hh, totalDuration: Hh },
	$i = function i(e, t, n) {
		var s = e.labels,
			r = e._recent || a5,
			o = e.duration() >= is ? r.endTime(!1) : e._dur,
			a,
			l,
			c;
		return Un(t) && (isNaN(t) || t in s)
			? ((l = t.charAt(0)),
			  (c = t.substr(-1) === '%'),
			  (a = t.indexOf('=')),
			  l === '<' || l === '>'
					? (a >= 0 && (t = t.replace(/=/, '')),
					  (l === '<' ? r._start : r.endTime(r._repeat >= 0)) +
							(parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? r : n).totalDuration() / 100 : 1))
					: a < 0
					? (t in s || (s[t] = o), s[t])
					: ((l = parseFloat(t.charAt(a - 1) + t.substr(a + 1))),
					  c && n && (l = (l / 100) * ($n(n) ? n[0] : n).totalDuration()),
					  a > 1 ? i(e, t.substr(0, a - 1), n) + l : o + l))
			: t == null
			? o
			: +t;
	},
	lh = function (e, t, n) {
		var s = Sr(t[1]),
			r = (s ? 2 : 1) + (e < 2 ? 0 : 1),
			o = t[r],
			a,
			l;
		if ((s && (o.duration = t[1]), (o.parent = n), e)) {
			for (a = o, l = n; l && !('immediateRender' in a); ) (a = l.vars.defaults || {}), (l = vi(l.vars.inherit) && l.parent);
			(o.immediateRender = vi(a.immediateRender)), e < 2 ? (o.runBackwards = 1) : (o.startAt = t[r - 1]);
		}
		return new Sn(t[0], o, t[r + 1]);
	},
	Io = function (e, t) {
		return e || e === 0 ? t(e) : t;
	},
	vu = function (e, t, n) {
		return n < e ? e : n > t ? t : n;
	},
	Yn = function (e, t) {
		return !Un(e) || !(t = $4.exec(e)) ? '' : t[1];
	},
	l5 = function (e, t, n) {
		return Io(n, function (s) {
			return vu(e, t, s);
		});
	},
	Tv = [].slice,
	q1 = function (e, t) {
		return e && Zs(e) && 'length' in e && ((!t && !e.length) || (e.length - 1 in e && Zs(e[0]))) && !e.nodeType && e !== Ns;
	},
	c5 = function (e, t, n) {
		return (
			n === void 0 && (n = []),
			e.forEach(function (s) {
				var r;
				return (Un(s) && !t) || q1(s, 1) ? (r = n).push.apply(r, ss(s)) : n.push(s);
			}) || n
		);
	},
	ss = function (e, t, n) {
		return Zt && !t && Zt.selector
			? Zt.selector(e)
			: Un(e) && !n && (wv || !sc())
			? Tv.call((t || D0).querySelectorAll(e), 0)
			: $n(e)
			? c5(e, n)
			: q1(e)
			? Tv.call(e, 0)
			: e
			? [e]
			: [];
	},
	Av = function (e) {
		return (
			(e = ss(e)[0] || Vh('Invalid scope') || {}),
			function (t) {
				var n = e.current || e.nativeElement || e;
				return ss(t, n.querySelectorAll ? n : n === e ? Vh('Invalid scope') || D0.createElement('div') : e);
			}
		);
	},
	Y1 = function (e) {
		return e.sort(function () {
			return 0.5 - Math.random();
		});
	},
	j1 = function (e) {
		if (hn(e)) return e;
		var t = Zs(e) ? e : { each: e },
			n = wa(t.ease),
			s = t.from || 0,
			r = parseFloat(t.base) || 0,
			o = {},
			a = s > 0 && s < 1,
			l = isNaN(s) || a,
			c = t.axis,
			h = s,
			u = s;
		return (
			Un(s) ? (h = u = { center: 0.5, edges: 0.5, end: 1 }[s] || 0) : !a && l && ((h = s[0]), (u = s[1])),
			function (d, p, g) {
				var v = (g || t).length,
					m = o[v],
					f,
					y,
					_,
					x,
					E,
					w,
					C,
					P,
					S;
				if (!m) {
					if (((S = t.grid === 'auto' ? 0 : (t.grid || [1, is])[1]), !S)) {
						for (C = -is; C < (C = g[S++].getBoundingClientRect().left) && S < v; );
						S < v && S--;
					}
					for (
						m = o[v] = [],
							f = l ? Math.min(S, v) * h - 0.5 : s % S,
							y = S === is ? 0 : l ? (v * u) / S - 0.5 : (s / S) | 0,
							C = 0,
							P = is,
							w = 0;
						w < v;
						w++
					)
						(_ = (w % S) - f),
							(x = y - ((w / S) | 0)),
							(m[w] = E = c ? Math.abs(c === 'y' ? x : _) : R1(_ * _ + x * x)),
							E > C && (C = E),
							E < P && (P = E);
					s === 'random' && Y1(m),
						(m.max = C - P),
						(m.min = P),
						(m.v = v =
							(parseFloat(t.amount) ||
								parseFloat(t.each) * (S > v ? v - 1 : c ? (c === 'y' ? v / S : S) : Math.max(S, v / S)) ||
								0) * (s === 'edges' ? -1 : 1)),
						(m.b = v < 0 ? r - v : r),
						(m.u = Yn(t.amount || t.each) || 0),
						(n = n && v < 0 ? sA(n) : n);
				}
				return (v = (m[d] - m.min) / m.max || 0), In(m.b + (n ? n(v) : v) * m.v) + m.u;
			}
		);
	},
	Cv = function (e) {
		var t = Math.pow(10, ((e + '').split('.')[1] || '').length);
		return function (n) {
			var s = In(Math.round(parseFloat(n) / e) * e * t);
			return (s - (s % 1)) / t + (Sr(n) ? 0 : Yn(n));
		};
	},
	K1 = function (e, t) {
		var n = $n(e),
			s,
			r;
		return (
			!n && Zs(e) && ((s = n = e.radius || is), e.values ? ((e = ss(e.values)), (r = !Sr(e[0])) && (s *= s)) : (e = Cv(e.increment))),
			Io(
				t,
				n
					? hn(e)
						? function (o) {
								return (r = e(o)), Math.abs(r - o) <= s ? r : o;
						  }
						: function (o) {
								for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), c = is, h = 0, u = e.length, d, p; u--; )
									r ? ((d = e[u].x - a), (p = e[u].y - l), (d = d * d + p * p)) : (d = Math.abs(e[u] - a)),
										d < c && ((c = d), (h = u));
								return (h = !s || c <= s ? e[h] : o), r || h === o || Sr(o) ? h : h + Yn(o);
						  }
					: Cv(e)
			)
		);
	},
	$1 = function (e, t, n, s) {
		return Io($n(e) ? !t : n === !0 ? !!(n = 0) : !s, function () {
			return $n(e)
				? e[~~(Math.random() * e.length)]
				: (n = n || 1e-5) &&
						(s = n < 1 ? Math.pow(10, (n + '').length - 2) : 1) &&
						Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * s) / s;
		});
	},
	h5 = function () {
		for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
		return function (s) {
			return t.reduce(function (r, o) {
				return o(r);
			}, s);
		};
	},
	u5 = function (e, t) {
		return function (n) {
			return e(parseFloat(n)) + (t || Yn(n));
		};
	},
	d5 = function (e, t, n) {
		return J1(e, t, 0, 1, n);
	},
	Z1 = function (e, t, n) {
		return Io(n, function (s) {
			return e[~~t(s)];
		});
	},
	p5 = function i(e, t, n) {
		var s = t - e;
		return $n(e)
			? Z1(e, i(0, e.length), t)
			: Io(n, function (r) {
					return ((s + ((r - e) % s)) % s) + e;
			  });
	},
	f5 = function i(e, t, n) {
		var s = t - e,
			r = s * 2;
		return $n(e)
			? Z1(e, i(0, e.length - 1), t)
			: Io(n, function (o) {
					return (o = (r + ((o - e) % r)) % r || 0), e + (o > s ? r - o : o);
			  });
	},
	Gh = function (e) {
		for (var t = 0, n = '', s, r, o, a; ~(s = e.indexOf('random(', t)); )
			(o = e.indexOf(')', s)),
				(a = e.charAt(s + 7) === '['),
				(r = e.substr(s + 7, o - s - 7).match(a ? D1 : bv)),
				(n += e.substr(t, s - t) + $1(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5)),
				(t = o + 1);
		return n + e.substr(t, e.length - t);
	},
	J1 = function (e, t, n, s, r) {
		var o = t - e,
			a = s - n;
		return Io(r, function (l) {
			return n + (((l - e) / o) * a || 0);
		});
	},
	m5 = function i(e, t, n, s) {
		var r = isNaN(e + t)
			? 0
			: function (p) {
					return (1 - p) * e + p * t;
			  };
		if (!r) {
			var o = Un(e),
				a = {},
				l,
				c,
				h,
				u,
				d;
			if ((n === !0 && (s = 1) && (n = null), o)) (e = { p: e }), (t = { p: t });
			else if ($n(e) && !$n(t)) {
				for (h = [], u = e.length, d = u - 2, c = 1; c < u; c++) h.push(i(e[c - 1], e[c]));
				u--,
					(r = function (g) {
						g *= u;
						var v = Math.min(d, ~~g);
						return h[v](g - v);
					}),
					(n = t);
			} else s || (e = Ua($n(e) ? [] : {}, e));
			if (!h) {
				for (l in t) B0.call(a, e, l, 'get', t[l]);
				r = function (g) {
					return H0(g, a) || (o ? e.p : e);
				};
			}
		}
		return Io(n, r);
	},
	bw = function (e, t, n) {
		var s = e.labels,
			r = is,
			o,
			a,
			l;
		for (o in s) (a = s[o] - t), a < 0 == !!n && a && r > (a = Math.abs(a)) && ((l = o), (r = a));
		return l;
	},
	Fi = function (e, t, n) {
		var s = e.vars,
			r = s[t],
			o = Zt,
			a = e._ctx,
			l,
			c,
			h;
		if (r)
			return (
				(l = s[t + 'Params']),
				(c = s.callbackScope || e),
				n && mo.length && dp(),
				a && (Zt = a),
				(h = l ? r.apply(c, l) : r.call(c)),
				(Zt = o),
				h
			);
	},
	Yc = function (e) {
		return So(e), e.scrollTrigger && e.scrollTrigger.kill(!!Kn), e.progress() < 1 && Fi(e, 'onInterrupt'), e;
	},
	Il,
	Q1 = [],
	eA = function (e) {
		if (e)
			if (((e = (!e.name && e.default) || e), I0() || e.headless)) {
				var t = e.name,
					n = hn(e),
					s =
						t && !n && e.init
							? function () {
									this._props = [];
							  }
							: e,
					r = { init: Hh, render: H0, add: B0, kill: L5, modifier: P5, rawVars: 0 },
					o = { targetTest: 0, get: 0, getSetter: V0, aliases: {}, register: 0 };
				if ((sc(), e !== s)) {
					if (Pi[t]) return;
					os(s, os(pp(e, r), o)),
						Ua(s.prototype, Ua(r, pp(e, o))),
						(Pi[(s.prop = t)] = s),
						e.targetTest && (Xd.push(s), (U0[t] = 1)),
						(t = (t === 'css' ? 'CSS' : t.charAt(0).toUpperCase() + t.substr(1)) + 'Plugin');
				}
				N1(t, s), e.register && e.register(Ei, s, yi);
			} else Q1.push(e);
	},
	kt = 255,
	jc = {
		aqua: [0, kt, kt],
		lime: [0, kt, 0],
		silver: [192, 192, 192],
		black: [0, 0, 0],
		maroon: [128, 0, 0],
		teal: [0, 128, 128],
		blue: [0, 0, kt],
		navy: [0, 0, 128],
		white: [kt, kt, kt],
		olive: [128, 128, 0],
		yellow: [kt, kt, 0],
		orange: [kt, 165, 0],
		gray: [128, 128, 128],
		purple: [128, 0, 128],
		green: [0, 128, 0],
		red: [kt, 0, 0],
		pink: [kt, 192, 203],
		cyan: [0, kt, kt],
		transparent: [kt, kt, kt, 0],
	},
	Km = function (e, t, n) {
		return (
			(e += e < 0 ? 1 : e > 1 ? -1 : 0),
			((e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * kt + 0.5) | 0
		);
	},
	tA = function (e, t, n) {
		var s = e ? (Sr(e) ? [e >> 16, (e >> 8) & kt, e & kt] : 0) : jc.black,
			r,
			o,
			a,
			l,
			c,
			h,
			u,
			d,
			p,
			g;
		if (!s) {
			if ((e.substr(-1) === ',' && (e = e.substr(0, e.length - 1)), jc[e])) s = jc[e];
			else if (e.charAt(0) === '#') {
				if (
					(e.length < 6 &&
						((r = e.charAt(1)),
						(o = e.charAt(2)),
						(a = e.charAt(3)),
						(e = '#' + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : ''))),
					e.length === 9)
				)
					return (s = parseInt(e.substr(1, 6), 16)), [s >> 16, (s >> 8) & kt, s & kt, parseInt(e.substr(7), 16) / 255];
				(e = parseInt(e.substr(1), 16)), (s = [e >> 16, (e >> 8) & kt, e & kt]);
			} else if (e.substr(0, 3) === 'hsl') {
				if (((s = g = e.match(bv)), !t))
					(l = (+s[0] % 360) / 360),
						(c = +s[1] / 100),
						(h = +s[2] / 100),
						(o = h <= 0.5 ? h * (c + 1) : h + c - h * c),
						(r = h * 2 - o),
						s.length > 3 && (s[3] *= 1),
						(s[0] = Km(l + 1 / 3, r, o)),
						(s[1] = Km(l, r, o)),
						(s[2] = Km(l - 1 / 3, r, o));
				else if (~e.indexOf('=')) return (s = e.match(L1)), n && s.length < 4 && (s[3] = 1), s;
			} else s = e.match(bv) || jc.transparent;
			s = s.map(Number);
		}
		return (
			t &&
				!g &&
				((r = s[0] / kt),
				(o = s[1] / kt),
				(a = s[2] / kt),
				(u = Math.max(r, o, a)),
				(d = Math.min(r, o, a)),
				(h = (u + d) / 2),
				u === d
					? (l = c = 0)
					: ((p = u - d),
					  (c = h > 0.5 ? p / (2 - u - d) : p / (u + d)),
					  (l = u === r ? (o - a) / p + (o < a ? 6 : 0) : u === o ? (a - r) / p + 2 : (r - o) / p + 4),
					  (l *= 60)),
				(s[0] = ~~(l + 0.5)),
				(s[1] = ~~(c * 100 + 0.5)),
				(s[2] = ~~(h * 100 + 0.5))),
			n && s.length < 4 && (s[3] = 1),
			s
		);
	},
	nA = function (e) {
		var t = [],
			n = [],
			s = -1;
		return (
			e.split(go).forEach(function (r) {
				var o = r.match(Ll) || [];
				t.push.apply(t, o), n.push((s += o.length + 1));
			}),
			(t.c = n),
			t
		);
	},
	ww = function (e, t, n) {
		var s = '',
			r = (e + s).match(go),
			o = t ? 'hsla(' : 'rgba(',
			a = 0,
			l,
			c,
			h,
			u;
		if (!r) return e;
		if (
			((r = r.map(function (d) {
				return (d = tA(d, t, 1)) && o + (t ? d[0] + ',' + d[1] + '%,' + d[2] + '%,' + d[3] : d.join(',')) + ')';
			})),
			n && ((h = nA(e)), (l = n.c), l.join(s) !== h.c.join(s)))
		)
			for (c = e.replace(go, '1').split(Ll), u = c.length - 1; a < u; a++)
				s += c[a] + (~l.indexOf(a) ? r.shift() || o + '0,0,0,0)' : (h.length ? h : r.length ? r : n).shift());
		if (!c) for (c = e.split(go), u = c.length - 1; a < u; a++) s += c[a] + r[a];
		return s + c[u];
	},
	go = (function () {
		var i = '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b',
			e;
		for (e in jc) i += '|' + e + '\\b';
		return new RegExp(i + ')', 'gi');
	})(),
	g5 = /hsl[a]?\(/,
	iA = function (e) {
		var t = e.join(' '),
			n;
		if (((go.lastIndex = 0), go.test(t))) return (n = g5.test(t)), (e[1] = ww(e[1], n)), (e[0] = ww(e[0], n, nA(e[1]))), !0;
	},
	Wh,
	Ii = (function () {
		var i = Date.now,
			e = 500,
			t = 33,
			n = i(),
			s = n,
			r = 1e3 / 240,
			o = r,
			a = [],
			l,
			c,
			h,
			u,
			d,
			p,
			g = function v(m) {
				var f = i() - s,
					y = m === !0,
					_,
					x,
					E,
					w;
				if (
					((f > e || f < 0) && (n += f - t),
					(s += f),
					(E = s - n),
					(_ = E - o),
					(_ > 0 || y) &&
						((w = ++u.frame), (d = E - u.time * 1e3), (u.time = E = E / 1e3), (o += _ + (_ >= r ? 4 : r - _)), (x = 1)),
					y || (l = c(v)),
					x)
				)
					for (p = 0; p < a.length; p++) a[p](E, d, w, m);
			};
		return (
			(u = {
				time: 0,
				frame: 0,
				tick: function () {
					g(!0);
				},
				deltaRatio: function (m) {
					return d / (1e3 / (m || 60));
				},
				wake: function () {
					O1 &&
						(!wv &&
							I0() &&
							((Ns = wv = window),
							(D0 = Ns.document || {}),
							(Vi.gsap = Ei),
							(Ns.gsapVersions || (Ns.gsapVersions = [])).push(Ei.version),
							U1(up || Ns.GreenSockGlobals || (!Ns.gsap && Ns) || {}),
							Q1.forEach(eA)),
						(h = typeof requestAnimationFrame < 'u' && requestAnimationFrame),
						l && u.sleep(),
						(c =
							h ||
							function (m) {
								return setTimeout(m, (o - u.time * 1e3 + 1) | 0);
							}),
						(Wh = 1),
						g(2));
				},
				sleep: function () {
					(h ? cancelAnimationFrame : clearTimeout)(l), (Wh = 0), (c = Hh);
				},
				lagSmoothing: function (m, f) {
					(e = m || 1 / 0), (t = Math.min(f || 33, e));
				},
				fps: function (m) {
					(r = 1e3 / (m || 240)), (o = u.time * 1e3 + r);
				},
				add: function (m, f, y) {
					var _ = f
						? function (x, E, w, C) {
								m(x, E, w, C), u.remove(_);
						  }
						: m;
					return u.remove(m), a[y ? 'unshift' : 'push'](_), sc(), _;
				},
				remove: function (m, f) {
					~(f = a.indexOf(m)) && a.splice(f, 1) && p >= f && p--;
				},
				_listeners: a,
			}),
			u
		);
	})(),
	sc = function () {
		return !Wh && Ii.wake();
	},
	mt = {},
	v5 = /^[\d.\-M][\d.\-,\s]/,
	_5 = /["']/g,
	y5 = function (e) {
		for (var t = {}, n = e.substr(1, e.length - 3).split(':'), s = n[0], r = 1, o = n.length, a, l, c; r < o; r++)
			(l = n[r]),
				(a = r !== o - 1 ? l.lastIndexOf(',') : l.length),
				(c = l.substr(0, a)),
				(t[s] = isNaN(c) ? c.replace(_5, '').trim() : +c),
				(s = l.substr(a + 1).trim());
		return t;
	},
	x5 = function (e) {
		var t = e.indexOf('(') + 1,
			n = e.indexOf(')'),
			s = e.indexOf('(', t);
		return e.substring(t, ~s && s < n ? e.indexOf(')', n + 1) : n);
	},
	b5 = function (e) {
		var t = (e + '').split('('),
			n = mt[t[0]];
		return n && t.length > 1 && n.config
			? n.config.apply(null, ~e.indexOf('{') ? [y5(t[1])] : x5(e).split(',').map(z1))
			: mt._CE && v5.test(e)
			? mt._CE('', e)
			: n;
	},
	sA = function (e) {
		return function (t) {
			return 1 - e(1 - t);
		};
	},
	rA = function i(e, t) {
		for (var n = e._first, s; n; )
			n instanceof oi
				? i(n, t)
				: n.vars.yoyoEase &&
				  (!n._yoyo || !n._repeat) &&
				  n._yoyo !== t &&
				  (n.timeline ? i(n.timeline, t) : ((s = n._ease), (n._ease = n._yEase), (n._yEase = s), (n._yoyo = t))),
				(n = n._next);
	},
	wa = function (e, t) {
		return (e && (hn(e) ? e : mt[e] || b5(e))) || t;
	},
	Ya = function (e, t, n, s) {
		n === void 0 &&
			(n = function (l) {
				return 1 - t(1 - l);
			}),
			s === void 0 &&
				(s = function (l) {
					return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
				});
		var r = { easeIn: t, easeOut: n, easeInOut: s },
			o;
		return (
			_i(e, function (a) {
				(mt[a] = Vi[a] = r), (mt[(o = a.toLowerCase())] = n);
				for (var l in r) mt[o + (l === 'easeIn' ? '.in' : l === 'easeOut' ? '.out' : '.inOut')] = mt[a + '.' + l] = r[l];
			}),
			r
		);
	},
	oA = function (e) {
		return function (t) {
			return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
		};
	},
	$m = function i(e, t, n) {
		var s = t >= 1 ? t : 1,
			r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
			o = (r / xv) * (Math.asin(1 / s) || 0),
			a = function (h) {
				return h === 1 ? 1 : s * Math.pow(2, -10 * h) * K4((h - o) * r) + 1;
			},
			l =
				e === 'out'
					? a
					: e === 'in'
					? function (c) {
							return 1 - a(1 - c);
					  }
					: oA(a);
		return (
			(r = xv / r),
			(l.config = function (c, h) {
				return i(e, c, h);
			}),
			l
		);
	},
	Zm = function i(e, t) {
		t === void 0 && (t = 1.70158);
		var n = function (o) {
				return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
			},
			s =
				e === 'out'
					? n
					: e === 'in'
					? function (r) {
							return 1 - n(1 - r);
					  }
					: oA(n);
		return (
			(s.config = function (r) {
				return i(e, r);
			}),
			s
		);
	};
_i('Linear,Quad,Cubic,Quart,Quint,Strong', function (i, e) {
	var t = e < 5 ? e + 1 : e;
	Ya(
		i + ',Power' + (t - 1),
		e
			? function (n) {
					return Math.pow(n, t);
			  }
			: function (n) {
					return n;
			  },
		function (n) {
			return 1 - Math.pow(1 - n, t);
		},
		function (n) {
			return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
		}
	);
});
mt.Linear.easeNone = mt.none = mt.Linear.easeIn;
Ya('Elastic', $m('in'), $m('out'), $m());
(function (i, e) {
	var t = 1 / e,
		n = 2 * t,
		s = 2.5 * t,
		r = function (a) {
			return a < t
				? i * a * a
				: a < n
				? i * Math.pow(a - 1.5 / e, 2) + 0.75
				: a < s
				? i * (a -= 2.25 / e) * a + 0.9375
				: i * Math.pow(a - 2.625 / e, 2) + 0.984375;
		};
	Ya(
		'Bounce',
		function (o) {
			return 1 - r(1 - o);
		},
		r
	);
})(7.5625, 2.75);
Ya('Expo', function (i) {
	return i ? Math.pow(2, 10 * (i - 1)) : 0;
});
Ya('Circ', function (i) {
	return -(R1(1 - i * i) - 1);
});
Ya('Sine', function (i) {
	return i === 1 ? 1 : -j4(i * q4) + 1;
});
Ya('Back', Zm('in'), Zm('out'), Zm());
mt.SteppedEase =
	mt.steps =
	Vi.SteppedEase =
		{
			config: function (e, t) {
				e === void 0 && (e = 1);
				var n = 1 / e,
					s = e + (t ? 0 : 1),
					r = t ? 1 : 0,
					o = 1 - Xt;
				return function (a) {
					return (((s * vu(0, o, a)) | 0) + r) * n;
				};
			},
		};
tc.ease = mt['quad.out'];
_i('onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt', function (i) {
	return (N0 += i + ',' + i + 'Params,');
});
var aA = function (e, t) {
		(this.id = Y4++),
			(e._gsap = this),
			(this.target = e),
			(this.harness = t),
			(this.get = t ? t.get : B1),
			(this.set = t ? t.getSetter : V0);
	},
	Xh = (function () {
		function i(t) {
			(this.vars = t),
				(this._delay = +t.delay || 0),
				(this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
					((this._rDelay = t.repeatDelay || 0), (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
				(this._ts = 1),
				ic(this, +t.duration, 1, 1),
				(this.data = t.data),
				Zt && ((this._ctx = Zt), Zt.data.push(this)),
				Wh || Ii.wake();
		}
		var e = i.prototype;
		return (
			(e.delay = function (n) {
				return n || n === 0
					? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay),
					  (this._delay = n),
					  this)
					: this._delay;
			}),
			(e.duration = function (n) {
				return arguments.length
					? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n)
					: this.totalDuration() && this._dur;
			}),
			(e.totalDuration = function (n) {
				return arguments.length
					? ((this._dirty = 0), ic(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1)))
					: this._tDur;
			}),
			(e.totalTime = function (n, s) {
				if ((sc(), !arguments.length)) return this._tTime;
				var r = this._dp;
				if (r && r.smoothChildTiming && this._ts) {
					for (Mf(this, n), !r._dp || r.parent || G1(r, this); r && r.parent; )
						r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) &&
							r.totalTime(r._tTime, !0),
							(r = r.parent);
					!this.parent &&
						this._dp.autoRemoveChildren &&
						((this._ts > 0 && n < this._tDur) || (this._ts < 0 && n > 0) || (!this._tDur && !n)) &&
						ks(this._dp, this, this._start - this._delay);
				}
				return (
					(this._tTime !== n ||
						(!this._dur && !s) ||
						(this._initted && Math.abs(this._zTime) === Xt) ||
						(!n && !this._initted && (this.add || this._ptLookup))) &&
						(this._ts || (this._pTime = n), k1(this, n, s)),
					this
				);
			}),
			(e.time = function (n, s) {
				return arguments.length
					? this.totalTime(Math.min(this.totalDuration(), n + yw(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), s)
					: this._time;
			}),
			(e.totalProgress = function (n, s) {
				return arguments.length
					? this.totalTime(this.totalDuration() * n, s)
					: this.totalDuration()
					? Math.min(1, this._tTime / this._tDur)
					: this.rawTime() > 0
					? 1
					: 0;
			}),
			(e.progress = function (n, s) {
				return arguments.length
					? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + yw(this), s)
					: this.duration()
					? Math.min(1, this._time / this._dur)
					: this.rawTime() > 0
					? 1
					: 0;
			}),
			(e.iteration = function (n, s) {
				var r = this.duration() + this._rDelay;
				return arguments.length ? this.totalTime(this._time + (n - 1) * r, s) : this._repeat ? nc(this._tTime, r) + 1 : 1;
			}),
			(e.timeScale = function (n, s) {
				if (!arguments.length) return this._rts === -Xt ? 0 : this._rts;
				if (this._rts === n) return this;
				var r = this.parent && this._ts ? fp(this.parent._time, this) : this._tTime;
				return (
					(this._rts = +n || 0),
					(this._ts = this._ps || n === -Xt ? 0 : this._rts),
					this.totalTime(vu(-Math.abs(this._delay), this._tDur, r), s !== !1),
					Sf(this),
					n5(this)
				);
			}),
			(e.paused = function (n) {
				return arguments.length
					? (this._ps !== n &&
							((this._ps = n),
							n
								? ((this._pTime = this._tTime || Math.max(-this._delay, this.rawTime())), (this._ts = this._act = 0))
								: (sc(),
								  (this._ts = this._rts),
								  this.totalTime(
										this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime,
										this.progress() === 1 && Math.abs(this._zTime) !== Xt && (this._tTime -= Xt)
								  ))),
					  this)
					: this._ps;
			}),
			(e.startTime = function (n) {
				if (arguments.length) {
					this._start = n;
					var s = this.parent || this._dp;
					return s && (s._sort || !this.parent) && ks(s, this, n - this._delay), this;
				}
				return this._start;
			}),
			(e.endTime = function (n) {
				return this._start + (vi(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
			}),
			(e.rawTime = function (n) {
				var s = this.parent || this._dp;
				return s
					? n && (!this._ts || (this._repeat && this._time && this.totalProgress() < 1))
						? this._tTime % (this._dur + this._rDelay)
						: this._ts
						? fp(s.rawTime(n), this)
						: this._tTime
					: this._tTime;
			}),
			(e.revert = function (n) {
				n === void 0 && (n = J4);
				var s = Kn;
				return (
					(Kn = n),
					(this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)),
					this.data !== 'nested' && n.kill !== !1 && this.kill(),
					(Kn = s),
					this
				);
			}),
			(e.globalTime = function (n) {
				for (var s = this, r = arguments.length ? n : s.rawTime(); s; ) (r = s._start + r / (Math.abs(s._ts) || 1)), (s = s._dp);
				return !this.parent && this._sat ? this._sat.globalTime(n) : r;
			}),
			(e.repeat = function (n) {
				return arguments.length ? ((this._repeat = n === 1 / 0 ? -2 : n), xw(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
			}),
			(e.repeatDelay = function (n) {
				if (arguments.length) {
					var s = this._time;
					return (this._rDelay = n), xw(this), s ? this.time(s) : this;
				}
				return this._rDelay;
			}),
			(e.yoyo = function (n) {
				return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
			}),
			(e.seek = function (n, s) {
				return this.totalTime($i(this, n), vi(s));
			}),
			(e.restart = function (n, s) {
				return this.play().totalTime(n ? -this._delay : 0, vi(s));
			}),
			(e.play = function (n, s) {
				return n != null && this.seek(n, s), this.reversed(!1).paused(!1);
			}),
			(e.reverse = function (n, s) {
				return n != null && this.seek(n || this.totalDuration(), s), this.reversed(!0).paused(!1);
			}),
			(e.pause = function (n, s) {
				return n != null && this.seek(n, s), this.paused(!0);
			}),
			(e.resume = function () {
				return this.paused(!1);
			}),
			(e.reversed = function (n) {
				return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Xt : 0)), this) : this._rts < 0;
			}),
			(e.invalidate = function () {
				return (this._initted = this._act = 0), (this._zTime = -Xt), this;
			}),
			(e.isActive = function () {
				var n = this.parent || this._dp,
					s = this._start,
					r;
				return !!(!n || (this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= s && r < this.endTime(!0) - Xt));
			}),
			(e.eventCallback = function (n, s, r) {
				var o = this.vars;
				return arguments.length > 1
					? (s ? ((o[n] = s), r && (o[n + 'Params'] = r), n === 'onUpdate' && (this._onUpdate = s)) : delete o[n], this)
					: o[n];
			}),
			(e.then = function (n) {
				var s = this;
				return new Promise(function (r) {
					var o = hn(n) ? n : V1,
						a = function () {
							var c = s.then;
							(s.then = null), hn(o) && (o = o(s)) && (o.then || o === s) && (s.then = c), r(o), (s.then = c);
						};
					(s._initted && s.totalProgress() === 1 && s._ts >= 0) || (!s._tTime && s._ts < 0) ? a() : (s._prom = a);
				});
			}),
			(e.kill = function () {
				Yc(this);
			}),
			i
		);
	})();
os(Xh.prototype, {
	_time: 0,
	_start: 0,
	_end: 0,
	_tTime: 0,
	_tDur: 0,
	_dirty: 0,
	_repeat: 0,
	_yoyo: !1,
	parent: null,
	_initted: !1,
	_rDelay: 0,
	_ts: 1,
	_dp: 0,
	ratio: 0,
	_zTime: -Xt,
	_prom: 0,
	_ps: !1,
	_rts: 1,
});
var oi = (function (i) {
	C1(e, i);
	function e(n, s) {
		var r;
		return (
			n === void 0 && (n = {}),
			(r = i.call(this, n) || this),
			(r.labels = {}),
			(r.smoothChildTiming = !!n.smoothChildTiming),
			(r.autoRemoveChildren = !!n.autoRemoveChildren),
			(r._sort = vi(n.sortChildren)),
			tn && ks(n.parent || tn, cr(r), s),
			n.reversed && r.reverse(),
			n.paused && r.paused(!0),
			n.scrollTrigger && W1(cr(r), n.scrollTrigger),
			r
		);
	}
	var t = e.prototype;
	return (
		(t.to = function (s, r, o) {
			return lh(0, arguments, this), this;
		}),
		(t.from = function (s, r, o) {
			return lh(1, arguments, this), this;
		}),
		(t.fromTo = function (s, r, o, a) {
			return lh(2, arguments, this), this;
		}),
		(t.set = function (s, r, o) {
			return (
				(r.duration = 0),
				(r.parent = this),
				ah(r).repeatDelay || (r.repeat = 0),
				(r.immediateRender = !!r.immediateRender),
				new Sn(s, r, $i(this, o), 1),
				this
			);
		}),
		(t.call = function (s, r, o) {
			return ks(this, Sn.delayedCall(0, s, r), o);
		}),
		(t.staggerTo = function (s, r, o, a, l, c, h) {
			return (
				(o.duration = r),
				(o.stagger = o.stagger || a),
				(o.onComplete = c),
				(o.onCompleteParams = h),
				(o.parent = this),
				new Sn(s, o, $i(this, l)),
				this
			);
		}),
		(t.staggerFrom = function (s, r, o, a, l, c, h) {
			return (o.runBackwards = 1), (ah(o).immediateRender = vi(o.immediateRender)), this.staggerTo(s, r, o, a, l, c, h);
		}),
		(t.staggerFromTo = function (s, r, o, a, l, c, h, u) {
			return (a.startAt = o), (ah(a).immediateRender = vi(a.immediateRender)), this.staggerTo(s, r, a, l, c, h, u);
		}),
		(t.render = function (s, r, o) {
			var a = this._time,
				l = this._dirty ? this.totalDuration() : this._tDur,
				c = this._dur,
				h = s <= 0 ? 0 : In(s),
				u = this._zTime < 0 != s < 0 && (this._initted || !c),
				d,
				p,
				g,
				v,
				m,
				f,
				y,
				_,
				x,
				E,
				w,
				C;
			if ((this !== tn && h > l && s >= 0 && (h = l), h !== this._tTime || o || u)) {
				if (
					(a !== this._time && c && ((h += this._time - a), (s += this._time - a)),
					(d = h),
					(x = this._start),
					(_ = this._ts),
					(f = !_),
					u && (c || (a = this._zTime), (s || !r) && (this._zTime = s)),
					this._repeat)
				) {
					if (((w = this._yoyo), (m = c + this._rDelay), this._repeat < -1 && s < 0)) return this.totalTime(m * 100 + s, r, o);
					if (
						((d = In(h % m)),
						h === l ? ((v = this._repeat), (d = c)) : ((v = ~~(h / m)), v && v === h / m && ((d = c), v--), d > c && (d = c)),
						(E = nc(this._tTime, m)),
						!a && this._tTime && E !== v && this._tTime - E * m - this._dur <= 0 && (E = v),
						w && v & 1 && ((d = c - d), (C = 1)),
						v !== E && !this._lock)
					) {
						var P = w && E & 1,
							S = P === (w && v & 1);
						if (
							(v < E && (P = !P),
							(a = P ? 0 : h % c ? c : h),
							(this._lock = 1),
							(this.render(a || (C ? 0 : In(v * m)), r, !c)._lock = 0),
							(this._tTime = h),
							!r && this.parent && Fi(this, 'onRepeat'),
							this.vars.repeatRefresh && !C && (this.invalidate()._lock = 1),
							(a && a !== this._time) || f !== !this._ts || (this.vars.onRepeat && !this.parent && !this._act))
						)
							return this;
						if (
							((c = this._dur),
							(l = this._tDur),
							S &&
								((this._lock = 2),
								(a = P ? c : -1e-4),
								this.render(a, !0),
								this.vars.repeatRefresh && !C && this.invalidate()),
							(this._lock = 0),
							!this._ts && !f)
						)
							return this;
						rA(this, C);
					}
				}
				if (
					(this._hasPause && !this._forcing && this._lock < 2 && ((y = o5(this, In(a), In(d))), y && (h -= d - (d = y._start))),
					(this._tTime = h),
					(this._time = d),
					(this._act = !_),
					this._initted || ((this._onUpdate = this.vars.onUpdate), (this._initted = 1), (this._zTime = s), (a = 0)),
					!a && d && !r && !v && (Fi(this, 'onStart'), this._tTime !== h))
				)
					return this;
				if (d >= a && s >= 0)
					for (p = this._first; p; ) {
						if (((g = p._next), (p._act || d >= p._start) && p._ts && y !== p)) {
							if (p.parent !== this) return this.render(s, r, o);
							if (
								(p.render(
									p._ts > 0 ? (d - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (d - p._start) * p._ts,
									r,
									o
								),
								d !== this._time || (!this._ts && !f))
							) {
								(y = 0), g && (h += this._zTime = -Xt);
								break;
							}
						}
						p = g;
					}
				else {
					p = this._last;
					for (var M = s < 0 ? s : d; p; ) {
						if (((g = p._prev), (p._act || M <= p._end) && p._ts && y !== p)) {
							if (p.parent !== this) return this.render(s, r, o);
							if (
								(p.render(
									p._ts > 0 ? (M - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (M - p._start) * p._ts,
									r,
									o || (Kn && (p._initted || p._startAt))
								),
								d !== this._time || (!this._ts && !f))
							) {
								(y = 0), g && (h += this._zTime = M ? -Xt : Xt);
								break;
							}
						}
						p = g;
					}
				}
				if (y && !r && (this.pause(), (y.render(d >= a ? 0 : -Xt)._zTime = d >= a ? 1 : -1), this._ts))
					return (this._start = x), Sf(this), this.render(s, r, o);
				this._onUpdate && !r && Fi(this, 'onUpdate', !0),
					((h === l && this._tTime >= this.totalDuration()) || (!h && a)) &&
						(x === this._start || Math.abs(_) !== Math.abs(this._ts)) &&
						(this._lock ||
							((s || !c) && ((h === l && this._ts > 0) || (!h && this._ts < 0)) && So(this, 1),
							!r &&
								!(s < 0 && !a) &&
								(h || a || !l) &&
								(Fi(this, h === l && s >= 0 ? 'onComplete' : 'onReverseComplete', !0),
								this._prom && !(h < l && this.timeScale() > 0) && this._prom())));
			}
			return this;
		}),
		(t.add = function (s, r) {
			var o = this;
			if ((Sr(r) || (r = $i(this, r, s)), !(s instanceof Xh))) {
				if ($n(s))
					return (
						s.forEach(function (a) {
							return o.add(a, r);
						}),
						this
					);
				if (Un(s)) return this.addLabel(s, r);
				if (hn(s)) s = Sn.delayedCall(0, s);
				else return this;
			}
			return this !== s ? ks(this, s, r) : this;
		}),
		(t.getChildren = function (s, r, o, a) {
			s === void 0 && (s = !0), r === void 0 && (r = !0), o === void 0 && (o = !0), a === void 0 && (a = -is);
			for (var l = [], c = this._first; c; )
				c._start >= a && (c instanceof Sn ? r && l.push(c) : (o && l.push(c), s && l.push.apply(l, c.getChildren(!0, r, o)))),
					(c = c._next);
			return l;
		}),
		(t.getById = function (s) {
			for (var r = this.getChildren(1, 1, 1), o = r.length; o--; ) if (r[o].vars.id === s) return r[o];
		}),
		(t.remove = function (s) {
			return Un(s)
				? this.removeLabel(s)
				: hn(s)
				? this.killTweensOf(s)
				: (wf(this, s), s === this._recent && (this._recent = this._last), ba(this));
		}),
		(t.totalTime = function (s, r) {
			return arguments.length
				? ((this._forcing = 1),
				  !this._dp &&
						this._ts &&
						(this._start = In(Ii.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))),
				  i.prototype.totalTime.call(this, s, r),
				  (this._forcing = 0),
				  this)
				: this._tTime;
		}),
		(t.addLabel = function (s, r) {
			return (this.labels[s] = $i(this, r)), this;
		}),
		(t.removeLabel = function (s) {
			return delete this.labels[s], this;
		}),
		(t.addPause = function (s, r, o) {
			var a = Sn.delayedCall(0, r || Hh, o);
			return (a.data = 'isPause'), (this._hasPause = 1), ks(this, a, $i(this, s));
		}),
		(t.removePause = function (s) {
			var r = this._first;
			for (s = $i(this, s); r; ) r._start === s && r.data === 'isPause' && So(r), (r = r._next);
		}),
		(t.killTweensOf = function (s, r, o) {
			for (var a = this.getTweensOf(s, o), l = a.length; l--; ) no !== a[l] && a[l].kill(s, r);
			return this;
		}),
		(t.getTweensOf = function (s, r) {
			for (var o = [], a = ss(s), l = this._first, c = Sr(r), h; l; )
				l instanceof Sn
					? Q4(l._targets, a) &&
					  (c
							? (!no || (l._initted && l._ts)) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r
							: !r || l.isActive()) &&
					  o.push(l)
					: (h = l.getTweensOf(a, r)).length && o.push.apply(o, h),
					(l = l._next);
			return o;
		}),
		(t.tweenTo = function (s, r) {
			r = r || {};
			var o = this,
				a = $i(o, s),
				l = r,
				c = l.startAt,
				h = l.onStart,
				u = l.onStartParams,
				d = l.immediateRender,
				p,
				g = Sn.to(
					o,
					os(
						{
							ease: r.ease || 'none',
							lazy: !1,
							immediateRender: !1,
							time: a,
							overwrite: 'auto',
							duration: r.duration || Math.abs((a - (c && 'time' in c ? c.time : o._time)) / o.timeScale()) || Xt,
							onStart: function () {
								if ((o.pause(), !p)) {
									var m = r.duration || Math.abs((a - (c && 'time' in c ? c.time : o._time)) / o.timeScale());
									g._dur !== m && ic(g, m, 0, 1).render(g._time, !0, !0), (p = 1);
								}
								h && h.apply(g, u || []);
							},
						},
						r
					)
				);
			return d ? g.render(0) : g;
		}),
		(t.tweenFromTo = function (s, r, o) {
			return this.tweenTo(r, os({ startAt: { time: $i(this, s) } }, o));
		}),
		(t.recent = function () {
			return this._recent;
		}),
		(t.nextLabel = function (s) {
			return s === void 0 && (s = this._time), bw(this, $i(this, s));
		}),
		(t.previousLabel = function (s) {
			return s === void 0 && (s = this._time), bw(this, $i(this, s), 1);
		}),
		(t.currentLabel = function (s) {
			return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + Xt);
		}),
		(t.shiftChildren = function (s, r, o) {
			o === void 0 && (o = 0);
			for (var a = this._first, l = this.labels, c; a; ) a._start >= o && ((a._start += s), (a._end += s)), (a = a._next);
			if (r) for (c in l) l[c] >= o && (l[c] += s);
			return ba(this);
		}),
		(t.invalidate = function (s) {
			var r = this._first;
			for (this._lock = 0; r; ) r.invalidate(s), (r = r._next);
			return i.prototype.invalidate.call(this, s);
		}),
		(t.clear = function (s) {
			s === void 0 && (s = !0);
			for (var r = this._first, o; r; ) (o = r._next), this.remove(r), (r = o);
			return this._dp && (this._time = this._tTime = this._pTime = 0), s && (this.labels = {}), ba(this);
		}),
		(t.totalDuration = function (s) {
			var r = 0,
				o = this,
				a = o._last,
				l = is,
				c,
				h,
				u;
			if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -s : s));
			if (o._dirty) {
				for (u = o.parent; a; )
					(c = a._prev),
						a._dirty && a.totalDuration(),
						(h = a._start),
						h > l && o._sort && a._ts && !o._lock ? ((o._lock = 1), (ks(o, a, h - a._delay, 1)._lock = 0)) : (l = h),
						h < 0 &&
							a._ts &&
							((r -= h),
							((!u && !o._dp) || (u && u.smoothChildTiming)) && ((o._start += h / o._ts), (o._time -= h), (o._tTime -= h)),
							o.shiftChildren(-h, !1, -1 / 0),
							(l = 0)),
						a._end > r && a._ts && (r = a._end),
						(a = c);
				ic(o, o === tn && o._time > r ? o._time : r, 1, 1), (o._dirty = 0);
			}
			return o._tDur;
		}),
		(e.updateRoot = function (s) {
			if ((tn._ts && (k1(tn, fp(s, tn)), (F1 = Ii.frame)), Ii.frame >= vw)) {
				vw += ki.autoSleep || 120;
				var r = tn._first;
				if ((!r || !r._ts) && ki.autoSleep && Ii._listeners.length < 2) {
					for (; r && !r._ts; ) r = r._next;
					r || Ii.sleep();
				}
			}
		}),
		e
	);
})(Xh);
os(oi.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var w5 = function (e, t, n, s, r, o, a) {
		var l = new yi(this._pt, e, t, 0, 1, pA, null, r),
			c = 0,
			h = 0,
			u,
			d,
			p,
			g,
			v,
			m,
			f,
			y;
		for (
			l.b = n,
				l.e = s,
				n += '',
				s += '',
				(f = ~s.indexOf('random(')) && (s = Gh(s)),
				o && ((y = [n, s]), o(y, e, t), (n = y[0]), (s = y[1])),
				d = n.match(Ym) || [];
			(u = Ym.exec(s));

		)
			(g = u[0]),
				(v = s.substring(c, u.index)),
				p ? (p = (p + 1) % 5) : v.substr(-5) === 'rgba(' && (p = 1),
				g !== d[h++] &&
					((m = parseFloat(d[h - 1]) || 0),
					(l._pt = {
						_next: l._pt,
						p: v || h === 1 ? v : ',',
						s: m,
						c: g.charAt(1) === '=' ? Vl(m, g) - m : parseFloat(g) - m,
						m: p && p < 4 ? Math.round : 0,
					}),
					(c = Ym.lastIndex));
		return (l.c = c < s.length ? s.substring(c, s.length) : ''), (l.fp = a), (I1.test(s) || f) && (l.e = 0), (this._pt = l), l;
	},
	B0 = function (e, t, n, s, r, o, a, l, c, h) {
		hn(s) && (s = s(r || 0, e, o));
		var u = e[t],
			d =
				n !== 'get'
					? n
					: hn(u)
					? c
						? e[t.indexOf('set') || !hn(e['get' + t.substr(3)]) ? t : 'get' + t.substr(3)](c)
						: e[t]()
					: u,
			p = hn(u) ? (c ? A5 : uA) : z0,
			g;
		if (
			(Un(s) &&
				(~s.indexOf('random(') && (s = Gh(s)), s.charAt(1) === '=' && ((g = Vl(d, s) + (Yn(d) || 0)), (g || g === 0) && (s = g))),
			!h || d !== s || Rv)
		)
			return !isNaN(d * s) && s !== ''
				? ((g = new yi(this._pt, e, t, +d || 0, s - (d || 0), typeof u == 'boolean' ? R5 : dA, 0, p)),
				  c && (g.fp = c),
				  a && g.modifier(a, this, e),
				  (this._pt = g))
				: (!u && !(t in e) && O0(t, s), w5.call(this, e, t, d, s, p, l || ki.stringFilter, c));
	},
	S5 = function (e, t, n, s, r) {
		if ((hn(e) && (e = ch(e, r, t, n, s)), !Zs(e) || (e.style && e.nodeType) || $n(e) || P1(e))) return Un(e) ? ch(e, r, t, n, s) : e;
		var o = {},
			a;
		for (a in e) o[a] = ch(e[a], r, t, n, s);
		return o;
	},
	lA = function (e, t, n, s, r, o) {
		var a, l, c, h;
		if (
			Pi[e] &&
			(a = new Pi[e]()).init(r, a.rawVars ? t[e] : S5(t[e], s, r, o, n), n, s, o) !== !1 &&
			((n._pt = l = new yi(n._pt, r, e, 0, 1, a.render, a, 0, a.priority)), n !== Il)
		)
			for (c = n._ptLookup[n._targets.indexOf(r)], h = a._props.length; h--; ) c[a._props[h]] = l;
		return a;
	},
	no,
	Rv,
	k0 = function i(e, t, n) {
		var s = e.vars,
			r = s.ease,
			o = s.startAt,
			a = s.immediateRender,
			l = s.lazy,
			c = s.onUpdate,
			h = s.runBackwards,
			u = s.yoyoEase,
			d = s.keyframes,
			p = s.autoRevert,
			g = e._dur,
			v = e._startAt,
			m = e._targets,
			f = e.parent,
			y = f && f.data === 'nested' ? f.vars.targets : m,
			_ = e._overwrite === 'auto' && !P0,
			x = e.timeline,
			E,
			w,
			C,
			P,
			S,
			M,
			k,
			q,
			B,
			W,
			Q,
			$,
			le;
		if (
			(x && (!d || !r) && (r = 'none'),
			(e._ease = wa(r, tc.ease)),
			(e._yEase = u ? sA(wa(u === !0 ? r : u, tc.ease)) : 0),
			u && e._yoyo && !e._repeat && ((u = e._yEase), (e._yEase = e._ease), (e._ease = u)),
			(e._from = !x && !!s.runBackwards),
			!x || (d && !s.stagger))
		) {
			if (
				((q = m[0] ? xa(m[0]).harness : 0),
				($ = q && s[q.prop]),
				(E = pp(s, U0)),
				v && (v._zTime < 0 && v.progress(1), t < 0 && h && a && !p ? v.render(-1, !0) : v.revert(h && g ? Wd : Z4), (v._lazy = 0)),
				o)
			) {
				if (
					(So(
						(e._startAt = Sn.set(
							m,
							os(
								{
									data: 'isStart',
									overwrite: !1,
									parent: f,
									immediateRender: !0,
									lazy: !v && vi(l),
									startAt: null,
									delay: 0,
									onUpdate:
										c &&
										function () {
											return Fi(e, 'onUpdate');
										},
									stagger: 0,
								},
								o
							)
						))
					),
					(e._startAt._dp = 0),
					(e._startAt._sat = e),
					t < 0 && (Kn || (!a && !p)) && e._startAt.revert(Wd),
					a && g && t <= 0 && n <= 0)
				) {
					t && (e._zTime = t);
					return;
				}
			} else if (h && g && !v) {
				if (
					(t && (a = !1),
					(C = os({ overwrite: !1, data: 'isFromStart', lazy: a && !v && vi(l), immediateRender: a, stagger: 0, parent: f }, E)),
					$ && (C[q.prop] = $),
					So((e._startAt = Sn.set(m, C))),
					(e._startAt._dp = 0),
					(e._startAt._sat = e),
					t < 0 && (Kn ? e._startAt.revert(Wd) : e._startAt.render(-1, !0)),
					(e._zTime = t),
					!a)
				)
					i(e._startAt, Xt, Xt);
				else if (!t) return;
			}
			for (e._pt = e._ptCache = 0, l = (g && vi(l)) || (l && !g), w = 0; w < m.length; w++) {
				if (
					((S = m[w]),
					(k = S._gsap || F0(m)[w]._gsap),
					(e._ptLookup[w] = W = {}),
					Sv[k.id] && mo.length && dp(),
					(Q = y === m ? w : y.indexOf(S)),
					q &&
						(B = new q()).init(S, $ || E, e, Q, y) !== !1 &&
						((e._pt = P = new yi(e._pt, S, B.name, 0, 1, B.render, B, 0, B.priority)),
						B._props.forEach(function (Z) {
							W[Z] = P;
						}),
						B.priority && (M = 1)),
					!q || $)
				)
					for (C in E)
						Pi[C] && (B = lA(C, E, e, Q, S, y))
							? B.priority && (M = 1)
							: (W[C] = P = B0.call(e, S, C, 'get', E[C], Q, y, 0, s.stringFilter));
				e._op && e._op[w] && e.kill(S, e._op[w]),
					_ && e._pt && ((no = e), tn.killTweensOf(S, W, e.globalTime(t)), (le = !e.parent), (no = 0)),
					e._pt && l && (Sv[k.id] = 1);
			}
			M && fA(e), e._onInit && e._onInit(e);
		}
		(e._onUpdate = c), (e._initted = (!e._op || e._pt) && !le), d && t <= 0 && x.render(is, !0, !0);
	},
	M5 = function (e, t, n, s, r, o, a, l) {
		var c = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
			h,
			u,
			d,
			p;
		if (!c)
			for (c = e._ptCache[t] = [], d = e._ptLookup, p = e._targets.length; p--; ) {
				if (((h = d[p][t]), h && h.d && h.d._pt)) for (h = h.d._pt; h && h.p !== t && h.fp !== t; ) h = h._next;
				if (!h) return (Rv = 1), (e.vars[t] = '+=0'), k0(e, a), (Rv = 0), l ? Vh(t + ' not eligible for reset') : 1;
				c.push(h);
			}
		for (p = c.length; p--; )
			(u = c[p]),
				(h = u._pt || u),
				(h.s = (s || s === 0) && !r ? s : h.s + (s || 0) + o * h.c),
				(h.c = n - h.s),
				u.e && (u.e = pn(n) + Yn(u.e)),
				u.b && (u.b = h.s + Yn(u.b));
	},
	E5 = function (e, t) {
		var n = e[0] ? xa(e[0]).harness : 0,
			s = n && n.aliases,
			r,
			o,
			a,
			l;
		if (!s) return t;
		r = Ua({}, t);
		for (o in s) if (o in r) for (l = s[o].split(','), a = l.length; a--; ) r[l[a]] = r[o];
		return r;
	},
	T5 = function (e, t, n, s) {
		var r = t.ease || s || 'power1.inOut',
			o,
			a;
		if ($n(t))
			(a = n[e] || (n[e] = [])),
				t.forEach(function (l, c) {
					return a.push({ t: (c / (t.length - 1)) * 100, v: l, e: r });
				});
		else for (o in t) (a = n[o] || (n[o] = [])), o === 'ease' || a.push({ t: parseFloat(e), v: t[o], e: r });
	},
	ch = function (e, t, n, s, r) {
		return hn(e) ? e.call(t, n, s, r) : Un(e) && ~e.indexOf('random(') ? Gh(e) : e;
	},
	cA = N0 + 'repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert',
	hA = {};
_i(cA + ',id,stagger,delay,duration,paused,scrollTrigger', function (i) {
	return (hA[i] = 1);
});
var Sn = (function (i) {
	C1(e, i);
	function e(n, s, r, o) {
		var a;
		typeof s == 'number' && ((r.duration = s), (s = r), (r = null)), (a = i.call(this, o ? s : ah(s)) || this);
		var l = a.vars,
			c = l.duration,
			h = l.delay,
			u = l.immediateRender,
			d = l.stagger,
			p = l.overwrite,
			g = l.keyframes,
			v = l.defaults,
			m = l.scrollTrigger,
			f = l.yoyoEase,
			y = s.parent || tn,
			_ = ($n(n) || P1(n) ? Sr(n[0]) : 'length' in s) ? [n] : ss(n),
			x,
			E,
			w,
			C,
			P,
			S,
			M,
			k;
		if (
			((a._targets = _.length ? F0(_) : Vh('GSAP target ' + n + ' not found. https://gsap.com', !ki.nullTargetWarn) || []),
			(a._ptLookup = []),
			(a._overwrite = p),
			g || d || Ad(c) || Ad(h))
		) {
			if (
				((s = a.vars),
				(x = a.timeline = new oi({ data: 'nested', defaults: v || {}, targets: y && y.data === 'nested' ? y.vars.targets : _ })),
				x.kill(),
				(x.parent = x._dp = cr(a)),
				(x._start = 0),
				d || Ad(c) || Ad(h))
			) {
				if (((C = _.length), (M = d && j1(d)), Zs(d))) for (P in d) ~cA.indexOf(P) && (k || (k = {}), (k[P] = d[P]));
				for (E = 0; E < C; E++)
					(w = pp(s, hA)),
						(w.stagger = 0),
						f && (w.yoyoEase = f),
						k && Ua(w, k),
						(S = _[E]),
						(w.duration = +ch(c, cr(a), E, S, _)),
						(w.delay = (+ch(h, cr(a), E, S, _) || 0) - a._delay),
						!d && C === 1 && w.delay && ((a._delay = h = w.delay), (a._start += h), (w.delay = 0)),
						x.to(S, w, M ? M(E, S, _) : 0),
						(x._ease = mt.none);
				x.duration() ? (c = h = 0) : (a.timeline = 0);
			} else if (g) {
				ah(os(x.vars.defaults, { ease: 'none' })), (x._ease = wa(g.ease || s.ease || 'none'));
				var q = 0,
					B,
					W,
					Q;
				if ($n(g))
					g.forEach(function ($) {
						return x.to(_, $, '>');
					}),
						x.duration();
				else {
					w = {};
					for (P in g) P === 'ease' || P === 'easeEach' || T5(P, g[P], w, g.easeEach);
					for (P in w)
						for (
							B = w[P].sort(function ($, le) {
								return $.t - le.t;
							}),
								q = 0,
								E = 0;
							E < B.length;
							E++
						)
							(W = B[E]),
								(Q = { ease: W.e, duration: ((W.t - (E ? B[E - 1].t : 0)) / 100) * c }),
								(Q[P] = W.v),
								x.to(_, Q, q),
								(q += Q.duration);
					x.duration() < c && x.to({}, { duration: c - x.duration() });
				}
			}
			c || a.duration((c = x.duration()));
		} else a.timeline = 0;
		return (
			p === !0 && !P0 && ((no = cr(a)), tn.killTweensOf(_), (no = 0)),
			ks(y, cr(a), r),
			s.reversed && a.reverse(),
			s.paused && a.paused(!0),
			(u || (!c && !g && a._start === In(y._time) && vi(u) && i5(cr(a)) && y.data !== 'nested')) &&
				((a._tTime = -Xt), a.render(Math.max(0, -h) || 0)),
			m && W1(cr(a), m),
			a
		);
	}
	var t = e.prototype;
	return (
		(t.render = function (s, r, o) {
			var a = this._time,
				l = this._tDur,
				c = this._dur,
				h = s < 0,
				u = s > l - Xt && !h ? l : s < Xt ? 0 : s,
				d,
				p,
				g,
				v,
				m,
				f,
				y,
				_,
				x;
			if (!c) r5(this, s, r, o);
			else if (u !== this._tTime || !s || o || (!this._initted && this._tTime) || (this._startAt && this._zTime < 0 !== h)) {
				if (((d = u), (_ = this.timeline), this._repeat)) {
					if (((v = c + this._rDelay), this._repeat < -1 && h)) return this.totalTime(v * 100 + s, r, o);
					if (
						((d = In(u % v)),
						u === l
							? ((g = this._repeat), (d = c))
							: ((g = ~~(u / v)), g && g === In(u / v) && ((d = c), g--), d > c && (d = c)),
						(f = this._yoyo && g & 1),
						f && ((x = this._yEase), (d = c - d)),
						(m = nc(this._tTime, v)),
						d === a && !o && this._initted && g === m)
					)
						return (this._tTime = u), this;
					g !== m &&
						(_ && this._yEase && rA(_, f),
						this.vars.repeatRefresh &&
							!f &&
							!this._lock &&
							this._time !== v &&
							this._initted &&
							((this._lock = o = 1), (this.render(In(v * g), !0).invalidate()._lock = 0)));
				}
				if (!this._initted) {
					if (X1(this, h ? s : d, o, r, u)) return (this._tTime = 0), this;
					if (a !== this._time && !(o && this.vars.repeatRefresh && g !== m)) return this;
					if (c !== this._dur) return this.render(s, r, o);
				}
				if (
					((this._tTime = u),
					(this._time = d),
					!this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
					(this.ratio = y = (x || this._ease)(d / c)),
					this._from && (this.ratio = y = 1 - y),
					d && !a && !r && !g && (Fi(this, 'onStart'), this._tTime !== u))
				)
					return this;
				for (p = this._pt; p; ) p.r(y, p.d), (p = p._next);
				(_ && _.render(s < 0 ? s : _._dur * _._ease(d / this._dur), r, o)) || (this._startAt && (this._zTime = s)),
					this._onUpdate && !r && (h && Mv(this, s, r, o), Fi(this, 'onUpdate')),
					this._repeat && g !== m && this.vars.onRepeat && !r && this.parent && Fi(this, 'onRepeat'),
					(u === this._tDur || !u) &&
						this._tTime === u &&
						(h && !this._onUpdate && Mv(this, s, !0, !0),
						(s || !c) && ((u === this._tDur && this._ts > 0) || (!u && this._ts < 0)) && So(this, 1),
						!r &&
							!(h && !a) &&
							(u || a || f) &&
							(Fi(this, u === l ? 'onComplete' : 'onReverseComplete', !0),
							this._prom && !(u < l && this.timeScale() > 0) && this._prom()));
			}
			return this;
		}),
		(t.targets = function () {
			return this._targets;
		}),
		(t.invalidate = function (s) {
			return (
				(!s || !this.vars.runBackwards) && (this._startAt = 0),
				(this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
				(this._ptLookup = []),
				this.timeline && this.timeline.invalidate(s),
				i.prototype.invalidate.call(this, s)
			);
		}),
		(t.resetTo = function (s, r, o, a, l) {
			Wh || Ii.wake(), this._ts || this.play();
			var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
				h;
			return (
				this._initted || k0(this, c),
				(h = this._ease(c / this._dur)),
				M5(this, s, r, o, a, h, c, l)
					? this.resetTo(s, r, o, a, 1)
					: (Mf(this, 0), this.parent || H1(this._dp, this, '_first', '_last', this._dp._sort ? '_start' : 0), this.render(0))
			);
		}),
		(t.kill = function (s, r) {
			if ((r === void 0 && (r = 'all'), !s && (!r || r === 'all'))) return (this._lazy = this._pt = 0), this.parent ? Yc(this) : this;
			if (this.timeline) {
				var o = this.timeline.totalDuration();
				return (
					this.timeline.killTweensOf(s, r, no && no.vars.overwrite !== !0)._first || Yc(this),
					this.parent && o !== this.timeline.totalDuration() && ic(this, (this._dur * this.timeline._tDur) / o, 0, 1),
					this
				);
			}
			var a = this._targets,
				l = s ? ss(s) : a,
				c = this._ptLookup,
				h = this._pt,
				u,
				d,
				p,
				g,
				v,
				m,
				f;
			if ((!r || r === 'all') && t5(a, l)) return r === 'all' && (this._pt = 0), Yc(this);
			for (
				u = this._op = this._op || [],
					r !== 'all' &&
						(Un(r) &&
							((v = {}),
							_i(r, function (y) {
								return (v[y] = 1);
							}),
							(r = v)),
						(r = E5(a, r))),
					f = a.length;
				f--;

			)
				if (~l.indexOf(a[f])) {
					(d = c[f]), r === 'all' ? ((u[f] = r), (g = d), (p = {})) : ((p = u[f] = u[f] || {}), (g = r));
					for (v in g)
						(m = d && d[v]),
							m && ((!('kill' in m.d) || m.d.kill(v) === !0) && wf(this, m, '_pt'), delete d[v]),
							p !== 'all' && (p[v] = 1);
				}
			return this._initted && !this._pt && h && Yc(this), this;
		}),
		(e.to = function (s, r) {
			return new e(s, r, arguments[2]);
		}),
		(e.from = function (s, r) {
			return lh(1, arguments);
		}),
		(e.delayedCall = function (s, r, o, a) {
			return new e(r, 0, {
				immediateRender: !1,
				lazy: !1,
				overwrite: !1,
				delay: s,
				onComplete: r,
				onReverseComplete: r,
				onCompleteParams: o,
				onReverseCompleteParams: o,
				callbackScope: a,
			});
		}),
		(e.fromTo = function (s, r, o) {
			return lh(2, arguments);
		}),
		(e.set = function (s, r) {
			return (r.duration = 0), r.repeatDelay || (r.repeat = 0), new e(s, r);
		}),
		(e.killTweensOf = function (s, r, o) {
			return tn.killTweensOf(s, r, o);
		}),
		e
	);
})(Xh);
os(Sn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
_i('staggerTo,staggerFrom,staggerFromTo', function (i) {
	Sn[i] = function () {
		var e = new oi(),
			t = Tv.call(arguments, 0);
		return t.splice(i === 'staggerFromTo' ? 5 : 4, 0, 0), e[i].apply(e, t);
	};
});
var z0 = function (e, t, n) {
		return (e[t] = n);
	},
	uA = function (e, t, n) {
		return e[t](n);
	},
	A5 = function (e, t, n, s) {
		return e[t](s.fp, n);
	},
	C5 = function (e, t, n) {
		return e.setAttribute(t, n);
	},
	V0 = function (e, t) {
		return hn(e[t]) ? uA : L0(e[t]) && e.setAttribute ? C5 : z0;
	},
	dA = function (e, t) {
		return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
	},
	R5 = function (e, t) {
		return t.set(t.t, t.p, !!(t.s + t.c * e), t);
	},
	pA = function (e, t) {
		var n = t._pt,
			s = '';
		if (!e && t.b) s = t.b;
		else if (e === 1 && t.e) s = t.e;
		else {
			for (; n; ) (s = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + s), (n = n._next);
			s += t.c;
		}
		t.set(t.t, t.p, s, t);
	},
	H0 = function (e, t) {
		for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
	},
	P5 = function (e, t, n, s) {
		for (var r = this._pt, o; r; ) (o = r._next), r.p === s && r.modifier(e, t, n), (r = o);
	},
	L5 = function (e) {
		for (var t = this._pt, n, s; t; )
			(s = t._next), (t.p === e && !t.op) || t.op === e ? wf(this, t, '_pt') : t.dep || (n = 1), (t = s);
		return !n;
	},
	I5 = function (e, t, n, s) {
		s.mSet(e, t, s.m.call(s.tween, n, s.mt), s);
	},
	fA = function (e) {
		for (var t = e._pt, n, s, r, o; t; ) {
			for (n = t._next, s = r; s && s.pr > t.pr; ) s = s._next;
			(t._prev = s ? s._prev : o) ? (t._prev._next = t) : (r = t), (t._next = s) ? (s._prev = t) : (o = t), (t = n);
		}
		e._pt = r;
	},
	yi = (function () {
		function i(t, n, s, r, o, a, l, c, h) {
			(this.t = n),
				(this.s = r),
				(this.c = o),
				(this.p = s),
				(this.r = a || dA),
				(this.d = l || this),
				(this.set = c || z0),
				(this.pr = h || 0),
				(this._next = t),
				t && (t._prev = this);
		}
		var e = i.prototype;
		return (
			(e.modifier = function (n, s, r) {
				(this.mSet = this.mSet || this.set), (this.set = I5), (this.m = n), (this.mt = r), (this.tween = s);
			}),
			i
		);
	})();
_i(
	N0 +
		'parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger',
	function (i) {
		return (U0[i] = 1);
	}
);
Vi.TweenMax = Vi.TweenLite = Sn;
Vi.TimelineLite = Vi.TimelineMax = oi;
tn = new oi({ sortChildren: !1, defaults: tc, autoRemoveChildren: !0, id: 'root', smoothChildTiming: !0 });
ki.stringFilter = iA;
var Sa = [],
	qd = {},
	D5 = [],
	Sw = 0,
	O5 = 0,
	Jm = function (e) {
		return (qd[e] || D5).map(function (t) {
			return t();
		});
	},
	Pv = function () {
		var e = Date.now(),
			t = [];
		e - Sw > 2 &&
			(Jm('matchMediaInit'),
			Sa.forEach(function (n) {
				var s = n.queries,
					r = n.conditions,
					o,
					a,
					l,
					c;
				for (a in s) (o = Ns.matchMedia(s[a]).matches), o && (l = 1), o !== r[a] && ((r[a] = o), (c = 1));
				c && (n.revert(), l && t.push(n));
			}),
			Jm('matchMediaRevert'),
			t.forEach(function (n) {
				return n.onMatch(n, function (s) {
					return n.add(null, s);
				});
			}),
			(Sw = e),
			Jm('matchMedia'));
	},
	mA = (function () {
		function i(t, n) {
			(this.selector = n && Av(n)), (this.data = []), (this._r = []), (this.isReverted = !1), (this.id = O5++), t && this.add(t);
		}
		var e = i.prototype;
		return (
			(e.add = function (n, s, r) {
				hn(n) && ((r = s), (s = n), (n = hn));
				var o = this,
					a = function () {
						var c = Zt,
							h = o.selector,
							u;
						return (
							c && c !== o && c.data.push(o),
							r && (o.selector = Av(r)),
							(Zt = o),
							(u = s.apply(o, arguments)),
							hn(u) && o._r.push(u),
							(Zt = c),
							(o.selector = h),
							(o.isReverted = !1),
							u
						);
					};
				return (
					(o.last = a),
					n === hn
						? a(o, function (l) {
								return o.add(null, l);
						  })
						: n
						? (o[n] = a)
						: a
				);
			}),
			(e.ignore = function (n) {
				var s = Zt;
				(Zt = null), n(this), (Zt = s);
			}),
			(e.getTweens = function () {
				var n = [];
				return (
					this.data.forEach(function (s) {
						return s instanceof i
							? n.push.apply(n, s.getTweens())
							: s instanceof Sn && !(s.parent && s.parent.data === 'nested') && n.push(s);
					}),
					n
				);
			}),
			(e.clear = function () {
				this._r.length = this.data.length = 0;
			}),
			(e.kill = function (n, s) {
				var r = this;
				if (
					(n
						? (function () {
								for (var a = r.getTweens(), l = r.data.length, c; l--; )
									(c = r.data[l]),
										c.data === 'isFlip' &&
											(c.revert(),
											c.getChildren(!0, !0, !1).forEach(function (h) {
												return a.splice(a.indexOf(h), 1);
											}));
								for (
									a
										.map(function (h) {
											return {
												g:
													h._dur || h._delay || (h._sat && !h._sat.vars.immediateRender)
														? h.globalTime(0)
														: -1 / 0,
												t: h,
											};
										})
										.sort(function (h, u) {
											return u.g - h.g || -1 / 0;
										})
										.forEach(function (h) {
											return h.t.revert(n);
										}),
										l = r.data.length;
									l--;

								)
									(c = r.data[l]),
										c instanceof oi
											? c.data !== 'nested' && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill())
											: !(c instanceof Sn) && c.revert && c.revert(n);
								r._r.forEach(function (h) {
									return h(n, r);
								}),
									(r.isReverted = !0);
						  })()
						: this.data.forEach(function (a) {
								return a.kill && a.kill();
						  }),
					this.clear(),
					s)
				)
					for (var o = Sa.length; o--; ) Sa[o].id === this.id && Sa.splice(o, 1);
			}),
			(e.revert = function (n) {
				this.kill(n || {});
			}),
			i
		);
	})(),
	U5 = (function () {
		function i(t) {
			(this.contexts = []), (this.scope = t), Zt && Zt.data.push(this);
		}
		var e = i.prototype;
		return (
			(e.add = function (n, s, r) {
				Zs(n) || (n = { matches: n });
				var o = new mA(0, r || this.scope),
					a = (o.conditions = {}),
					l,
					c,
					h;
				Zt && !o.selector && (o.selector = Zt.selector), this.contexts.push(o), (s = o.add('onMatch', s)), (o.queries = n);
				for (c in n)
					c === 'all'
						? (h = 1)
						: ((l = Ns.matchMedia(n[c])),
						  l &&
								(Sa.indexOf(o) < 0 && Sa.push(o),
								(a[c] = l.matches) && (h = 1),
								l.addListener ? l.addListener(Pv) : l.addEventListener('change', Pv)));
				return (
					h &&
						s(o, function (u) {
							return o.add(null, u);
						}),
					this
				);
			}),
			(e.revert = function (n) {
				this.kill(n || {});
			}),
			(e.kill = function (n) {
				this.contexts.forEach(function (s) {
					return s.kill(n, !0);
				});
			}),
			i
		);
	})(),
	mp = {
		registerPlugin: function () {
			for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
			t.forEach(function (s) {
				return eA(s);
			});
		},
		timeline: function (e) {
			return new oi(e);
		},
		getTweensOf: function (e, t) {
			return tn.getTweensOf(e, t);
		},
		getProperty: function (e, t, n, s) {
			Un(e) && (e = ss(e)[0]);
			var r = xa(e || {}).get,
				o = n ? V1 : z1;
			return (
				n === 'native' && (n = ''),
				e &&
					(t
						? o(((Pi[t] && Pi[t].get) || r)(e, t, n, s))
						: function (a, l, c) {
								return o(((Pi[a] && Pi[a].get) || r)(e, a, l, c));
						  })
			);
		},
		quickSetter: function (e, t, n) {
			if (((e = ss(e)), e.length > 1)) {
				var s = e.map(function (h) {
						return Ei.quickSetter(h, t, n);
					}),
					r = s.length;
				return function (h) {
					for (var u = r; u--; ) s[u](h);
				};
			}
			e = e[0] || {};
			var o = Pi[t],
				a = xa(e),
				l = (a.harness && (a.harness.aliases || {})[t]) || t,
				c = o
					? function (h) {
							var u = new o();
							(Il._pt = 0), u.init(e, n ? h + n : h, Il, 0, [e]), u.render(1, u), Il._pt && H0(1, Il);
					  }
					: a.set(e, l);
			return o
				? c
				: function (h) {
						return c(e, l, n ? h + n : h, a, 1);
				  };
		},
		quickTo: function (e, t, n) {
			var s,
				r = Ei.to(e, Ua(((s = {}), (s[t] = '+=0.1'), (s.paused = !0), s), n || {})),
				o = function (l, c, h) {
					return r.resetTo(t, l, c, h);
				};
			return (o.tween = r), o;
		},
		isTweening: function (e) {
			return tn.getTweensOf(e, !0).length > 0;
		},
		defaults: function (e) {
			return e && e.ease && (e.ease = wa(e.ease, tc.ease)), _w(tc, e || {});
		},
		config: function (e) {
			return _w(ki, e || {});
		},
		registerEffect: function (e) {
			var t = e.name,
				n = e.effect,
				s = e.plugins,
				r = e.defaults,
				o = e.extendTimeline;
			(s || '').split(',').forEach(function (a) {
				return a && !Pi[a] && !Vi[a] && Vh(t + ' effect requires ' + a + ' plugin.');
			}),
				(jm[t] = function (a, l, c) {
					return n(ss(a), os(l || {}, r), c);
				}),
				o &&
					(oi.prototype[t] = function (a, l, c) {
						return this.add(jm[t](a, Zs(l) ? l : (c = l) && {}, this), c);
					});
		},
		registerEase: function (e, t) {
			mt[e] = wa(t);
		},
		parseEase: function (e, t) {
			return arguments.length ? wa(e, t) : mt;
		},
		getById: function (e) {
			return tn.getById(e);
		},
		exportRoot: function (e, t) {
			e === void 0 && (e = {});
			var n = new oi(e),
				s,
				r;
			for (n.smoothChildTiming = vi(e.smoothChildTiming), tn.remove(n), n._dp = 0, n._time = n._tTime = tn._time, s = tn._first; s; )
				(r = s._next),
					(t || !(!s._dur && s instanceof Sn && s.vars.onComplete === s._targets[0])) && ks(n, s, s._start - s._delay),
					(s = r);
			return ks(tn, n, 0), n;
		},
		context: function (e, t) {
			return e ? new mA(e, t) : Zt;
		},
		matchMedia: function (e) {
			return new U5(e);
		},
		matchMediaRefresh: function () {
			return (
				Sa.forEach(function (e) {
					var t = e.conditions,
						n,
						s;
					for (s in t) t[s] && ((t[s] = !1), (n = 1));
					n && e.revert();
				}) || Pv()
			);
		},
		addEventListener: function (e, t) {
			var n = qd[e] || (qd[e] = []);
			~n.indexOf(t) || n.push(t);
		},
		removeEventListener: function (e, t) {
			var n = qd[e],
				s = n && n.indexOf(t);
			s >= 0 && n.splice(s, 1);
		},
		utils: {
			wrap: p5,
			wrapYoyo: f5,
			distribute: j1,
			random: $1,
			snap: K1,
			normalize: d5,
			getUnit: Yn,
			clamp: l5,
			splitColor: tA,
			toArray: ss,
			selector: Av,
			mapRange: J1,
			pipe: h5,
			unitize: u5,
			interpolate: m5,
			shuffle: Y1,
		},
		install: U1,
		effects: jm,
		ticker: Ii,
		updateRoot: oi.updateRoot,
		plugins: Pi,
		globalTimeline: tn,
		core: {
			PropTween: yi,
			globals: N1,
			Tween: Sn,
			Timeline: oi,
			Animation: Xh,
			getCache: xa,
			_removeLinkedListItem: wf,
			reverting: function () {
				return Kn;
			},
			context: function (e) {
				return e && Zt && (Zt.data.push(e), (e._ctx = Zt)), Zt;
			},
			suppressOverwrites: function (e) {
				return (P0 = e);
			},
		},
	};
_i('to,from,fromTo,delayedCall,set,killTweensOf', function (i) {
	return (mp[i] = Sn[i]);
});
Ii.add(oi.updateRoot);
Il = mp.to({}, { duration: 0 });
var N5 = function (e, t) {
		for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; ) n = n._next;
		return n;
	},
	F5 = function (e, t) {
		var n = e._targets,
			s,
			r,
			o;
		for (s in t)
			for (r = n.length; r--; )
				(o = e._ptLookup[r][s]), o && (o = o.d) && (o._pt && (o = N5(o, s)), o && o.modifier && o.modifier(t[s], e, n[r], s));
	},
	Qm = function (e, t) {
		return {
			name: e,
			rawVars: 1,
			init: function (s, r, o) {
				o._onInit = function (a) {
					var l, c;
					if (
						(Un(r) &&
							((l = {}),
							_i(r, function (h) {
								return (l[h] = 1);
							}),
							(r = l)),
						t)
					) {
						l = {};
						for (c in r) l[c] = t(r[c]);
						r = l;
					}
					F5(a, r);
				};
			},
		};
	},
	Ei =
		mp.registerPlugin(
			{
				name: 'attr',
				init: function (e, t, n, s, r) {
					var o, a, l;
					this.tween = n;
					for (o in t)
						(l = e.getAttribute(o) || ''),
							(a = this.add(e, 'setAttribute', (l || 0) + '', t[o], s, r, 0, 0, o)),
							(a.op = o),
							(a.b = l),
							this._props.push(o);
				},
				render: function (e, t) {
					for (var n = t._pt; n; ) Kn ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
				},
			},
			{
				name: 'endArray',
				init: function (e, t) {
					for (var n = t.length; n--; ) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
				},
			},
			Qm('roundProps', Cv),
			Qm('modifiers'),
			Qm('snap', K1)
		) || mp;
Sn.version = oi.version = Ei.version = '3.12.5';
O1 = 1;
I0() && sc();
mt.Power0;
mt.Power1;
mt.Power2;
mt.Power3;
mt.Power4;
mt.Linear;
mt.Quad;
mt.Cubic;
mt.Quart;
mt.Quint;
mt.Strong;
mt.Elastic;
mt.Back;
mt.SteppedEase;
mt.Bounce;
mt.Sine;
mt.Expo;
mt.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Mw,
	io,
	Hl,
	G0,
	pa,
	Ew,
	W0,
	B5 = function () {
		return typeof window < 'u';
	},
	Mr = {},
	na = 180 / Math.PI,
	Gl = Math.PI / 180,
	Ml = Math.atan2,
	Tw = 1e8,
	X0 = /([A-Z])/g,
	k5 = /(left|right|width|margin|padding|x)/i,
	z5 = /[\s,\(]\S/,
	Ws = { autoAlpha: 'opacity,visibility', scale: 'scaleX,scaleY', alpha: 'opacity' },
	Lv = function (e, t) {
		return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
	},
	V5 = function (e, t) {
		return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
	},
	H5 = function (e, t) {
		return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
	},
	G5 = function (e, t) {
		var n = t.s + t.c * e;
		t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
	},
	gA = function (e, t) {
		return t.set(t.t, t.p, e ? t.e : t.b, t);
	},
	vA = function (e, t) {
		return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
	},
	W5 = function (e, t, n) {
		return (e.style[t] = n);
	},
	X5 = function (e, t, n) {
		return e.style.setProperty(t, n);
	},
	q5 = function (e, t, n) {
		return (e._gsap[t] = n);
	},
	Y5 = function (e, t, n) {
		return (e._gsap.scaleX = e._gsap.scaleY = n);
	},
	j5 = function (e, t, n, s, r) {
		var o = e._gsap;
		(o.scaleX = o.scaleY = n), o.renderTransform(r, o);
	},
	K5 = function (e, t, n, s, r) {
		var o = e._gsap;
		(o[t] = n), o.renderTransform(r, o);
	},
	sn = 'transform',
	xi = sn + 'Origin',
	$5 = function i(e, t) {
		var n = this,
			s = this.target,
			r = s.style,
			o = s._gsap;
		if (e in Mr && r) {
			if (((this.tfm = this.tfm || {}), e !== 'transform'))
				(e = Ws[e] || e),
					~e.indexOf(',')
						? e.split(',').forEach(function (a) {
								return (n.tfm[a] = ur(s, a));
						  })
						: (this.tfm[e] = o.x ? o[e] : ur(s, e)),
					e === xi && (this.tfm.zOrigin = o.zOrigin);
			else
				return Ws.transform.split(',').forEach(function (a) {
					return i.call(n, a, t);
				});
			if (this.props.indexOf(sn) >= 0) return;
			o.svg && ((this.svgo = s.getAttribute('data-svg-origin')), this.props.push(xi, t, '')), (e = sn);
		}
		(r || t) && this.props.push(e, t, r[e]);
	},
	_A = function (e) {
		e.translate && (e.removeProperty('translate'), e.removeProperty('scale'), e.removeProperty('rotate'));
	},
	Z5 = function () {
		var e = this.props,
			t = this.target,
			n = t.style,
			s = t._gsap,
			r,
			o;
		for (r = 0; r < e.length; r += 3)
			e[r + 1]
				? (t[e[r]] = e[r + 2])
				: e[r + 2]
				? (n[e[r]] = e[r + 2])
				: n.removeProperty(e[r].substr(0, 2) === '--' ? e[r] : e[r].replace(X0, '-$1').toLowerCase());
		if (this.tfm) {
			for (o in this.tfm) s[o] = this.tfm[o];
			s.svg && (s.renderTransform(), t.setAttribute('data-svg-origin', this.svgo || '')),
				(r = W0()),
				(!r || !r.isStart) &&
					!n[sn] &&
					(_A(n),
					s.zOrigin && n[xi] && ((n[xi] += ' ' + s.zOrigin + 'px'), (s.zOrigin = 0), s.renderTransform()),
					(s.uncache = 1));
		}
	},
	yA = function (e, t) {
		var n = { target: e, props: [], revert: Z5, save: $5 };
		return (
			e._gsap || Ei.core.getCache(e),
			t &&
				t.split(',').forEach(function (s) {
					return n.save(s);
				}),
			n
		);
	},
	xA,
	Iv = function (e, t) {
		var n = io.createElementNS
			? io.createElementNS((t || 'http://www.w3.org/1999/xhtml').replace(/^https/, 'http'), e)
			: io.createElement(e);
		return n && n.style ? n : io.createElement(e);
	},
	Ys = function i(e, t, n) {
		var s = getComputedStyle(e);
		return s[t] || s.getPropertyValue(t.replace(X0, '-$1').toLowerCase()) || s.getPropertyValue(t) || (!n && i(e, rc(t) || t, 1)) || '';
	},
	Aw = 'O,Moz,ms,Ms,Webkit'.split(','),
	rc = function (e, t, n) {
		var s = t || pa,
			r = s.style,
			o = 5;
		if (e in r && !n) return e;
		for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(Aw[o] + e in r); );
		return o < 0 ? null : (o === 3 ? 'ms' : o >= 0 ? Aw[o] : '') + e;
	},
	Dv = function () {
		B5() &&
			window.document &&
			((Mw = window),
			(io = Mw.document),
			(Hl = io.documentElement),
			(pa = Iv('div') || { style: {} }),
			Iv('div'),
			(sn = rc(sn)),
			(xi = sn + 'Origin'),
			(pa.style.cssText = 'border-width:0;line-height:0;position:absolute;padding:0'),
			(xA = !!rc('perspective')),
			(W0 = Ei.core.reverting),
			(G0 = 1));
	},
	eg = function i(e) {
		var t = Iv('svg', (this.ownerSVGElement && this.ownerSVGElement.getAttribute('xmlns')) || 'http://www.w3.org/2000/svg'),
			n = this.parentNode,
			s = this.nextSibling,
			r = this.style.cssText,
			o;
		if ((Hl.appendChild(t), t.appendChild(this), (this.style.display = 'block'), e))
			try {
				(o = this.getBBox()), (this._gsapBBox = this.getBBox), (this.getBBox = i);
			} catch (a) {}
		else this._gsapBBox && (o = this._gsapBBox());
		return n && (s ? n.insertBefore(this, s) : n.appendChild(this)), Hl.removeChild(t), (this.style.cssText = r), o;
	},
	Cw = function (e, t) {
		for (var n = t.length; n--; ) if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
	},
	bA = function (e) {
		var t;
		try {
			t = e.getBBox();
		} catch (n) {
			t = eg.call(e, !0);
		}
		return (
			(t && (t.width || t.height)) || e.getBBox === eg || (t = eg.call(e, !0)),
			t && !t.width && !t.x && !t.y
				? { x: +Cw(e, ['x', 'cx', 'x1']) || 0, y: +Cw(e, ['y', 'cy', 'y1']) || 0, width: 0, height: 0 }
				: t
		);
	},
	wA = function (e) {
		return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && bA(e));
	},
	Na = function (e, t) {
		if (t) {
			var n = e.style,
				s;
			t in Mr && t !== xi && (t = sn),
				n.removeProperty
					? ((s = t.substr(0, 2)),
					  (s === 'ms' || t.substr(0, 6) === 'webkit') && (t = '-' + t),
					  n.removeProperty(s === '--' ? t : t.replace(X0, '-$1').toLowerCase()))
					: n.removeAttribute(t);
		}
	},
	so = function (e, t, n, s, r, o) {
		var a = new yi(e._pt, t, n, 0, 1, o ? vA : gA);
		return (e._pt = a), (a.b = s), (a.e = r), e._props.push(n), a;
	},
	Rw = { deg: 1, rad: 1, turn: 1 },
	J5 = { grid: 1, flex: 1 },
	Mo = function i(e, t, n, s) {
		var r = parseFloat(n) || 0,
			o = (n + '').trim().substr((r + '').length) || 'px',
			a = pa.style,
			l = k5.test(t),
			c = e.tagName.toLowerCase() === 'svg',
			h = (c ? 'client' : 'offset') + (l ? 'Width' : 'Height'),
			u = 100,
			d = s === 'px',
			p = s === '%',
			g,
			v,
			m,
			f;
		if (s === o || !r || Rw[s] || Rw[o]) return r;
		if ((o !== 'px' && !d && (r = i(e, t, n, 'px')), (f = e.getCTM && wA(e)), (p || o === '%') && (Mr[t] || ~t.indexOf('adius'))))
			return (g = f ? e.getBBox()[l ? 'width' : 'height'] : e[h]), pn(p ? (r / g) * u : (r / 100) * g);
		if (
			((a[l ? 'width' : 'height'] = u + (d ? o : s)),
			(v = ~t.indexOf('adius') || (s === 'em' && e.appendChild && !c) ? e : e.parentNode),
			f && (v = (e.ownerSVGElement || {}).parentNode),
			(!v || v === io || !v.appendChild) && (v = io.body),
			(m = v._gsap),
			m && p && m.width && l && m.time === Ii.time && !m.uncache)
		)
			return pn((r / m.width) * u);
		if (p && (t === 'height' || t === 'width')) {
			var y = e.style[t];
			(e.style[t] = u + s), (g = e[h]), y ? (e.style[t] = y) : Na(e, t);
		} else
			(p || o === '%') && !J5[Ys(v, 'display')] && (a.position = Ys(e, 'position')),
				v === e && (a.position = 'static'),
				v.appendChild(pa),
				(g = pa[h]),
				v.removeChild(pa),
				(a.position = 'absolute');
		return l && p && ((m = xa(v)), (m.time = Ii.time), (m.width = v[h])), pn(d ? (g * r) / u : g && r ? (u / g) * r : 0);
	},
	ur = function (e, t, n, s) {
		var r;
		return (
			G0 || Dv(),
			t in Ws && t !== 'transform' && ((t = Ws[t]), ~t.indexOf(',') && (t = t.split(',')[0])),
			Mr[t] && t !== 'transform'
				? ((r = Yh(e, s)), (r = t !== 'transformOrigin' ? r[t] : r.svg ? r.origin : vp(Ys(e, xi)) + ' ' + r.zOrigin + 'px'))
				: ((r = e.style[t]),
				  (!r || r === 'auto' || s || ~(r + '').indexOf('calc(')) &&
						(r = (gp[t] && gp[t](e, t, n)) || Ys(e, t) || B1(e, t) || (t === 'opacity' ? 1 : 0))),
			n && !~(r + '').trim().indexOf(' ') ? Mo(e, t, r, n) + n : r
		);
	},
	Q5 = function (e, t, n, s) {
		if (!n || n === 'none') {
			var r = rc(t, e, 1),
				o = r && Ys(e, r, 1);
			o && o !== n ? ((t = r), (n = o)) : t === 'borderColor' && (n = Ys(e, 'borderTopColor'));
		}
		var a = new yi(this._pt, e.style, t, 0, 1, pA),
			l = 0,
			c = 0,
			h,
			u,
			d,
			p,
			g,
			v,
			m,
			f,
			y,
			_,
			x,
			E;
		if (
			((a.b = n),
			(a.e = s),
			(n += ''),
			(s += ''),
			s === 'auto' && ((v = e.style[t]), (e.style[t] = s), (s = Ys(e, t) || s), v ? (e.style[t] = v) : Na(e, t)),
			(h = [n, s]),
			iA(h),
			(n = h[0]),
			(s = h[1]),
			(d = n.match(Ll) || []),
			(E = s.match(Ll) || []),
			E.length)
		) {
			for (; (u = Ll.exec(s)); )
				(m = u[0]),
					(y = s.substring(l, u.index)),
					g ? (g = (g + 1) % 5) : (y.substr(-5) === 'rgba(' || y.substr(-5) === 'hsla(') && (g = 1),
					m !== (v = d[c++] || '') &&
						((p = parseFloat(v) || 0),
						(x = v.substr((p + '').length)),
						m.charAt(1) === '=' && (m = Vl(p, m) + x),
						(f = parseFloat(m)),
						(_ = m.substr((f + '').length)),
						(l = Ll.lastIndex - _.length),
						_ || ((_ = _ || ki.units[t] || x), l === s.length && ((s += _), (a.e += _))),
						x !== _ && (p = Mo(e, t, v, _) || 0),
						(a._pt = {
							_next: a._pt,
							p: y || c === 1 ? y : ',',
							s: p,
							c: f - p,
							m: (g && g < 4) || t === 'zIndex' ? Math.round : 0,
						}));
			a.c = l < s.length ? s.substring(l, s.length) : '';
		} else a.r = t === 'display' && s === 'none' ? vA : gA;
		return I1.test(s) && (a.e = 0), (this._pt = a), a;
	},
	Pw = { top: '0%', bottom: '100%', left: '0%', right: '100%', center: '50%' },
	eG = function (e) {
		var t = e.split(' '),
			n = t[0],
			s = t[1] || '50%';
		return (
			(n === 'top' || n === 'bottom' || s === 'left' || s === 'right') && ((e = n), (n = s), (s = e)),
			(t[0] = Pw[n] || n),
			(t[1] = Pw[s] || s),
			t.join(' ')
		);
	},
	tG = function (e, t) {
		if (t.tween && t.tween._time === t.tween._dur) {
			var n = t.t,
				s = n.style,
				r = t.u,
				o = n._gsap,
				a,
				l,
				c;
			if (r === 'all' || r === !0) (s.cssText = ''), (l = 1);
			else
				for (r = r.split(','), c = r.length; --c > -1; )
					(a = r[c]), Mr[a] && ((l = 1), (a = a === 'transformOrigin' ? xi : sn)), Na(n, a);
			l && (Na(n, sn), o && (o.svg && n.removeAttribute('transform'), Yh(n, 1), (o.uncache = 1), _A(s)));
		}
	},
	gp = {
		clearProps: function (e, t, n, s, r) {
			if (r.data !== 'isFromStart') {
				var o = (e._pt = new yi(e._pt, t, n, 0, 0, tG));
				return (o.u = s), (o.pr = -10), (o.tween = r), e._props.push(n), 1;
			}
		},
	},
	qh = [1, 0, 0, 1, 0, 0],
	SA = {},
	MA = function (e) {
		return e === 'matrix(1, 0, 0, 1, 0, 0)' || e === 'none' || !e;
	},
	Lw = function (e) {
		var t = Ys(e, sn);
		return MA(t) ? qh : t.substr(7).match(L1).map(pn);
	},
	q0 = function (e, t) {
		var n = e._gsap || xa(e),
			s = e.style,
			r = Lw(e),
			o,
			a,
			l,
			c;
		return n.svg && e.getAttribute('transform')
			? ((l = e.transform.baseVal.consolidate().matrix), (r = [l.a, l.b, l.c, l.d, l.e, l.f]), r.join(',') === '1,0,0,1,0,0' ? qh : r)
			: (r === qh &&
					!e.offsetParent &&
					e !== Hl &&
					!n.svg &&
					((l = s.display),
					(s.display = 'block'),
					(o = e.parentNode),
					(!o || !e.offsetParent) && ((c = 1), (a = e.nextElementSibling), Hl.appendChild(e)),
					(r = Lw(e)),
					l ? (s.display = l) : Na(e, 'display'),
					c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Hl.removeChild(e))),
			  t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
	},
	Ov = function (e, t, n, s, r, o) {
		var a = e._gsap,
			l = r || q0(e, !0),
			c = a.xOrigin || 0,
			h = a.yOrigin || 0,
			u = a.xOffset || 0,
			d = a.yOffset || 0,
			p = l[0],
			g = l[1],
			v = l[2],
			m = l[3],
			f = l[4],
			y = l[5],
			_ = t.split(' '),
			x = parseFloat(_[0]) || 0,
			E = parseFloat(_[1]) || 0,
			w,
			C,
			P,
			S;
		n
			? l !== qh &&
			  (C = p * m - g * v) &&
			  ((P = x * (m / C) + E * (-v / C) + (v * y - m * f) / C),
			  (S = x * (-g / C) + E * (p / C) - (p * y - g * f) / C),
			  (x = P),
			  (E = S))
			: ((w = bA(e)),
			  (x = w.x + (~_[0].indexOf('%') ? (x / 100) * w.width : x)),
			  (E = w.y + (~(_[1] || _[0]).indexOf('%') ? (E / 100) * w.height : E))),
			s || (s !== !1 && a.smooth)
				? ((f = x - c), (y = E - h), (a.xOffset = u + (f * p + y * v) - f), (a.yOffset = d + (f * g + y * m) - y))
				: (a.xOffset = a.yOffset = 0),
			(a.xOrigin = x),
			(a.yOrigin = E),
			(a.smooth = !!s),
			(a.origin = t),
			(a.originIsAbsolute = !!n),
			(e.style[xi] = '0px 0px'),
			o &&
				(so(o, a, 'xOrigin', c, x),
				so(o, a, 'yOrigin', h, E),
				so(o, a, 'xOffset', u, a.xOffset),
				so(o, a, 'yOffset', d, a.yOffset)),
			e.setAttribute('data-svg-origin', x + ' ' + E);
	},
	Yh = function (e, t) {
		var n = e._gsap || new aA(e);
		if ('x' in n && !t && !n.uncache) return n;
		var s = e.style,
			r = n.scaleX < 0,
			o = 'px',
			a = 'deg',
			l = getComputedStyle(e),
			c = Ys(e, xi) || '0',
			h,
			u,
			d,
			p,
			g,
			v,
			m,
			f,
			y,
			_,
			x,
			E,
			w,
			C,
			P,
			S,
			M,
			k,
			q,
			B,
			W,
			Q,
			$,
			le,
			Z,
			xe,
			ue,
			Te,
			Ae,
			We,
			se,
			Se;
		return (
			(h = u = d = v = m = f = y = _ = x = 0),
			(p = g = 1),
			(n.svg = !!(e.getCTM && wA(e))),
			l.translate &&
				((l.translate !== 'none' || l.scale !== 'none' || l.rotate !== 'none') &&
					(s[sn] =
						(l.translate !== 'none' ? 'translate3d(' + (l.translate + ' 0 0').split(' ').slice(0, 3).join(', ') + ') ' : '') +
						(l.rotate !== 'none' ? 'rotate(' + l.rotate + ') ' : '') +
						(l.scale !== 'none' ? 'scale(' + l.scale.split(' ').join(',') + ') ' : '') +
						(l[sn] !== 'none' ? l[sn] : '')),
				(s.scale = s.rotate = s.translate = 'none')),
			(C = q0(e, n.svg)),
			n.svg &&
				(n.uncache
					? ((Z = e.getBBox()), (c = n.xOrigin - Z.x + 'px ' + (n.yOrigin - Z.y) + 'px'), (le = ''))
					: (le = !t && e.getAttribute('data-svg-origin')),
				Ov(e, le || c, !!le || n.originIsAbsolute, n.smooth !== !1, C)),
			(E = n.xOrigin || 0),
			(w = n.yOrigin || 0),
			C !== qh &&
				((k = C[0]),
				(q = C[1]),
				(B = C[2]),
				(W = C[3]),
				(h = Q = C[4]),
				(u = $ = C[5]),
				C.length === 6
					? ((p = Math.sqrt(k * k + q * q)),
					  (g = Math.sqrt(W * W + B * B)),
					  (v = k || q ? Ml(q, k) * na : 0),
					  (y = B || W ? Ml(B, W) * na + v : 0),
					  y && (g *= Math.abs(Math.cos(y * Gl))),
					  n.svg && ((h -= E - (E * k + w * B)), (u -= w - (E * q + w * W))))
					: ((Se = C[6]),
					  (We = C[7]),
					  (ue = C[8]),
					  (Te = C[9]),
					  (Ae = C[10]),
					  (se = C[11]),
					  (h = C[12]),
					  (u = C[13]),
					  (d = C[14]),
					  (P = Ml(Se, Ae)),
					  (m = P * na),
					  P &&
							((S = Math.cos(-P)),
							(M = Math.sin(-P)),
							(le = Q * S + ue * M),
							(Z = $ * S + Te * M),
							(xe = Se * S + Ae * M),
							(ue = Q * -M + ue * S),
							(Te = $ * -M + Te * S),
							(Ae = Se * -M + Ae * S),
							(se = We * -M + se * S),
							(Q = le),
							($ = Z),
							(Se = xe)),
					  (P = Ml(-B, Ae)),
					  (f = P * na),
					  P &&
							((S = Math.cos(-P)),
							(M = Math.sin(-P)),
							(le = k * S - ue * M),
							(Z = q * S - Te * M),
							(xe = B * S - Ae * M),
							(se = W * M + se * S),
							(k = le),
							(q = Z),
							(B = xe)),
					  (P = Ml(q, k)),
					  (v = P * na),
					  P &&
							((S = Math.cos(P)),
							(M = Math.sin(P)),
							(le = k * S + q * M),
							(Z = Q * S + $ * M),
							(q = q * S - k * M),
							($ = $ * S - Q * M),
							(k = le),
							(Q = Z)),
					  m && Math.abs(m) + Math.abs(v) > 359.9 && ((m = v = 0), (f = 180 - f)),
					  (p = pn(Math.sqrt(k * k + q * q + B * B))),
					  (g = pn(Math.sqrt($ * $ + Se * Se))),
					  (P = Ml(Q, $)),
					  (y = Math.abs(P) > 2e-4 ? P * na : 0),
					  (x = se ? 1 / (se < 0 ? -se : se) : 0)),
				n.svg &&
					((le = e.getAttribute('transform')),
					(n.forceCSS = e.setAttribute('transform', '') || !MA(Ys(e, sn))),
					le && e.setAttribute('transform', le))),
			Math.abs(y) > 90 &&
				Math.abs(y) < 270 &&
				(r ? ((p *= -1), (y += v <= 0 ? 180 : -180), (v += v <= 0 ? 180 : -180)) : ((g *= -1), (y += y <= 0 ? 180 : -180))),
			(t = t || n.uncache),
			(n.x =
				h -
				((n.xPercent = h && ((!t && n.xPercent) || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0)))
					? (e.offsetWidth * n.xPercent) / 100
					: 0) +
				o),
			(n.y =
				u -
				((n.yPercent = u && ((!t && n.yPercent) || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0)))
					? (e.offsetHeight * n.yPercent) / 100
					: 0) +
				o),
			(n.z = d + o),
			(n.scaleX = pn(p)),
			(n.scaleY = pn(g)),
			(n.rotation = pn(v) + a),
			(n.rotationX = pn(m) + a),
			(n.rotationY = pn(f) + a),
			(n.skewX = y + a),
			(n.skewY = _ + a),
			(n.transformPerspective = x + o),
			(n.zOrigin = parseFloat(c.split(' ')[2]) || (!t && n.zOrigin) || 0) && (s[xi] = vp(c)),
			(n.xOffset = n.yOffset = 0),
			(n.force3D = ki.force3D),
			(n.renderTransform = n.svg ? iG : xA ? EA : nG),
			(n.uncache = 0),
			n
		);
	},
	vp = function (e) {
		return (e = e.split(' '))[0] + ' ' + e[1];
	},
	tg = function (e, t, n) {
		var s = Yn(t);
		return pn(parseFloat(t) + parseFloat(Mo(e, 'x', n + 'px', s))) + s;
	},
	nG = function (e, t) {
		(t.z = '0px'), (t.rotationY = t.rotationX = '0deg'), (t.force3D = 0), EA(e, t);
	},
	Jo = '0deg',
	Hc = '0px',
	Qo = ') ',
	EA = function (e, t) {
		var n = t || this,
			s = n.xPercent,
			r = n.yPercent,
			o = n.x,
			a = n.y,
			l = n.z,
			c = n.rotation,
			h = n.rotationY,
			u = n.rotationX,
			d = n.skewX,
			p = n.skewY,
			g = n.scaleX,
			v = n.scaleY,
			m = n.transformPerspective,
			f = n.force3D,
			y = n.target,
			_ = n.zOrigin,
			x = '',
			E = (f === 'auto' && e && e !== 1) || f === !0;
		if (_ && (u !== Jo || h !== Jo)) {
			var w = parseFloat(h) * Gl,
				C = Math.sin(w),
				P = Math.cos(w),
				S;
			(w = parseFloat(u) * Gl),
				(S = Math.cos(w)),
				(o = tg(y, o, C * S * -_)),
				(a = tg(y, a, -Math.sin(w) * -_)),
				(l = tg(y, l, P * S * -_ + _));
		}
		m !== Hc && (x += 'perspective(' + m + Qo),
			(s || r) && (x += 'translate(' + s + '%, ' + r + '%) '),
			(E || o !== Hc || a !== Hc || l !== Hc) &&
				(x += l !== Hc || E ? 'translate3d(' + o + ', ' + a + ', ' + l + ') ' : 'translate(' + o + ', ' + a + Qo),
			c !== Jo && (x += 'rotate(' + c + Qo),
			h !== Jo && (x += 'rotateY(' + h + Qo),
			u !== Jo && (x += 'rotateX(' + u + Qo),
			(d !== Jo || p !== Jo) && (x += 'skew(' + d + ', ' + p + Qo),
			(g !== 1 || v !== 1) && (x += 'scale(' + g + ', ' + v + Qo),
			(y.style[sn] = x || 'translate(0, 0)');
	},
	iG = function (e, t) {
		var n = t || this,
			s = n.xPercent,
			r = n.yPercent,
			o = n.x,
			a = n.y,
			l = n.rotation,
			c = n.skewX,
			h = n.skewY,
			u = n.scaleX,
			d = n.scaleY,
			p = n.target,
			g = n.xOrigin,
			v = n.yOrigin,
			m = n.xOffset,
			f = n.yOffset,
			y = n.forceCSS,
			_ = parseFloat(o),
			x = parseFloat(a),
			E,
			w,
			C,
			P,
			S;
		(l = parseFloat(l)),
			(c = parseFloat(c)),
			(h = parseFloat(h)),
			h && ((h = parseFloat(h)), (c += h), (l += h)),
			l || c
				? ((l *= Gl),
				  (c *= Gl),
				  (E = Math.cos(l) * u),
				  (w = Math.sin(l) * u),
				  (C = Math.sin(l - c) * -d),
				  (P = Math.cos(l - c) * d),
				  c &&
						((h *= Gl),
						(S = Math.tan(c - h)),
						(S = Math.sqrt(1 + S * S)),
						(C *= S),
						(P *= S),
						h && ((S = Math.tan(h)), (S = Math.sqrt(1 + S * S)), (E *= S), (w *= S))),
				  (E = pn(E)),
				  (w = pn(w)),
				  (C = pn(C)),
				  (P = pn(P)))
				: ((E = u), (P = d), (w = C = 0)),
			((_ && !~(o + '').indexOf('px')) || (x && !~(a + '').indexOf('px'))) && ((_ = Mo(p, 'x', o, 'px')), (x = Mo(p, 'y', a, 'px'))),
			(g || v || m || f) && ((_ = pn(_ + g - (g * E + v * C) + m)), (x = pn(x + v - (g * w + v * P) + f))),
			(s || r) && ((S = p.getBBox()), (_ = pn(_ + (s / 100) * S.width)), (x = pn(x + (r / 100) * S.height))),
			(S = 'matrix(' + E + ',' + w + ',' + C + ',' + P + ',' + _ + ',' + x + ')'),
			p.setAttribute('transform', S),
			y && (p.style[sn] = S);
	},
	sG = function (e, t, n, s, r) {
		var o = 360,
			a = Un(r),
			l = parseFloat(r) * (a && ~r.indexOf('rad') ? na : 1),
			c = l - s,
			h = s + c + 'deg',
			u,
			d;
		return (
			a &&
				((u = r.split('_')[1]),
				u === 'short' && ((c %= o), c !== c % (o / 2) && (c += c < 0 ? o : -o)),
				u === 'cw' && c < 0
					? (c = ((c + o * Tw) % o) - ~~(c / o) * o)
					: u === 'ccw' && c > 0 && (c = ((c - o * Tw) % o) - ~~(c / o) * o)),
			(e._pt = d = new yi(e._pt, t, n, s, c, V5)),
			(d.e = h),
			(d.u = 'deg'),
			e._props.push(n),
			d
		);
	},
	Iw = function (e, t) {
		for (var n in t) e[n] = t[n];
		return e;
	},
	rG = function (e, t, n) {
		var s = Iw({}, n._gsap),
			r = 'perspective,force3D,transformOrigin,svgOrigin',
			o = n.style,
			a,
			l,
			c,
			h,
			u,
			d,
			p,
			g;
		s.svg
			? ((c = n.getAttribute('transform')),
			  n.setAttribute('transform', ''),
			  (o[sn] = t),
			  (a = Yh(n, 1)),
			  Na(n, sn),
			  n.setAttribute('transform', c))
			: ((c = getComputedStyle(n)[sn]), (o[sn] = t), (a = Yh(n, 1)), (o[sn] = c));
		for (l in Mr)
			(c = s[l]),
				(h = a[l]),
				c !== h &&
					r.indexOf(l) < 0 &&
					((p = Yn(c)),
					(g = Yn(h)),
					(u = p !== g ? Mo(n, l, c, g) : parseFloat(c)),
					(d = parseFloat(h)),
					(e._pt = new yi(e._pt, a, l, u, d - u, Lv)),
					(e._pt.u = g || 0),
					e._props.push(l));
		Iw(a, s);
	};
_i('padding,margin,Width,Radius', function (i, e) {
	var t = 'Top',
		n = 'Right',
		s = 'Bottom',
		r = 'Left',
		o = (e < 3 ? [t, n, s, r] : [t + r, t + n, s + n, s + r]).map(function (a) {
			return e < 2 ? i + a : 'border' + a + i;
		});
	gp[e > 1 ? 'border' + i : i] = function (a, l, c, h, u) {
		var d, p;
		if (arguments.length < 4)
			return (
				(d = o.map(function (g) {
					return ur(a, g, c);
				})),
				(p = d.join(' ')),
				p.split(d[0]).length === 5 ? d[0] : p
			);
		(d = (h + '').split(' ')),
			(p = {}),
			o.forEach(function (g, v) {
				return (p[g] = d[v] = d[v] || d[((v - 1) / 2) | 0]);
			}),
			a.init(l, p, u);
	};
});
var TA = {
	name: 'css',
	register: Dv,
	targetTest: function (e) {
		return e.style && e.nodeType;
	},
	init: function (e, t, n, s, r) {
		var o = this._props,
			a = e.style,
			l = n.vars.startAt,
			c,
			h,
			u,
			d,
			p,
			g,
			v,
			m,
			f,
			y,
			_,
			x,
			E,
			w,
			C,
			P;
		G0 || Dv(), (this.styles = this.styles || yA(e)), (P = this.styles.props), (this.tween = n);
		for (v in t)
			if (v !== 'autoRound' && ((h = t[v]), !(Pi[v] && lA(v, t, n, s, e, r)))) {
				if (
					((p = typeof h),
					(g = gp[v]),
					p === 'function' && ((h = h.call(n, s, e, r)), (p = typeof h)),
					p === 'string' && ~h.indexOf('random(') && (h = Gh(h)),
					g)
				)
					g(this, e, v, h, n) && (C = 1);
				else if (v.substr(0, 2) === '--')
					(c = (getComputedStyle(e).getPropertyValue(v) + '').trim()),
						(h += ''),
						(go.lastIndex = 0),
						go.test(c) || ((m = Yn(c)), (f = Yn(h))),
						f ? m !== f && (c = Mo(e, v, c, f) + f) : m && (h += m),
						this.add(a, 'setProperty', c, h, s, r, 0, 0, v),
						o.push(v),
						P.push(v, 0, a[v]);
				else if (p !== 'undefined') {
					if (
						(l && v in l
							? ((c = typeof l[v] == 'function' ? l[v].call(n, s, e, r) : l[v]),
							  Un(c) && ~c.indexOf('random(') && (c = Gh(c)),
							  Yn(c + '') || c === 'auto' || (c += ki.units[v] || Yn(ur(e, v)) || ''),
							  (c + '').charAt(1) === '=' && (c = ur(e, v)))
							: (c = ur(e, v)),
						(d = parseFloat(c)),
						(y = p === 'string' && h.charAt(1) === '=' && h.substr(0, 2)),
						y && (h = h.substr(2)),
						(u = parseFloat(h)),
						v in Ws &&
							(v === 'autoAlpha' &&
								(d === 1 && ur(e, 'visibility') === 'hidden' && u && (d = 0),
								P.push('visibility', 0, a.visibility),
								so(this, a, 'visibility', d ? 'inherit' : 'hidden', u ? 'inherit' : 'hidden', !u)),
							v !== 'scale' && v !== 'transform' && ((v = Ws[v]), ~v.indexOf(',') && (v = v.split(',')[0]))),
						(_ = v in Mr),
						_)
					) {
						if (
							(this.styles.save(v),
							x ||
								((E = e._gsap),
								(E.renderTransform && !t.parseTransform) || Yh(e, t.parseTransform),
								(w = t.smoothOrigin !== !1 && E.smooth),
								(x = this._pt = new yi(this._pt, a, sn, 0, 1, E.renderTransform, E, 0, -1)),
								(x.dep = 1)),
							v === 'scale')
						)
							(this._pt = new yi(this._pt, E, 'scaleY', E.scaleY, (y ? Vl(E.scaleY, y + u) : u) - E.scaleY || 0, Lv)),
								(this._pt.u = 0),
								o.push('scaleY', v),
								(v += 'X');
						else if (v === 'transformOrigin') {
							P.push(xi, 0, a[xi]),
								(h = eG(h)),
								E.svg
									? Ov(e, h, 0, w, 0, this)
									: ((f = parseFloat(h.split(' ')[2]) || 0),
									  f !== E.zOrigin && so(this, E, 'zOrigin', E.zOrigin, f),
									  so(this, a, v, vp(c), vp(h)));
							continue;
						} else if (v === 'svgOrigin') {
							Ov(e, h, 1, w, 0, this);
							continue;
						} else if (v in SA) {
							sG(this, E, v, d, y ? Vl(d, y + h) : h);
							continue;
						} else if (v === 'smoothOrigin') {
							so(this, E, 'smooth', E.smooth, h);
							continue;
						} else if (v === 'force3D') {
							E[v] = h;
							continue;
						} else if (v === 'transform') {
							rG(this, h, e);
							continue;
						}
					} else v in a || (v = rc(v) || v);
					if (_ || ((u || u === 0) && (d || d === 0) && !z5.test(h) && v in a))
						(m = (c + '').substr((d + '').length)),
							u || (u = 0),
							(f = Yn(h) || (v in ki.units ? ki.units[v] : m)),
							m !== f && (d = Mo(e, v, c, f)),
							(this._pt = new yi(
								this._pt,
								_ ? E : a,
								v,
								d,
								(y ? Vl(d, y + u) : u) - d,
								!_ && (f === 'px' || v === 'zIndex') && t.autoRound !== !1 ? G5 : Lv
							)),
							(this._pt.u = f || 0),
							m !== f && f !== '%' && ((this._pt.b = c), (this._pt.r = H5));
					else if (v in a) Q5.call(this, e, v, c, y ? y + h : h);
					else if (v in e) this.add(e, v, c || e[v], y ? y + h : h, s, r);
					else if (v !== 'parseTransform') {
						O0(v, h);
						continue;
					}
					_ || (v in a ? P.push(v, 0, a[v]) : P.push(v, 1, c || e[v])), o.push(v);
				}
			}
		C && fA(this);
	},
	render: function (e, t) {
		if (t.tween._time || !W0()) for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
		else t.styles.revert();
	},
	get: ur,
	aliases: Ws,
	getSetter: function (e, t, n) {
		var s = Ws[t];
		return (
			s && s.indexOf(',') < 0 && (t = s),
			t in Mr && t !== xi && (e._gsap.x || ur(e, 'x'))
				? n && Ew === n
					? t === 'scale'
						? Y5
						: q5
					: (Ew = n || {}) && (t === 'scale' ? j5 : K5)
				: e.style && !L0(e.style[t])
				? W5
				: ~t.indexOf('-')
				? X5
				: V0(e, t)
		);
	},
	core: { _removeProperty: Na, _getMatrix: q0 },
};
Ei.utils.checkPrefix = rc;
Ei.core.getStyleSaver = yA;
(function (i, e, t, n) {
	var s = _i(i + ',' + e + ',' + t, function (r) {
		Mr[r] = 1;
	});
	_i(e, function (r) {
		(ki.units[r] = 'deg'), (SA[r] = 1);
	}),
		(Ws[s[13]] = i + ',' + e),
		_i(n, function (r) {
			var o = r.split(':');
			Ws[o[1]] = s[o[0]];
		});
})(
	'x,y,z,scale,scaleX,scaleY,xPercent,yPercent',
	'rotation,rotationX,rotationY,skewX,skewY',
	'transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective',
	'0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY'
);
_i('x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective', function (i) {
	ki.units[i] = 'px';
});
Ei.registerPlugin(TA);
var Bn = Ei.registerPlugin(TA) || Ei;
Bn.core.Tween;
var oG = Object.defineProperty,
	aG = (i, e, t) => (e in i ? oG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Je = (i, e, t) => (aG(i, typeof e != 'symbol' ? e + '' : e, t), t),
	lG = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {};
function cG(i) {
	return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, 'default') ? i.default : i;
}
var AA = { exports: {} };
(function (i, e) {
	(function (t, n) {
		i.exports = n();
	})(lG, function () {
		var t = function () {
			function n(p) {
				return o.appendChild(p.dom), p;
			}
			function s(p) {
				for (var g = 0; g < o.children.length; g++) o.children[g].style.display = g === p ? 'block' : 'none';
				r = p;
			}
			var r = 0,
				o = document.createElement('div');
			(o.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000'),
				o.addEventListener(
					'click',
					function (p) {
						p.preventDefault(), s(++r % o.children.length);
					},
					!1
				);
			var a = (performance || Date).now(),
				l = a,
				c = 0,
				h = n(new t.Panel('FPS', '#0ff', '#002')),
				u = n(new t.Panel('MS', '#0f0', '#020'));
			if (self.performance && self.performance.memory) var d = n(new t.Panel('MB', '#f08', '#201'));
			return (
				s(0),
				{
					REVISION: 16,
					dom: o,
					addPanel: n,
					showPanel: s,
					begin: function () {
						a = (performance || Date).now();
					},
					end: function () {
						c++;
						var p = (performance || Date).now();
						if ((u.update(p - a, 200), p > l + 1e3 && (h.update((1e3 * c) / (p - l), 100), (l = p), (c = 0), d))) {
							var g = performance.memory;
							d.update(g.usedJSHeapSize / 1048576, g.jsHeapSizeLimit / 1048576);
						}
						return p;
					},
					update: function () {
						a = this.end();
					},
					domElement: o,
					setMode: s,
				}
			);
		};
		return (
			(t.Panel = function (n, s, r) {
				var o = 1 / 0,
					a = 0,
					l = Math.round,
					c = l(window.devicePixelRatio || 1),
					h = 80 * c,
					u = 48 * c,
					d = 3 * c,
					p = 2 * c,
					g = 3 * c,
					v = 15 * c,
					m = 74 * c,
					f = 30 * c,
					y = document.createElement('canvas');
				(y.width = h), (y.height = u), (y.style.cssText = 'width:80px;height:48px');
				var _ = y.getContext('2d');
				return (
					(_.font = 'bold ' + 9 * c + 'px Helvetica,Arial,sans-serif'),
					(_.textBaseline = 'top'),
					(_.fillStyle = r),
					_.fillRect(0, 0, h, u),
					(_.fillStyle = s),
					_.fillText(n, d, p),
					_.fillRect(g, v, m, f),
					(_.fillStyle = r),
					(_.globalAlpha = 0.9),
					_.fillRect(g, v, m, f),
					{
						dom: y,
						update: function (x, E) {
							(o = Math.min(o, x)),
								(a = Math.max(a, x)),
								(_.fillStyle = r),
								(_.globalAlpha = 1),
								_.fillRect(0, 0, h, v),
								(_.fillStyle = s),
								_.fillText(l(x) + ' ' + n + ' (' + l(o) + '-' + l(a) + ')', d, p),
								_.drawImage(y, g + c, v, m - c, f, g, v, m - c, f),
								_.fillRect(g + m - c, v, c, f),
								(_.fillStyle = r),
								(_.globalAlpha = 0.9),
								_.fillRect(g + m - c, v, c, l((1 - x / E) * f));
						},
					}
				);
			}),
			t
		);
	});
})(AA);
var hG = AA.exports;
const uG = cG(hG),
	dG = (i) => {
		const e = new Ch();
		return i != null && i.background && (e.background = i.background), e;
	},
	pG = (i) => {
		const {
				dev: e,
				width: t,
				height: n,
				alpha: s = !1,
				colorSpace: r = ot,
				devicePixelRatio: o = Math.min(2, window.devicePixelRatio),
				toneMapping: a = Up,
				toneMappingExposure: l = 1,
			} = i,
			c = new bE({ powerPreference: 'high-performance', alpha: s, antialias: !1, stencil: !1, depth: !1 });
		return (
			(c.debug.checkShaderErrors = e != null ? e : !0),
			(c.outputColorSpace = r),
			c.setSize(t, n),
			c.setPixelRatio(o),
			(c.toneMapping = a),
			(c.toneMappingExposure = l),
			c
		);
	};
function fG(i, e) {
	const t =
		i == null
			? void 0
			: i.addFolder('Renderer', {
					toneMapping: {
						value: e.toneMapping,
						options: [
							{ text: 'None', value: Xs },
							{ text: 'Linear', value: Up },
							{ text: 'Reinhard', value: d_ },
							{ text: 'Cineon', value: p_ },
							{ text: 'ACESFilmic', value: f_ },
						],
						onChange: (n) => {
							e.toneMapping = n;
						},
					},
					toneMappingExposure: {
						value: e.toneMappingExposure,
						min: 0,
						max: 2,
						step: 0.01,
						onChange: (n) => {
							e.toneMappingExposure = n;
						},
					},
			  });
	return (t.expanded = !1), t;
}
function Dw(i, e) {
	const t = new K3();
	return (
		t.setSize(i, e),
		(t.domElement.style.position = 'absolute'),
		(t.domElement.style.top = '0'),
		(t.domElement.style.pointerEvents = 'none'),
		t
	);
}
function Ow(i, e) {
	const t = new Q3();
	return (
		t.setSize(i, e),
		(t.domElement.style.position = 'absolute'),
		(t.domElement.style.top = '0'),
		(t.domElement.style.pointerEvents = 'none'),
		t
	);
}
function mG(i, e, t) {
	return t ? (t === '2d' ? [Dw(i, e)] : t === '3d' ? [Ow(i, e)] : [Dw(i, e), Ow(i, e)]) : [];
}
const { DEG2RAD: CA, RAD2DEG: RA } = Dn;
function PA(i, e = 16 / 9) {
	return Math.atan(Math.tan(i * CA * 0.5) / e) * RA * 2;
}
function gG(i, e = 16 / 9) {
	return Math.atan(Math.tan(i * CA * 0.5) * e) * RA * 2;
}
Oh.install({ THREE: q3 });
const vG = (i) => {
	const {
			width: e,
			height: t,
			domElement: n,
			fov: s = PA(90, Math.max(e / t, 16 / 9)),
			near: r = 0.1,
			far: o = 1e3,
			position: a = new I(0, 0, 10),
			target: l = new I(0, 0, 0),
		} = i,
		c = new fn(s, e / t, r, o);
	i.focalLength && c.setFocalLength(i.focalLength);
	const h = new Oh(c, n);
	return h.setLookAt(a.x, a.y, a.z, l.x, l.y, l.z), h;
};
function _G(i, e) {
	const t =
		i == null
			? void 0
			: i.addFolder('Camera', {
					x: {
						value: e.camera.position.x,
						min: -500,
						max: 500,
						step: 0.1,
						onChange: (n) => {
							const s = e.getPosition(new I());
							e.setPosition(n, s.y, s.z);
						},
					},
					y: {
						value: e.camera.position.y,
						min: -500,
						max: 500,
						step: 0.1,
						onChange: (n) => {
							const s = e.getPosition(new I());
							e.setPosition(s.x, n, s.z);
						},
					},
					z: {
						value: e.camera.position.z,
						min: -500,
						max: 500,
						step: 0.1,
						onChange: (n) => {
							const s = e.getPosition(new I());
							e.setPosition(s.x, s.y, n);
						},
					},
					near: {
						value: e.camera.near,
						min: 0,
						max: 30,
						step: 0.001,
						onChange: (n) => {
							(e.camera.near = n), e.camera.updateProjectionMatrix();
						},
					},
					far: {
						value: e.camera.far,
						min: 0,
						max: 5e3,
						step: 1,
						onChange: (n) => {
							(e.camera.far = n), e.camera.updateProjectionMatrix();
						},
					},
			  });
	return (t.expanded = !1), t;
}
var yG = Object.defineProperty,
	xG = (i, e, t) => (e in i ? yG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	ng = (i, e, t) => (xG(i, typeof e != 'symbol' ? e + '' : e, t), t);
class bG {
	constructor(e) {
		ng(this, 'composer'), ng(this, 'options'), ng(this, 'bloomEffect');
		const { renderer: t, scene: n, camera: s, bloom: r } = e,
			o = new cB(t, { frameBufferType: fi });
		(this.options = e), (this.composer = o), o.addPass(new TT(n, s));
		const a = [this.addAAEffect()].filter(Boolean);
		r && a.push(this.addBloomEffect(r === !0 ? {} : r)), o.addPass(new bk(s, ...a));
	}
	addAAEffect() {
		const { renderer: e, antialias: t = 'msaa', multisampling: n = 4 } = this.options,
			{ isWebGL2: s, maxSamples: r } = e.capabilities;
		if (((this.composer.multisampling = s && t === 'msaa' ? Math.min(n, r) : 0), t === 'msaa')) return this.composer.addPass(new MT());
		if (t === 'fxaa') return new dk({ blendFunction: ht.ADD });
	}
	addBloomEffect(e) {
		const { scene: t, camera: n } = this.options,
			s = new gk(t, n, {
				blendFunction: ht.ADD,
				luminanceThreshold: 0.3,
				luminanceSmoothing: 0.2,
				mipmapBlur: !0,
				intensity: 4,
				...e,
			});
		return (s.ignoreBackground = !0), (this.bloomEffect = s), s;
	}
	toggleBloom(e) {
		var t;
		(t = this.bloomEffect) == null || t.selection.toggle(e);
	}
	dispose() {
		(this.composer.multisampling = 0), this.composer.dispose(), (this.bloomEffect = void 0);
	}
}
function Y0(i) {
	i instanceof Ui && i.children.length
		? i.children.forEach((e) => {
				Y0(e);
		  })
		: i instanceof bt &&
		  (i.geometry && i.geometry.dispose(),
		  i.material &&
				(Array.isArray(i.material)
					? i.material.forEach((e) => {
							e.dispose();
					  })
					: i.material.dispose()));
}
function j0(i) {
	const e = new An().setFromObject(i),
		t = e.getCenter(new I()),
		n = e.getSize(new I()),
		s = new un();
	return e.getBoundingSphere(s), { bbox: e, sphere: s, center: t, size: n };
}
function LA(i, e) {
	let t = !1;
	return (
		e.traverse((n) => {
			n === i && (t = !0);
		}),
		t
	);
}
function IA(i, e, t, n) {
	const s = new I();
	i.updateWorldMatrix(!0, !1), i.getWorldPosition(s);
	const r = s.clone();
	r.project(e), t.setFromCamera(r, e);
	const o = t.intersectObjects(n);
	return o.length ? o[0].object === i : !1;
}
function wG(i, e) {
	const t = document.createElement('a'),
		n = URL.createObjectURL(i);
	(t.href = n), (t.download = e), t.click(), URL.revokeObjectURL(n);
}
function SG(i) {
	let e = i.getBoundingClientRect().left,
		t = i.offsetParent;
	for (; t; ) (e += t.getBoundingClientRect().left), (t = t.offsetParent);
	return e;
}
function MG(i) {
	let e = i.getBoundingClientRect().top,
		t = i.offsetParent;
	for (; t; ) (e += t.getBoundingClientRect().top), (t = t.offsetParent);
	return e;
}
function EG(i, e, t) {
	const n = (i / e) * Math.PI * 2;
	return { x: Math.cos(n) * t, y: Math.sin(n) * t };
}
function TG(i, e, t) {
	const n = (90 - e) * (Math.PI / 180),
		s = (i + 180) * (Math.PI / 180);
	return { x: -t * Math.sin(n) * Math.cos(s), y: t * Math.cos(n), z: t * Math.sin(n) * Math.sin(s) };
}
function DA() {
	let i = () => {},
		e = () => {};
	return {
		promise: new Promise((t, n) => {
			(i = t), (e = n);
		}),
		resolve: i,
		reject: e,
	};
}
function gc(i) {
	return new Promise((e, t) => {
		(i.oncomplete = i.onsuccess = () => e(i.result)), (i.onabort = i.onerror = () => t(i.error));
	});
}
function AG(i, e) {
	const t = indexedDB.open(i);
	t.onupgradeneeded = () => t.result.createObjectStore(e);
	const n = gc(t);
	return (s, r) => n.then((o) => r(o.transaction(e, s).objectStore(e)));
}
let ig;
function Ef() {
	return ig || (ig = AG('keyval-store', 'keyval')), ig;
}
function CG(i, e = Ef()) {
	return e('readonly', (t) => gc(t.get(i)));
}
function RG(i, e, t = Ef()) {
	return t('readwrite', (n) => (n.put(e, i), gc(n.transaction)));
}
function PG(i, e = Ef()) {
	return e('readwrite', (t) => (i.forEach((n) => t.delete(n)), gc(t.transaction)));
}
function LG(i, e) {
	return (
		(i.openCursor().onsuccess = function () {
			this.result && (e(this.result), this.result.continue());
		}),
		gc(i.transaction)
	);
}
function IG(i = Ef()) {
	return i('readonly', (e) => {
		if (e.getAllKeys) return gc(e.getAllKeys());
		const t = [];
		return LG(e, (n) => t.push(n.key)).then(() => t);
	});
}
async function OA(i, e = 'blob', t) {
	const n = ''.concat(i).concat(t ? '@'.concat(t) : ''),
		s = await CG(n);
	if (!s) {
		const r = (await IG()).filter((a) => a.startsWith(i));
		r.length && (await PG(r));
		const o = await fetch(i);
		if (o.ok) {
			const a = await (e === 'blob' ? o.blob() : o.json());
			return await RG(n, a), URL.createObjectURL(a);
		}
	}
	return URL.createObjectURL(s);
}
const Tf = {
	__proto__: null,
	calculateHorizontalFoV: gG,
	calculateVerticalFoV: PA,
	createPromise: DA,
	disposeObject3D: Y0,
	downloadBlob: wG,
	getBounds: j0,
	getCache: OA,
	getCirclePosition: EG,
	getElementViewLeft: SG,
	getElementViewTop: MG,
	hasObject: LA,
	isObjectVisible: IA,
	lonlat2Spherical: TG,
};
var DG = Object.defineProperty,
	OG = (i, e, t) => (e in i ? DG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Uw = (i, e, t) => (OG(i, typeof e != 'symbol' ? e + '' : e, t), t);
let ja = class {
	constructor() {
		Uw(this, 'viz'), Uw(this, 'name', 'Manager');
	}
	install(i) {
		this.viz = i;
	}
	update(i) {}
	setSize(i, e) {}
	dispose() {
		this.viz = void 0;
	}
};
var UG = Object.defineProperty,
	NG = (i, e, t) => (e in i ? UG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	vs = (i, e, t) => (NG(i, typeof e != 'symbol' ? e + '' : e, t), t);
class Cs extends Hi {
	constructor(e = {}) {
		super(),
			// vs(this, 'isComponent', !0),
			// vs(this, 'options', {}),
			// vs(this, 'object3D', new Ui()),
			// vs(this, 'id'),
			// vs(this, 'manager'),
			// vs(this, 'viz'),
			// vs(this, 'userData', {}),
			// vs(this, 'pm', DA()),
			this.isComponent = !0;
			this.options = {};
			this.object3D = new Ui();
			this.id = null;
			this.manager = null;
			this.viz = null;
			this.userData = {};
			this.pm = DA();

			(this.options = e),
			(this.id = e.key || Dn.generateUUID());
	}
	get visible() {
		return IA(this.object3D, this.viz.camera, this.viz.raycaster, this.manager.object3Ds);
	}
	get bound() {
		return j0(this.object3D);
	}
	create() {}
	render() {}
	update(e) {}
	setSize(e, t) {}
	hide() {
		this.object3D.visible = !1;
	}
	show() {
		this.object3D.visible = !0;
	}
	add(e) {
		this.object3D.add(e);
	}
	remove(e) {
		this.object3D.remove(e);
	}
	has(e) {
		return LA(e, this.object3D);
	}
	showBoundingBox(e = '#ff0000') {
		var n, s, r;
		if (!((n = this.viz) != null && n.option.dev)) return;
		const t = new hT(this.bound.bbox, new Ee(e));
		(r = (s = this.viz) == null ? void 0 : s.scene) == null || r.add(t);
	}
	showBoundingSphere(e = '#ff0000') {
		var a, l, c;
		if (!((a = this.viz) != null && a.option.dev)) return;
		const { center: t, radius: n } = this.bound.sphere,
			s = new hc(n, 16, 16),
			r = new En({ color: new Ee(e), wireframe: !0 }),
			o = new bt(s, r);
		o.position.copy(t), (c = (l = this.viz) == null ? void 0 : l.scene) == null || c.add(o);
	}
	dispose() {
		this.object3D.removeFromParent(), Y0(this.object3D), (this.viz = void 0), (this.manager = void 0);
	}
}
class K0 extends ja {
	constructor(e) {
		super(),
			// vs(this, 'name', 'ComponentManager'),
			// vs(this, 'componentMap', new Map()),
			// vs(this, 'instances', []),
			this.name = "ComponentManager";
			this.componentMap = new Map();
			this.instances = [];


			Object.entries(e).forEach(([t, n]) => {
				this.componentMap.set(t, n);
			});
	}
	get componentPromise() {
		return this.instances.map((e) => e.pm.promise);
	}
	get object3Ds() {
		return this.instances.map((e) => e.object3D);
	}
	getInstances(e, t = void 0) {
		return typeof t == 'string'
			? this.instances.find((n) => n.id === ''.concat(e, '#').concat(t))
			: Array.isArray(t) && t.length
			? t.map((n) => this.instances.find((s) => s.id === ''.concat(e, '#').concat(n))).filter(Boolean)
			: this.instances.filter((n) => {
					var s;
					return (s = n.id) == null ? void 0 : s.startsWith(e);
			  });
	}
	getInstance(e, t) {
		return t
			? this.instances.find((n) => n.id === ''.concat(e, '#').concat(t))
			: this.instances.find((n) => {
					var s;
					return (s = n.id) == null ? void 0 : s.startsWith(e);
			  });
	}
	async draw(e, t = {}, n) {
		const s = this.componentMap.get(e);
		if (!s) throw new Error('未找到名为'.concat(e, '的组件'));
		const r = this.viz,
			o = t.key;
		let a = ''.concat(e, '#').concat(Dn.generateUUID());
		o && (a = ''.concat(e, '#').concat(o));
		const l = new s(t);
		(l.id = a), this.instances.push(l), (l.viz = r), (l.manager = this);
		try {
			await l.create();
		} catch (c) {
			l.pm.reject('创建'.concat(e, '时发生错误: ').concat(c));
		}
		return l.render(), l.pm.resolve(), (n = n || r.scene), n == null || n.add(l.object3D), l;
	}
	erase(e, t) {
		const n = typeof e == 'string' ? this.getInstances(e, Array.isArray(t) ? t : [t].filter(Boolean)) : Array.isArray(e) ? e : [e];
		n != null &&
			n.length &&
			n.forEach((s) => {
				s.dispose(), (this.instances = this.instances.filter((r) => r.id !== s.id));
			});
	}
	clear() {
		this.instances.forEach((e) => this.erase(e)), (this.instances = []);
	}
	update(e) {
		this.instances.forEach((t) => t.update(e));
	}
	setSize(e, t) {
		this.instances.forEach((n) => n.setSize(e, t));
	}
	dispose() {
		this.clear(), super.dispose();
	}
}
function FG(i) {
	return {
		all: (i = i || new Map()),
		on: function (e, t) {
			var n = i.get(e);
			n ? n.push(t) : i.set(e, [t]);
		},
		off: function (e, t) {
			var n = i.get(e);
			n && (t ? n.splice(n.indexOf(t) >>> 0, 1) : i.set(e, []));
		},
		emit: function (e, t) {
			var n = i.get(e);
			n &&
				n.slice().map(function (s) {
					s(t);
				}),
				(n = i.get('*')) &&
					n.slice().map(function (s) {
						s(e, t);
					});
		},
	};
}
var BG = Object.defineProperty,
	kG = (i, e, t) => (e in i ? BG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Nw = (i, e, t) => (kG(i, typeof e != 'symbol' ? e + '' : e, t), t);
class zG extends ja {
	constructor() {
		super(), Nw(this, 'name', 'EventManager'), Nw(this, 'emitter', FG());
	}
	on(e, t) {
		this.emitter.on(e, t);
	}
	off(e, t) {
		this.emitter.off(e, t);
	}
	emit(e, t) {
		this.emitter.emit(e, t);
	}
	dispose() {
		this.emitter.all.clear(), super.dispose();
	}
}
var Fw = class {
		constructor(i, e) {
			Je(this, 'target'),
				Je(this, 'name'),
				Je(this, 'intersected'),
				Je(this, 'wasIntersected', !1),
				Je(this, 'wasIntersectedOnMouseDown', !1),
				Je(this, 'distance'),
				(this.target = i),
				(this.name = e),
				(this.intersected = !1),
				(this.distance = 0);
		}
	},
	ui = class {
		constructor(i, e = null) {
			Je(this, 'type'),
				Je(this, 'cancelBubble'),
				Je(this, 'originalEvent'),
				Je(this, 'coords', new ce(0, 0)),
				Je(this, 'distance', 0),
				Je(this, 'intersected', !1),
				Je(this, 'wasIntersected', !1),
				Je(this, 'wasIntersectedOnMouseDown', !1),
				(this.cancelBubble = !1),
				(this.type = i),
				(this.originalEvent = e);
		}
		stopPropagation() {
			this.cancelBubble = !0;
		}
	},
	VG = class {
		constructor(i, e, t, n) {
			Je(this, 'renderer'),
				Je(this, 'camera'),
				Je(this, 'domElement'),
				Je(this, 'bindEventsOnBodyElement'),
				Je(this, 'autoAdd'),
				Je(this, 'scene'),
				Je(this, 'mouse'),
				Je(this, 'supportsPointerEvents'),
				Je(this, 'interactiveObjects'),
				Je(this, 'closestObject'),
				Je(this, 'raycaster'),
				Je(this, 'treatTouchEventsAsMouseEvents'),
				Je(this, 'dispose', () => {
					this.domElement.removeEventListener('click', this.onMouseClick),
						this.supportsPointerEvents &&
							(this.bindEventsOnBodyElement
								? this.domElement.ownerDocument.removeEventListener('pointermove', this.onDocumentPointerMove)
								: this.domElement.removeEventListener('pointermove', this.onDocumentPointerMove),
							this.domElement.removeEventListener('pointerdown', this.onPointerDown),
							this.domElement.removeEventListener('pointerup', this.onPointerUp)),
						this.bindEventsOnBodyElement
							? this.domElement.ownerDocument.removeEventListener('mousemove', this.onDocumentMouseMove)
							: this.domElement.removeEventListener('mousemove', this.onDocumentMouseMove),
						this.domElement.removeEventListener('mousedown', this.onMouseDown),
						this.domElement.removeEventListener('mouseup', this.onMouseUp),
						this.domElement.removeEventListener('touchstart', this.onTouchStart),
						this.domElement.removeEventListener('touchmove', this.onTouchMove),
						this.domElement.removeEventListener('touchend', this.onTouchEnd);
				}),
				Je(this, 'add', (s, r = []) => {
					if (s && !this.interactiveObjects.find((o) => o.target === s))
						if (r.length > 0)
							r.forEach((o) => {
								let a = s.getObjectByName(o);
								if (a) {
									let l = new Fw(a, o);
									this.interactiveObjects.push(l);
								}
							});
						else {
							let o = new Fw(s, s.name);
							this.interactiveObjects.push(o);
						}
				}),
				Je(this, 'remove', (s, r = []) => {
					!s ||
						(r.length > 0
							? r.forEach((o) => {
									let a = s.getObjectByName(o);
									a && (this.interactiveObjects = this.interactiveObjects.filter((l) => l.target !== a));
							  })
							: (this.interactiveObjects = this.interactiveObjects.filter((o) => o.target !== s)));
				}),
				Je(this, 'update', () => {
					var a;
					this.raycaster.setFromCamera(this.mouse, this.camera),
						this.interactiveObjects.forEach((l) => {
							l.target && this.checkIntersection(l);
						}),
						this.interactiveObjects.sort(function (l, c) {
							return l.distance - c.distance;
						});
					let s = (a = this.interactiveObjects.find((l) => l.intersected)) != null ? a : null;
					if (s != this.closestObject) {
						if (this.closestObject) {
							let l = new ui('mouseout');
							this.dispatch(this.closestObject, l);
						}
						if (s) {
							let l = new ui('mouseover');
							this.dispatch(s, l);
						}
						this.closestObject = s;
					}
					let r;
					this.interactiveObjects.forEach((l) => {
						!l.intersected && l.wasIntersected && (r || (r = new ui('mouseleave')), this.dispatch(l, r));
					});
					let o;
					this.interactiveObjects.forEach((l) => {
						l.intersected && !l.wasIntersected && (o || (o = new ui('mouseenter')), this.dispatch(l, o));
					});
				}),
				Je(this, 'checkIntersection', (s) => {
					let r = this.raycaster.intersectObjects([s.target], !0);
					if (((s.wasIntersected = s.intersected), r.length > 0)) {
						let o = r[0].distance;
						r.forEach((a) => {
							a.distance < o && (o = a.distance);
						}),
							(s.intersected = !0),
							(s.distance = o);
					} else s.intersected = !1;
				}),
				Je(this, 'onDocumentMouseMove', (s) => {
					this.mapPositionToPoint(this.mouse, s.clientX, s.clientY);
					let r = new ui('mousemove', s);
					this.interactiveObjects.forEach((o) => {
						this.dispatch(o, r);
					});
				}),
				Je(this, 'onDocumentPointerMove', (s) => {
					this.mapPositionToPoint(this.mouse, s.clientX, s.clientY);
					let r = new ui('pointermove', s);
					this.interactiveObjects.forEach((o) => {
						this.dispatch(o, r);
					});
				}),
				Je(this, 'onTouchMove', (s) => {
					s.touches.length > 0 && this.mapPositionToPoint(this.mouse, s.touches[0].clientX, s.touches[0].clientY);
					let r = new ui(this.treatTouchEventsAsMouseEvents ? 'mousemove' : 'touchmove', s);
					this.interactiveObjects.forEach((o) => {
						this.dispatch(o, r);
					});
				}),
				Je(this, 'onMouseClick', (s) => {
					this.update();
					let r = new ui('click', s);
					this.interactiveObjects.forEach((o) => {
						o.intersected && this.dispatch(o, r);
					});
				}),
				Je(this, 'onMouseDown', (s) => {
					this.mapPositionToPoint(this.mouse, s.clientX, s.clientY), this.update();
					let r = new ui('mousedown', s);
					this.interactiveObjects.forEach((o) => {
						o.intersected ? ((o.wasIntersectedOnMouseDown = !0), this.dispatch(o, r)) : (o.wasIntersectedOnMouseDown = !1);
					});
				}),
				Je(this, 'onPointerDown', (s) => {
					this.mapPositionToPoint(this.mouse, s.clientX, s.clientY), this.update();
					let r = new ui('pointerdown', s);
					this.interactiveObjects.forEach((o) => {
						o.intersected && this.dispatch(o, r);
					});
				}),
				Je(this, 'onTouchStart', (s) => {
					s.touches.length > 0 && this.mapPositionToPoint(this.mouse, s.touches[0].clientX, s.touches[0].clientY), this.update();
					let r = new ui(this.treatTouchEventsAsMouseEvents ? 'mousedown' : 'touchstart', s);
					this.interactiveObjects.forEach((o) => {
						o.intersected && this.dispatch(o, r);
					});
				}),
				Je(this, 'onMouseUp', (s) => {
					let r = new ui('mouseup', s);
					this.interactiveObjects.forEach((o) => {
						this.dispatch(o, r);
					});
				}),
				Je(this, 'onPointerUp', (s) => {
					let r = new ui('pointerup', s);
					this.interactiveObjects.forEach((o) => {
						this.dispatch(o, r);
					});
				}),
				Je(this, 'onTouchEnd', (s) => {
					s.touches.length > 0 && this.mapPositionToPoint(this.mouse, s.touches[0].clientX, s.touches[0].clientY), this.update();
					let r = new ui(this.treatTouchEventsAsMouseEvents ? 'mouseup' : 'touchend', s);
					this.interactiveObjects.forEach((o) => {
						this.dispatch(o, r);
					});
				}),
				Je(this, 'dispatch', (s, r) => {
					s.target &&
						!r.cancelBubble &&
						((r.coords = this.mouse),
						(r.distance = s.distance),
						(r.intersected = s.intersected),
						(r.wasIntersected = s.wasIntersected),
						(r.wasIntersectedOnMouseDown = s.wasIntersectedOnMouseDown),
						s.target.dispatchEvent(r));
				}),
				Je(this, 'mapPositionToPoint', (s, r, o) => {
					let a = this.renderer.domElement.getBoundingClientRect();
					(s.x = ((r - a.left) / a.width) * 2 - 1), (s.y = -((o - a.top) / a.height) * 2 + 1);
				}),
				(this.renderer = i),
				(this.camera = e),
				(this.domElement = t),
				(this.bindEventsOnBodyElement = n && typeof n.bindEventsOnBodyElement < 'u' ? n.bindEventsOnBodyElement : !0),
				(this.scene = n && typeof n.scene < 'u' ? n.scene : null),
				this.scene &&
					(this.scene.onBeforeRender = () => {
						this.autoAdd &&
							this.scene !== null &&
							this.scene.traverse((s) => {
								this.add(s),
									s.addEventListener('removed', (r) => {
										this.remove(r.target);
									});
							}),
							this.update();
					}),
				(this.autoAdd = n && typeof n.autoAdd < 'u' ? n.autoAdd : !1),
				this.autoAdd && this.scene === null && console.error('Attention: Options.scene needs to be set when using options.autoAdd'),
				(this.mouse = new ce(-1, 1)),
				(this.supportsPointerEvents = !!window.PointerEvent),
				(this.interactiveObjects = []),
				(this.closestObject = null),
				(this.raycaster = new e0()),
				t.addEventListener('click', this.onMouseClick),
				this.supportsPointerEvents &&
					(this.bindEventsOnBodyElement
						? t.ownerDocument.addEventListener('pointermove', this.onDocumentPointerMove)
						: t.addEventListener('pointermove', this.onDocumentPointerMove),
					t.addEventListener('pointerdown', this.onPointerDown),
					t.addEventListener('pointerup', this.onPointerUp)),
				this.bindEventsOnBodyElement
					? t.ownerDocument.addEventListener('mousemove', this.onDocumentMouseMove)
					: t.addEventListener('mousemove', this.onDocumentMouseMove),
				t.addEventListener('mousedown', this.onMouseDown),
				t.addEventListener('mouseup', this.onMouseUp),
				t.addEventListener('touchstart', this.onTouchStart, { passive: !0 }),
				t.addEventListener('touchmove', this.onTouchMove, { passive: !0 }),
				t.addEventListener('touchend', this.onTouchEnd, { passive: !0 }),
				(this.treatTouchEventsAsMouseEvents = !0);
		}
	},
	HG = Object.defineProperty,
	GG = (i, e, t) => (e in i ? HG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Bw = (i, e, t) => (GG(i, typeof e != 'symbol' ? e + '' : e, t), t);
class WG extends ja {
	constructor(e, t) {
		super(), Bw(this, 'name', 'InteractionManager'), Bw(this, 'im'), (this.im = new VG(e, t, e.domElement));
	}
	update() {
		this.im.update();
	}
	dispose() {
		super.dispose(), this.im.dispose();
	}
}
var XG = Object.defineProperty,
	qG = (i, e, t) => (e in i ? XG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	kw = (i, e, t) => (qG(i, typeof e != 'symbol' ? e + '' : e, t), t);
class YG extends ja {
	constructor() {
		super(), kw(this, 'name', 'GuiManager'), kw(this, 'pane');
		const e = document.createElement('div');
		(e.style.position = 'absolute'),
			(e.style.top = '8px'),
			(e.style.right = '8px'),
			(e.style.bottom = '8px'),
			(e.style.width = '256px'),
			(e.style.zIndex = '9999'),
			(e.style.overflowY = 'auto'),
			document.body.appendChild(e),
			(this.pane = new W4({ title: '控制面板', container: e }));
	}
	addFolder(e, t, n = !1) {
		const s = this.pane.addFolder({ title: e });
		return (
			Object.keys(t).forEach((r) => {
				this.addBinding(r, t[r], s);
			}),
			(s.expanded = n),
			s
		);
	}
	addBinding(e, t, n) {
		const { value: s, label: r, min: o, max: a, step: l, options: c, target: h, onChange: u } = t,
			d = h ? h() : { [e]: s },
			p = e.toLowerCase().includes('color'),
			g = d[e] instanceof ce || d[e] instanceof I;
		let v;
		const m = n != null ? n : this.pane;
		return (
			p
				? (v = m.addBinding(d, e, { label: r != null ? r : e, color: { type: 'float' } }))
				: g
				? (v = this.addPoint(e, d, o, a, l, r, m))
				: (v = m.addBinding(d, e, {
						label: r != null ? r : e,
						min: o,
						max: a,
						step: l,
						options: c == null ? void 0 : c.map((f) => (typeof f == 'string' ? { text: f, value: f } : f)),
				  })),
			v.on('change', (f) => (u == null ? void 0 : u(f.value))),
			v
		);
	}
	addPoint(e, t, n, s, r, o, a) {
		const l = a != null ? a : this.pane,
			c = Object.keys(t[e]).reduce((h, u) => ((h[u] = { min: n, max: s, step: r }), h), {});
		return l.addBinding(t, e, { label: o != null ? o : e, ...c });
	}
	addButton(e, t, n) {
		(n != null ? n : this.pane).addButton({ title: e }).on('click', t);
	}
	exportConfig() {
		const e = this.pane.exportState(),
			t = new Blob([JSON.stringify(e, null, 2)], { type: 'application/json' }),
			n = URL.createObjectURL(t),
			s = document.createElement('a');
		(s.href = n),
			(s.download = 'config.json'),
			document.body.appendChild(s),
			s.click(),
			document.body.removeChild(s),
			URL.revokeObjectURL(n);
	}
	importConfig(e) {
		this.pane.importState(JSON.parse(e));
	}
	findFolder(e) {
		return this.pane.children.find((t) => t.title === e);
	}
	update() {}
	dispose() {
		this.pane.dispose(), super.dispose();
	}
}
var jG = Object.defineProperty,
	KG = (i, e, t) => (e in i ? jG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	zw = (i, e, t) => (KG(i, typeof e != 'symbol' ? e + '' : e, t), t);
class $G extends ja {
	constructor() {
		super(...arguments), zw(this, 'name', 'CacheManager'), zw(this, 'cache', {});
	}
	set(e, t) {
		this.cache[e] = t;
	}
	get(e) {
		return this.cache[e];
	}
	has(e) {
		return e in this.cache;
	}
	remove(e) {
		delete this.cache[e];
	}
	clear() {
		this.cache = {};
	}
	dispose() {
		super.dispose(), this.clear();
	}
}
var ZG = Object.defineProperty,
	JG = (i, e, t) => (e in i ? ZG(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	El = (i, e, t) => (JG(i, typeof e != 'symbol' ? e + '' : e, t), t);
function Vw(i, e) {
	return ''.concat(i.replace(/\/$/, ''), '/').concat(e.replace(/^\//, ''));
}
class QG extends ja {
	constructor() {
		super(),
			El(this, 'name', 'AssetManager'),
			El(this, 'assetStore', new Map()),
			El(this, 'assetMap', new Map()),
			El(this, 'loadingManager', new pf()),
			El(this, 'loaders', {
				gltf: new fF(this.loadingManager),
				texture: new ff(this.loadingManager),
				json: new Si(this.loadingManager),
				hdr: new KF(this.loadingManager),
				exr: new $F(this.loadingManager),
			}),
			El(this, 'dracoLoader', new ZF()),
			(Hs.enabled = !0);
	}
	get total() {
		return Array.from(this.assetMap.values()).length;
	}
	get loaded() {
		return Array.from(this.assetMap.values()).filter((e) => e.loaded).length;
	}
	get progress() {
		return this.total === 0 ? 1 : this.loaded / this.total;
	}
	get isLoaded() {
		return this.total === 0 ? !0 : this.loaded === this.total;
	}
	get staticPath() {
		var e;
		return ((e = this.viz) == null ? void 0 : e.option.staticPath) || '';
	}
	setDracoPath(e) {
		this.dracoLoader.setDecoderPath(e), this.dracoLoader.preload(), this.loaders.gltf.setDRACOLoader(this.dracoLoader);
	}
	setAsset(e) {
		Array.isArray(e) || (e = [e]),
			e.forEach((t) => {
				this.assetMap.set(t.url, t);
			});
	}
	load() {
		return (
			this.setDracoPath(Vw(this.staticPath, '/draco/gltf/')),
			Promise.all(
				Array.from(this.assetMap.keys()).map((e) => {
					const t = this.assetMap.get(e);
					return t ? this.loadAsset(t) : (console.error('Asset '.concat(e, ' not found')), Promise.resolve());
				})
			)
		);
	}
	getAssetUrl(e) {
		debugger
		var s = e.startsWith(this.staticPath) ? e : Vw(this.staticPath, e);
		console.log(s);
		// 这里把资源放置到自己的静态服务器上

		return s;
	}
	async loadAsset(e) {
		const { url: t, version: n, type: s } = e;
		console.log(e);
		if (this.assetStore.has(t)) return this.assetStore.get(t);
		let r = this.getAssetUrl(t);
		n && (r = await OA(r, s === 'json' ? 'json' : 'blob', n));
		let o = Promise.resolve();
		return (
			s === 'video'
				? (o = this.loadVideoTexture(e))
				: (o = new Promise((a, l) => {
						this.loaders[s].load(
							r,
							(c) => {
								this.assetLoaded(t), a(s === 'json' ? JSON.parse(c) : c);
							},
							void 0,
							l
						);
				  })),
			this.assetStore.set(t, o),
			o
		);
	}
	async loadVideoTexture(e) {
		const { url: t } = e,
			n = new Promise((s, r) => {
				const o = document.createElement('video');
				(o.src = this.getAssetUrl(t)), (o.loop = !0), (o.muted = !0), (o.autoplay = !0), (o.preload = 'auto');
				const a = new TE(o);
				(a.colorSpace = ot),
					o.addEventListener('canplaythrough', () => {
						o.play(), this.assetLoaded(t), s(a);
					}),
					(o.onerror = r);
			});
		return this.assetStore.set(t, n), n;
	}
	assetLoaded(e) {
		var n, s;
		const t = this.assetMap.get(e);
		t &&
			((t.loaded = !0),
			(n = this.viz) == null || n.eventManager.emit('progress', this.progress),
			(s = this.viz) == null || s.eventManager.emit('loaded', this.isLoaded));
	}
	async getAsset(e) {
		return this.assetStore.get(e);
	}
	dispose() {
		this.assetStore.clear(), this.assetMap.clear(), this.dracoLoader.dispose();
	}
}
var eW = Object.defineProperty,
	tW = (i, e, t) => (e in i ? eW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Cd = (i, e, t) => (tW(i, typeof e != 'symbol' ? e + '' : e, t), t);
class nW extends ja {
	constructor() {
		super(), Cd(this, 'name', 'LightManager'), Cd(this, 'dirLights', []), Cd(this, 'spotLights', []), Cd(this, 'hemiSphereLights', []);
	}
	createAmbientLight(e = 16777215, t = 1) {
		var s, r;
		const n = new K_(e, t);
		return (r = (s = this.viz) == null ? void 0 : s.scene) == null || r.add(n), n;
	}
	createSpotLight(e = {}) {
		var p, g, v, m, f, y, _;
		const {
				color: t = 16777215,
				intensity: n = 1,
				distance: s = 0,
				angle: r = Math.PI / 3,
				penumbra: o = 0,
				decay: a = 1,
				position: l = new I(0, 0, 0),
				target: c = new I(0, 0, 0),
				helper: h = !1,
			} = e,
			u = new mf(new Ee(t), n, s, r, o, a);
		u.position.copy(l),
			u.target.position.copy(c),
			(g = (p = this.viz) == null ? void 0 : p.scene) == null || g.add(u),
			(m = (v = this.viz) == null ? void 0 : v.scene) == null || m.add(u.target);
		let d;
		if (
			(h && ((d = new oT(u)), (y = (f = this.viz) == null ? void 0 : f.scene) == null || y.add(d)),
			(_ = this.viz) == null ? void 0 : _.guiManager)
		) {
			const x = this.viz.guiManager.addFolder('聚光灯-'.concat(this.spotLights.length), {
				color: {
					label: '灯光颜色',
					value: t,
					onChange: (E) => {
						u.color.set(E), d == null || d.update();
					},
				},
				intensity: {
					label: '灯光强度',
					value: n,
					min: 0,
					max: 100,
					step: 0.01,
					onChange: (E) => {
						(u.intensity = E), d == null || d.update();
					},
				},
				distance: {
					label: '灯光距离',
					value: s,
					min: 0,
					max: 1e3,
					step: 1,
					onChange: (E) => {
						(u.distance = E), d == null || d.update();
					},
				},
				angle: {
					label: '灯光角度',
					value: r,
					min: 0,
					max: Math.PI / 2,
					step: 0.01,
					onChange: (E) => {
						(u.angle = E), d == null || d.update();
					},
				},
				penumbra: {
					label: '灯光边缘软化',
					value: o,
					min: 0,
					max: 1,
					step: 0.01,
					onChange: (E) => {
						(u.penumbra = E), d == null || d.update();
					},
				},
				decay: {
					label: '灯光衰减',
					value: a,
					min: 0,
					max: 2,
					step: 0.01,
					onChange: (E) => {
						(u.decay = E), d == null || d.update();
					},
				},
				position: {
					label: '灯光位置',
					target: () => u,
					min: -500,
					max: 500,
					step: 0.1,
					onChange: () => {
						d == null || d.update();
					},
				},
				target: {
					label: '灯光目标',
					value: c,
					min: -500,
					max: 500,
					step: 0.1,
					onChange: (E) => {
						u.target.position.copy(E), d == null || d.update();
					},
				},
			});
			x.expanded = !1;
		}
		return this.spotLights.push({ light: u, helper: d }), u;
	}
	createDirectionalLight(e = {}) {
		var c, h, u, d, p, g, v;
		const { color: t = '#ffffff', intensity: n = 1, position: s = new I(0, 0, 1), target: r = new I(0, 0, 0), helper: o = !1 } = e,
			a = new gf(t, n);
		a.position.copy(s),
			a.target.position.copy(r),
			(h = (c = this.viz) == null ? void 0 : c.scene) == null || h.add(a),
			(d = (u = this.viz) == null ? void 0 : u.scene) == null || d.add(a.target);
		let l;
		if (
			(o && ((l = new cT(a)), (g = (p = this.viz) == null ? void 0 : p.scene) == null || g.add(l)),
			(v = this.viz) == null ? void 0 : v.guiManager)
		) {
			const m = this.viz.guiManager.addFolder('平行光-'.concat(this.dirLights.length), {
				color: {
					label: '灯光颜色',
					value: t,
					onChange: (f) => {
						a.color.set(f), l == null || l.update();
					},
				},
				intensity: {
					label: '灯光强度',
					value: n,
					min: 0,
					max: 10,
					step: 0.01,
					onChange: (f) => {
						(a.intensity = f), l == null || l.update();
					},
				},
				position: {
					label: '灯光位置',
					target: () => a,
					min: -500,
					max: 500,
					step: 0.1,
					onChange: () => {
						l == null || l.update();
					},
				},
				target: {
					label: '灯光目标',
					value: r,
					min: -500,
					max: 500,
					step: 0.1,
					onChange: (f) => {
						a.target.position.copy(f), l == null || l.update();
					},
				},
			});
			m.expanded = !1;
		}
		return this.dirLights.push({ light: a, helper: l }), a;
	}
	createHemisphereLight(e = {}) {
		var c, h, u, d, p;
		const { skyColor: t = '#ffffff', groundColor: n = '#ffffff', intensity: s = 1, position: r = new I(0, 0, 0), helper: o = !1 } = e,
			a = new q_(t, n, s);
		a.position.copy(r), (h = (c = this.viz) == null ? void 0 : c.scene) == null || h.add(a);
		let l;
		if (
			(o && ((l = new lT(a, 5)), (d = (u = this.viz) == null ? void 0 : u.scene) == null || d.add(l)),
			(p = this.viz) == null ? void 0 : p.guiManager)
		) {
			const g = this.viz.guiManager.addFolder('半球光-'.concat(this.hemiSphereLights.length), {
				skyColor: {
					label: '天空颜色',
					value: t,
					onChange: (v) => {
						a.color.set(v), l == null || l.update();
					},
				},
				groundColor: {
					label: '地面颜色',
					value: n,
					onChange: (v) => {
						a.groundColor.set(v), l == null || l.update();
					},
				},
				intensity: {
					label: '灯光强度',
					value: s,
					min: 0,
					max: 10,
					step: 0.01,
					onChange: (v) => {
						(a.intensity = v), l == null || l.update();
					},
				},
				position: {
					label: '灯光位置',
					target: () => a,
					min: -500,
					max: 500,
					step: 0.1,
					onChange: () => {
						l == null || l.update();
					},
				},
			});
			g.expanded = !1;
		}
		return this.hemiSphereLights.push({ light: a, helper: l }), a;
	}
	dispose() {
		super.dispose(),
			this.dirLights.forEach(({ light: e, helper: t }) => {
				e.dispose(), t == null || t.dispose();
			}),
			this.spotLights.forEach(({ light: e, helper: t }) => {
				e.dispose(), t == null || t.dispose();
			}),
			this.hemiSphereLights.forEach(({ light: e, helper: t }) => {
				e.dispose(), t == null || t.dispose();
			}),
			(this.dirLights.length = 0),
			(this.spotLights.length = 0),
			(this.hemiSphereLights.length = 0);
	}
}
var iW = Object.defineProperty,
	sW = (i, e, t) => (e in i ? iW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	fs = (i, e, t) => (sW(i, typeof e != 'symbol' ? e + '' : e, t), t);
const rW = { staticPath: '/', gui: !0, stats: !0, axis: !0 };
class $0 {
	constructor(e, t) {
		fs(this, 'option'),
			fs(this, 'scene'),
			fs(this, 'renderer'),
			fs(this, 'cssRenderer', []),
			fs(this, 'cameraControl'),
			fs(this, 'composerController'),
			fs(this, 'managerMap', new Map()),
			fs(this, 'stats'),
			fs(this, 'resizeObserver'),
			fs(this, 'raycaster', new e0()),
			fs(this, 'animationFrames', []),
			(this.option = { ...rW, ...e }),
			t &&
				Object.entries(t).forEach(([n, s]) => {
					this.registerManager(n, s);
				}),
			this.registerManager('event', new zG()),
			this.registerManager('cache', new $G()),
			this.registerManager('asset', new QG()),
			// 添加gui面板
			this.option.dev && this.option.gui && this.registerManager('gui', new YG()),
			this.init(),
			this.registerManager('interaction', new WG(this.renderer, this.camera));
	}
	get camera() {
		var e;
		return (e = this.cameraControl) == null ? void 0 : e.camera;
	}
	get eventManager() {
		return this.getManager('event');
	}
	get interactionManager() {
		return this.getManager('interaction').im;
	}
	get guiManager() {
		return this.getManager('gui');
	}
	get assetManager() {
		return this.getManager('asset');
	}
	get cacheManager() {
		return this.getManager('cache');
	}
	get bound() {
		return j0(this.scene);
	}
	init() {
		const { dev: e, stats: t, axis: n, container: s, cssRenderer: r, scene: o, renderer: a, camera: l, composer: c } = this.option,
			h = dG(o);
		this.scene = h;
		const { width: u, height: d } = this.getSize(),
			p = pG({ ...a, dev: e, width: u, height: d });
		s.appendChild(p.domElement),
			(this.renderer = p),
			(this.cssRenderer = mG(u, d, r)),
			this.cssRenderer.forEach((m) => {
				s.appendChild(m.domElement);
			});
		const g = vG({ width: u, height: d, domElement: s, ...l });
		(this.cameraControl = g), (this.composerController = new bG({ renderer: p, scene: h, camera: g.camera, ...c }));
		const v = new ResizeObserver((m) => {
			for (const f of m) {
				const { width: y, height: _ } = f.contentRect;
				this.resize(y, _);
			}
		});
		debugger;
		if ((v.observe(s), (this.resizeObserver = v), this.resize(u, d), e)) {
			if (n) {
				const m = new uT(5);
				h.add(m);
			}
			if (t) {
				const m = new uG();
				m.showPanel(0), document.body.appendChild(m.dom), (this.stats = m);
			}
			this.guiManager && (fG(this.guiManager, p), _G(this.guiManager, g)),
				(window.getCPCT = () => {
					const m = this.getCameraPosition(),
						f = this.getCameraTarget();
					console.log('position:', m), console.log('target:', f);
				});
		}
	}
	registerManager(e, t) {
		t.install(this), this.managerMap.set(e, t);
	}
	unregisterManager(e) {
		const t = this.managerMap.get(e);
		t && (t.dispose(), this.managerMap.delete(e));
	}
	getManager(e) {
		return this.managerMap.get(e);
	}
	pick(e, t) {
		return this.raycaster.setFromCamera(this.interactionManager.mouse, this.camera), this.raycaster.intersectObjects(e, t);
	}
	getSize() {
		const { width: e, height: t } = this.option.container.getBoundingClientRect();
		return { width: e, height: t };
	}
	getCameraPosition() {
		var t;
		const e = new I();
		return (t = this.cameraControl) == null || t.getPosition(e), e;
	}
	getCameraTarget() {
		var t;
		const e = new I();
		return (t = this.cameraControl) == null || t.getTarget(e), e;
	}
	render(e) {
		var t, n, s, r;
		this.managerMap.forEach((o) => o.update(e)),
			(t = this.cameraControl) == null || t.update(e),
			(n = this.stats) == null || n.update(),
			(r = (s = this.composerController) == null ? void 0 : s.composer) == null || r.render(),
			this.cssRenderer.forEach((o) => {
				o.render(this.scene, this.camera);
			});
	}
	resize(e, t) {
		var n;
		this.managerMap.forEach((s) => s.setSize(e, t)),
			(this.camera.aspect = e / t),
			this.camera.updateProjectionMatrix(),
			(n = this.composerController) == null || n.composer.setSize(e, t),
			this.cssRenderer.forEach((s) => {
				s.setSize(e, t);
			});
	}
	start(e) {
		var n;
		const t = new Z_();
		(n = this.renderer) == null ||
			n.setAnimationLoop(() => {
				const s = t.getDelta();
				this.render(s), e == null || e(s), this.animationFrames.forEach((r) => r(s));
			});
	}
	requestAnimationFrame(e, t = {}) {
		const { once: n = !1, duration: s = 1 / 0 } = t;
		let r;
		const o = (a) => {
			r || (r = performance.now());
			const l = performance.now() - r;
			e(a), (n || l > s) && (this.animationFrames = this.animationFrames.filter((c) => c !== o));
		};
		this.animationFrames.push(o);
	}
	stop() {
		var e;
		(e = this.renderer) == null || e.setAnimationLoop(null);
	}
	dispose() {
		var e, t, n, s, r;
		this.stop(),
			(e = this.resizeObserver) == null || e.disconnect(),
			(this.resizeObserver = void 0),
			Array.from(this.managerMap.keys()).forEach((o) => this.unregisterManager(o)),
			(t = this.cameraControl) == null || t.dispose(),
			(this.cameraControl = void 0),
			this.managerMap.clear(),
			(n = this.composerController) == null || n.dispose(),
			(this.composerController = void 0),
			(s = this.renderer) == null || s.dispose(),
			(this.renderer = void 0),
			(this.scene = void 0),
			(r = this.stats) == null || r.dom.remove(),
			(this.stats = void 0);
	}
}
var oW = Object.defineProperty,
	aW = (i, e, t) => (e in i ? oW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	ti = (i, e, t) => (aW(i, typeof e != 'symbol' ? e + '' : e, t), t);
function sg(i, e, t, n, s) {
	let r;
	if (
		((i = i.subarray || i.slice ? i : i.buffer),
		(t = t.subarray || t.slice ? t : t.buffer),
		(i = e ? (i.subarray ? i.subarray(e, s && e + s) : i.slice(e, s && e + s)) : i),
		t.set)
	)
		t.set(i, n);
	else for (r = 0; r < i.length; r++) t[r + n] = i[r];
	return t;
}
function lW(i) {
	return i instanceof Float32Array
		? i
		: i instanceof Ze
		? i.getAttribute('position').array
		: i
				.map((e) => {
					const t = Array.isArray(e);
					return e instanceof I
						? [e.x, e.y, e.z]
						: e instanceof ce
						? [e.x, e.y, 0]
						: t && e.length === 3
						? [e[0], e[1], e[2]]
						: t && e.length === 2
						? [e[0], e[1], 0]
						: e;
				})
				.flat();
}
class cW extends Ze {
	constructor() {
		super(),
			ti(this, 'type', 'MeshLine'),
			ti(this, 'isMeshLine', !0),
			ti(this, 'positions', []),
			ti(this, 'previous', []),
			ti(this, 'next', []),
			ti(this, 'side', []),
			ti(this, 'width', []),
			ti(this, 'indices_array', []),
			ti(this, 'uvs', []),
			ti(this, 'counters', []),
			ti(this, 'widthCallback', null),
			ti(this, '_attributes'),
			ti(this, '_points', []),
			ti(this, 'points'),
			ti(this, 'matrixWorld', new He()),
			Object.defineProperties(this, {
				points: {
					enumerable: !0,
					get() {
						return this._points;
					},
					set(e) {
						this.setPoints(e, this.widthCallback);
					},
				},
			});
	}
	setMatrixWorld(e) {
		this.matrixWorld = e;
	}
	setPoints(e, t) {
		if (
			((e = lW(e)),
			(this._points = e),
			(this.widthCallback = t != null ? t : null),
			(this.positions = []),
			(this.counters = []),
			e.length && e[0] instanceof I)
		)
			for (let n = 0; n < e.length; n++) {
				const s = e[n],
					r = n / (e.length - 1);
				this.positions.push(s.x, s.y, s.z), this.positions.push(s.x, s.y, s.z), this.counters.push(r), this.counters.push(r);
			}
		else
			for (let n = 0; n < e.length; n += 3) {
				const s = n / (e.length - 1);
				this.positions.push(e[n], e[n + 1], e[n + 2]),
					this.positions.push(e[n], e[n + 1], e[n + 2]),
					this.counters.push(s),
					this.counters.push(s);
			}
		this.process();
	}
	compareV3(e, t) {
		const n = e * 6,
			s = t * 6;
		return (
			this.positions[n] === this.positions[s] &&
			this.positions[n + 1] === this.positions[s + 1] &&
			this.positions[n + 2] === this.positions[s + 2]
		);
	}
	copyV3(e) {
		const t = e * 6;
		return [this.positions[t], this.positions[t + 1], this.positions[t + 2]];
	}
	process() {
		const e = this.positions.length / 6;
		(this.previous = []), (this.next = []), (this.side = []), (this.width = []), (this.indices_array = []), (this.uvs = []);
		let t, n;
		this.compareV3(0, e - 1) ? (n = this.copyV3(e - 2)) : (n = this.copyV3(0)),
			this.previous.push(n[0], n[1], n[2]),
			this.previous.push(n[0], n[1], n[2]);
		for (let s = 0; s < e; s++) {
			if (
				(this.side.push(1),
				this.side.push(-1),
				this.widthCallback ? (t = this.widthCallback(s / (e - 1))) : (t = 1),
				this.width.push(t),
				this.width.push(t),
				this.uvs.push(s / (e - 1), 0),
				this.uvs.push(s / (e - 1), 1),
				s < e - 1)
			) {
				(n = this.copyV3(s)), this.previous.push(n[0], n[1], n[2]), this.previous.push(n[0], n[1], n[2]);
				const r = s * 2;
				this.indices_array.push(r, r + 1, r + 2), this.indices_array.push(r + 2, r + 1, r + 3);
			}
			s > 0 && ((n = this.copyV3(s)), this.next.push(n[0], n[1], n[2]), this.next.push(n[0], n[1], n[2]));
		}
		this.compareV3(e - 1, 0) ? (n = this.copyV3(1)) : (n = this.copyV3(e - 1)),
			this.next.push(n[0], n[1], n[2]),
			this.next.push(n[0], n[1], n[2]),
			!this._attributes || this._attributes.position.count !== this.counters.length
				? (this._attributes = {
						position: new $e(new Float32Array(this.positions), 3),
						previous: new $e(new Float32Array(this.previous), 3),
						next: new $e(new Float32Array(this.next), 3),
						side: new $e(new Float32Array(this.side), 1),
						width: new $e(new Float32Array(this.width), 1),
						uv: new $e(new Float32Array(this.uvs), 2),
						index: new $e(new Uint16Array(this.indices_array), 1),
						counters: new $e(new Float32Array(this.counters), 1),
				  })
				: (this._attributes.position.copyArray(new Float32Array(this.positions)),
				  (this._attributes.position.needsUpdate = !0),
				  this._attributes.previous.copyArray(new Float32Array(this.previous)),
				  (this._attributes.previous.needsUpdate = !0),
				  this._attributes.next.copyArray(new Float32Array(this.next)),
				  (this._attributes.next.needsUpdate = !0),
				  this._attributes.side.copyArray(new Float32Array(this.side)),
				  (this._attributes.side.needsUpdate = !0),
				  this._attributes.width.copyArray(new Float32Array(this.width)),
				  (this._attributes.width.needsUpdate = !0),
				  this._attributes.uv.copyArray(new Float32Array(this.uvs)),
				  (this._attributes.uv.needsUpdate = !0),
				  this._attributes.index.copyArray(new Uint16Array(this.indices_array)),
				  (this._attributes.index.needsUpdate = !0)),
			this.setAttribute('position', this._attributes.position),
			this.setAttribute('previous', this._attributes.previous),
			this.setAttribute('next', this._attributes.next),
			this.setAttribute('side', this._attributes.side),
			this.setAttribute('width', this._attributes.width),
			this.setAttribute('uv', this._attributes.uv),
			this.setAttribute('counters', this._attributes.counters),
			this.setAttribute('position', this._attributes.position),
			this.setAttribute('previous', this._attributes.previous),
			this.setAttribute('next', this._attributes.next),
			this.setAttribute('side', this._attributes.side),
			this.setAttribute('width', this._attributes.width),
			this.setAttribute('uv', this._attributes.uv),
			this.setAttribute('counters', this._attributes.counters),
			this.setIndex(this._attributes.index),
			this.computeBoundingSphere(),
			this.computeBoundingBox();
	}
	advance({ x: e, y: t, z: n }) {
		const s = this._attributes.position.array,
			r = this._attributes.previous.array,
			o = this._attributes.next.array,
			a = s.length;
		sg(s, 0, r, 0, a),
			sg(s, 6, s, 0, a - 6),
			(s[a - 6] = e),
			(s[a - 5] = t),
			(s[a - 4] = n),
			(s[a - 3] = e),
			(s[a - 2] = t),
			(s[a - 1] = n),
			sg(s, 6, o, 0, a - 6),
			(o[a - 6] = e),
			(o[a - 5] = t),
			(o[a - 4] = n),
			(o[a - 3] = e),
			(o[a - 2] = t),
			(o[a - 1] = n),
			(this._attributes.position.needsUpdate = !0),
			(this._attributes.previous.needsUpdate = !0),
			(this._attributes.next.needsUpdate = !0);
	}
}
function hW(i, e) {
	const t = new He(),
		n = new ka(),
		s = new un(),
		r = new I(),
		o = this.geometry;
	if ((s.copy(o.boundingSphere), s.applyMatrix4(this.matrixWorld), !i.ray.intersectSphere(s, r))) return;
	t.copy(this.matrixWorld).invert(), n.copy(i.ray).applyMatrix4(t);
	const a = new I(),
		l = new I(),
		c = new I(),
		h = this instanceof as ? 2 : 1,
		u = o.index,
		d = o.attributes;
	if (u !== null) {
		const p = u.array,
			g = d.position.array,
			v = d.width.array;
		for (let m = 0, f = p.length - 1; m < f; m += h) {
			const y = p[m],
				_ = p[m + 1];
			a.fromArray(g, y * 3), l.fromArray(g, _ * 3);
			const x = v[Math.floor(m / 3)] !== void 0 ? v[Math.floor(m / 3)] : 1,
				E = i.params.Line.threshold + (this.material.lineWidth * x) / 2,
				w = E * E;
			if (n.distanceSqToSegment(a, l, r, c) > w) continue;
			r.applyMatrix4(this.matrixWorld);
			const C = i.ray.origin.distanceTo(r);
			C < i.near ||
				C > i.far ||
				(e.push({
					distance: C,
					point: c.clone().applyMatrix4(this.matrixWorld),
					index: m,
					face: null,
					faceIndex: void 0,
					object: this,
				}),
				(m = f));
		}
	}
}
var uW = Object.defineProperty,
	dW = (i, e, t) => (e in i ? uW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Fn = (i, e, t) => (dW(i, typeof e != 'symbol' ? e + '' : e, t), t);
const pW =
		'\n  #include <common>\n  #include <logdepthbuf_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n\n  attribute vec3 previous;\n  attribute vec3 next;\n  attribute float side;\n  attribute float width;\n  attribute float counters;\n\n  uniform vec2 resolution;\n  uniform float lineWidth;\n  uniform vec3 color;\n  uniform float opacity;\n  uniform float sizeAttenuation;\n\n  varying vec2 vUV;\n  varying vec4 vColor;\n  varying float vCounters;\n\n  vec2 fix(vec4 i, float aspect) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n  }\n\n  void main() {\n    float aspect = resolution.x / resolution.y;\n    vColor = vec4(color, opacity);\n    vUV = uv;\n    vCounters = counters;\n\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec4 finalPosition = m * vec4(position, 1.0) * aspect;\n    vec4 prevPos = m * vec4(previous, 1.0);\n    vec4 nextPos = m * vec4(next, 1.0);\n\n    vec2 currentP = fix(finalPosition, aspect);\n    vec2 prevP = fix(prevPos, aspect);\n    vec2 nextP = fix(nextPos, aspect);\n\n    float w = lineWidth * width;\n\n    vec2 dir;\n    if (nextP == currentP) dir = normalize(currentP - prevP);\n    else if (prevP == currentP) dir = normalize(nextP - currentP);\n    else {\n      vec2 dir1 = normalize(currentP - prevP);\n      vec2 dir2 = normalize(nextP - currentP);\n      dir = normalize(dir1 + dir2);\n\n      vec2 perp = vec2(-dir1.y, dir1.x);\n      vec2 miter = vec2(-dir.y, dir.x);\n      //w = clamp(w / dot(miter, perp), 0., 4. * lineWidth * width);\n    }\n\n    //vec2 normal = (cross(vec3(dir, 0.), vec3(0., 0., 1.))).xy;\n    vec4 normal = vec4(-dir.y, dir.x, 0., 1.);\n    normal.xy *= .5 * w;\n    //normal *= projectionMatrix;\n    if (sizeAttenuation == 0.) {\n      normal.xy *= finalPosition.w;\n      normal.xy /= (vec4(resolution, 0., 1.) * projectionMatrix).xy * aspect;\n    }\n\n    finalPosition.xy += normal.xy * side;\n    gl_Position = finalPosition;\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    #include <clipping_planes_vertex>\n    #include <fog_vertex>\n  }\n',
	fW = Number.parseInt(Co.replace(/\D+/g, '')),
	mW = fW >= 154 ? 'colorspace_fragment' : 'encodings_fragment',
	gW =
		'\n  #include <fog_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n\n  uniform sampler2D map;\n  uniform sampler2D alphaMap;\n  uniform float useGradient;\n  uniform float useMap;\n  uniform float useAlphaMap;\n  uniform float useDash;\n  uniform float dashArray;\n  uniform float dashOffset;\n  uniform float dashRatio;\n  uniform float visibility;\n  uniform float alphaTest;\n  uniform vec2 repeat;\n  uniform vec2 offset;\n  uniform vec3 gradient[2];\n\n  varying vec2 vUV;\n  varying vec4 vColor;\n  varying float vCounters;\n\n  void main() {\n    #include <logdepthbuf_fragment>\n    vec4 diffuseColor = vColor;\n    if (useGradient == 1.) diffuseColor = vec4(mix(gradient[0], gradient[1], vCounters), 1.0);\n    if (useMap == 1.) diffuseColor *= texture2D(map, vUV * repeat + offset);\n    if (useAlphaMap == 1.) diffuseColor.a *= texture2D(alphaMap, vUV * repeat + offset).a;\n    if (diffuseColor.a < alphaTest) discard;\n    if (useDash == 1.) diffuseColor.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\n    diffuseColor.a *= step(vCounters, visibility);\n    #include <clipping_planes_fragment>\n    gl_FragColor = diffuseColor;\n    #include <fog_fragment>\n    #include <tonemapping_fragment>\n    #include <'.concat(
			mW,
			'>\n  }\n'
		);
class Hw extends xn {
	constructor(e) {
		super({
			uniforms: {
				...Pe.fog,
				lineWidth: { value: 1 },
				map: { value: null },
				useMap: { value: 0 },
				alphaMap: { value: null },
				useAlphaMap: { value: 0 },
				color: { value: new Ee(16777215) },
				gradient: { value: [new Ee(16711680), new Ee(65280)] },
				opacity: { value: 1 },
				resolution: { value: new ce(1, 1) },
				sizeAttenuation: { value: 1 },
				dashArray: { value: 0 },
				dashOffset: { value: 0 },
				dashRatio: { value: 0.5 },
				useDash: { value: 0 },
				useGradient: { value: 0 },
				visibility: { value: 1 },
				alphaTest: { value: 0 },
				repeat: { value: new ce(1, 1) },
				offset: { value: new ce(0, 0) },
			},
			vertexShader: pW,
			fragmentShader: gW,
		}),
			Fn(this, 'lineWidth'),
			Fn(this, 'map'),
			Fn(this, 'useMap'),
			Fn(this, 'alphaMap'),
			Fn(this, 'useAlphaMap'),
			Fn(this, 'color'),
			Fn(this, 'gradient'),
			Fn(this, 'resolution'),
			Fn(this, 'sizeAttenuation'),
			Fn(this, 'dashArray'),
			Fn(this, 'dashOffset'),
			Fn(this, 'dashRatio'),
			Fn(this, 'useDash'),
			Fn(this, 'useGradient'),
			Fn(this, 'visibility'),
			Fn(this, 'repeat'),
			Fn(this, 'offset'),
			(this.type = 'MeshLineMaterial'),
			Object.defineProperties(this, {
				lineWidth: {
					enumerable: !0,
					get() {
						return this.uniforms.lineWidth.value;
					},
					set(t) {
						this.uniforms.lineWidth.value = t;
					},
				},
				map: {
					enumerable: !0,
					get() {
						return this.uniforms.map.value;
					},
					set(t) {
						this.uniforms.map.value = t;
					},
				},
				useMap: {
					enumerable: !0,
					get() {
						return this.uniforms.useMap.value;
					},
					set(t) {
						this.uniforms.useMap.value = t;
					},
				},
				alphaMap: {
					enumerable: !0,
					get() {
						return this.uniforms.alphaMap.value;
					},
					set(t) {
						this.uniforms.alphaMap.value = t;
					},
				},
				useAlphaMap: {
					enumerable: !0,
					get() {
						return this.uniforms.useAlphaMap.value;
					},
					set(t) {
						this.uniforms.useAlphaMap.value = t;
					},
				},
				color: {
					enumerable: !0,
					get() {
						return this.uniforms.color.value;
					},
					set(t) {
						this.uniforms.color.value = t;
					},
				},
				gradient: {
					enumerable: !0,
					get() {
						return this.uniforms.gradient.value;
					},
					set(t) {
						this.uniforms.gradient.value = t;
					},
				},
				opacity: {
					enumerable: !0,
					get() {
						return this.uniforms.opacity.value;
					},
					set(t) {
						this.uniforms.opacity.value = t;
					},
				},
				resolution: {
					enumerable: !0,
					get() {
						return this.uniforms.resolution.value;
					},
					set(t) {
						this.uniforms.resolution.value.copy(t);
					},
				},
				sizeAttenuation: {
					enumerable: !0,
					get() {
						return this.uniforms.sizeAttenuation.value;
					},
					set(t) {
						this.uniforms.sizeAttenuation.value = t;
					},
				},
				dashArray: {
					enumerable: !0,
					get() {
						return this.uniforms.dashArray.value;
					},
					set(t) {
						(this.uniforms.dashArray.value = t), (this.useDash = t !== 0 ? 1 : 0);
					},
				},
				dashOffset: {
					enumerable: !0,
					get() {
						return this.uniforms.dashOffset.value;
					},
					set(t) {
						this.uniforms.dashOffset.value = t;
					},
				},
				dashRatio: {
					enumerable: !0,
					get() {
						return this.uniforms.dashRatio.value;
					},
					set(t) {
						this.uniforms.dashRatio.value = t;
					},
				},
				useDash: {
					enumerable: !0,
					get() {
						return this.uniforms.useDash.value;
					},
					set(t) {
						this.uniforms.useDash.value = t;
					},
				},
				useGradient: {
					enumerable: !0,
					get() {
						return this.uniforms.useGradient.value;
					},
					set(t) {
						this.uniforms.useGradient.value = t;
					},
				},
				visibility: {
					enumerable: !0,
					get() {
						return this.uniforms.visibility.value;
					},
					set(t) {
						this.uniforms.visibility.value = t;
					},
				},
				alphaTest: {
					enumerable: !0,
					get() {
						return this.uniforms.alphaTest.value;
					},
					set(t) {
						this.uniforms.alphaTest.value = t;
					},
				},
				repeat: {
					enumerable: !0,
					get() {
						return this.uniforms.repeat.value;
					},
					set(t) {
						this.uniforms.repeat.value.copy(t);
					},
				},
				offset: {
					enumerable: !0,
					get() {
						return this.uniforms.offset.value;
					},
					set(t) {
						this.uniforms.offset.value.copy(t);
					},
				},
			}),
			this.setValues(e);
	}
	copy(e) {
		return (
			super.copy(e),
			(this.lineWidth = e.lineWidth),
			(this.map = e.map),
			(this.useMap = e.useMap),
			(this.alphaMap = e.alphaMap),
			(this.useAlphaMap = e.useAlphaMap),
			this.color.copy(e.color),
			(this.gradient = e.gradient),
			(this.opacity = e.opacity),
			this.resolution.copy(e.resolution),
			(this.sizeAttenuation = e.sizeAttenuation),
			(this.dashArray = e.dashArray),
			(this.dashOffset = e.dashOffset),
			(this.dashRatio = e.dashRatio),
			(this.useDash = e.useDash),
			(this.useGradient = e.useGradient),
			(this.visibility = e.visibility),
			(this.alphaTest = e.alphaTest),
			this.repeat.copy(e.repeat),
			this.offset.copy(e.offset),
			this
		);
	}
}
var vW = Object.defineProperty,
	_W = (i, e, t) => (e in i ? vW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	rg = (i, e, t) => (_W(i, typeof e != 'symbol' ? e + '' : e, t), t);
class yW extends Cs {
	constructor(e) {
		super(e), rg(this, 'options'), rg(this, 'material'), rg(this, 'tween'), (this.options = e);
	}
	create() {
		var u, d;
		const { points: e, wcb: t, material: n, pickable: s, useCache: r } = this.options,
			{ width: o, height: a } = this.viz.getSize(),
			l = new cW();
		l.setPoints(e, t);
		let c;
		r
			? ((c = (u = this.viz) == null ? void 0 : u.cacheManager.get('lineMaterial')),
			  c || ((c = new Hw({ ...n, resolution: new ce(o, a) })), (d = this.viz) == null || d.cacheManager.set('lineMaterial', c)))
			: (c = new Hw({ ...n, resolution: new ce(o, a) })),
			n.transparent && ((c.toneMapped = !1), (c.depthWrite = !1), (c.transparent = !0), (c.blending = n.blending || co)),
			(this.material = c);
		const h = new bt(l, c);
		s && (h.raycast = hW), (this.object3D = h);
	}
	animateIn(e) {
		this.material &&
			Bn.fromTo(
				this.material,
				{ visibility: 0 },
				{
					visibility: 1,
					duration: e,
					onStart: () => {
						this.show();
					},
				}
			);
	}
	animateTexture() {
		const { animation: e } = this.options;
		if (e && this.material) {
			const { duration: t = 3, delay: n = 0, repeat: s = -1, repeatDelay: r = 0 } = e;
			this.tween = Bn.to(this.material.offset, { x: -1, duration: t, delay: n, repeat: s, repeatDelay: r, ease: 'none' });
		}
	}
	animateDash() {
		const { animation: e } = this.options;
		if (e && this.material) {
			const { duration: t = 3, delay: n = 0, repeat: s = -1, repeatDelay: r = 0 } = e;
			this.tween = Bn.to(this.material, { dashOffset: 0, duration: t, delay: n, repeat: s, repeatDelay: r, ease: 'none' });
		}
	}
	render() {
		const { animation: e } = this.options;
		if (e) {
			const { animationType: t = 'texture' } = e;
			t === 'texture' ? this.animateTexture() : t === 'dash' && this.animateDash();
		}
	}
	setSize(e, t) {
		var n;
		(n = this.material) == null || n.resolution.set(e, t);
	}
	dispose() {
		var e;
		super.dispose(), (this.material = void 0), (e = this.tween) == null || e.kill(), (this.tween = void 0);
	}
}
var xW = Object.defineProperty,
	bW = (i, e, t) => (e in i ? xW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Gw = (i, e, t) => (bW(i, typeof e != 'symbol' ? e + '' : e, t), t);
const wW = { '2d': j3, '3d': dT, sprite: Z3 };
class Z0 extends Cs {
	constructor(e) {
		super(e), Gw(this, 'options'), Gw(this, 'element'), (this.options = e);
	}
	create() {
		const { element: e, position: t, scale: n, zIndex: s } = this.options,
			r = document.createElement('div');
		r.appendChild(e);
		const o = new wW[this.options.type](r);
		o.position.copy(t), n && this.setScale(n, o), s && (o.renderOrder = s), (this.object3D = o), (this.element = r);
	}
	setScale(e, t) {
		typeof e == 'number' ? t.scale.set(e, e, e) : t.scale.copy(e);
	}
	dispose() {
		super.dispose(), this.element && (this.element.remove(), (this.element = void 0));
	}
}
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */ /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ function SW(i, e) {
	var t = {
			label: 0,
			sent: function () {
				if (r[0] & 1) throw r[1];
				return r[1];
			},
			trys: [],
			ops: [],
		},
		n,
		s,
		r,
		o;
	return (
		(o = { next: a(0), throw: a(1), return: a(2) }),
		typeof Symbol == 'function' &&
			(o[Symbol.iterator] = function () {
				return this;
			}),
		o
	);
	function a(c) {
		return function (h) {
			return l([c, h]);
		};
	}
	function l(c) {
		if (n) throw new TypeError('Generator is already executing.');
		for (; t; )
			try {
				if (
					((n = 1),
					s &&
						(r = c[0] & 2 ? s.return : c[0] ? s.throw || ((r = s.return) && r.call(s), 0) : s.next) &&
						!(r = r.call(s, c[1])).done)
				)
					return r;
				switch (((s = 0), r && (c = [c[0] & 2, r.value]), c[0])) {
					case 0:
					case 1:
						r = c;
						break;
					case 4:
						return t.label++, { value: c[1], done: !1 };
					case 5:
						t.label++, (s = c[1]), (c = [0]);
						continue;
					case 7:
						(c = t.ops.pop()), t.trys.pop();
						continue;
					default:
						if (((r = t.trys), !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2))) {
							t = 0;
							continue;
						}
						if (c[0] === 3 && (!r || (c[1] > r[0] && c[1] < r[3]))) {
							t.label = c[1];
							break;
						}
						if (c[0] === 6 && t.label < r[1]) {
							(t.label = r[1]), (r = c);
							break;
						}
						if (r && t.label < r[2]) {
							(t.label = r[2]), t.ops.push(c);
							break;
						}
						r[2] && t.ops.pop(), t.trys.pop();
						continue;
				}
				c = e.call(i, t);
			} catch (h) {
				(c = [6, h]), (s = 0);
			} finally {
				n = r = 0;
			}
		if (c[0] & 5) throw c[1];
		return { value: c[0] ? c[1] : void 0, done: !0 };
	}
}
var Eo = (function () {
	function i(e, t) {
		(this.next = null), (this.key = e), (this.data = t), (this.left = null), (this.right = null);
	}
	return i;
})();
function MW(i, e) {
	return i > e ? 1 : i < e ? -1 : 0;
}
function Qr(i, e, t) {
	for (var n = new Eo(null, null), s = n, r = n; ; ) {
		var o = t(i, e.key);
		if (o < 0) {
			if (e.left === null) break;
			if (t(i, e.left.key) < 0) {
				var a = e.left;
				if (((e.left = a.right), (a.right = e), (e = a), e.left === null)) break;
			}
			(r.left = e), (r = e), (e = e.left);
		} else if (o > 0) {
			if (e.right === null) break;
			if (t(i, e.right.key) > 0) {
				var a = e.right;
				if (((e.right = a.left), (a.left = e), (e = a), e.right === null)) break;
			}
			(s.right = e), (s = e), (e = e.right);
		} else break;
	}
	return (s.right = e.left), (r.left = e.right), (e.left = n.right), (e.right = n.left), e;
}
function og(i, e, t, n) {
	var s = new Eo(i, e);
	if (t === null) return (s.left = s.right = null), s;
	t = Qr(i, t, n);
	var r = n(i, t.key);
	return r < 0 ? ((s.left = t.left), (s.right = t), (t.left = null)) : r >= 0 && ((s.right = t.right), (s.left = t), (t.right = null)), s;
}
function Ww(i, e, t) {
	var n = null,
		s = null;
	if (e) {
		e = Qr(i, e, t);
		var r = t(e.key, i);
		r === 0
			? ((n = e.left), (s = e.right))
			: r < 0
			? ((s = e.right), (e.right = null), (n = e))
			: ((n = e.left), (e.left = null), (s = e));
	}
	return { left: n, right: s };
}
function EW(i, e, t) {
	return e === null ? i : (i === null || ((e = Qr(i.key, e, t)), (e.left = i)), e);
}
function Uv(i, e, t, n, s) {
	if (i) {
		n('' + e + (t ? '└── ' : '├── ') + s(i) + '\n');
		var r = e + (t ? '    ' : '│   ');
		i.left && Uv(i.left, r, !1, n, s), i.right && Uv(i.right, r, !0, n, s);
	}
}
var TW = (function () {
	function i(e) {
		e === void 0 && (e = MW), (this._root = null), (this._size = 0), (this._comparator = e);
	}
	return (
		(i.prototype.insert = function (e, t) {
			return this._size++, (this._root = og(e, t, this._root, this._comparator));
		}),
		(i.prototype.add = function (e, t) {
			var n = new Eo(e, t);
			this._root === null && ((n.left = n.right = null), this._size++, (this._root = n));
			var s = this._comparator,
				r = Qr(e, this._root, s),
				o = s(e, r.key);
			return (
				o === 0
					? (this._root = r)
					: (o < 0
							? ((n.left = r.left), (n.right = r), (r.left = null))
							: o > 0 && ((n.right = r.right), (n.left = r), (r.right = null)),
					  this._size++,
					  (this._root = n)),
				this._root
			);
		}),
		(i.prototype.remove = function (e) {
			this._root = this._remove(e, this._root, this._comparator);
		}),
		(i.prototype._remove = function (e, t, n) {
			var s;
			if (t === null) return null;
			t = Qr(e, t, n);
			var r = n(e, t.key);
			return r === 0 ? (t.left === null ? (s = t.right) : ((s = Qr(e, t.left, n)), (s.right = t.right)), this._size--, s) : t;
		}),
		(i.prototype.pop = function () {
			var e = this._root;
			if (e) {
				for (; e.left; ) e = e.left;
				return (
					(this._root = Qr(e.key, this._root, this._comparator)),
					(this._root = this._remove(e.key, this._root, this._comparator)),
					{ key: e.key, data: e.data }
				);
			}
			return null;
		}),
		(i.prototype.findStatic = function (e) {
			for (var t = this._root, n = this._comparator; t; ) {
				var s = n(e, t.key);
				if (s === 0) return t;
				s < 0 ? (t = t.left) : (t = t.right);
			}
			return null;
		}),
		(i.prototype.find = function (e) {
			return this._root && ((this._root = Qr(e, this._root, this._comparator)), this._comparator(e, this._root.key) !== 0)
				? null
				: this._root;
		}),
		(i.prototype.contains = function (e) {
			for (var t = this._root, n = this._comparator; t; ) {
				var s = n(e, t.key);
				if (s === 0) return !0;
				s < 0 ? (t = t.left) : (t = t.right);
			}
			return !1;
		}),
		(i.prototype.forEach = function (e, t) {
			for (var n = this._root, s = [], r = !1; !r; )
				n !== null ? (s.push(n), (n = n.left)) : s.length !== 0 ? ((n = s.pop()), e.call(t, n), (n = n.right)) : (r = !0);
			return this;
		}),
		(i.prototype.range = function (e, t, n, s) {
			for (var r = [], o = this._comparator, a = this._root, l; r.length !== 0 || a; )
				if (a) r.push(a), (a = a.left);
				else {
					if (((a = r.pop()), (l = o(a.key, t)), l > 0)) break;
					if (o(a.key, e) >= 0 && n.call(s, a)) return this;
					a = a.right;
				}
			return this;
		}),
		(i.prototype.keys = function () {
			var e = [];
			return (
				this.forEach(function (t) {
					var n = t.key;
					return e.push(n);
				}),
				e
			);
		}),
		(i.prototype.values = function () {
			var e = [];
			return (
				this.forEach(function (t) {
					var n = t.data;
					return e.push(n);
				}),
				e
			);
		}),
		(i.prototype.min = function () {
			return this._root ? this.minNode(this._root).key : null;
		}),
		(i.prototype.max = function () {
			return this._root ? this.maxNode(this._root).key : null;
		}),
		(i.prototype.minNode = function (e) {
			if ((e === void 0 && (e = this._root), e)) for (; e.left; ) e = e.left;
			return e;
		}),
		(i.prototype.maxNode = function (e) {
			if ((e === void 0 && (e = this._root), e)) for (; e.right; ) e = e.right;
			return e;
		}),
		(i.prototype.at = function (e) {
			for (var t = this._root, n = !1, s = 0, r = []; !n; )
				if (t) r.push(t), (t = t.left);
				else if (r.length > 0) {
					if (((t = r.pop()), s === e)) return t;
					s++, (t = t.right);
				} else n = !0;
			return null;
		}),
		(i.prototype.next = function (e) {
			var t = this._root,
				n = null;
			if (e.right) {
				for (n = e.right; n.left; ) n = n.left;
				return n;
			}
			for (var s = this._comparator; t; ) {
				var r = s(e.key, t.key);
				if (r === 0) break;
				r < 0 ? ((n = t), (t = t.left)) : (t = t.right);
			}
			return n;
		}),
		(i.prototype.prev = function (e) {
			var t = this._root,
				n = null;
			if (e.left !== null) {
				for (n = e.left; n.right; ) n = n.right;
				return n;
			}
			for (var s = this._comparator; t; ) {
				var r = s(e.key, t.key);
				if (r === 0) break;
				r < 0 ? (t = t.left) : ((n = t), (t = t.right));
			}
			return n;
		}),
		(i.prototype.clear = function () {
			return (this._root = null), (this._size = 0), this;
		}),
		(i.prototype.toList = function () {
			return CW(this._root);
		}),
		(i.prototype.load = function (e, t, n) {
			t === void 0 && (t = []), n === void 0 && (n = !1);
			var s = e.length,
				r = this._comparator;
			if ((n && Bv(e, t, 0, s - 1, r), this._root === null)) (this._root = Nv(e, t, 0, s)), (this._size = s);
			else {
				var o = RW(this.toList(), AW(e, t), r);
				(s = this._size + s), (this._root = Fv({ head: o }, 0, s));
			}
			return this;
		}),
		(i.prototype.isEmpty = function () {
			return this._root === null;
		}),
		Object.defineProperty(i.prototype, 'size', {
			get: function () {
				return this._size;
			},
			enumerable: !0,
			configurable: !0,
		}),
		Object.defineProperty(i.prototype, 'root', {
			get: function () {
				return this._root;
			},
			enumerable: !0,
			configurable: !0,
		}),
		(i.prototype.toString = function (e) {
			e === void 0 &&
				(e = function (n) {
					return String(n.key);
				});
			var t = [];
			return (
				Uv(
					this._root,
					'',
					!0,
					function (n) {
						return t.push(n);
					},
					e
				),
				t.join('')
			);
		}),
		(i.prototype.update = function (e, t, n) {
			var s = this._comparator,
				r = Ww(e, this._root, s),
				o = r.left,
				a = r.right;
			s(e, t) < 0 ? (a = og(t, n, a, s)) : (o = og(t, n, o, s)), (this._root = EW(o, a, s));
		}),
		(i.prototype.split = function (e) {
			return Ww(e, this._root, this._comparator);
		}),
		(i.prototype[Symbol.iterator] = function () {
			var e, t, n;
			return SW(this, function (s) {
				switch (s.label) {
					case 0:
						(e = this._root), (t = []), (n = !1), (s.label = 1);
					case 1:
						return n ? [3, 6] : e === null ? [3, 2] : (t.push(e), (e = e.left), [3, 5]);
					case 2:
						return t.length === 0 ? [3, 4] : ((e = t.pop()), [4, e]);
					case 3:
						return s.sent(), (e = e.right), [3, 5];
					case 4:
						(n = !0), (s.label = 5);
					case 5:
						return [3, 1];
					case 6:
						return [2];
				}
			});
		}),
		i
	);
})();
function Nv(i, e, t, n) {
	var s = n - t;
	if (s > 0) {
		var r = t + Math.floor(s / 2),
			o = i[r],
			a = e[r],
			l = new Eo(o, a);
		return (l.left = Nv(i, e, t, r)), (l.right = Nv(i, e, r + 1, n)), l;
	}
	return null;
}
function AW(i, e) {
	for (var t = new Eo(null, null), n = t, s = 0; s < i.length; s++) n = n.next = new Eo(i[s], e[s]);
	return (n.next = null), t.next;
}
function CW(i) {
	for (var e = i, t = [], n = !1, s = new Eo(null, null), r = s; !n; )
		e ? (t.push(e), (e = e.left)) : t.length > 0 ? ((e = r = r.next = t.pop()), (e = e.right)) : (n = !0);
	return (r.next = null), s.next;
}
function Fv(i, e, t) {
	var n = t - e;
	if (n > 0) {
		var s = e + Math.floor(n / 2),
			r = Fv(i, e, s),
			o = i.head;
		return (o.left = r), (i.head = i.head.next), (o.right = Fv(i, s + 1, t)), o;
	}
	return null;
}
function RW(i, e, t) {
	for (var n = new Eo(null, null), s = n, r = i, o = e; r !== null && o !== null; )
		t(r.key, o.key) < 0 ? ((s.next = r), (r = r.next)) : ((s.next = o), (o = o.next)), (s = s.next);
	return r !== null ? (s.next = r) : o !== null && (s.next = o), n.next;
}
function Bv(i, e, t, n, s) {
	if (!(t >= n)) {
		for (var r = i[(t + n) >> 1], o = t - 1, a = n + 1; ; ) {
			do o++;
			while (s(i[o], r) < 0);
			do a--;
			while (s(i[a], r) > 0);
			if (o >= a) break;
			var l = i[o];
			(i[o] = i[a]), (i[a] = l), (l = e[o]), (e[o] = e[a]), (e[a] = l);
		}
		Bv(i, e, t, a, s), Bv(i, e, a + 1, n, s);
	}
}
let ro = Number.EPSILON;
ro === void 0 && (ro = Math.pow(2, -52));
const PW = ro * ro,
	Xw = (i, e) => {
		if (-ro < i && i < ro && -ro < e && e < ro) return 0;
		const t = i - e;
		return t * t < PW * i * e ? 0 : i < e ? -1 : 1;
	};
class LW {
	constructor() {
		this.reset();
	}
	reset() {
		(this.xRounder = new qw()), (this.yRounder = new qw());
	}
	round(e, t) {
		return { x: this.xRounder.round(e), y: this.yRounder.round(t) };
	}
}
class qw {
	constructor() {
		(this.tree = new TW()), this.round(0);
	}
	round(e) {
		const t = this.tree.add(e),
			n = this.tree.prev(t);
		if (n !== null && Xw(t.key, n.key) === 0) return this.tree.remove(e), n.key;
		const s = this.tree.next(t);
		return s !== null && Xw(t.key, s.key) === 0 ? (this.tree.remove(e), s.key) : e;
	}
}
new LW();
var IW = Object.defineProperty,
	DW = (i, e, t) => (e in i ? IW(i, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (i[e] = t)),
	Yw = (i, e, t) => (DW(i, typeof e != 'symbol' ? e + '' : e, t), t);
class OW extends Cs {
	constructor(e) {
		super(e), Yw(this, 'options'), Yw(this, 'billboard'), (this.options = e);
	}
	create() {
		const { object: e, billboardConfig: t = {} } = this.options,
			n = X4();
		n.group.add(e), n.updateProps(t), (this.billboard = n), (this.object3D = n.group);
	}
	updateProps(e) {
		var t;
		(t = this.billboard) == null || t.updateProps(e);
	}
	update() {
		var e;
		(e = this.billboard) == null || e.update(this.viz.camera);
	}
	dispose() {
		super.dispose(), (this.billboard = void 0);
	}
}
const kv = (i) => new Promise((e) => setTimeout(e, i)),
	UW = (i, e) => {
		let t = 0;
		return function (...n) {
			const s = new Date().getTime();
			s - t >= e && ((t = s), i(...n));
		};
	},
	Os = window.location.search.includes('dev'),
	jw = [
		{
			map: [
				{ type: 'map', url: '/scene1/textures/top-light.mp4' },
				{ type: 'emissiveMap', url: '/scene1/textures/top-light.mp4' },
				{ type: 'alphaMap', url: '/scene1/textures/top-light.mp4' },
			],
			mesh: '柱体024',
		},
		{ map: [{ type: 'alphaMap', url: '/scene1/textures/top-circle.png' }], mesh: '柱体002' },
		{
			map: [
				{ type: 'alphaMap', url: '/scene1/textures/light-pillar1.png' },
				{ type: 'emissiveMap', url: '/scene1/textures/light-pillar1.png' },
			],
			mesh: '柱体014',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/scene1/textures/glow.mp4' },
				{ type: 'emissiveMap', url: '/scene1/textures/light-pillar1.png' },
			],
			mesh: '倒圆锥',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/scene1/textures/bottom-inner-circle.png' },
				{ type: 'emissiveMap', url: '/scene1/textures/bottom-inner-circle.png' },
			],
			mesh: '柱体005',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/scene1/textures/bottom-out-circle.png' },
				{ type: 'emissiveMap', url: '/scene1/textures/bottom-out-circle.png' },
			],
			mesh: '柱体006',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/textures/bottom.png' },
				{ type: 'emissiveMap', url: '/textures/bottom.png' },
			],
			mesh: 'Plane',
		},
		{
			map: [
				{ type: 'emissiveMap', url: '/scene1/textures/board.png' },
				{ type: 'alphaMap', url: '/scene1/textures/board.png' },
			],
			mesh: '柱体008',
		},
		{
			map: [
				{ type: 'emissiveMap', url: 'scene1/textures/board.mp4' },
				{ type: 'alphaMap', url: 'scene1/textures/board.mp4' },
			],
			mesh: '柱体013',
		},
	],
	qr = {
		核心模型glb: { text: '数据平台', type: 1, position: new I(0, -1.5, 0) },
		聚1glb: { text: '健康惠民“一站式”', type: 2 },
		聚2glb: { text: '健康大脑“一张屏”', type: 2 },
		聚3glb: { text: '政务协同“一网办”', type: 2 },
		聚4glb: { text: '集约整合“一平台”', type: 2, position: new I(-1.5, -1.5, -0.5) },
		聚5glb: { text: '业务协同“一体化”', type: 2 },
		用8glb: { text: '全民健康信息平台', type: 3, position: new I(0, 0, 0) },
		用7glb: { text: '影像云平台', type: 3, position: new I(0, 0, 0) },
		用10glb: { text: '基层卫生管理平台', type: 3, position: new I(0, 0, 0) },
		用9glb: { text: '电子健康卡平台', type: 3, position: new I(0, 0, 0) },
		用5glb: { text: '健康甘肃', type: 3, position: new I(0, 0, 0) },
		用6glb: { text: '健康档案浏览器', type: 3, position: new I(0, 0, 0) },
		用1glb: { text: '远程诊断', type: 3, position: new I(0, 0, 0) },
		用4glb: { text: '检查检验共享互认', type: 3, position: new I(0, 0, 0) },
		用3glb: { text: '双向转诊', type: 3, position: new I(0, 0, 0) },
		用2glb: { text: '远程会诊', type: 3, position: new I(0, 0, 0) },
	},
	Tl = new K0({ Marker: Z0, Line: yW });
class NW {
	constructor(e) {
		Ut(this, 'viz');
		Ut(this, 'scene');
		Ut(this, 'autoRotate', !Os);
		const t = new $0(
			{
				dev: Os,
				container: e,
				staticPath: '/',
				camera: { position: new I(0, 14, 0.6), target: new I(0, -6, 0.6), focalLength: 50 },
				cssRenderer: '3d',
			},
			{ componentManager: Tl }
		);
		(t.cameraControl.enabled = !1),
			t.assetManager.setAsset([
				{ url: '/scene1/scene.glb', type: 'gltf', version: '0.0.3' },
				{ url: '/textures/BG.png', type: 'texture' },
				{ url: '/textures/environment.jpg', type: 'texture' },
				{ url: '/scene1/textures/number.png', type: 'texture' },
			]),
			Array.from(new Set(jw.map((s) => s.map.map(({ url: r }) => r)).flat())).forEach((s) => {
				t.assetManager.setAsset([{ url: s, type: s.includes('mp4') ? 'video' : 'texture' }]);
			}),
			(this.viz = t),
			Os && (window.viz = t);
	}
	get outItems() {
		return Object.keys(qr)
			.filter((e) => qr[e].type !== 1)
			.map((e) => {
				var n;
				const t = (n = this.scene) == null ? void 0 : n.getObjectByName(e);
				if (t) return (t.userData.type = qr[e].type), t;
			})
			.filter(Boolean);
	}
	get innerItems() {
		return Object.keys(qr)
			.filter((e) => qr[e].type !== 3)
			.map((e) => {
				var t;
				return (t = this.scene) == null ? void 0 : t.getObjectByName(e);
			})
			.filter(Boolean);
	}
	get allItems() {
		return Object.keys(qr)
			.map((e) => {
				var t;
				return (t = this.scene) == null ? void 0 : t.getObjectByName(e);
			})
			.filter(Boolean);
	}
	async init() {
		debugger;
		var a, l, c;
		await this.viz.assetManager.load();
		const e = await this.loadEnvMap(),
			t = await this.viz.assetManager.getAsset('/textures/BG.png');
		(t.magFilter = It), (t.minFilter = It), (t.colorSpace = ot), (this.viz.scene.background = t), (this.viz.scene.environment = e);
		const { scene: n } = await this.viz.assetManager.getAsset('/scene1/scene.glb');
		console.log('scene', n),
			n.traverse(async (h) => {
				const u = jw.find(({ mesh: d }) => d === h.name);
				u &&
					u.map.forEach(async ({ type: d, url: p }) => {
						const g = await this.viz.assetManager.getAsset(p);
						(d === 'emissiveMap' || d === 'map') && (g.colorSpace = ot), (h.material[d] = g);
					}),
					h instanceof bt &&
						h.material instanceof Ha &&
						(h.name === '平面001' && (h.rotateX(Math.PI), (h.material.blending = bs), (h.material.side = mn), (h.visible = !1)),
						h.name === '柱体014' && (h.material.emissiveIntensity = 20),
						h.name === '柱体024' && ((h.material.emissiveIntensity = 5), (h.material.blending = bs)),
						h.name === '柱体013' && ((h.material.emissiveIntensity = 30), (h.material.blending = bs)),
						h.name === '倒圆锥' && (h.material.emissiveIntensity = 1),
						(h.material.envMap = e),
						(h.material.needsUpdate = !0));
			}),
			await Promise.all(
				Object.keys(qr).map(async (h) => {
					const { text: u, position: d, type: p, rotation: g } = qr[h],
						v = n.getObjectByName(h);
					if (v) {
						const { size: m, center: f } = this.getObjectSizeAndCenter(v);
						(v.userData.size = m), (v.userData.center = f);
						const y = new I(f.x, f.y + (p === 3 ? -m.y : m.y), f.z).add(d != null ? d : new I(0, 0, 0));
						await this.drawLabels(h, p, u, v, y, g);
					}
				})
			);
		const s = n.getObjectByName('数字glb'),
			r = await this.viz.assetManager.getAsset('/scene1/textures/number.png');
		(r.flipY = !1), (r.wrapT = rs);
		const o = s.children[0].material;
		(o.map = r),
			(o.needsUpdate = !0),
			(o.emissive = new Ee(16777215)),
			(o.blending = bs),
			(o.side = mn),
			s.children.forEach((h) => {
				h.rotateX(Math.PI);
			}),
			(a = this.viz.scene) == null || a.add(n),
			(this.scene = n),
			(l = this.viz.cameraControl) == null ||
				l.addEventListener('controlstart', () => {
					this.autoRotate = !1;
				}),
			(c = this.viz.cameraControl) == null ||
				c.addEventListener('controlend', () => {
					this.autoRotate = !Os;
				}),
			await this.drawFlylines(),
			this.viz.start((h) => {
				(o.map.offset.y += 0.003), this.autoRotate && (this.viz.cameraControl.azimuthAngle += 20 * h * Dn.DEG2RAD);
			});
	}
	createLineTexture(e, t, n = 0.4) {
		const s = document.createElement('canvas');
		(s.width = 256), (s.height = 1);
		const r = s.getContext('2d'),
			o = r.createLinearGradient(0, 0, 256, 1);
		o.addColorStop(0, e),
			o.addColorStop(n / 2, t),
			o.addColorStop(n, e),
			o.addColorStop(1, e),
			(r.fillStyle = o),
			r.fillRect(0, 0, 256, 1);
		const a = new N_(s);
		return (a.colorSpace = ot), (a.wrapS = rs), (a.wrapT = rs), a;
	}
	async drawFlylines() {
		const e = new I(0.56, 0.25, -0.64),
			t = [
				new I(0.06, 0.25, -0.42),
				new I(0.82, 0.25, -0.55),
				new I(0.41, 0.25, -0.93),
				new I(1.52, 0.25, -1.11),
				new I(1.15, 0.25, -0.44),
				new I(0.96, 0.25, -0.93),
				new I(1.14, 0.25, -1.27),
				new I(0.89, 0.25, -1.56),
				new I(0.56, 0.25, -1.71),
				new I(-0.17, 0.25, -0.14),
				new I(-0.33, 0.25, 0.33),
				new I(-0.45, 0.25, 0.97),
				new I(-0.66, 0.25, 0.94),
				new I(-0.79, 0.25, 1.65),
			];
		let n = this.viz.cacheManager.get('flyline_texture');
		return (
			n || ((n = this.createLineTexture('#ecffff', '#ff0', 0.4)), this.viz.cacheManager.set('flyline_texture', n)),
			Promise.all(
				t.map(async (s) => {
					const r = s.clone().add(e).divideScalar(2);
					r.y = 0.75;
					const o = new Jp(s, r, e),
						a = o.getLength();
					(
						await Tl.draw('Line', {
							points: o.getPoints(50),
							material: { map: n, useMap: 1, sizeAttenuation: 1, transparent: !0, lineWidth: 0.05, visibility: 0 },
							animation: { duration: 1 * (a / 0.6) },
						})
					).hide();
				})
			)
		);
	}
	async animateIn() {
		// const e = this.viz.getCameraPosition(),
		// 	t = this.viz.getCameraTarget(),
		// 	n = { value: Dn.radToDeg(this.scene.rotation.y) },
		// 	{ height: s } = this.viz.getSize(),
		// 	o = s === 1080 || s === 2160 ? new I(-0.97, 12, 18) : new I(-0.9, 10.4, 18.65);

		const e = this.viz.getCameraPosition();
		const t = this.viz.getCameraTarget();
		const n = { value: Dn.radToDeg(this.scene.rotation.y) };
		const { height: s } = this.viz.getSize();

		// 根据屏幕视口高度，决定相机位置
		let o;
		if (s === 1080 || s === 2160) {
			o = new I(-0.97, 12, 18);
		} else {
			o = new I(-0.9, 10.4, 18.65);
		}

		console.log(e, t);
		return new Promise((a) => {
			// gasp串行动画
			const l = Bn.timeline({
				onComplete: () => {
					// 所有动画执行完后的回调
					// 显示和更新文字标签
					var c;
					this.viz.cameraControl && (this.viz.cameraControl.maxDistance = 35),
						(this.viz.cameraControl.enabled = !0),
						Tl.getInstances('Marker').forEach((h) => h.show()),
						this.updateLabels(),
						(c = this.viz.cameraControl) == null ||
							c.addEventListener(
								'update',
								UW(() => {
									this.updateLabels();
								}, 500)
							),
						a();
				},
			});
			// 相机上移
			l.to(e, {
				x: 0,
				y: 20.5,
				z: 0.6,
				duration: Os ? 0 : 2,
				onUpdate: () => {
					var c;
					(c = this.viz.cameraControl) == null || c.setPosition(e.x, e.y, e.z, !1);
				},
				ease: 'power1.inOut',
			});
			// 相机旋转
			l.to(e, {
				x: o.x,
				y: o.y,
				z: o.z,
				duration: Os ? 0 : 2,
				onUpdate: () => {
					var c;
					(c = this.viz.cameraControl) == null || c.setPosition(e.x, e.y, e.z, !1);
				},
				ease: 'power1.inOut',
			});
			// 相机观察点目标
			l.to(
				t,
				{
					x: 0,
					y: 0.6,
					z: 0,
					duration: Os ? 0 : 2,
					onUpdate: () => {
						var c;
						(c = this.viz.cameraControl) == null || c.setTarget(t.x, t.y, t.z, !1);
					},
					ease: 'power1.inOut',
				},
				Os ? 0 : 2
			);

			// 场景旋转动画
				l.to(
					n,// 场景旋转的角度
					{
						value: n.value - 225,
						duration: Os ? 0 : 4,
						onUpdate: () => {
							// 4秒的场景旋转动画
							var c;
							(c = this.scene) == null || c.rotation.set(0, Dn.degToRad(n.value), 0);
						},
						onComplete: () => {
							//场景旋转完成后,底部的地图飞线
							Tl.getInstances('Line').forEach((h) => {
								h.animateIn(1);
							});
						},
						ease: 'power1.inOut',
					},
					Os ? 0 : 2
				);
		});
	}
	async loadEnvMap() {
		const e = new Ah(this.viz.renderer);
		e.compileEquirectangularShader();
		const t = await this.viz.assetManager.getAsset('/textures/environment.jpg'),
			n = e.fromEquirectangular(t).texture;
		return e.dispose(), n;
	}
	getObjectSizeAndCenter(e) {
		const t = new An().setFromObject(e),
			n = new I(),
			s = new I();
		return t.getSize(n), t.getCenter(s), { size: n, center: s };
	}
	async drawLabels(e, t, n, s, r, o) {
		const a = document.createElement('div');
		(a.innerHTML = n),
			(a.className = 'scene1-label label-'.concat(t)),
			await Tl.draw('Marker', { element: a, type: 'sprite', position: r, scale: t === 1 ? 0.005 : t === 2 ? 0.004 : 0.003 }, s).then(
				(l) => {
					l.hide(), (l.userData = { type: t, meshName: e }), o && l.object3D.setRotationFromEuler(o);
				}
			);
	}
	has(e, t) {
		let n = !1;
		return (
			e.traverse((s) => {
				s === t && (n = !0);
			}),
			n
		);
	}
	isVisible(e) {
		const t = e.userData.type === 2 ? e.children[0] : e,
			s = this.getObjectSizeAndCenter(t).center.clone();
		s.project(this.viz.camera), this.viz.raycaster.setFromCamera(s, this.viz.camera);
		const r = this.viz.raycaster.intersectObjects(this.allItems);
		return r.length > 0 ? this.has(e, r[0].object) : !1;
	}
	updateLabels() {
		const e = Tl.getInstances('Marker');
		this.outItems.forEach((t) => {
			const n = e.find((r) => r.userData.meshName === t.name);
			this.isVisible(t) ? n == null || n.show() : n == null || n.hide();
		});
	}
	dispose() {
		var e;
		(e = this.viz.scene) == null ||
			e.children.forEach((t) => {
				Tf.disposeObject3D(t);
			}),
			this.viz.dispose(),
			(this.scene = void 0);
	}
}
class FW extends Cs {
	constructor(t) {
		super(t);
		Ut(this, 'options');
		Ut(this, 'marker');
		Ut(this, 'element');
		Ut(this, 'tl');
		this.options = t;
	}
	async create() {
		const { position: t } = this.options,
			n = document.createElement('div');
		(n.className = 'scene2-panel'),
			(this.element = n),
			(this.marker = await Yd.draw('Marker', { element: n, type: 'sprite', position: t, scale: 0.002 }, this.object3D)),
			this.hide(),
			this.marker.hide();
	}
	render() {
		var t;
		(t = this.viz) != null &&
			t.guiManager &&
			this.marker &&
			this.viz.guiManager.addFolder('Panel', {
				x: {
					value: this.marker.object3D.position.x,
					min: -5,
					max: 5,
					step: 0.01,
					onChange: (n) => {
						var s;
						(s = this.marker) == null || s.object3D.position.setX(n);
					},
				},
				y: {
					value: this.marker.object3D.position.y,
					min: -5,
					max: 5,
					step: 0.01,
					onChange: (n) => {
						var s;
						(s = this.marker) == null || s.object3D.position.setY(n);
					},
				},
				z: {
					value: this.marker.object3D.position.z,
					min: -5,
					max: 5,
					step: 0.01,
					onChange: (n) => {
						var s;
						(s = this.marker) == null || s.object3D.position.setZ(n);
					},
				},
			});
	}
	setContent(t) {
		this.element &&
			(this.element.innerHTML =
				'\n        <div class="scene2-panel-row">\n          <div class="scene2-panel-label">数据集总数：</div>\n          <div class="scene2-panel-flex">\n            <div class="scene2-panel-value">'
					.concat(
						t.SJJZS || t.SJKJS || '-',
						'</div>\n            <div class="scene2-panel-unit">个</div>\n          </div>\n        </div>\n        <div class="scene2-panel-row">\n          <div class="scene2-panel-label">数据库存量：</div>\n          <div class="scene2-panel-flex">\n            <div class="scene2-panel-value">'
					)
					.concat(
						t.SJKCL || '-',
						'</div>\n            <div class="scene2-panel-unit">GB</div>\n          </div>\n        </div>\n        <div class="scene2-panel-row">\n          <div class="scene2-panel-label">数据记录：</div>\n          <div class="scene2-panel-flex">\n            <div class="scene2-panel-value">'
					)
					.concat(
						t.SJJL || t.SJJLS || '-',
						'</div>\n            <div class="scene2-panel-unit">万条</div>\n          </div>\n        </div>\n        <div class="scene2-panel-row">\n          <div class="scene2-panel-label">数据格式：</div>\n          <div class="scene2-panel-value">'
					)
					.concat(
						t.SJGS || '-',
						'</div>\n        </div>\n        <div class="scene2-panel-row">\n          <div class="scene2-panel-label">更新日期：</div>\n          <div class="scene2-panel-value">'
					)
					.concat(
						t.GXRQ || '-',
						'</div>\n        </div>\n        <div class="scene2-panel-row">\n          <div class="scene2-panel-label">更新频率：</div>\n          <div class="scene2-panel-flex">\n            <div class="scene2-panel-value">'
					)
					.concat(
						t.GXPL || '-',
						'</div>\n            <div class="scene2-panel-unit">天/次</div>\n          </div>\n        </div>\n      '
					));
	}
	async animateIn(t) {
		return new Promise((n) => {
			if (this.marker && !this.tl) {
				const s = Bn.timeline({
					onStart: () => {
						var r;
						this.setContent(t), this.show(), (r = this.marker) == null || r.show();
					},
					onComplete: () => {
						(this.tl = void 0), n();
					},
				});
				s.fromTo(this.marker.element, { opacity: 0 }, { opacity: 1, duration: 0.5, ease: 'power1.in' }),
					s.fromTo(this.marker.object3D.position, { y: -0.4 }, { y: -0.1, duration: 0.5, ease: 'power1.in' }, 0),
					(this.tl = s);
			} else n();
		});
	}
	async animateOut() {
		return new Promise((t) => {
			if (this.marker && !this.tl) {
				const n = Bn.timeline({
					onComplete: () => {
						var s;
						(this.tl = void 0), this.hide(), (s = this.marker) == null || s.hide(), t();
					},
				});
				n.fromTo(this.marker.element, { opacity: 1 }, { opacity: 0, duration: 0.5, ease: 'power1.out' }),
					n.fromTo(this.marker.object3D.position, { y: -0.1 }, { y: -0.4, duration: 0.5, ease: 'power1.out' }, 0),
					(this.tl = n);
			} else t();
		});
	}
	dispose() {
		super.dispose(), (this.marker = void 0), (this.element = void 0), this.tl && (this.tl.kill(), (this.tl = void 0));
	}
}
const Yd = new K0({ Marker: Z0, Panel: FW }),
	BW = !1,
	Kw = [
		{
			map: [
				{ type: 'alphaMap', url: '/scene2/textures/board.mp4' },
				{ type: 'emissiveMap', url: '/scene2/textures/board.mp4' },
			],
			mesh: '柱体042',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/scene2/textures/Frame.png' },
				{ type: 'emissiveMap', url: '/scene2/textures/Frame.png' },
			],
			mesh: '柱体034',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/scene2/textures/board.png' },
				{ type: 'emissiveMap', url: '/scene2/textures/board.png' },
			],
			mesh: '柱体035',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/textures/light.png' },
				{ type: 'emissiveMap', url: '/textures/light-effect.png' },
			],
			mesh: '底座外环1',
		},
		{
			map: [
				{ type: 'alphaMap', url: '/textures/bottom.png' },
				{ type: 'emissiveMap', url: '/textures/bottom.png' },
			],
			mesh: 'Plane',
		},
	],
	kW = [
		{ type: 1, mesh: '核心模型_glb', label: '信息资源库' },
		{ type: 2, mesh: '五大库1_glb', label: '检查检验共享', key: 'JCJYJGHR' },
		{ type: 2, mesh: '五大库2_glb', label: '全员人口数据库', key: 'QYRKSJK' },
		{ type: 2, mesh: '五大库3_glb', label: '健康档案数据库', key: 'JKDASJK' },
		{ type: 2, mesh: '五大库4_glb', label: '卫生资源数据库', key: 'WSZYSJK' },
		{ type: 2, mesh: '五大库5_glb', label: '电子病历数据库', key: 'DZBL' },
	],
	zW = (i) => {
		switch (i) {
			case -72:
				return '检查检验共享';
			case -144:
				return '全员人口数据库';
			case -216:
				return '健康档案数据库';
			case -288:
				return '卫生资源数据库';
			case -360:
				return '电子病历数据库';
		}
	};
class VW {
	constructor(e) {
		Ut(this, 'viz');
		Ut(this, 'scene');
		Ut(this, 'panel');
		Ut(this, 'rotating', !1);
		Ut(this, 'rotateTween');
		const t = new $0(
			{
				dev: BW,
				container: e,
				staticPath: '/',
				camera: { position: new I(0, 5, 9), focalLength: 50 },
				composer: { multisampling: 8 },
				cssRenderer: '3d',
			},
			{ componentManager: Yd }
		);
		(t.cameraControl.enabled = !1),
			t.assetManager.setAsset([
				{ url: '/scene2/scene.glb', type: 'gltf', version: '0.0.4' },
				{ url: '/textures/BG.png', type: 'texture' },
				{ url: '/textures/environment.jpg', type: 'texture' },
			]),
			Array.from(new Set(Kw.map((s) => s.map.map(({ url: r }) => r)).flat())).forEach((s) => {
				t.assetManager.setAsset([{ url: s, type: s.includes('mp4') ? 'video' : 'texture' }]);
			}),
			(this.viz = t);
	}
	async init() {
		var s;
		await this.viz.assetManager.load();
		const e = await this.loadEnvMap(),
			t = await this.viz.assetManager.getAsset('/textures/BG.png');
		(t.magFilter = It), (t.minFilter = It), (t.colorSpace = ot), (this.viz.scene.background = t), (this.viz.scene.environment = e);
		const { scene: n } = await this.viz.assetManager.getAsset('/scene2/scene.glb');
		n.traverse(async (r) => {
			const o = Kw.find(({ mesh: a }) => a === r.name);
			o &&
				(o.map.forEach(async ({ type: a, url: l }) => {
					const c = await this.viz.assetManager.getAsset(l);
					a === 'emissiveMap' && (c.colorSpace = ot), (c.magFilter = It), (r.material[a] = c);
				}),
				(r.material.needsUpdate = !0)),
				r.name === '柱体034' && (r.material.emissiveIntensity = 5),
				r.name === '柱体035' && (r.material.emissiveIntensity = 10);
		}),
			await Promise.all(
				kW.map(async ({ type: r, mesh: o, label: a, key: l }) => {
					const c = n.getObjectByName(o);
					if (c) {
						const { size: h, center: u } = this.getObjectSizeAndCenter(c),
							d = new I(u.x, u.y + h.y * 0.8, u.z);
						(c.userData = { name: a, center: u, size: h, key: l }),
							r === 2 &&
								(this.viz.interactionManager.add(c),
								c.addEventListener('click', async (p) => {
									p && p.target && window.parent.postMessage(p.target.userData.key, '*');
								})),
							await this.drawLabels(r, a, c, d);
					}
				})
			),
			(this.panel = await Yd.draw('Panel', { position: new I(0.45, -0.1, 0.5) })),
			(this.scene = n),
			(s = this.viz.scene) == null || s.add(n),
			this.viz.start();
	}
	async animateIn() {
		const e = { x: 0, y: 5, z: 9 };
		return new Promise((t) => {
			Bn.to(e, {
				x: 0,
				y: 2.22,
				z: 4.38,
				duration: 1,
				onUpdate: () => {
					var n;
					(n = this.viz.cameraControl) == null || n.setPosition(e.x, e.y, e.z, !1);
				},
				onComplete: () => {
					(this.viz.cameraControl.enabled = !0), (this.viz.cameraControl.maxDistance = 25), t();
				},
			});
		});
	}
	startRotate() {
		(this.rotating = !0), this.rotate();
	}
	endRotate() {
		this.rotating = !1;
	}
	setData(e) {
		e.forEach((t) => {
			var s;
			const n = (s = this.scene) == null ? void 0 : s.children.find((r) => r.userData.key === t.YWFL);
			n && (n.userData.data = t);
		});
	}
	async rotate() {
		var s;
		if (!this.rotating) return;
		const e = Dn.radToDeg(this.scene.rotation.y),
			t = { value: e <= -360 ? 0 : e },
			n = 360 / 5;
		return (
			(s = this.panel) != null && s.visible && (await this.panel.animateOut()),
			new Promise((r) => {
				this.rotateTween = Bn.to(t, {
					value: t.value - n,
					duration: 1,
					onUpdate: () => {
						var o;
						(o = this.scene) == null || o.rotation.set(0, Dn.degToRad(t.value), 0);
					},
					onComplete: () => {
						var c, h;
						const o = zW(t.value),
							a = (c = this.scene) == null ? void 0 : c.children.find((u) => u.userData.name === o),
							l = (a == null ? void 0 : a.userData.data) || {};
						(h = this.panel) == null ||
							h.animateIn(l).then(async () => {
								var u, d, p;
								r(),
									await kv(2e3),
									await ((u = this.panel) == null ? void 0 : u.animateOut()),
									this.rotating
										? (await kv(150), this.rotate())
										: (d = this.panel) != null && d.visible && ((p = this.panel) == null || p.animateOut());
							});
					},
					ease: 'power1.inOut',
				});
			})
		);
	}
	async loadEnvMap() {
		const e = new Ah(this.viz.renderer);
		e.compileEquirectangularShader();
		const t = await this.viz.assetManager.getAsset('/textures/environment.jpg'),
			n = e.fromEquirectangular(t).texture;
		return e.dispose(), n;
	}
	getObjectSizeAndCenter(e) {
		const t = new An().setFromObject(e),
			n = new I(),
			s = new I();
		return t.getSize(n), t.getCenter(s), { size: n, center: s };
	}
	async drawLabels(e, t, n, s, r) {
		const o = document.createElement('div');
		(o.innerHTML = t),
			(o.className = 'scene2-label label-'.concat(e)),
			await Yd.draw('Marker', { element: o, type: 'sprite', position: s, scale: 0.001 }, n).then((a) => {
				(a.userData = { type: e }), r && a.object3D.setRotationFromEuler(r);
			});
	}
	dispose() {
		var e, t;
		(e = this.viz.scene) == null ||
			e.children.forEach((n) => {
				Tf.disposeObject3D(n);
			}),
			this.viz.dispose(),
			(this.scene = void 0),
			(this.panel = void 0),
			(t = this.rotateTween) == null || t.kill(),
			(this.rotateTween = void 0);
	}
}
class HW extends Cs {
	constructor(t) {
		super(t);
		Ut(this, 'options');
		Ut(this, 'organs', []);
		this.options = t;
	}
	get size() {
		return Math.round(this.bound.sphere.radius);
	}
	get boundingSphere() {
		const { center: t, radius: n } = this.bound.sphere;
		return new un(t, n * 1.5);
	}
	async create() {
		const { modelUrl: t, bodyMaterial: n, boneMaterial: s, organMaterial: r } = this.options,
			{ scene: o } = await this.viz.assetManager.getAsset(t);
		console.log(t, o);
		const a = o.children[0];
		a.traverse((l) => {
			l.name.includes('外表') && ((l.material = n), (l.renderOrder = 2), (l.name = '外表')),
				(l.name === '骨' || l.name === '骨骼') &&
					l.children.forEach((c) => {
						c.material = s;
					}),
				l.name === '血管' && (l.material.emissive = new Ee('#53def3')),
				l.name === '器官' &&
					(console.log('器官', l.children),
					(this.organs = l.children),
					(l.renderOrder = 1),
					l.children.forEach((c) => {
						c.material = r;
					})),
				l.name === '定位' && ((l.visible = !1), console.log('定位', l));
		}),
			(o.rotation.y = -a.rotation.y),
			o.scale.set(0.1, 0.1, 0.1),
			(this.object3D = o);
	}
	alert(t) {
		let n;
		return (
			this.object3D.children[0].traverse((s) => {
				var r;
				s.name === t &&
					(((r = s.parent) == null ? void 0 : r.name) === '定位'
						? (s.userData.isLocateHelper = !0)
						: s instanceof bt && t !== '外表' && ((s.material = this.options.alertMaterial), (s.userData.isOrgan = !0)),
					(n = s));
			}),
			n
		);
	}
}
class GW extends Cs {
	async create() {
		var a;
		const e = await ((a = this.viz) == null ? void 0 : a.assetManager.getAsset('/scene3/base.mp4'));
		(e.magFilter = Tt), (e.minFilter = Tt);
		const { videoWidth: t, videoHeight: n } = e.image,
			s = new js(t, n),
			r = new En({ map: e, side: gn, blending: bs, transparent: !0, opacity: 1 }),
			o = new bt(s, r);
		o.scale.multiplyScalar(0.03), o.rotateX(Math.PI / 2), this.object3D.add(o);
	}
	createBg() {
		const e = new js(200, 200),
			t = new En({ color: 663874, transparent: !0, opacity: 0.52, side: gn }),
			n = new bt(e, t);
		return n.rotateX(Math.PI / 2), (n.position.y = -0.5), (n.position.z = 72), n;
	}
}
class WW extends Cs {
	async create() {
		const { scene: e } = await this.viz.assetManager.getAsset('/scene3/ring.gltf'),
			n = e.children[0].children[0].material;
		(n.side = mn),
			(n.emissiveMap.magFilter = It),
			(n.emissiveMap.minFilter = It),
			(n.map.magFilter = It),
			(n.map.minFilter = It),
			(n.opacity = 0.5);
		const s = Tf.getBounds(e).size;
		(e.children[0].position.y = s.y / 2), e.scale.multiplyScalar(0.08), (this.object3D = e);
	}
	render() {
		var e;
		(e = this.viz) != null &&
			e.guiManager &&
			this.viz.guiManager.addFolder('粒子环', {
				scale: {
					value: this.object3D.scale.x,
					min: 0,
					max: 1,
					step: 0.001,
					onChange: (t) => {
						this.object3D.scale.set(t, t, t);
					},
				},
			});
	}
	update(e) {
		this.object3D.children[0].rotation.y += e / 5;
	}
}
class XW extends Cs {
	constructor(t) {
		super(t);
		Ut(this, 'flyHeight');
		Ut(this, 'speed');
		Ut(this, 'options');
		Ut(this, 'texture', null);
		Ut(this, 'meshGroup', null);
		Ut(this, 'startLoop', !1);
		(this.flyHeight = Dn.randFloat(0, t.height * 0.5)), (this.speed = Dn.randFloat(3, 4) * t.scale), (this.options = t);
	}
	async create() {
		const { scale: t } = this.options,
			n = await this.viz.assetManager.getAsset('/scene3/number2.png');
		(n.wrapT = rs), (n.colorSpace = ot), (this.texture = n);
		const s = new js(512, 512),
			r = new En({ map: n, transparent: !0, color: new Ee('#40bff3'), side: mn, blending: bs, depthWrite: !1 }),
			o = new bt(s, r);
		o.position.copy(this.options.position), (o.position.y = this.flyHeight);
		const a = Dn.randFloat(0.01 * t, 0.03 * t);
		o.scale.set(a, a, a);
		const l = r.clone(),
			c = new bt(s, l);
		(c.visible = !1), c.scale.set(a, a, a), c.position.copy(this.options.position), (c.position.y = 0);
		const h = new Ui();
		h.add(o, c), (this.meshGroup = h), await $t.draw('Billboard', { object: h }, this);
	}
	update(t) {
		if (this.meshGroup) {
			const { height: n } = this.options,
				[s, r] = this.meshGroup.children;
			s.position.y >= n && ((s.position.y = 0), (s.material.opacity = 1)),
				r.position.y >= n && ((r.position.y = 0), (r.material.opacity = 1)),
				s.position.y >= n / 2 && ((this.startLoop = !0), (r.visible = !0)),
				(s.position.y += t * this.speed),
				(s.material.opacity = 1 - s.position.y / n),
				this.startLoop && ((r.position.y += t * this.speed), (r.material.opacity = 1 - r.position.y / n));
		}
	}
	dispose() {
		(this.texture = null), super.dispose();
	}
}
class qW extends Cs {
	constructor() {
		super(...arguments);
		Ut(this, 'size', 0);
	}
	async create() {
		var l;
		const t = await ((l = this.viz) == null ? void 0 : l.assetManager.getAsset('/scene3/marker.mp4')),
			{ videoWidth: n, videoHeight: s } = t.image,
			r = new js(n, s),
			o = new En({ map: t, side: mn, blending: bs, opacity: 0, depthTest: !1, transparent: !0 }),
			a = new bt(r, o);
		(this.object3D = a), (this.size = n);
	}
	render() {
		this.hide();
	}
	async animateIn(t, n, s = 0.5) {
		const r = this.object3D.material;
		await Bn.to(r, {
			opacity: 1,
			duration: s,
			onStart: () => {
				this.object3D.position.copy(t), this.object3D.scale.set(n, n, n), this.show();
			},
		});
	}
	async animateOut(t = 0.5) {
		if (this.object3D.visible === !1) return;
		const n = this.object3D.material;
		if (t === 0) {
			$t.erase(this);
			return;
		}
		await Bn.to(n, {
			opacity: 0,
			duration: t,
			onComplete: () => {
				$t.erase(this);
			},
		});
	}
}
class YW extends Cs {
	constructor(t) {
		super(t);
		Ut(this, 'marker');
		Ut(this, 'size', 512);
	}
	async create() {
		const { position: t, scale: n } = this.options,
			s = document.createElement('div');
		s.className = 'scene3-alert';
		const r = await $t.draw('Marker', { element: s, type: 'sprite', position: t, scale: n }, this.object3D);
		this.marker = r;
	}
	dispose() {
		var t;
		super.dispose(), (t = this.marker) == null || t.dispose(), (this.marker = void 0);
	}
}
const ag = 4;
class jW extends Cs {
	createTexture() {
		const e = document.createElement('canvas');
		(e.width = 256), (e.height = 256);
		const t = e.getContext('2d');
		if (t) {
			const n = t.createLinearGradient(0, 0, 0, 256);
			n.addColorStop(0, 'rgba(2,56,163, 0)'), n.addColorStop(1, 'rgba(2,56,163, 1)'), (t.fillStyle = n), t.fillRect(0, 0, 256, 256);
		}
		return new N_(e);
	}
	create() {
		const e = this.createTexture();
		e.colorSpace = ot;
		const t = new Va(8, 6, 4, 32, 1, !0),
			n = new En({ map: e, transparent: !0, opacity: 0, blending: bs, side: mn, depthWrite: !1 }),
			s = new bt(t, n);
		s.position.set(0, 2.5, 0), this.object3D.add(s), this.object3D.scale.set(ag, 1, ag), (this.object3D.visible = !1);
	}
	async animateIn(e = 1) {
		const t = { scale: ag * e },
			n = this.object3D.children[0];
		(n.material.opacity = 0),
			await Promise.all([
				Bn.to(t, {
					scale: e,
					duration: 1.5,
					onStart: () => {
						this.object3D.visible = !0;
					},
					onUpdate: () => {
						this.object3D.scale.set(t.scale, t.scale, t.scale);
					},
				}),
				Bn.to(n.material, { opacity: 1, duration: 1.5 }),
			]);
	}
}
const $t = new K0({ Human: HW, Base: GW, Ring: WW, Line: XW, Marker: Z0, Locate: qW, Alert: YW, Halo: jW, Billboard: OW });
var KW =
		'varying vec3 vView;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  vView = normalize(vec3(modelViewMatrix * vec4(position, 1.0)).xyz);\n  vNormal = normalize(normalMatrix * normal);\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}',
	$W =
		'uniform vec3 diffuseColor;\nuniform float fresnelIntensity;\nuniform float fresnelExponent;\nuniform float opacity;\nuniform sampler2D alertTextures[NUM_ALERT_TEXTURES];\nuniform float alertIntensity;\n\nvarying vec3 vView;\nvarying vec3 vNormal;\nvarying vec2 vUv;\n\nvoid main() {\n  float intensity = pow(fresnelIntensity - -min(dot(vView, normalize(vNormal)), 0.0), fresnelExponent);\n  vec4 fresnelColor = vec4(diffuseColor, min(intensity, opacity));\n  vec4 alertColor = vec4(0.0);\n  #if NUM_ALERT_TEXTURES > 0\n    alertColor += texture2D(alertTextures[0], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 1\n    alertColor += texture2D(alertTextures[1], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 2\n    alertColor += texture2D(alertTextures[2], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 3\n    alertColor += texture2D(alertTextures[3], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 4\n    alertColor += texture2D(alertTextures[4], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 5\n    alertColor += texture2D(alertTextures[5], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 6\n    alertColor += texture2D(alertTextures[6], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 7\n    alertColor += texture2D(alertTextures[7], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 8\n    alertColor += texture2D(alertTextures[8], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 9\n    alertColor += texture2D(alertTextures[9], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 10\n    alertColor += texture2D(alertTextures[10], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 11\n    alertColor += texture2D(alertTextures[11], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 12\n    alertColor += texture2D(alertTextures[12], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 13\n    alertColor += texture2D(alertTextures[13], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 14\n    alertColor += texture2D(alertTextures[13], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 15\n    alertColor += texture2D(alertTextures[15], vUv) * alertIntensity;\n  #endif\n  #if NUM_ALERT_TEXTURES > 16\n    alertColor += texture2D(alertTextures[16], vUv) * alertIntensity;\n  #endif\n  vec4 finalColor = mix(fresnelColor, alertColor, smoothstep(0.01, 0.1, alertColor.a));\n  gl_FragColor = finalColor;\n}';
const Gc = window.location.search.includes('dev'),
	lg = 11,
	ZW = [
		'chest',
		'l-arm',
		'l-foot',
		'l-forearm',
		'l-shins',
		'l-thigh',
		'l-hand',
		'l-shoulder',
		'l-wrist',
		'r-arm',
		'r-foot',
		'r-forearm',
		'r-shins',
		'r-thigh',
		'r-hand',
		'r-shoulder',
		'r-wrist',
	],
	cg = [
		{ text: '脑', value: '脑' },
		{ text: '肺部', value: '肺部' },
		{ text: '心脏', value: '心脏' },
		{ text: '头部', value: '头骨' },
		{ text: '肝脏', value: '肝脏' },
		{ text: '肠道', value: '肠道' },
		{ text: '肾', value: '肾' },
		{ text: '胃', value: '胃' },
		{ text: '胆', value: '胆' },
		{ text: '胰腺', value: '胰腺' },
		{ text: '子宫', value: '子宫卵巢' },
		{ text: '乳腺', value: '乳房' },
		{ text: '膀胱', value: '膀胱' },
		{ text: '右肘关节', value: '右肘关节' },
		{ text: '右髋关节', value: '右髋关节' },
		{ text: '右膝关节', value: '左膝关节' },
		{ text: '右脚踝', value: '左脚踝' },
		{ text: '左肘关节', value: '左肘关节' },
		{ text: '左髋关节', value: '左髋关节' },
		{ text: '左膝关节', value: '右膝关节' },
		{ text: '左脚踝', value: '右脚踝' },
		{ text: '胸部', value: 'chest' },
		{ text: '左大臂', value: 'l-arm' },
		{ text: '左脚', value: 'l-foot' },
		{ text: '左小臂', value: 'l-forearm' },
		{ text: '左手', value: 'l-hand' },
		{ text: '左小腿', value: 'l-shins' },
		{ text: '左肩', value: 'l-shoulder' },
		{ text: '左大腿', value: 'l-thigh' },
		{ text: '左手腕', value: 'l-wrist' },
		{ text: '右大臂', value: 'r-arm' },
		{ text: '右脚', value: 'r-foot' },
		{ text: '右小臂', value: 'r-forearm' },
		{ text: '右手', value: 'r-hand' },
		{ text: '右小腿', value: 'r-shins' },
		{ text: '右肩', value: 'r-shoulder' },
		{ text: '右大腿', value: 'r-thigh' },
		{ text: '右手腕', value: 'r-wrist' },
	];
function JW(i, e, t, n) {
	const s = i.clone();
	s.project(e);
	const r = ((s.x + 1) * t) / 2,
		o = ((-s.y + 1) * n) / 2;
	return { x: r, y: o };
}
function QW(i, e) {
	return ''.concat(i.replace(/\/$/, ''), '/').concat(e.replace(/^\//, ''));
}
function e6(i) {
	return i.startsWith('/') ? i : QW('/', i);
}
class t6 {
	constructor(e, t = 'man.glb') {
		Ut(this, 'viz');
		Ut(this, 'materialStore', {});
		Ut(this, 'alertObjects', new Map());
		Ut(this, 'currentHuman');
		Ut(this, 'autoRotate', !1);
		this.currentHuman = t;
		const n = new nW(),
			s = new ff().load(e6('/scene3/bg.png'));
		s.colorSpace = ot;
		const r = new $0(
			{
				dev: Gc,
				container: e,
				staticPath: '/',
				scene: { background: s },
				camera: { position: new I(0, 11, 23), target: new I(0, 9, 0) },
				renderer: { toneMappingExposure: 0.91 },
				cssRenderer: '3d',
			},
			{ componentManager: $t, lightManager: n }
		);
		r.assetManager.setAsset([
			{ url: '/scene3/models/'.concat(t), type: 'gltf', version: '0.0.5' },
			{ url: '/scene3/base.mp4', type: 'video' },
			{ url: '/scene3/marker.mp4', type: 'video' },
			{ url: '/scene3/line.png', type: 'texture' },
			{ url: '/scene3/number2.png', type: 'texture' },
		]),
			(this.viz = r),
			Gc && (window.viz = r);
	}
	async init() {
		var t, n;
		const e = this.viz.getManager('lightManager');
		debugger;
		await this.viz.assetManager.load(); //报错

		e.createDirectionalLight({ color: 16777215, intensity: 3, position: new I(0, 0, 10) }),
			e.createDirectionalLight({ color: 16777215, intensity: 3, position: new I(0, 0, -10) }),
			(this.viz.scene.fog = new tu(0, 0.02)),
			this.createMaterial(),
			await Promise.all([
				$t.draw('Human', {
					modelUrl: '/scene3/models/'.concat(this.currentHuman),
					bodyMaterial: this.materialStore.bodyMaterial,
					boneMaterial: this.materialStore.boneMaterial,
					alertMaterial: this.materialStore.alertMaterial,
					organMaterial: this.materialStore.organMaterial,
				}),
				$t.draw('Base'),
				this.drawLight(),
			]),
			await this.createFlylines(),
			(t = this.viz.cameraControl) == null ||
				t.addEventListener('controlstart', () => {
					(this.autoRotate = !1), this.viz.eventManager.emit('controlstart', {});
				}),
			(n = this.viz.cameraControl) == null ||
				n.addEventListener('controlend', () => {
					(this.autoRotate = !Gc), this.viz.eventManager.emit('controlend', {});
				}),
			this.viz.start((s) => {
				this.autoRotate && (this.viz.cameraControl.azimuthAngle += 20 * s * Dn.DEG2RAD);
			}),
			Gc && this.createGUI();
	}
	pick() {
		const e = $t.getInstance('Human');
		if (!e) return;
		const t = this.viz.pick(e.organs, !0);
		if (t && t.length) {
			const n = cg.find((s) => s.text === t[0].object.name);
			n && this.alert(n.value);
		}
	}
	async drawLight() {
		const e = document.createElement('div');
		(e.className = 'light-bg'), await $t.draw('Marker', { type: '3d', element: e, position: new I(-1.6, 10, -36), scale: 0.05 });
	}
	async changeModel(e) {
		const t = '/scene3/models/'.concat(e);
		(this.currentHuman = e),
			await this.resetAlert(),
			await this.viz.assetManager.loadAsset({ url: t, type: 'gltf', version: '0.0.4' }),
			$t.erase('Human'),
			$t.erase('Line'),
			await $t.draw('Human', {
				modelUrl: t,
				bodyMaterial: this.materialStore.bodyMaterial,
				boneMaterial: this.materialStore.boneMaterial,
				alertMaterial: this.materialStore.alertMaterial,
				organMaterial: this.materialStore.organMaterial,
			}),
			await this.createFlylines(),
			await this.animateIn();
	}
	async createFlylines() {
		const e = $t.getInstance('Human'),
			t = e.bound.size,
			n = e.size / lg,
			s = t.x * 1.5,
			r = t.z * 1.5,
			o = Array.from({ length: 4 })
				.fill(0)
				.map(() => {
					const l = new I(Dn.randFloat(-s, -((t.x / 2) * 1.2)), 0, Dn.randFloat(-r, r));
					return $t.draw('Line', { position: l, height: t.y, scale: n });
				}),
			a = Array.from({ length: 4 })
				.fill(0)
				.map(() => {
					const l = new I(Dn.randFloat(s, (t.x / 2) * 1.2), 0, Dn.randFloat(-r, r));
					return $t.draw('Line', { position: l, height: t.y, scale: n });
				});
		return Promise.all([...o, ...a]);
	}
	createMaterial() {
		(this.materialStore.bodyMaterial = this.createFresnelMaterial('外表', new Ee(4167423), 1.2, 3.5, 1, !1)),
			(this.materialStore.boneMaterial = this.createFresnelMaterial('骨头', new Ee(4362995), 1.4, 3, 1, !1)),
			(this.materialStore.alertMaterial = this.createFresnelMaterial('告警', new Ee(16760576), 1.3, 5, 0, !0, !1)),
			(this.materialStore.organMaterial = new Ha({
				name: '器官',
				color: 4099071,
				transparent: !0,
				emissive: '#001f59',
				emissiveIntensity: 0.43,
				metalness: 0.11,
				roughness: 0.61,
			}));
	}
	createFresnelMaterial(e, t = new Ee(255), n = 1.2, s = 3.5, r = 1, o = !0, a = !0) {
		const l = new xn({
			vertexShader: KW,
			fragmentShader: $W,
			uniforms: {
				diffuseColor: { value: t },
				fresnelIntensity: { value: n },
				fresnelExponent: { value: s },
				opacity: { value: r },
				alertTextures: { value: [null] },
				alertIntensity: { value: 1 },
			},
			defines: { NUM_ALERT_TEXTURES: 1 },
			transparent: !0,
			depthTest: a,
			depthWrite: o,
		});
		return (l.name = e), l;
	}
	createFresnelGui(e) {
		this.viz.guiManager.addFolder(e.name, {
			diffuseColor: {
				label: '颜色',
				value: e.uniforms.diffuseColor.value.getHex(),
				onChange: (n) => {
					e.uniforms.diffuseColor.value.set(n);
				},
			},
			fresnelIntensity: {
				label: '菲涅尔强度',
				value: e.uniforms.fresnelIntensity.value,
				min: 0,
				max: 10,
				step: 0.01,
				onChange: (n) => {
					e.uniforms.fresnelIntensity.value = n;
				},
			},
			fresnelExponent: {
				label: '菲涅尔指数',
				value: e.uniforms.fresnelExponent.value,
				min: 0,
				max: 10,
				step: 0.01,
				onChange: (n) => {
					e.uniforms.fresnelExponent.value = n;
				},
			},
			opacity: {
				label: '透明度',
				value: e.uniforms.opacity.value,
				min: 0,
				max: 1,
				step: 0.01,
				onChange: (n) => {
					e.uniforms.opacity.value = n;
				},
			},
		});
	}
	createGUI() {
		const e = this.viz.guiManager;
		this.createFresnelGui(this.materialStore.bodyMaterial),
			this.createFresnelGui(this.materialStore.boneMaterial),
			this.createFresnelGui(this.materialStore.alertMaterial);
		const t = this.materialStore.organMaterial;
		e.addFolder('器官', {
			color: {
				label: '颜色',
				value: t.color.getHex(),
				onChange: (s) => {
					t.color.set(s);
				},
			},
			emissive: {
				label: '自发光',
				value: '#000',
				onChange: (s) => {
					t.emissive.set(s);
				},
			},
			opacity: {
				label: '透明度',
				value: 1,
				min: 0,
				max: 1,
				step: 0.01,
				onChange: (s) => {
					t.opacity = s;
				},
			},
			emissiveIntensity: {
				label: '自发光强度',
				value: t.emissiveIntensity,
				min: 0,
				max: 10,
				step: 0.01,
				onChange: (s) => {
					t.emissiveIntensity = s;
				},
			},
			roughness: {
				label: '粗糙度',
				value: t.roughness,
				min: 0,
				max: 1,
				step: 0.01,
				onChange: (s) => {
					t.roughness = s;
				},
			},
			metalness: {
				label: '金属度',
				value: t.metalness,
				min: 0,
				max: 1,
				step: 0.01,
				onChange: (s) => {
					t.metalness = s;
				},
			},
		}),
			e.addFolder('模型', {
				模型: {
					value: '/scene3/models/man.glb',
					options: [
						{ text: '成年女', value: 'woman.glb' },
						{ text: '成年男', value: 'man.glb' },
						{ text: '儿童男', value: 'child-boy.glb' },
						{ text: '儿童女', value: 'child-girl.glb' },
						{ text: '老年男', value: 'elder-man.glb' },
						{ text: '老年女', value: 'elder-woman.glb' },
						{ text: '青少年男', value: 'teen-boy.glb' },
						{ text: '青少年女', value: 'teen-girl.glb' },
						{ text: '幼儿男', value: 'baby-boy.glb' },
						{ text: '幼儿女', value: 'baby-girl.glb' },
						{ text: '中年男', value: 'middle-man.glb' },
						{ text: '中年女', value: 'middle-woman.glb' },
					],
					onChange: (s) => {
						this.changeModel(s);
					},
				},
			});
		const n = $t.getInstance('Marker').object3D;
		e.addFolder('光效', {
			x: {
				value: n.position.x,
				min: -500,
				max: 500,
				step: 0.1,
				onChange: (s) => {
					n.position.x = s;
				},
			},
			y: {
				value: n.position.y,
				min: -500,
				max: 500,
				step: 0.1,
				onChange: (s) => {
					n.position.y = s;
				},
			},
			z: {
				value: n.position.z,
				min: -500,
				max: 500,
				step: 0.1,
				onChange: (s) => {
					n.position.z = s;
				},
			},
			scale: {
				value: n.scale.x,
				min: 0,
				max: 1,
				step: 0.01,
				onChange: (s) => {
					n.scale.set(s, s, s);
				},
			},
		}),
			e.addBinding('告警', {
				value: '',
				options: cg,
				onChange: (s) => {
					this.alert(s);
				},
			}),
			e.addBinding('去除告警', {
				value: '',
				options: cg,
				onChange: (s) => {
					this.alertOut(s);
				},
			}),
			e.addButton('重置告警', () => {
				this.resetAlert();
			}),
			e.addButton('重置相机', () => {
				this.resetCameraPosition();
			});
	}
	async animateIn() {
		var s;
		const e = $t.getInstance('Human'),
			t = $t.getInstance('Base');
		this.viz.cameraControl.maxDistance = e.size * 5;
		const n = (e.size / lg) * 0.03;
		t.object3D.children[0].scale.set(n, n, n),
			await Promise.all([(s = this.viz.cameraControl) == null ? void 0 : s.fitToSphere(e.boundingSphere, !0)]),
			(this.autoRotate = !Gc);
	}
	async alert(e, t = !1) {
		var h, u;
		const n = this.materialStore.alertMaterial,
			s = this.materialStore.boneMaterial,
			r = this.materialStore.organMaterial,
			o = this.materialStore.bodyMaterial,
			a = $t.getInstance('Human'),
			l = ZW.includes(e),
			c = a == null ? void 0 : a.alert(l ? '外表' : e);
		if ((console.log('targetOrgan', c), c)) {
			const d = c.userData.isLocateHelper,
				{ sphere: p, center: g } = Tf.getBounds(c),
				{ width: v, height: m } = this.viz.getSize();
			if (l) {
				let f;
				o.userData.alertTextures
					? (f = o.userData.alertTextures.find((y) => y.userData.organ === e))
					: (o.userData.alertTextures = []),
					f ||
						((f = await this.viz.assetManager.loadAsset({ type: 'texture', url: '/scene3/alert-texture/'.concat(e, '.png') })),
						(f.userData.organ = e),
						(f.flipY = !1),
						(f.colorSpace = ot),
						o.userData.alertTextures.push(f)),
					(o.depthWrite = !0),
					(o.uniforms.alertTextures.value = [...o.uniforms.alertTextures.value, f].filter(Boolean)),
					(o.defines.NUM_ALERT_TEXTURES = o.uniforms.alertTextures.value.length),
					(o.needsUpdate = !0),
					await this.resetCameraPosition(),
					o.userData.alertTween ||
						(o.userData.alertTween = Bn.fromTo(
							o.uniforms.alertIntensity,
							{ value: 1 },
							{ value: 1.5, duration: 0.8, yoyo: !0, repeat: -1, ease: 'power1.inOut' }
						));
			} else if (d) {
				const f = (a.size / lg) * 0.005;
				await $t.draw('Alert', { position: g, scale: f, key: e }),
					t && (await ((h = this.viz.cameraControl) == null ? void 0 : h.fitToSphere(new un(p.center, 3), !0)));
			} else {
				const f = await $t.draw('Locate', { key: e }),
					y = (p.radius / f.size) * 0.3,
					_ = Array.from(this.alertObjects.values()).some((E) => E.userData.isOrgan),
					x = [f.animateIn(g, y)];
				_ ||
					x.push(
						Bn.to(n.uniforms.opacity, {
							value: 1,
							duration: 0.5,
							onUpdate: () => {
								const E = Math.max(1 - n.uniforms.opacity.value, 0.1);
								(s.uniforms.opacity.value = E), (r.opacity = E);
							},
						})
					),
					t && x.push((u = this.viz.cameraControl) == null ? void 0 : u.fitToSphere(new un(p.center, p.radius * 1.5), !0)),
					await Promise.all(x),
					n.userData.alertTween ||
						(n.userData.alertTween = Bn.fromTo(
							n.uniforms.fresnelIntensity,
							{ value: 1.3 },
							{ value: 1.63, duration: 0.8, yoyo: !0, repeat: -1, ease: 'power1.inOut' }
						));
			}
			this.alertObjects.set(e, c), this.viz.eventManager.emit('alert', { position: JW(g, this.viz.camera, v, m), organ: e });
		}
	}
	async alertOut(e, t = !1) {
		var c;
		const n = this.alertObjects.get(e);
		if (!n) return;
		const s = this.materialStore.alertMaterial,
			r = this.materialStore.boneMaterial,
			o = this.materialStore.organMaterial,
			a = this.materialStore.bodyMaterial,
			l = n.userData.isLocateHelper;
		if ((this.alertObjects.delete(e), n.name === '外表')) {
			(a.depthWrite = !1), (a.uniforms.alertTextures.value = a.uniforms.alertTextures.value.filter((u) => u.userData.organ !== e));
			const h = a.uniforms.alertTextures.value.length;
			(a.defines.NUM_ALERT_TEXTURES = Math.max(h, 1)),
				h === 0 &&
					((a.uniforms.alertTextures.value = [null]),
					a.userData.alertTween && (a.userData.alertTween.kill(), (a.userData.alertTween = null)),
					(a.uniforms.alertIntensity.value = 1)),
				(a.needsUpdate = !0);
		} else if (l) $t.erase('Alert', e);
		else if (n.userData.isOrgan) {
			const h = [(c = $t.getInstance('Locate', e)) == null ? void 0 : c.animateOut()],
				u = Array.from(this.alertObjects.values()).some((d) => d.userData.isOrgan && d !== n);
			(n.material = o),
				u ||
					h.push(
						Bn.to(s.uniforms.opacity, {
							value: 0,
							duration: 0.5,
							onUpdate: () => {
								const d = 1 - s.uniforms.opacity.value;
								(r.uniforms.opacity.value = d), (o.opacity = d);
							},
							onComplete: () => {
								s.userData.alertTween && (s.userData.alertTween.kill(), (s.userData.alertTween = null));
							},
						})
					),
				await Promise.all(h);
		}
		t && (await this.resetCameraPosition());
	}
	async resetAlert() {
		const e = this.materialStore.bodyMaterial,
			t = this.materialStore.alertMaterial;
		await Promise.all(Array.from(this.alertObjects.keys()).map((n) => this.alertOut(n))),
			t.userData.alertTween && (t.userData.alertTween.kill(), (t.userData.alertTween = null)),
			e.userData.alertTween && (e.userData.alertTween.kill(), (e.userData.alertTween = null));
	}
	async resetCameraPosition() {
		var t;
		const e = $t.getInstance('Human');
		await ((t = this.viz.cameraControl) == null ? void 0 : t.fitToSphere(e.boundingSphere, !0));
	}
	dispose() {
		const e = this.materialStore.bodyMaterial,
			t = this.materialStore.alertMaterial;
		t.userData.alertTween && (t.userData.alertTween.kill(), (t.userData.alertTween = null)),
			e.userData.alertTween && (e.userData.alertTween.kill(), (e.userData.alertTween = null)),
			e.userData.alertTextures && (e.userData.alertTextures.forEach((n) => n.dispose()), (e.userData.alertTextures = [])),
			this.alertObjects.clear(),
			Object.values(this.materialStore).forEach((n) => n.dispose()),
			(this.materialStore = {}),
			this.viz.dispose();
	}
}
const n6 = { class: 'wrapper' },
	i6 = ac({
		__name: 'scene-one',
		setup(i) {
			// 根路径组件
			const e = Mp();
			let t;
			const n = window.location.search.includes('dev');
			debugger;
			Ap(async () => {
				// 创建自定义封装对象
				t = new NW(e.value);
				debugger;
				// 初始化
				await t.init();
				// 动画
				await t.animateIn();
			});
			Cp(() => {
				t.dispose();
			});
			return (s, r) => (
				Lp(),
				n_('div', n6, [
					$d('div', { class: 'vis-container', ref_key: 'container', ref: e }, null, 512),
					$d('div', { class: bp(['bg', { show: ao(n) }]) }, null, 2),
				])
			);
		},
	}),
	J0 = (i, e) => {
		const t = i.__vccOpts || i;
		for (const [n, s] of e) t[n] = s;
		return t;
	},
	s6 = J0(i6, [['__scopeId', 'data-v-f3a7a86c']]),
	r6 = ac({
		__name: 'scene-two',
		setup(i) {
			debugger;
			const e = Mp();
			let t;
			return (
				Ap(async () => {
					window.addEventListener('message', (n) => {
						n.data.record && t.setData(n.data.record.filter(Boolean));
					}),
						(t = new VW(e.value)),
						await t.init(),
						await t.animateIn(),
						window.parent.postMessage('mounted', '*'),
						await kv(150),
						t.startRotate();
				}),
				Cp(() => {
					t.dispose();
				}),
				(n, s) => (Lp(), n_('div', { class: 'vis-container', ref_key: 'container', ref: e }, null, 512))
			);
		},
	}),
	o6 = J0(r6, [['__scopeId', 'data-v-40c9111c']]),
	a6 = ac({
		__name: 'scene-three',
		setup(i) {
			debugger;
			const e = Mp();
			let t;
			const n = window.location.search.includes('dev'),
				s = [
					{ name: 4, value: 'woman.glb' },
					{ name: 5, value: 'man.glb' },
					{ name: 3, value: 'child-boy.glb' },
					{ name: 2, value: 'child-girl.glb' },
					{ name: 7, value: 'elder-man.glb' },
					{ name: 6, value: 'elder-woman.glb' },
					{ name: 11, value: 'teen-boy.glb' },
					{ name: 10, value: 'teen-girl.glb' },
					{ name: 9, value: 'baby-boy.glb' },
					{ name: 8, value: 'baby-girl.glb' },
					{ name: 1, value: 'middle-man.glb' },
					{ name: 0, value: 'middle-woman.glb' },
				],
				r = [
					{ name: '脑', value: '脑' },
					{ name: '肺部', value: '肺部' },
					{ name: '心脏', value: '心脏' },
					{ name: '头部', value: '头骨' },
					{ name: '肝脏', value: '肝脏' },
					{ name: '肠道', value: '肠道' },
					{ name: '肾', value: '肾' },
					{ name: '胃', value: '胃' },
					{ name: '子宫', value: '子宫卵巢' },
					{ name: '乳腺', value: '乳房' },
					{ name: '胆', value: '胆' },
					{ name: '胰腺', value: '胰腺' },
					{ name: '膀胱', value: '膀胱' },
					{ name: '右肘关节', value: '右肘关节' },
					{ name: '右髋关节', value: '右髋关节' },
					{ name: '右膝关节', value: '左膝关节' },
					{ name: '右脚踝', value: '左脚踝' },
					{ name: '左肘关节', value: '左肘关节' },
					{ name: '左髋关节', value: '左髋关节' },
					{ name: '左膝关节', value: '右膝关节' },
					{ name: '左脚踝', value: '右脚踝' },
					{ name: '胸部', value: 'chest' },
					{ name: '左大臂', value: 'l-arm' },
					{ name: '左脚', value: 'l-foot' },
					{ name: '左小臂', value: 'l-forearm' },
					{ name: '左手', value: 'l-hand' },
					{ name: '左小腿', value: 'l-shins' },
					{ name: '左肩', value: 'l-shoulder' },
					{ name: '左大腿', value: 'l-thigh' },
					{ name: '左手腕', value: 'l-wrist' },
					{ name: '右大臂', value: 'r-arm' },
					{ name: '右脚', value: 'r-foot' },
					{ name: '右小臂', value: 'r-forearm' },
					{ name: '右手', value: 'r-hand' },
					{ name: '右小腿', value: 'r-shins' },
					{ name: '右肩', value: 'r-shoulder' },
					{ name: '右大腿', value: 'r-thigh' },
					{ name: '右手腕', value: 'r-wrist' },
				];
			let o = !1,
				a;
			return (
				Ap(async () => {
					(a = async (l) => {
						var h, u, d, p;
						console.log('message', l.data);
						const c = l.data;
						if (c.type === 'init') {
							const g = (h = s.find((v) => v.name === c.value)) == null ? void 0 : h.value;
							(t = new t6(e.value, g || 'man.glb')), (window.scene = t);
							console.log(1);
							await t.init(); //报错
							console.log(2);

							await t.animateIn(),
								e.value.addEventListener('click', () => {
									t.pick();
								}),
								(o = !0),
								t.viz.eventManager.on('alert', (v) => {
									window.parent.postMessage({ event: 'alert-tooltip', data: v }, '*');
								}),
								t.viz.eventManager.on('controlstart', () => {
									window.parent.postMessage({ event: 'controlstart' }, '*');
								}),
								t.viz.eventManager.on('controlend', () => {
									window.parent.postMessage({ event: 'controlend' }, '*');
								}),
								window.parent.postMessage('mounted', '*');
						}
						if (c.type === 'changeModel') {
							const g = (u = s.find((v) => v.name === c.value)) == null ? void 0 : u.value;
							g && o && t.changeModel(g);
						}
						if (c.type === 'alert') {
							const g = (d = r.find((v) => v.name === c.value)) == null ? void 0 : d.value;
							g && o && t.alert(g, c.focus);
						}
						if (c.type === 'alert-out') {
							const g = (p = r.find((v) => v.name === c.value)) == null ? void 0 : p.value;
							g && o && t.alertOut(g, c.reset);
						}
						c.type === 'reset-alert' && o && t.resetAlert(), c.type === 'reset-camera' && o && t.resetCameraPosition();
					}),
						window.addEventListener('message', a),
						n && window.postMessage({ type: 'init' });
				}),
				Cp(() => {
					window.removeEventListener('message', a), t == null || t.dispose();
				}),
				(l, c) => (Lp(), n_('div', { class: 'vis-container', ref_key: 'container', ref: e }, null, 512))
			);
		},
	}),
	l6 = J0(a6, [['__scopeId', 'data-v-381dcd0c']]);

function createWebHashHistory(base) {
	base = location.host ? base || location.pathname + location.search : '';
	if (!base.includes('#')) base += '#';
	return FP(base); //这里调用了createWebHistory(),对应当前网站的函数是FP
}

var c6 = lL({
		history: FP('/'),
		//修改为hash模式
		// history: createWebHashHistory('/'),
		routes: [
			{ path: '/', name: 'SceneOne', component: s6 },
			{ path: '/scene2', name: 'SceneTwo', component: o6 },
			{ path: '/scene3', name: 'SceneThree', component: l6 },
		],
	}),
	UA = sP(hL);
UA.use(c6);
UA.mount('#app');
export { u6 as __vite_legacy_guard };
